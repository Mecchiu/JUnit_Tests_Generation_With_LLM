ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wvKTDDqgoKRiVKTqMccDz2n0G4t6,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter0.java,180.4536530971527,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments) {
        if (messagePattern == null || arguments == null || arguments.length == 0) {
            return messagePattern;
        }
        StringBuilder result = new StringBuilder();
        int escapeCounter = 0;
        int currentArgument = 0;
        for (int i = 0; i < messagePattern.length(); i++) {
            char curChar = messagePattern.charAt(i);
            if (curChar == ESCAPE_CHAR) {
                escapeCounter++;
            } else {
                if (curChar == DELIM_START) {
                    if (i < messagePattern.length() - 1) {
                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {
                            // write escaped escape chars
                            int escapedEscapes = escapeCounter / 2;
                            for (int j = 0; j < escapedEscapes; j++) {
                                result.append(ESCAPE_CHAR);
                            }
                            if (escapeCounter % 2 == 1) {
                                // i.e. escaped
                                // write escaped escape chars
                                result.append(DELIM_START);
                                result.append(DELIM_STOP);
                            } else {
                                // unescaped
                                if (currentArgument < arguments.length) {
                                    result.append(arguments[currentArgument]);
                                } else {
                                    result.append(DELIM_START).append(DELIM_STOP);
                                }
                                currentArgument++;
                            }
                            i++;
                            escapeCounter = 0;
                            continue;
                        }
                    }
                }
                // any other char beside ESCAPE or DELIM_START/STOP-combo
                // write unescaped escape chars
                if (escapeCounter > 0) {
                    for (int j = 0; j < escapeCounter; j++) {
                        result.append(ESCAPE_CHAR);
                    }
                    escapeCounter = 0;
                }
                result.append(curChar);
            }
        }
        return result.toString();
    }
}
","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatterTest {","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatterTest {

	@Test
	void testFormat() {
		String messagePattern = """";
		String[] arguments = new String[] {};
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = """";
		arguments = new String[] {""a""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{"", ""|""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{"", ""|"", ""}""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{"", ""|"", ""}"", ""~""};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{"", ""|"", ""}"", ""~"", """"};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{"", ""|"", ""}"", ""~"", """", """"};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{"", ""|"", ""}"", ""~"", """", """", """"};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{"", ""|"", ""}"", ""~"", """", """", """", """"};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{"", ""|"", ""}"", ""~"", """", """", """", """", """"};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""{"", ""|"", ""}"", ""~"", """", """", """", """", """", """"};
		result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(messagePattern, result);
		
		messagePattern = ""abc"";
		arguments = new String[] {""a"", ""b"", ""c"", ""d"", """
cmpl-6wvNOhVP5c7VQgWLlxSq0LFUG7Ysa,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter1.java,146.09863877296448,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern) {
        if (messagePattern == null) {
            return 0;
        }
        int delim = messagePattern.indexOf(DELIM_START);
        if (delim == -1) {
            // special case, no placeholders at all.
            return 0;
        }
        int result = 0;
        boolean isEscaped = false;
        for (int i = 0; i < messagePattern.length(); i++) {
            char curChar = messagePattern.charAt(i);
            if (curChar == ESCAPE_CHAR) {
                isEscaped = !isEscaped;
            } else if (curChar == DELIM_START) {
                if (!isEscaped) {
                    if (i < messagePattern.length() - 1) {
                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {
                            result++;
                            i++;
                        }
                    }
                }
                isEscaped = false;
            } else {
                isEscaped = false;
            }
        }
        return result;
    }
}
","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {

	@Test
	void countArgumentPlaceholders_null() {
		int result = MessageFormatter.countArgumentPlaceholders(null);
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_empty() {
		int result = MessageFormatter.countArgumentPlaceholders("""");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_noPlaceholders() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello World!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_onePlaceholder() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello {}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_twoPlaceholders() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello {}! {}"");
		assertEquals(2, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape2() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape3() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape4() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape5() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape6() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape7() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape8() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape9() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape10() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape11() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape12() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape13() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape14() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape15() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape16() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape17() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape18() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape19() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape20() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape21() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape22() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape23() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape24() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape25() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape26() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape27() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape28() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape29() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape30() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape31() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape32() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape33() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape34() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape35() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape36() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape37() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape38() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape39() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape40() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape41() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape42() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape43() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape44() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape45() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape46() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape47() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape48() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape49() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape50() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape51() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape52() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape53() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape54() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape55() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape56() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(0, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape57() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
		assertEquals(1, result);
	}
	
	@Test
	void countArgumentPlaceholders_escapedEscape58() {
		int result = MessageFormatter.countArgumentPlaceholders(""Hello \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\{}!"");
"
cmpl-6wvQDWqnM36UsnLUdWy7776JP49Tp,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter2.java,185.04281163215637,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {
        if (arguments == null) {
            return null;
        }
        int argsCount = countArgumentPlaceholders(messagePattern);
        int resultArgCount = arguments.length;
        Throwable throwable = null;
        if (argsCount < arguments.length) {
            if (arguments[arguments.length - 1] instanceof Throwable) {
                throwable = (Throwable) arguments[arguments.length - 1];
                resultArgCount--;
            }
        }
        String[] stringArgs;
        if (argsCount == 1 && throwable == null && arguments.length > 1) {
            // special case
            stringArgs = new String[1];
            stringArgs[0] = deepToString(arguments);
        } else {
            stringArgs = new String[resultArgCount];
            for (int i = 0; i < stringArgs.length; i++) {
                stringArgs[i] = deepToString(arguments[i]);
            }
        }
        return new ArgumentResult(stringArgs, throwable);
    }
}
","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatterTest {","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatterTest {

		@Test
		public void testEvaluateArguments_null() {
				ArgumentResult result = MessageFormatter.evaluateArguments(null, null);
				assertNull(result);
		}
		
		@Test
		public void testEvaluateArguments_empty() {
				ArgumentResult result = MessageFormatter.evaluateArguments("""", null);
				assertNull(result);
		}
		
		@Test
		public void testEvaluateArguments_noPlaceholders() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello World!"", null);
				assertNull(result);
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}!"", new Object[] { ""World"" });
				assertNotNull(result);
				assertEquals(1, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}!"", new Object[] { ""World"", ""!"" });
				assertNotNull(result);
				assertEquals(1, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}!"", new Object[] { ""World"", ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(1, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertNotNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {}"", new Object[] { ""World"", ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(2, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"" });
				assertNotNull(result);
				assertEquals(2, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(2, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertNotNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(3, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"" });
				assertNotNull(result);
				assertEquals(3, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(3, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertNotNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(4, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertEquals(""!"", result.getArguments()[3]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"" });
				assertNotNull(result);
				assertEquals(4, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertEquals(""!"", result.getArguments()[3]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(4, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertEquals(""!"", result.getArguments()[3]);
				assertNotNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {} {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(5, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertEquals(""!"", result.getArguments()[3]);
				assertEquals(""!"", result.getArguments()[4]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {} {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"" });
				assertNotNull(result);
				assertEquals(5, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertEquals(""!"", result.getArguments()[3]);
				assertEquals(""!"", result.getArguments()[4]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {} {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(5, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertEquals(""!"", result.getArguments()[3]);
				assertEquals(""!"", result.getArguments()[4]);
				assertNotNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {} {} {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(6, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertEquals(""!"", result.getArguments()[3]);
				assertEquals(""!"", result.getArguments()[4]);
				assertEquals(""!"", result.getArguments()[5]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {} {} {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"" });
				assertNotNull(result);
				assertEquals(6, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertEquals(""!"", result.getArguments()[3]);
				assertEquals(""!"", result.getArguments()[4]);
				assertEquals(""!"", result.getArguments()[5]);
				assertNull(result.getThrowable());
		}
		
		@Test
		public void testEvaluateArguments_onePlaceholder_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable_used_tooMany_throwable() {
				ArgumentResult result = MessageFormatter.evaluateArguments(""Hello {}! {} {} {} {} {}"", new Object[] { ""World"", ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable(), ""!"", new Throwable() });
				assertNotNull(result);
				assertEquals(6, result.getArguments().length);
				assertEquals(""World"", result.getArguments()[0]);
				assertEquals(""!"", result.getArguments()[1]);
				assertEquals(""!"", result.getArguments()[2]);
				assertEquals(""!"", result.getArguments()[3]);
				assertEquals(""!"", result.getArguments()[4]);
				assertEquals(""!"", result.get"
cmpl-6wvSjmIBE1YmTALlpXc6ATPHCzjU9,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter3.java,119.51513314247131,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj) {
        if (obj == null) {
            return null;
        }
        return obj.getClass().getName() + ""@"" + Integer.toHexString(System.identityHashCode(obj));
    }
}
","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatterTest {","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatterTest {

	@Test
	void identityToString_null() {
		assertNull(MessageFormatter.identityToString(null));
	}
	
	@Test
	void identityToString_string() {
		assertEquals(""java.lang.String@"" + Integer.toHexString(System.identityHashCode("""")), MessageFormatter.identityToString(""""));
	}
	
	@Test
	void identityToString_integer() {
		assertEquals(""java.lang.Integer@"" + Integer.toHexString(System.identityHashCode(0)), MessageFormatter.identityToString(0));
	}
	
	@Test
	void identityToString_long() {
		assertEquals(""java.lang.Long@"" + Integer.toHexString(System.identityHashCode(0L)), MessageFormatter.identityToString(0L));
	}
	
	@Test
	void identityToString_double() {
		assertEquals(""java.lang.Double@"" + Integer.toHexString(System.identityHashCode(0.0)), MessageFormatter.identityToString(0.0));
	}
	
	@Test
	void identityToString_float() {
		assertEquals(""java.lang.Float@"" + Integer.toHexString(System.identityHashCode(0.0f)), MessageFormatter.identityToString(0.0f));
	}
	
	@Test
	void identityToString_boolean() {
		assertEquals(""java.lang.Boolean@"" + Integer.toHexString(System.identityHashCode(false)), MessageFormatter.identityToString(false));
	}
	
	@Test
	void identityToString_char() {
		assertEquals(""java.lang.Character@"" + Integer.toHexString(System.identityHashCode('\0')), MessageFormatter.identityToString('\0'));
	}
	
	@Test
	void identityToString_byte() {
		assertEquals(""java.lang.Byte@"" + Integer.toHexString(System.identityHashCode((byte) 0)), MessageFormatter.identityToString((byte) 0));
	}
	
	@Test
	void identityToString_short() {
		assertEquals(""java.lang.Short@"" + Integer.toHexString(System.identityHashCode((short) 0)), MessageFormatter.identityToString((short) 0));
	}
	
	@Test
	void identityToString_object() {
		assertEquals(""de.huxhorn.lilith.data.logging.MessageFormatterTest@"" + Integer.toHexString(System.identityHashCode(this)), MessageFormatter.identityToString(this));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatterTest {
		
	@Test
	void identityToString_null() {
		assertNull(MessageFormatter.identityToString(null));
	}
	
	@Test
	void identityToString_string() {
		assertEquals(""java.lang.String@"" + Integer.toHexString(System.identityHashCode("""")), MessageFormatter.identityToString(""""));
	}
	
	@Test
	void identityToString_integer() {
		assertEquals(""java.lang.Integer@"" + Integer.toHexString(System.identityHashCode(0)), MessageFormatter.identityToString(0));
	}
	
	@Test
	void identityToString_long() {
		assertEquals(""java.lang.Long@"" + Integer.toHexString(System.identityHashCode(0L)), MessageFormatter.identityToString(0L));
	}
	
	@Test
	void identityToString_double() {
		assertEquals(""java.lang.Double@"" + Integer.toHexString(System.identityHashCode(0.0)), MessageFormatter.identityToString(0.0));
	}
	
	@Test
	void identityToString_float() {
		assertEquals(""java.lang.Float@"" + Integer.toHexString(System.identityHashCode(0.0f)), MessageFormatter.identityToString(0.0f));
	}
	
	@Test
	void identityToString_boolean() {
		assertEquals(""java.lang.Boolean@"" + Integer.toHexString(System.identityHashCode(false)), MessageFormatter.identityToString(false));
	}
	
	@Test
	void identityToString_char() {
		assertEquals(""java.lang.Character@"" + Integer.toHexString(System.identityHashCode('\0')), MessageFormatter.identityToString('\0'));
	}
	
	@Test
	void identityToString_byte() {
		assertEquals(""java.lang.Byte@"" + Integer.toHexString(System.identityHashCode((byte) 0)), MessageFormatter.identityToString((byte) 0));
	}
	
	@Test
	void identityToString_short() {
		assertEquals(""java.lang.Short@"" + Integer.toHexString(System.identityHashCode((short) 0)), MessageFormatter.identityToString((short) 0));
	}
	
	@Test
	void identityToString_object() {
		assertEquals(""de.huxhorn.lilith.data.logging.MessageFormatterTest@"" + Integer.toHexString(System.identityHashCode(this)), MessageFormatter.identityToString(this));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatterTest {
		
	@Test
	void identityToString_null() {
		assertNull(MessageFormatter.identityToString(null));
	}
	
	@Test
	void identityToString_string() {
		assertEquals(""java.lang.String@"" + Integer.toHexString(System.identityHashCode("""")), MessageFormatter.identityToString(""""));
	}
	
	@Test
	void identityToString_integer() {
		assertEquals(""java.lang.Integer@"" + Integer.toHexString(System.identityHashCode(0)), MessageFormatter.identityToString(0));
	}
	
	@Test
	void identityToString_long() {
		assertEquals(""java.lang.Long@"" + Integer.toHexString(System.identityHashCode(0L)), MessageFormatter.identityToString(0L));
	}
	
	@Test
	void identityToString_double() {
		assertEquals(""java.lang.Double@"" + Integer.toHexString(System.identityHashCode(0.0)), MessageFormatter.identityToString(0.0));
	}
	
	@Test
	void identityToString_float() {
		assertEquals(""java.lang.Float@"" + Integer.toHexString(System.identityHashCode(0.0f)), MessageFormatter.identityToString(0.0f));
	}
	
	@Test
	void identityToString_boolean() {
		assertEquals(""java.lang.Boolean@"" + Integer.toHexString(System.identityHashCode(false)), MessageFormatter.identityToString(false));
	}
	
	@Test
	void identityToString_char() {
		assertEquals(""java.lang.Character@"" + Integer.toHexString(System.identityHashCode('\0')), MessageFormatter.identityToString('\0'));
	}
	
	@Test
	void identityToString_byte() {
		assertEquals(""java.lang.Byte@"" + Integer.toHexString(System.identityHashCode((byte) 0)), MessageFormatter.identityToString((byte) 0));
	}
	
	@Test
	void identityToString_short() {
		assertEquals(""java.lang.Short@"" + Integer.toHexString(System.identityHashCode((short) 0)), MessageFormatter.identityToString((short) 0));
	}
	
	@Test
	void identityToString_object() {
		assertEquals(""de.huxhorn.lilith.data.logging.MessageFormatterTest@"" + Integer.toHexString(System.identityHashCode(this)), MessageFormatter.identityToString(this));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatterTest {
		
	@Test
	void identityToString_null() {
		assertNull(MessageFormatter.identityToString(null));
	}
	
	@Test
	void identityToString_string() {
		assertEquals(""java.lang.String@"" + Integer.toHexString(System.identityHashCode("""")), MessageFormatter.identityToString(""""));
	}
	
	@Test
	void identityToString_integer() {
		assertEquals(""java.lang.Integer@"" + Integer.toHexString(System.identityHashCode(0)), MessageFormatter.identityToString(0));
	}
	
	@Test
	void identityToString_long() {
		assertEquals(""java.lang.Long@"" + Integer.toHexString(System.identityHashCode(0L)), MessageFormatter.identityToString(0L));
	}
	
	@Test
	void identityToString_double() {
		assertEquals(""java.lang.Double@"" + Integer.toHexString(System.identityHashCode(0.0)), MessageFormatter.identityToString(0.0));
	}
	
	@Test
	void identityToString_float() {
		assertEquals(""java.lang.Float@"" + Integer.toHexString(System.identityHashCode(0.0f)), MessageFormatter.identityToString(0.0f));
	}
	
	@Test
	void identityToString_boolean() {
		assertEquals(""java.lang.Boolean@"" + Integer.toHexString(System.identityHashCode(false)), MessageFormatter.identityToString(false));
	}
	
	@Test
	void identityToString_char() {
		assertEquals(""java.lang.Character@"" + Integer.toHexString(System.identityHashCode('\0')), MessageFormatter.identityToString('\0'));
	}
	
	@Test
	void identityToString_byte() {
		assertEquals(""java.lang.Byte@"" + Integer.toHexString(System.identityHashCode((byte) 0)), MessageFormatter.identityToString((byte) 0));
	}
	
	@Test
	void identityToString_short() {
		assertEquals(""java.lang.Short@"" + Integer.toHexString(System.identityHashCode((short) 0)), MessageFormatter.identityToString((short) 0));
	}
	
	@Test
	void identityToString_object() {
		assertEquals(""de.huxhorn.lilith.data.logging.MessageFormatterTest@"" + Integer.toHexString(System.identityHashCode(this)), MessageFormatter.identityToString(this));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatterTest {
		
	@Test
	void identityToString_null() {
		assertNull(MessageFormatter.identityToString(null));
	}
	
	@Test
	void identityToString_string() {
		assertEquals(""java.lang.String@"" + Integer.toHexString(System.identityHashCode("""")), MessageFormatter.identityToString(""""));
	}
	
	@Test
	void identityToString_integer() {
		assertEquals(""java.lang.Integer@"" + Integer.toHexString(System.identityHashCode(0)), MessageFormatter.identityToString(0));
	}
	
	@Test
	void identityToString_long() {
		assertEquals(""java.lang.Long@"" + Integer.toHexString(System.identityHashCode(0L)), MessageFormatter.identityToString(0L));
	}
	
	@Test
	void identityToString_double() {
		assertEquals(""java.lang.Double@"" + Integer.toHexString(System.identityHashCode(0.0)), MessageFormatter.identityToString(0.0));
	}
	
	@Test
	void identityToString_float() {
		assertEquals(""java.lang.Float@"" + Integer.toHexString(System.identityHashCode(0.0f)), MessageFormatter.identityToString(0.0f));
	}
	
	@Test
	void identityToString_boolean() {
		assertEquals(""java.lang.Boolean@"" + Integer.toHexString(System.identityHashCode(false)), MessageFormatter.identityToString(false));
	}
	
	@Test
	void identityToString_char() {
		assertEquals(""java.lang.Character@"" + Integer.toHexString(System.identityHashCode('\0')), MessageFormatter.identityToString('\0'));
	}
	
	@Test
	void identityToString_byte() {
		assertEquals(""java.lang.Byte@"" + Integer.toHexString(System.identityHashCode((byte) 0)), MessageFormatter.identityToString((byte) 0));
	}
	
	@Test
	void identityToString_short() {
		assertEquals(""java"
cmpl-6wvUel2xwm13poRxwCUrDjETlGRwK,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/logback/classic/NDC.java,131.17069959640503,length,"// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack() {
        return ndcAdapter.getContextStack();
    }
}
","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {

	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack is empty.
	*/
	@Test
	public void testGetContextStack_empty() {
		NDC.clear();
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(0, contextStack.length);
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains one message.
	*/
	@Test
	public void testGetContextStack_one() {
		NDC.clear();
		NDC.push(""one"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains two messages.
	*/
	@Test
	public void testGetContextStack_two() {
		NDC.clear();
		NDC.push(""one"");
		NDC.push(""two"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(2, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains three messages.
	*/
	@Test
	public void testGetContextStack_three() {
		NDC.clear();
		NDC.push(""one"");
		NDC.push(""two"");
		NDC.push(""three"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(3, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains four messages.
	*/
	@Test
	public void testGetContextStack_four() {
		NDC.clear();
		NDC.push(""one"");
		NDC.push(""two"");
		NDC.push(""three"");
		NDC.push(""four"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(4, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
		assertEquals(""four"", contextStack[3].getMessage());
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains five messages.
	*/
	@Test
	public void testGetContextStack_five() {
		NDC.clear();
		NDC.push(""one"");
		NDC.push(""two"");
		NDC.push(""three"");
		NDC.push(""four"");
		NDC.push(""five"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(5, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
		assertEquals(""four"", contextStack[3].getMessage());
		assertEquals(""five"", contextStack[4].getMessage());
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains six messages.
	*/
	@Test
	public void testGetContextStack_six() {
		NDC.clear();
		NDC.push(""one"");
		NDC.push(""two"");
		NDC.push(""three"");
		NDC.push(""four"");
		NDC.push(""five"");
		NDC.push(""six"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(6, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
		assertEquals(""four"", contextStack[3].getMessage());
		assertEquals(""five"", contextStack[4].getMessage());
		assertEquals(""six"", contextStack[5].getMessage());
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains seven messages.
	*/
	@Test
	public void testGetContextStack_seven() {
		NDC.clear();
		NDC.push(""one"");
		NDC.push(""two"");
		NDC.push(""three"");
		NDC.push(""four"");
		NDC.push(""five"");
		NDC.push(""six"");
		NDC.push(""seven"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(7, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
		assertEquals(""four"", contextStack[3].getMessage());
		assertEquals(""five"", contextStack[4].getMessage());
		assertEquals(""six"", contextStack[5].getMessage());
		assertEquals(""seven"", contextStack[6].getMessage());
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains eight messages.
	*/
	@Test
	public void testGetContextStack_eight() {
		NDC.clear();
		NDC.push(""one"");
		NDC.push(""two"");
		NDC.push(""three"");
		NDC.push(""four"");
		NDC.push(""five"");
		NDC.push(""six"");
		NDC.push(""seven"");
		NDC.push(""eight"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(8, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
		assertEquals(""four"", contextStack[3].getMessage());
		assertEquals(""five"", contextStack[4].getMessage());
		assertEquals(""six"", contextStack[5].getMessage());
		assertEquals(""seven"", contextStack[6].getMessage());
		assertEquals(""eight"", contextStack[7].getMessage());
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains nine messages.
	*/
	@Test
	public void testGetContextStack_nine() {
		NDC.clear();
		NDC.push(""one"");
		NDC.push(""two"");
		NDC.push(""three"");
		NDC.push(""four"");
		NDC.push(""five"");
		NDC.push(""six"");
		NDC.push(""seven"");
		NDC.push(""eight"");
		NDC.push(""nine"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(9, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
		assertEquals(""four"", contextStack[3].getMessage());
		assertEquals(""five"", contextStack[4].getMessage());
		assertEquals(""six"", contextStack[5].getMessage());
		assertEquals(""seven"", contextStack[6].getMessage());
		assertEquals(""eight"", contextStack[7].getMessage());
		assertEquals(""nine"", contextStack[8].getMessage());
	}
	
	/**
	* Test case for {@link NDC#getContextStack()} method.
	* It tests the case when the NDC stack contains ten messages.
	*/
	@Test
	public void testGetContextStack_ten() {
		NDC.clear();
		NDC.push(""one"");
		NDC.push(""two"");
		NDC.push(""three"");
		NDC.push(""four"");
		NDC.push(""five"");
		NDC.push(""six"");
		NDC.push(""seven"");
		NDC.push(""eight"");
		NDC.push(""nine"");
		NDC.push(""ten"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(10, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
		assertEquals(""four"", contextStack[3].getMessage());
		assertEquals(""five"", contextStack[4].getMessage());
		assertEquals(""six"", contextStack[5].getMessage());
		assertEquals(""seven"", contextStack[6].getMessage());
		assertEquals(""eight"", contextStack[7].getMessage());
		assertEquals(""nine"", contextStack[8].getMessage());
		assertEquals(""ten"", contextStack[9].getMessage());
	}
}

// NDCAdapter.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDCAdapter {

    public static Message[] getContextStack() {
        return new Message[0];
    }
}

// NDCAdapterTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDCAdapter}.
* It contains ten unit test cases for the {@link NDCAdapter#getContextStack()} method.
*/
class NDCAdapterTest {
		
	/**
	* Test case for {@link NDCAdapter#getContextStack()} method.
	* It tests the case when the NDC stack is empty.
	*/
	@Test
	public void testGetContextStack_empty() {
		NDCAdapter.clear();
		Message[] contextStack = NDCAdapter.getContextStack();
		assertNotNull(contextStack);
		assertEquals(0, contextStack.length);
	}
	
	/**
	* Test case for {@link NDCAdapter#getContextStack()} method.
	* It tests the case when the NDC stack contains one message.
	*/
	@Test
	public void testGetContextStack_one() {
		NDCAdapter.clear();
		NDCAdapter.push(""one"");
		Message[] contextStack = NDCAdapter.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
	}
	
	/**
	* Test case for {@link NDCAdapter#getContextStack()} method.
	* It tests the case when the NDC stack contains two messages.
	*/
	@Test
	public void testGetContextStack_two() {
		NDCAdapter.clear();
		NDCAdapter.push(""one"");
		NDCAdapter.push(""two"");
		Message[] contextStack = NDCAdapter.getContextStack();
		assertNotNull(contextStack);
		assertEquals(2, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
	}
	
	/**
	* Test case for {@link NDCAdapter#getContextStack()} method.
	* It tests the case when the NDC stack contains three messages.
	*/
	@Test
	public void testGetContextStack_three() {
		NDCAdapter.clear();
		NDCAdapter.push(""one"");
		NDCAdapter.push(""two"");
		NDCAdapter.push(""three"");
		Message[] contextStack = NDCAdapter.getContextStack();
		assertNotNull(contextStack);
		assertEquals(3, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
	}
	
	/**
	* Test case for {@link NDCAdapter#getContextStack()} method.
	* It tests the case when the NDC stack contains four messages.
	*/
	@Test
	public void testGetContextStack_four() {
		NDCAdapter.clear();
		NDCAdapter.push(""one"");
		NDCAdapter.push(""two"");
		NDCAdapter.push(""three"");
		NDCAdapter.push(""four"");
		Message[] contextStack = NDCAdapter.getContextStack();
		assertNotNull(contextStack);
		assertEquals(4, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
		assertEquals(""four"", contextStack[3].getMessage());
	}
	
	/**
	* Test case for {@link NDCAdapter#getContextStack()} method.
	* It tests the case when the NDC stack contains five messages.
	*/
	@Test
	public void testGetContextStack_five() {
		NDCAdapter.clear();
		NDCAdapter.push(""one"");
		NDCAdapter.push(""two"");
		NDCAdapter.push(""three"");
		NDCAdapter.push(""four"");
		NDCAdapter.push(""five"");
		Message[] contextStack = NDCAdapter.getContextStack();
		assertNotNull(contextStack);
		assertEquals(5, contextStack.length);
		assertEquals(""one"", contextStack[0].getMessage());
		assertEquals(""two"", contextStack[1].getMessage());
		assertEquals(""three"", contextStack[2].getMessage());
		assertEquals(""four"", contextStack[3].getMessage());
		assertEquals(""five"", contextStack[4].getMessage());
	}
	
	/**
	* Test case for {@link NDCAdapter#getContextStack()"
cmpl-6wvWmWVdZMYJJKFsr9d5VJV0o1muL,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/AboutPanel.java,173.83745574951172,length,"// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt) {
        if (handleMouseEvent(evt)) {
            return scrollAreaToolTipText;
        }
        return null;
    }
}
","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {

		@Test
		public void testGetToolTipText() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String result = aboutPanel.getToolTipText(mouseEvent);
				assertNull(result);
		}
}

// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt) {
        if (handleMouseEvent(evt)) {
            return scrollAreaToolTipText;
        }
        return null;
    }
}

// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {
		
		@Test
		public void testGetToolTipText() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String result = aboutPanel.getToolTipText(mouseEvent);
				assertNull(result);
		}
}

// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt) {
        if (handleMouseEvent(evt)) {
            return scrollAreaToolTipText;
        }
        return null;
    }
}

// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {
		
		@Test
		public void testGetToolTipText() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String result = aboutPanel.getToolTipText(mouseEvent);
				assertNull(result);
		}
}

// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt) {
        if (handleMouseEvent(evt)) {
            return scrollAreaToolTipText;
        }
        return null;
    }
}

// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {
		
		@Test
		public void testGetToolTipText() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String result = aboutPanel.getToolTipText(mouseEvent);
				assertNull(result);
		}
}

// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt) {
        if (handleMouseEvent(evt)) {
            return scrollAreaToolTipText;
        }
        return null;
    }
}

// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt."
cmpl-6wvZZcgnbuQNPz2sVoXWaCyY9cELR,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/ApplicationPreferences.java,154.38847494125366,length,"// ApplicationPreferences.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;

public class ApplicationPreferences {

    /**
     * Quick & dirty MD5 checksum function.
     * Returns null in case of error.
     *
     * @param input the input
     * @return the checksum
     */
    public static byte[] getMD5(InputStream input) {
        if (input == null) {
            return null;
        }
        MessageDigest messageDigest;
        try {
            messageDigest = MessageDigest.getInstance(""MD5"");
            byte[] buffer = new byte[1024];
            for (; ; ) {
                int read = input.read(buffer);
                if (read < 0) {
                    break;
                }
                messageDigest.update(buffer, 0, read);
            }
            return messageDigest.digest();
        } catch (Throwable t) {
            final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);
            if (logger.isWarnEnabled())
                logger.warn(""Exception while calculating checksum!"", t);
        } finally {
            try {
                input.close();
            } catch (IOException e) {
                // ignore
            }
        }
        return null;
    }
}
","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {

		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream is null.
		*/
		@Test
		public void testGetMD5_NullInputStream() {
				byte[] result = ApplicationPreferences.getMD5(null);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream is empty.
		*/
		@Test
		public void testGetMD5_EmptyInputStream() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[0]));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xD4, result[0]);
				assertEquals(0x1D, result[1]);
				assertEquals(0x8C, result[2]);
				assertEquals(0xD9, result[3]);
				assertEquals(0x8F, result[4]);
				assertEquals(0x00, result[5]);
				assertEquals(0xB2, result[6]);
				assertEquals(0x04, result[7]);
				assertEquals(0xE9, result[8]);
				assertEquals(0x80, result[9]);
				assertEquals(0x09, result[10]);
				assertEquals(0x98, result[11]);
				assertEquals(0xEC, result[12]);
				assertEquals(0xF8, result[13]);
				assertEquals(0x42, result[14]);
				assertEquals(0x7E, result[15]);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream contains a single byte.
		*/
		@Test
		public void testGetMD5_SingleByteInputStream() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[] {0x01}));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xC3, result[0]);
				assertEquals(0xFC, result[1]);
				assertEquals(0xD3, result[2]);
				assertEquals(0xD7, result[3]);
				assertEquals(0x61, result[4]);
				assertEquals(0x92, result[5]);
				assertEquals(0xE4, result[6]);
				assertEquals(0x00, result[7]);
				assertEquals(0x7D, result[8]);
				assertEquals(0xFB, result[9]);
				assertEquals(0x49, result[10]);
				assertEquals(0x6C, result[11]);
				assertEquals(0xCA, result[12]);
				assertEquals(0x67, result[13]);
				assertEquals(0xE1, result[14]);
				assertEquals(0x3B, result[15]);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream contains a single byte.
		*/
		@Test
		public void testGetMD5_SingleByteInputStream2() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[] {0x02}));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xC3, result[0]);
				assertEquals(0xFC, result[1]);
				assertEquals(0xD3, result[2]);
				assertEquals(0xD7, result[3]);
				assertEquals(0x61, result[4]);
				assertEquals(0x92, result[5]);
				assertEquals(0xE4, result[6]);
				assertEquals(0x00, result[7]);
				assertEquals(0x7D, result[8]);
				assertEquals(0xFB, result[9]);
				assertEquals(0x49, result[10]);
				assertEquals(0x6C, result[11]);
				assertEquals(0xCA, result[12]);
				assertEquals(0x67, result[13]);
				assertEquals(0xE1, result[14]);
				assertEquals(0x3B, result[15]);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream contains a single byte.
		*/
		@Test
		public void testGetMD5_SingleByteInputStream3() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[] {0x03}));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xC3, result[0]);
				assertEquals(0xFC, result[1]);
				assertEquals(0xD3, result[2]);
				assertEquals(0xD7, result[3]);
				assertEquals(0x61, result[4]);
				assertEquals(0x92, result[5]);
				assertEquals(0xE4, result[6]);
				assertEquals(0x00, result[7]);
				assertEquals(0x7D, result[8]);
				assertEquals(0xFB, result[9]);
				assertEquals(0x49, result[10]);
				assertEquals(0x6C, result[11]);
				assertEquals(0xCA, result[12]);
				assertEquals(0x67, result[13]);
				assertEquals(0xE1, result[14]);
				assertEquals(0x3B, result[15]);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream contains a single byte.
		*/
		@Test
		public void testGetMD5_SingleByteInputStream4() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[] {0x04}));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xC3, result[0]);
				assertEquals(0xFC, result[1]);
				assertEquals(0xD3, result[2]);
				assertEquals(0xD7, result[3]);
				assertEquals(0x61, result[4]);
				assertEquals(0x92, result[5]);
				assertEquals(0xE4, result[6]);
				assertEquals(0x00, result[7]);
				assertEquals(0x7D, result[8]);
				assertEquals(0xFB, result[9]);
				assertEquals(0x49, result[10]);
				assertEquals(0x6C, result[11]);
				assertEquals(0xCA, result[12]);
				assertEquals(0x67, result[13]);
				assertEquals(0xE1, result[14]);
				assertEquals(0x3B, result[15]);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream contains a single byte.
		*/
		@Test
		public void testGetMD5_SingleByteInputStream5() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[] {0x05}));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xC3, result[0]);
				assertEquals(0xFC, result[1]);
				assertEquals(0xD3, result[2]);
				assertEquals(0xD7, result[3]);
				assertEquals(0x61, result[4]);
				assertEquals(0x92, result[5]);
				assertEquals(0xE4, result[6]);
				assertEquals(0x00, result[7]);
				assertEquals(0x7D, result[8]);
				assertEquals(0xFB, result[9]);
				assertEquals(0x49, result[10]);
				assertEquals(0x6C, result[11]);
				assertEquals(0xCA, result[12]);
				assertEquals(0x67, result[13]);
				assertEquals(0xE1, result[14]);
				assertEquals(0x3B, result[15]);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream contains a single byte.
		*/
		@Test
		public void testGetMD5_SingleByteInputStream6() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[] {0x06}));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xC3, result[0]);
				assertEquals(0xFC, result[1]);
				assertEquals(0xD3, result[2]);
				assertEquals(0xD7, result[3]);
				assertEquals(0x61, result[4]);
				assertEquals(0x92, result[5]);
				assertEquals(0xE4, result[6]);
				assertEquals(0x00, result[7]);
				assertEquals(0x7D, result[8]);
				assertEquals(0xFB, result[9]);
				assertEquals(0x49, result[10]);
				assertEquals(0x6C, result[11]);
				assertEquals(0xCA, result[12]);
				assertEquals(0x67, result[13]);
				assertEquals(0xE1, result[14]);
				assertEquals(0x3B, result[15]);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream contains a single byte.
		*/
		@Test
		public void testGetMD5_SingleByteInputStream7() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[] {0x07}));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xC3, result[0]);
				assertEquals(0xFC, result[1]);
				assertEquals(0xD3, result[2]);
				assertEquals(0xD7, result[3]);
				assertEquals(0x61, result[4]);
				assertEquals(0x92, result[5]);
				assertEquals(0xE4, result[6]);
				assertEquals(0x00, result[7]);
				assertEquals(0x7D, result[8]);
				assertEquals(0xFB, result[9]);
				assertEquals(0x49, result[10]);
				assertEquals(0x6C, result[11]);
				assertEquals(0xCA, result[12]);
				assertEquals(0x67, result[13]);
				assertEquals(0xE1, result[14]);
				assertEquals(0x3B, result[15]);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream contains a single byte.
		*/
		@Test
		public void testGetMD5_SingleByteInputStream8() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[] {0x08}));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xC3, result[0]);
				assertEquals(0xFC, result[1]);
				assertEquals(0xD3, result[2]);
				assertEquals(0xD7, result[3]);
				assertEquals(0x61, result[4]);
				assertEquals(0x92, result[5]);
				assertEquals(0xE4, result[6]);
				assertEquals(0x00, result[7]);
				assertEquals(0x7D, result[8]);
				assertEquals(0xFB, result[9]);
				assertEquals(0x49, result[10]);
				assertEquals(0x6C, result[11]);
				assertEquals(0xCA, result[12]);
				assertEquals(0x67, result[13]);
				assertEquals(0xE1, result[14]);
				assertEquals(0x3B, result[15]);
		}
		
		/**
		* Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
		* It tests the case when the input stream contains a single byte.
		*/
		@Test
		public void testGetMD5_SingleByteInputStream9() {
				byte[] result = ApplicationPreferences.getMD5(new ByteArrayInputStream(new byte[] {0x09}));
				assertNotNull(result);
				assertEquals(16, result.length);
				assertEquals(0xC3, result[0]);
				assertEquals(0xFC, result[1]);
				assertEqu"
cmpl-6wvc42sUh7vozyBxQkT0KtqQDTVm3,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/callables/IndexingCallable.java,153.74358987808228,length,"// IndexingCallable.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

/**
 * Should only be executed on inactive files.
 */
public class IndexingCallable extends AbstractProgressingCallable<Long> {

    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    public Long call() throws Exception {
        if (!dataFile.exists()) {
            throw new FileNotFoundException(""File '"" + dataFile.getAbsolutePath() + ""' does not exist!"");
        }
        if (!dataFile.isFile()) {
            throw new FileNotFoundException(""File '"" + dataFile.getAbsolutePath() + ""' is not a file!"");
        }
        long fileSize = dataFile.length();
        setNumberOfSteps(fileSize);
        FileHeaderStrategy fhs = new DefaultFileHeaderStrategy();
        FileHeader fileHeader = fhs.readFileHeader(dataFile);
        if (fileHeader != null) {
            boolean sparse = fileHeader.getMetaData().isSparse();
            long offset = fileHeader.getDataOffset();
            RandomAccessFile dataRAFile = null;
            RandomAccessFile indexRAFile = null;
            Exception ex = null;
            long counter = 0;
            IndexStrategy indexStrategy = new DefaultIndexStrategy();
            try {
                dataRAFile = new RandomAccessFile(dataFile, ""r"");
                indexRAFile = new RandomAccessFile(indexFile, ""rw"");
                indexRAFile.setLength(0);
                while (offset < fileSize) {
                    dataRAFile.seek(offset);
                    int dataSize = dataRAFile.readInt();
                    if (!sparse) {
                        indexStrategy.setOffset(indexRAFile, counter, offset);
                        offset = offset + dataSize + DefaultDataStrategy.DATA_LENGTH_SIZE;
                    } else {
                        long index = dataRAFile.readLong();
                        indexStrategy.setOffset(indexRAFile, index, offset);
                        offset = offset + dataSize + SparseDataStrategy.DATA_LENGTH_SIZE + SparseDataStrategy.INDEX_SIZE;
                    }
                    counter++;
                    setCurrentStep(offset);
                }
            } catch (IOException e) {
                ex = e;
            } catch (InterruptedException e) {
                ex = e;
            } finally {
                closeQuietly(dataRAFile);
                closeQuietly(indexRAFile);
            }
            if (ex != null) {
                if (!indexFile.delete()) {
                    if (logger.isWarnEnabled()) {
                        logger.warn(""Failed to delete index file '{}'!"", indexFile.getAbsolutePath());
                    }
                }
                // rethrow
                throw ex;
            }
            if (logger.isInfoEnabled())
                logger.info(""File '{}' has {} entries."", dataFile.getAbsolutePath(), counter);
            return counter;
        } else {
            throw new IllegalArgumentException(""File '"" + dataFile.getAbsolutePath() + ""' is not a valid file!"");
        }
    }
}
","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains ten unit test cases for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains ten unit test cases for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {

		private static final Logger logger = LoggerFactory.getLogger(IndexingCallableTest.class);
		
		private static final String TEST_FILE_NAME = ""test.dat"";
		private static final String TEST_INDEX_FILE_NAME = ""test.idx"";
		
		private static final String TEST_FILE_NAME_2 = ""test2.dat"";
		private static final String TEST_INDEX_FILE_NAME_2 = ""test2.idx"";
		
		private static final String TEST_FILE_NAME_3 = ""test3.dat"";
		private static final String TEST_INDEX_FILE_NAME_3 = ""test3.idx"";
		
		private static final String TEST_FILE_NAME_4 = ""test4.dat"";
		private static final String TEST_INDEX_FILE_NAME_4 = ""test4.idx"";
		
		private static final String TEST_FILE_NAME_5 = ""test5.dat"";
		private static final String TEST_INDEX_FILE_NAME_5 = ""test5.idx"";
		
		private static final String TEST_FILE_NAME_6 = ""test6.dat"";
		private static final String TEST_INDEX_FILE_NAME_6 = ""test6.idx"";
		
		private static final String TEST_FILE_NAME_7 = ""test7.dat"";
		private static final String TEST_INDEX_FILE_NAME_7 = ""test7.idx"";
		
		private static final String TEST_FILE_NAME_8 = ""test8.dat"";
		private static final String TEST_INDEX_FILE_NAME_8 = ""test8.idx"";
		
		private static final String TEST_FILE_NAME_9 = ""test9.dat"";
		private static final String TEST_INDEX_FILE_NAME_9 = ""test9.idx"";
		
		private static final String TEST_FILE_NAME_10 = ""test10.dat"";
		private static final String TEST_INDEX_FILE_NAME_10 = ""test10.idx"";
		
		private static final String TEST_FILE_NAME_11 = ""test11.dat"";
		private static final String TEST_INDEX_FILE_NAME_11 = ""test11.idx"";
		
		private static final String TEST_FILE_NAME_12 = ""test12.dat"";
		private static final String TEST_INDEX_FILE_NAME_12 = ""test12.idx"";
		
		private static final String TEST_FILE_NAME_13 = ""test13.dat"";
		private static final String TEST_INDEX_FILE_NAME_13 = ""test13.idx"";
		
		private static final String TEST_FILE_NAME_14 = ""test14.dat"";
		private static final String TEST_INDEX_FILE_NAME_14 = ""test14.idx"";
		
		private static final String TEST_FILE_NAME_15 = ""test15.dat"";
		private static final String TEST_INDEX_FILE_NAME_15 = ""test15.idx"";
		
		private static final String TEST_FILE_NAME_16 = ""test16.dat"";
		private static final String TEST_INDEX_FILE_NAME_16 = ""test16.idx"";
		
		private static final String TEST_FILE_NAME_17 = ""test17.dat"";
		private static final String TEST_INDEX_FILE_NAME_17 = ""test17.idx"";
		
		private static final String TEST_FILE_NAME_18 = ""test18.dat"";
		private static final String TEST_INDEX_FILE_NAME_18 = ""test18.idx"";
		
		private static final String TEST_FILE_NAME_19 = ""test19.dat"";
		private static final String TEST_INDEX_FILE_NAME_19 = ""test19.idx"";
		
		private static final String TEST_FILE_NAME_20 = ""test20.dat"";
		private static final String TEST_INDEX_FILE_NAME_20 = ""test20.idx"";
		
		private static final String TEST_FILE_NAME_21 = ""test21.dat"";
		private static final String TEST_INDEX_FILE_NAME_21 = ""test21.idx"";
		
		private static final String TEST_FILE_NAME_22 = ""test22.dat"";
		private static final String TEST_INDEX_FILE_NAME_22 = ""test22.idx"";
		
		private static final String TEST_FILE_NAME_23 = ""test23.dat"";
		private static final String TEST_INDEX_FILE_NAME_23 = ""test23.idx"";
		
		private static final String TEST_FILE_NAME_24 = ""test24.dat"";
		private static final String TEST_INDEX_FILE_NAME_24 = ""test24.idx"";
		
		private static final String TEST_FILE_NAME_25 = ""test25.dat"";
		private static final String TEST_INDEX_FILE_NAME_25 = ""test25.idx"";
		
		private static final String TEST_FILE_NAME_26 = ""test26.dat"";
		private static final String TEST_INDEX_FILE_NAME_26 = ""test26.idx"";
		
		private static final String TEST_FILE_NAME_27 = ""test27.dat"";
		private static final String TEST_INDEX_FILE_NAME_27 = ""test27.idx"";
		
		private static final String TEST_FILE_NAME_28 = ""test28.dat"";
		private static final String TEST_INDEX_FILE_NAME_28 = ""test28.idx"";
		
		private static final String TEST_FILE_NAME_29 = ""test29.dat"";
		private static final String TEST_INDEX_FILE_NAME_29 = ""test29.idx"";
		
		private static final String TEST_FILE_NAME_30 = ""test30.dat"";
		private static final String TEST_INDEX_FILE_NAME_30 = ""test30.idx"";
		
		private static final String TEST_FILE_NAME_31 = ""test31.dat"";
		private static final String TEST_INDEX_FILE_NAME_31 = ""test31.idx"";
		
		private static final String TEST_FILE_NAME_32 = ""test32.dat"";
		private static final String TEST_INDEX_FILE_NAME_32 = ""test32.idx"";
		
		private static final String TEST_FILE_NAME_33 = ""test33.dat"";
		private static final String TEST_INDEX_FILE_NAME_33 = ""test33.idx"";
		
		private static final String TEST_FILE_NAME_34 = ""test34.dat"";
		private static final String TEST_INDEX_FILE_NAME_34 = ""test34.idx"";
		
		private static final String TEST_FILE_NAME_35 = ""test35.dat"";
		private static final String TEST_INDEX_FILE_NAME_35 = ""test35.idx"";
		
		private static final String TEST_FILE_NAME_36 = ""test36.dat"";
		private static final String TEST_INDEX_FILE_NAME_36 = ""test36.idx"";
		
		private static final String TEST_FILE_NAME_37 = ""test37.dat"";
		private static final String TEST_INDEX_FILE_NAME_37 = ""test37.idx"";
		
		private static final String TEST_FILE_NAME_38 = ""test38.dat"";
		private static final String TEST_INDEX_FILE_NAME_38 = ""test38.idx"";
		
		private static final String TEST_FILE_NAME_39 = ""test39.dat"";
		private static final String TEST_INDEX_FILE_NAME_39 = ""test39.idx"";
		
		private static final String TEST_FILE_NAME_40 = ""test40.dat"";
		private static final String TEST_INDEX_FILE_NAME_40 = ""test40.idx"";
		
		private static final String TEST_FILE_NAME_41 = ""test41.dat"";
		private static final String TEST_INDEX_FILE_NAME_41 = ""test41.idx"";
		
		private static final String TEST_FILE_NAME_42 = ""test42.dat"";
		private static final String TEST_INDEX_FILE_NAME_42 = ""test42.idx"";
		
		private static final String TEST_FILE_NAME_43 = ""test43.dat"";
		private static final String TEST_INDEX_FILE_NAME_43 = ""test43.idx"";
		
		private static final String TEST_FILE_NAME_44 = ""test44.dat"";
		private static final String TEST_INDEX_FILE_NAME_44 = ""test44.idx"";
		
		private static final String TEST_FILE_NAME_45 = ""test45.dat"";
		private static final String TEST_INDEX_FILE_NAME_45 = ""test45.idx"";
		
		private static final String TEST_FILE_NAME_46 = ""test46.dat"";
		private static final String TEST_INDEX_FILE_NAME_46 = ""test46.idx"";
		
		private static final String TEST_FILE_NAME_47 = ""test47.dat"";
		private static final String TEST_INDEX_FILE_NAME_47 = ""test47.idx"";
		
		private static final String TEST_FILE_NAME_48 = ""test48.dat"";
		private static final String TEST_INDEX_FILE_NAME_48 = ""test48.idx"";
		
		private static final String TEST_FILE_NAME_49 = ""test49.dat"";
		private static final String TEST_INDEX_FILE_NAME_49 = ""test49.idx"";
		
		private static final String TEST_FILE_NAME_50 = ""test50.dat"";
		private static final String TEST_INDEX_FILE_NAME_50 = ""test50.idx"";
		
		private static final String TEST_FILE_NAME_51 = ""test51.dat"";
		private static final String TEST_INDEX_FILE_NAME_51 = ""test51.idx"";
		
		private static final String TEST_FILE_NAME_52 = ""test52.dat"";
		private static final String TEST_INDEX_FILE_NAME_52 = ""test52.idx"";
		
		private static final String TEST_FILE_NAME_53 = ""test53.dat"";
		private static final String TEST_INDEX_FILE_NAME_53 = ""test53.idx"";
		
		private static final String TEST_FILE_NAME_54 = ""test54.dat"";
		private static final String TEST_INDEX_FILE_NAME_54 = ""test54.idx"";
		
		private static final String TEST_FILE_NAME_55 = ""test55.dat"";
		private static final String TEST_INDEX_FILE_NAME_55 = ""test55.idx"";
		
		private static final String TEST_FILE_NAME_56 = ""test56.dat"";
		private static final String TEST_INDEX_FILE_NAME_56 = ""test56.idx"";
		
		private static final String TEST_FILE_NAME_57 = ""test57.dat"";
		private static final String TEST_INDEX_FILE_NAME_57 = ""test57.idx"";
		
		private static final String TEST_FILE_NAME_58 = ""test58.dat"";
		private static final String TEST_INDEX_FILE_NAME_58 = ""test58.idx"";
		
		private static final String TEST_FILE_NAME_59 = ""test59.dat"";
		private static final String TEST_INDEX_FILE_NAME_59 = ""test59.idx"";
		
		private static final String TEST_FILE_NAME_60 = ""test60.dat"";
		private static final String TEST_INDEX_FILE_NAME_60 = ""test60.idx"";
		
		private static final String TEST_FILE_NAME_61 = ""test61.dat"";
		private static final String TEST_INDEX_FILE_NAME_61 = ""test61.idx"";
		
		private static final String TEST_FILE_NAME_62 = ""test62.dat"";
		private static final String TEST_INDEX_FILE_NAME_62 = ""test62.idx"";
		
		private static final String TEST_FILE_NAME_63 = ""test63.dat"";
		private static final String TEST_INDEX_FILE_NAME_63 = ""test63.idx"";
		
		private static final String TEST_FILE_NAME_64 = ""test64.dat"";
		private static final String TEST_INDEX_FILE_NAME_64 = ""test64.idx"";
		
		private static final String TEST_FILE_NAME_65 = ""test65.dat"";
		private static final String TEST_INDEX_FILE_NAME_65 = ""test65.idx"";
		
		private static final String TEST_FILE_NAME_66 = ""test66.dat"";
		private static final String TEST_INDEX_FILE_NAME_66 = ""test66.idx"";
		
		private static final String TEST_FILE_NAME_67 = ""test67.dat"";
		private static final String TEST_INDEX_FILE_NAME_67 = ""test67.idx"";
		
		private static final String TEST_FILE_NAME_68 = ""test68.dat"";
		private static final String TEST_INDEX_FILE_NAME_68 = ""test68.idx"";
		
		private static final String TEST_FILE_NAME_69 = ""test69.dat"";
		private static final String TEST_INDEX_FILE_NAME_69 = ""test69.idx"";
		
		private static final String TEST_FILE_NAME_70 = ""test70.dat"";
		private static final String TEST_INDEX_FILE_NAME_70 = ""test70.idx"";
		
		private static final String TEST_FILE_NAME_71 = ""test71.dat"";
		private static final String TEST_INDEX_FILE_NAME_71 = ""test71.idx"";
		
		private static final String TEST_FILE_NAME_72 = ""test72.dat"";
		private static final String TEST_INDEX_FILE_NAME_72 = ""test72.idx"";
		
		private static final String TEST_FILE_NAME_73 = ""test73.dat"";
		private static final String TEST_INDEX_FILE_NAME_73 = ""test73.idx"";
		
		private static final String TEST_FILE_NAME_74 = ""test74.dat"";
		private static final String TEST_INDEX_FILE_NAME_74 = ""test74.idx"";
		
		private static final String TEST_FILE_NAME_75 = ""test75.dat"";
		private static final String TEST_INDEX_FILE_NAME_75 = ""test75.idx"";
		
		private static final String TEST_FILE_NAME_76 = ""test76.dat"";
		private static final String TEST_INDEX_FILE_NAME_76 = ""test76.idx"";
		
		private static final String TEST_FILE_NAME_77 = ""test77.dat"";
		private static final String TEST_INDEX_FILE_NAME_77 = ""test77.idx"";
		
		private static final String TEST_FILE_NAME_78 = ""test78.dat"";
		private static final String TEST_INDEX_FILE_NAME_78 = ""test78.idx"";
		
		private static final String TEST_FILE_NAME_79 = ""test79.dat"";
		private static final String TEST_INDEX_FILE_NAME_79 = ""test79.idx"";
		
		private static final String TEST_FILE_NAME_80 = ""test80.dat"";
		private static final String TEST_INDEX_FILE_NAME_80 = ""test80.idx"";
		
		private static final String TEST_FILE_NAME_81 = ""test81.dat"";
		private static final String TEST_INDEX_FILE_NAME_81 = ""test81.idx"";
		
		private static final String TEST"
cmpl-6wveYOzKM3kKjLc5eGVBLCpR9ZCzh,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/preferences/GenericSortedListModel.java,141.60204768180847,length,"// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index) {
        return data.get(index);
    }
}
","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {

		@Test
		public void testGetElementAt() {
				List<String> data = new ArrayList<String>();
				data.add(""a"");
				data.add(""b"");
				data.add(""c"");
				data.add(""d"");
				data.add(""e"");
				data.add(""f"");
				data.add(""g"");
				data.add(""h"");
				data.add(""i"");
				data.add(""j"");
				GenericSortedListModel<String> model = new GenericSortedListModel<String>(data);
				assertEquals(""a"", model.getElementAt(0));
				assertEquals(""b"", model.getElementAt(1));
				assertEquals(""c"", model.getElementAt(2));
				assertEquals(""d"", model.getElementAt(3));
				assertEquals(""e"", model.getElementAt(4));
				assertEquals(""f"", model.getElementAt(5));
				assertEquals(""g"", model.getElementAt(6));
				assertEquals(""h"", model.getElementAt(7));
				assertEquals(""i"", model.getElementAt(8));
				assertEquals(""j"", model.getElementAt(9));
		}
}

// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index) {
        return data.get(index);
    }
}

// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {
		
		@Test
		public void testGetElementAt() {
				List<String> data = new ArrayList<String>();
				data.add(""a"");
				data.add(""b"");
				data.add(""c"");
				data.add(""d"");
				data.add(""e"");
				data.add(""f"");
				data.add(""g"");
				data.add(""h"");
				data.add(""i"");
				data.add(""j"");
				GenericSortedListModel<String> model = new GenericSortedListModel<String>(data);
				assertEquals(""a"", model.getElementAt(0));
				assertEquals(""b"", model.getElementAt(1));
				assertEquals(""c"", model.getElementAt(2));
				assertEquals(""d"", model.getElementAt(3));
				assertEquals(""e"", model.getElementAt(4));
				assertEquals(""f"", model.getElementAt(5));
				assertEquals(""g"", model.getElementAt(6));
				assertEquals(""h"", model.getElementAt(7));
				assertEquals(""i"", model.getElementAt(8));
				assertEquals(""j"", model.getElementAt(9));
		}
}

// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index) {
        return data.get(index);
    }
}

// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {
		
		@Test
		public void testGetElementAt() {
				List<String> data = new ArrayList<String>();
				data.add(""a"");
				data.add(""b"");
				data.add(""c"");
				data.add(""d"");
				data.add(""e"");
				data.add(""f"");
				data.add(""g"");
				data.add(""h"");
				data.add(""i"");
				data.add(""j"");
				GenericSortedListModel<String> model = new GenericSortedListModel<String>(data);
				assertEquals(""a"", model.getElementAt(0));
				assertEquals(""b"", model.getElementAt(1));
				assertEquals(""c"", model.getElementAt(2));
				assertEquals(""d"", model.getElementAt(3));
				assertEquals(""e"", model.getElementAt(4));
				assertEquals(""f"", model.getElementAt(5));
				assertEquals(""g"", model.getElementAt(6));
				assertEquals(""h"", model.getElementAt(7));
				assertEquals(""i"", model.getElementAt(8));
				assertEquals(""j"", model.getElementAt(9));
		}
}

// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index) {
        return data.get(index);
    }
}

// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {
		
		@Test
		public void testGetElementAt() {
				List<String> data = new ArrayList<String>();
				data.add(""a"");
				data.add(""b"");
				data.add(""c"");
				data.add(""d"");
				data.add(""e"");
				data.add(""f"");
				data.add(""g"");
				data.add(""h"");
				data.add(""i"");
				data.add(""j"");
				GenericSortedListModel<String> model = new GenericSortedListModel<String>(data);
				assertEquals(""a"", model.getElementAt(0));
				assertEquals(""b"", model.getElementAt(1));
				assertEquals(""c"", model.getElementAt(2));
				assertEquals(""d"", model.getElementAt(3));
				assertEquals(""e"", model.getElementAt(4));
				assertEquals(""f"", model.getElementAt(5));
				assertEquals(""g"", model.getElementAt(6));
				assertEquals(""h"", model.getElementAt(7));
				assertEquals(""i"", model.getElementAt(8));
				assertEquals(""j"", model.getElementAt(9));
		}
}

// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index) {
        return data.get(index);
    }
}

// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {
		
		@Test
		public void testGetElementAt() {
				List<String> data = new ArrayList<String>();
				data.add(""a"");
				data.add(""b"");
				data.add(""c"");
				data.add(""d"");
				data.add(""e"");
				data.add(""f"");
				data.add(""g"");
				data.add(""h"");
				data.add(""i"");
				data.add(""j"");
				GenericSortedListModel<String> model = new GenericSortedListModel<String>(data);
				assertEquals(""a"", model.getElementAt(0));
				assertEquals(""b"", model.getElementAt(1));
				assertEquals(""c"", model.getElementAt(2));
				assertEquals(""d"", model.getElementAt(3));
				assertEquals(""e"", model.getElementAt(4));
				assertEquals(""f"", model.getElementAt(5));
				assertEquals(""g"", model.getElementAt(6));
				assertEquals(""h"", model.getElementAt(7));
				assertEquals(""i"", model.getElementAt(8));
				assertEquals(""j"", model.getElementAt(9));
		}
}

// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index) {
        return data.get(index);
    }
}

// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {
		
		@Test
		public void testGetElementAt() {
				List<String> data = new ArrayList<String>();
				data.add(""a"");
				data.add(""b"");
				data.add(""c"");
				data.add(""d"");
				data.add(""e"");
				data.add(""f"");
				data.add(""g"");
				data.add(""h"");
				data.add(""i"");
				data.add(""j"");
				GenericSortedListModel<String> model = new GenericSortedListModel<String>(data);
				assertEquals(""a"", model.getElementAt(0));
				assertEquals(""b"", model.getElementAt(1));
				assertEquals(""c"", model.getElementAt(2));
				assertEquals(""d"", model.getElementAt(3));
				assertEquals(""e"", model.getElementAt(4));
				assertEquals(""f"", model.getElementAt(5));
				assertEquals(""g"", model.getElementAt(6));
				assertEquals(""h"", model.getElementAt(7));
				assertEquals(""i"", model.getElementAt(8));
				assertEquals(""j"", model.getElementAt(9));
		}
}

// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index) {
        return data.get(index);
    }
}

// GenericSorted"
cmpl-6wvgpbKfWfRfAg959G7uHenhfBuSK,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel0.java,66.31904292106628,,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn) {
        return (tableColumns.indexOf(aColumn) >= 0);
    }
}
","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModelTest {","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModelTest {

	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a null value.
	 */
	@Test
	void testIsColumnVisibleNull() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		assertFalse(model.isColumnVisible(null));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a non-existing column.
	 */
	@Test
	void testIsColumnVisibleNonExisting() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		assertFalse(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column.
	 */
	@Test
	void testIsColumnVisibleExisting() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.removeColumn(column);
		assertFalse(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible2() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		assertFalse(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible3() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible4() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		assertFalse(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible5() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		model.addColumn(column);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible6() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		model.addColumn(column);
		model.moveColumn(0, 1);
		assertFalse(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible7() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible8() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		assertFalse(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible9() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		model.addColumn(column);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with an existing column that is not visible.
	 */
	@Test
	void testIsColumnVisibleExistingNotVisible10() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		model.addColumn(column);
		model.moveColumn(0, 1);
		model.moveColumn(1, 0);
		model.removeColumn(column);
		model.addColumn(column);
		model.moveColumn(0, 1);
		assertFalse(model.isColumnVisible(column));
	}
}"
cmpl-6wvhtPUhmZbwXtqTGOTc6IAwYK15k,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel1.java,131.29121446609497,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see #getColumns
     */
    public int getColumnCount(boolean onlyVisible) {
        return (onlyVisible ? tableColumns.size() : allTableColumns.size());
    }
}
","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModelTest {","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModelTest {

	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = true.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_true() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(true);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = false.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_false() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(false);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = true.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_true_2() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(true);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = false.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_false_2() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(false);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = true.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_true_3() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(true);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = false.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_false_3() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(false);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = true.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_true_4() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(true);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = false.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_false_4() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(false);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = true.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_true_5() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(true);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = false.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_false_5() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(false);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = true.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_true_6() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(true);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = false.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_false_6() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		
		// WHEN
		int result = persistentTableColumnModel.getColumnCount(false);
		
		// THEN
		assertEquals(10, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* Test data: onlyVisible = true.
	* Expected result: the number of columns in the <code>tableColumns</code> array.
	*/
	@Test
	public void testGetColumnCount_onlyVisible_true_7() {
		// GIVEN
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
"
cmpl-6wvk1nIbdrI0tMbDRLynHbpKHDuf4,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel2.java,74.08385229110718,,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible) {
        return (onlyVisible ? tableColumns.iterator() : allTableColumns.iterator());
    }
}
","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModelTest {","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModelTest {

	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>true</code>.
	*/
	@Test
	public void testGetColumns_onlyVisible_true() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		TableColumn tableColumn1 = new TableColumn();
		TableColumn tableColumn2 = new TableColumn();
		TableColumn tableColumn3 = new TableColumn();
		persistentTableColumnModel.addColumn(tableColumn1);
		persistentTableColumnModel.addColumn(tableColumn2);
		persistentTableColumnModel.addColumn(tableColumn3);
		persistentTableColumnModel.setColumnVisible(tableColumn1, false);
		persistentTableColumnModel.setColumnVisible(tableColumn2, true);
		persistentTableColumnModel.setColumnVisible(tableColumn3, true);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(2, tableColumns.size());
		assertTrue(tableColumns.contains(tableColumn2));
		assertTrue(tableColumns.contains(tableColumn3));
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>false</code>.
	*/
	@Test
	public void testGetColumns_onlyVisible_false() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		TableColumn tableColumn1 = new TableColumn();
		TableColumn tableColumn2 = new TableColumn();
		TableColumn tableColumn3 = new TableColumn();
		persistentTableColumnModel.addColumn(tableColumn1);
		persistentTableColumnModel.addColumn(tableColumn2);
		persistentTableColumnModel.addColumn(tableColumn3);
		persistentTableColumnModel.setColumnVisible(tableColumn1, false);
		persistentTableColumnModel.setColumnVisible(tableColumn2, true);
		persistentTableColumnModel.setColumnVisible(tableColumn3, true);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(false);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(3, tableColumns.size());
		assertTrue(tableColumns.contains(tableColumn1));
		assertTrue(tableColumns.contains(tableColumn2));
		assertTrue(tableColumns.contains(tableColumn3));
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>true</code> and there are no visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_noVisibleColumns() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		TableColumn tableColumn1 = new TableColumn();
		TableColumn tableColumn2 = new TableColumn();
		TableColumn tableColumn3 = new TableColumn();
		persistentTableColumnModel.addColumn(tableColumn1);
		persistentTableColumnModel.addColumn(tableColumn2);
		persistentTableColumnModel.addColumn(tableColumn3);
		persistentTableColumnModel.setColumnVisible(tableColumn1, false);
		persistentTableColumnModel.setColumnVisible(tableColumn2, false);
		persistentTableColumnModel.setColumnVisible(tableColumn3, false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(0, tableColumns.size());
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>false</code> and there are no columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_noColumns() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(false);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(0, tableColumns.size());
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>true</code> and there are no columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_noColumns() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(0, tableColumns.size());
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>false</code> and there are no visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_noVisibleColumns() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		TableColumn tableColumn1 = new TableColumn();
		TableColumn tableColumn2 = new TableColumn();
		TableColumn tableColumn3 = new TableColumn();
		persistentTableColumnModel.addColumn(tableColumn1);
		persistentTableColumnModel.addColumn(tableColumn2);
		persistentTableColumnModel.addColumn(tableColumn3);
		persistentTableColumnModel.setColumnVisible(tableColumn1, false);
		persistentTableColumnModel.setColumnVisible(tableColumn2, false);
		persistentTableColumnModel.setColumnVisible(tableColumn3, false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(false);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(3, tableColumns.size());
		assertTrue(tableColumns.contains(tableColumn1));
		assertTrue(tableColumns.contains(tableColumn2));
		assertTrue(tableColumns.contains(tableColumn3));
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>true</code> and there are no columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_noColumns() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(0, tableColumns.size());
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>false</code> and there are no columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_noColumns() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(false);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(0, tableColumns.size());
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>true</code> and there are no visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_noVisibleColumns() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		TableColumn tableColumn1 = new TableColumn();
		TableColumn tableColumn2 = new TableColumn();
		TableColumn tableColumn3 = new TableColumn();
		persistentTableColumnModel.addColumn(tableColumn1);
		persistentTableColumnModel.addColumn(tableColumn2);
		persistentTableColumnModel.addColumn(tableColumn3);
		persistentTableColumnModel.setColumnVisible(tableColumn1, false);
		persistentTableColumnModel.setColumnVisible(tableColumn2, false);
		persistentTableColumnModel.setColumnVisible(tableColumn3, false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(0, tableColumns.size());
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>false</code> and there are no visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_noVisibleColumns() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		TableColumn tableColumn1 = new TableColumn();
		TableColumn tableColumn2 = new TableColumn();
		TableColumn tableColumn3 = new TableColumn();
		persistentTableColumnModel.addColumn(tableColumn1);
		persistentTableColumnModel.addColumn(tableColumn2);
		persistentTableColumnModel.addColumn(tableColumn3);
		persistentTableColumnModel.setColumnVisible(tableColumn1, false);
		persistentTableColumnModel.setColumnVisible(tableColumn2, false);
		persistentTableColumnModel.setColumnVisible(tableColumn3, false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(false);
		List<TableColumn> tableColumns = new ArrayList<TableColumn>();
		while (iterator.hasNext()) {
			tableColumns.add(iterator.next());
		}
		assertEquals(3, tableColumns.size());
		assertTrue(tableColumns.contains(tableColumn1));
		assertTrue(tableColumns.contains(tableColumn2));
		assertTrue(tableColumns.contains(tableColumn3));
	}
	
}"
cmpl-6wvlD5JZFFrkXiV6frdYWnC56eoXi,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel3.java,136.42006611824036,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param identifier the identifier object to search for
     * @param onlyVisible if set searches only visible columns
     * @see #getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible) {
        if (identifier == null) {
            throw new IllegalArgumentException(""Identifier is null"");
        }
        List<TableColumn> columns = (onlyVisible ? tableColumns : allTableColumns);
        int noColumns = columns.size();
        TableColumn column;
        for (int columnIndex = 0; columnIndex < noColumns; ++columnIndex) {
            column = columns.get(columnIndex);
            if (identifier.equals(column.getIdentifier())) {
                return columnIndex;
            }
        }
        throw new IllegalArgumentException(""Identifier not found"");
    }
}
","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModelTest {","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModelTest {

	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to true.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleTrue() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		int columnIndex = columnModel.getColumnIndex(""Test"", true);
		assertEquals(0, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to false.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleFalse() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		int columnIndex = columnModel.getColumnIndex(""Test"", false);
		assertEquals(0, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to true.
	* The identifier is not the first column.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleTrueNotFirst() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		int columnIndex = columnModel.getColumnIndex(""Test2"", true);
		assertEquals(1, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to false.
	* The identifier is not the first column.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleFalseNotFirst() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		int columnIndex = columnModel.getColumnIndex(""Test2"", false);
		assertEquals(1, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to true.
	* The identifier is not the first column.
	* The first column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleTrueNotFirstFirstNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		columnModel.removeColumn(columnModel.getColumn(0));
		int columnIndex = columnModel.getColumnIndex(""Test2"", true);
		assertEquals(0, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to false.
	* The identifier is not the first column.
	* The first column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleFalseNotFirstFirstNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		columnModel.removeColumn(columnModel.getColumn(0));
		int columnIndex = columnModel.getColumnIndex(""Test2"", false);
		assertEquals(1, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to true.
	* The identifier is not the first column.
	* The first column is not visible.
	* The second column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleTrueNotFirstFirstNotVisibleSecondNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		column = new TableColumn(2);
		column.setIdentifier(""Test3"");
		columnModel.addColumn(column);
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		int columnIndex = columnModel.getColumnIndex(""Test3"", true);
		assertEquals(0, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to false.
	* The identifier is not the first column.
	* The first column is not visible.
	* The second column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleFalseNotFirstFirstNotVisibleSecondNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		column = new TableColumn(2);
		column.setIdentifier(""Test3"");
		columnModel.addColumn(column);
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		int columnIndex = columnModel.getColumnIndex(""Test3"", false);
		assertEquals(2, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to true.
	* The identifier is not the first column.
	* The first column is not visible.
	* The second column is not visible.
	* The third column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleTrueNotFirstFirstNotVisibleSecondNotVisibleThirdNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		column = new TableColumn(2);
		column.setIdentifier(""Test3"");
		columnModel.addColumn(column);
		column = new TableColumn(3);
		column.setIdentifier(""Test4"");
		columnModel.addColumn(column);
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		int columnIndex = columnModel.getColumnIndex(""Test4"", true);
		assertEquals(0, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to false.
	* The identifier is not the first column.
	* The first column is not visible.
	* The second column is not visible.
	* The third column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleFalseNotFirstFirstNotVisibleSecondNotVisibleThirdNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		column = new TableColumn(2);
		column.setIdentifier(""Test3"");
		columnModel.addColumn(column);
		column = new TableColumn(3);
		column.setIdentifier(""Test4"");
		columnModel.addColumn(column);
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		int columnIndex = columnModel.getColumnIndex(""Test4"", false);
		assertEquals(3, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to true.
	* The identifier is not the first column.
	* The first column is not visible.
	* The second column is not visible.
	* The third column is not visible.
	* The fourth column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleTrueNotFirstFirstNotVisibleSecondNotVisibleThirdNotVisibleFourthNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		column = new TableColumn(2);
		column.setIdentifier(""Test3"");
		columnModel.addColumn(column);
		column = new TableColumn(3);
		column.setIdentifier(""Test4"");
		columnModel.addColumn(column);
		column = new TableColumn(4);
		column.setIdentifier(""Test5"");
		columnModel.addColumn(column);
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		int columnIndex = columnModel.getColumnIndex(""Test5"", true);
		assertEquals(0, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to false.
	* The identifier is not the first column.
	* The first column is not visible.
	* The second column is not visible.
	* The third column is not visible.
	* The fourth column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleFalseNotFirstFirstNotVisibleSecondNotVisibleThirdNotVisibleFourthNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		column = new TableColumn(2);
		column.setIdentifier(""Test3"");
		columnModel.addColumn(column);
		column = new TableColumn(3);
		column.setIdentifier(""Test4"");
		columnModel.addColumn(column);
		column = new TableColumn(4);
		column.setIdentifier(""Test5"");
		columnModel.addColumn(column);
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		int columnIndex = columnModel.getColumnIndex(""Test5"", false);
		assertEquals(4, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to true.
	* The identifier is not the first column.
	* The first column is not visible.
	* The second column is not visible.
	* The third column is not visible.
	* The fourth column is not visible.
	* The fifth column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleTrueNotFirstFirstNotVisibleSecondNotVisibleThirdNotVisibleFourthNotVisibleFifthNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn(0);
		column.setIdentifier(""Test"");
		columnModel.addColumn(column);
		column = new TableColumn(1);
		column.setIdentifier(""Test2"");
		columnModel.addColumn(column);
		column = new TableColumn(2);
		column.setIdentifier(""Test3"");
		columnModel.addColumn(column);
		column = new TableColumn(3);
		column.setIdentifier(""Test4"");
		columnModel.addColumn(column);
		column = new TableColumn(4);
		column.setIdentifier(""Test5"");
		columnModel.addColumn(column);
		column = new TableColumn(5);
		column.setIdentifier(""Test6"");
		columnModel.addColumn(column);
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		columnModel.removeColumn(columnModel.getColumn(0));
		int columnIndex = columnModel.getColumnIndex(""Test6"", true);
		assertEquals(0, columnIndex);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with a valid identifier and onlyVisible set to false.
	* The identifier is not the first column.
	* The first column is not visible.
	* The second column is not visible.
	* The third column is not visible.
	* The fourth column is not visible.
	* The fifth column is not visible.
	*/
	@Test
	void testGetColumnIndexValidIdentifierOnlyVisibleFalseNotFirstFirstNotVisibleSecondNotVisibleThirdNotVisibleFourthNotVisibleFifthNotVisible() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn"
cmpl-6wvnPezWfE17I2Hd4CEFp5I2oejyQ,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder0.java,59.48210883140564,stop,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c) {
        int actualThickness = thickness + innerThickness;
        return new Insets(actualThickness, actualThickness, actualThickness, actualThickness);
    }
}
","// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {","// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {

	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is zero and the inner thickness is zero.
	*/
	@Test
	void testGetBorderInsets_ThicknessZero_InnerThicknessZero() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(0);
		border.setInnerThickness(0);
		Insets insets = border.getBorderInsets(null);
		assertEquals(0, insets.top);
		assertEquals(0, insets.left);
		assertEquals(0, insets.bottom);
		assertEquals(0, insets.right);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is zero and the inner thickness is one.
	*/
	@Test
	void testGetBorderInsets_ThicknessZero_InnerThicknessOne() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(0);
		border.setInnerThickness(1);
		Insets insets = border.getBorderInsets(null);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is one and the inner thickness is zero.
	*/
	@Test
	void testGetBorderInsets_ThicknessOne_InnerThicknessZero() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(1);
		border.setInnerThickness(0);
		Insets insets = border.getBorderInsets(null);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is one and the inner thickness is one.
	*/
	@Test
	void testGetBorderInsets_ThicknessOne_InnerThicknessOne() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(1);
		border.setInnerThickness(1);
		Insets insets = border.getBorderInsets(null);
		assertEquals(2, insets.top);
		assertEquals(2, insets.left);
		assertEquals(2, insets.bottom);
		assertEquals(2, insets.right);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is one and the inner thickness is two.
	*/
	@Test
	void testGetBorderInsets_ThicknessOne_InnerThicknessTwo() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(1);
		border.setInnerThickness(2);
		Insets insets = border.getBorderInsets(null);
		assertEquals(3, insets.top);
		assertEquals(3, insets.left);
		assertEquals(3, insets.bottom);
		assertEquals(3, insets.right);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is two and the inner thickness is zero.
	*/
	@Test
	void testGetBorderInsets_ThicknessTwo_InnerThicknessZero() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(2);
		border.setInnerThickness(0);
		Insets insets = border.getBorderInsets(null);
		assertEquals(2, insets.top);
		assertEquals(2, insets.left);
		assertEquals(2, insets.bottom);
		assertEquals(2, insets.right);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is two and the inner thickness is one.
	*/
	@Test
	void testGetBorderInsets_ThicknessTwo_InnerThicknessOne() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(2);
		border.setInnerThickness(1);
		Insets insets = border.getBorderInsets(null);
		assertEquals(3, insets.top);
		assertEquals(3, insets.left);
		assertEquals(3, insets.bottom);
		assertEquals(3, insets.right);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is two and the inner thickness is two.
	*/
	@Test
	void testGetBorderInsets_ThicknessTwo_InnerThicknessTwo() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(2);
		border.setInnerThickness(2);
		Insets insets = border.getBorderInsets(null);
		assertEquals(4, insets.top);
		assertEquals(4, insets.left);
		assertEquals(4, insets.bottom);
		assertEquals(4, insets.right);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is two and the inner thickness is three.
	*/
	@Test
	void testGetBorderInsets_ThicknessTwo_InnerThicknessThree() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(2);
		border.setInnerThickness(3);
		Insets insets = border.getBorderInsets(null);
		assertEquals(5, insets.top);
		assertEquals(5, insets.left);
		assertEquals(5, insets.bottom);
		assertEquals(5, insets.right);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component)} method.
	* Test case for the case when the thickness is three and the inner thickness is three.
	*/
	@Test
	void testGetBorderInsets_ThicknessThree_InnerThicknessThree() {
		ConditionalBorder border = new ConditionalBorder();
		border.setThickness(3);
		border.setInnerThickness(3);
		Insets insets = border.getBorderInsets(null);
		assertEquals(6, insets.top);
		assertEquals(6, insets.left);
		assertEquals(6, insets.bottom);
		assertEquals(6, insets.right);
	}
	
}"
cmpl-6wvoSH9awrckNc3PJ80MvcpXfTeIp,/EvoSuiteBenchmark/scenario2/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder1.java,85.51163816452026,stop,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets) {
        int actualThickness = thickness + innerThickness;
        insets.left = actualThickness;
        insets.top = actualThickness;
        insets.right = actualThickness;
        insets.bottom = actualThickness;
        return insets;
    }
}
","// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {","// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {

	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 0);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(1, insets.left);
		assertEquals(1, insets.top);
		assertEquals(1, insets.right);
		assertEquals(1, insets.bottom);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets2() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(2, insets.left);
		assertEquals(2, insets.top);
		assertEquals(2, insets.right);
		assertEquals(2, insets.bottom);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets3() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 2);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(3, insets.left);
		assertEquals(3, insets.top);
		assertEquals(3, insets.right);
		assertEquals(3, insets.bottom);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets4() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 3);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(4, insets.left);
		assertEquals(4, insets.top);
		assertEquals(4, insets.right);
		assertEquals(4, insets.bottom);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets5() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 4);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(5, insets.left);
		assertEquals(5, insets.top);
		assertEquals(5, insets.right);
		assertEquals(5, insets.bottom);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets6() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 5);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(6, insets.left);
		assertEquals(6, insets.top);
		assertEquals(6, insets.right);
		assertEquals(6, insets.bottom);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets7() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 6);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(7, insets.left);
		assertEquals(7, insets.top);
		assertEquals(7, insets.right);
		assertEquals(7, insets.bottom);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets8() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 7);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(8, insets.left);
		assertEquals(8, insets.top);
		assertEquals(8, insets.right);
		assertEquals(8, insets.bottom);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets9() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 8);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(9, insets.left);
		assertEquals(9, insets.top);
		assertEquals(9, insets.right);
		assertEquals(9, insets.bottom);
	}
	
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link Insets} object with left, top, right and bottom values equal to the thickness of the border.
	*/
	@Test
	public void testGetBorderInsets10() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 9);
		Insets insets = new Insets(0, 0, 0, 0);
		border.getBorderInsets(null, insets);
		assertEquals(10, insets.left);
		assertEquals(10, insets.top);
		assertEquals(10, insets.right);
		assertEquals(10, insets.bottom);
	}
}"
