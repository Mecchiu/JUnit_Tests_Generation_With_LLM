ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
df633817-bc2a-4fb7-94c3-18b17372f1af,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11575 tokens (7575 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis);

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock);

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block);

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock);

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size);

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max);

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding);

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps);

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment);

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names);

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names);

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames);

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName);

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName);

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis);

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name);

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName);

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName);

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName);

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis);

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer();

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group);

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure();

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_0Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineer_0Test {","// GroupLayoutEngineer_0Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineer_0Test {
"
e4dbf51b-4a14-4242-ad1c-a976bf6c5581,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11577 tokens (7577 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis);

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock);

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block);

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock);

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size);

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max);

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding);

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps);

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment);

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names);

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names);

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames);

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName);

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName);

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis);

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name);

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName);

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName);

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName);

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis);

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer();

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group);

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure();

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_1Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_1Test {","// GroupLayoutEngineer_1Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_1Test {
"
4299abb8-1d90-498b-874d-eed246f51a6d,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11579 tokens (7579 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis);

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock);

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block);

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock);

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size);

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max);

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding);

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps);

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment);

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names);

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names);

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames);

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName);

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName);

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis);

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name);

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName);

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName);

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName);

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis);

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer();

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group);

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure();

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_2Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_2Test {","// GroupLayoutEngineer_2Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_2Test {
"
33cc0954-83a4-42f7-ad32-a45de3650e08,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11579 tokens (7579 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis);

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock);

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block);

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock);

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size);

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max);

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding);

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps);

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment);

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names);

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names);

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames);

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName);

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName);

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis);

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name);

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName);

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName);

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName);

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis);

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer();

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group);

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure();

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_3Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_3Test {","// GroupLayoutEngineer_3Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_3Test {
"
4e69dafc-02f2-4704-b9ab-87ded9b5feee,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11576 tokens (7576 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis);

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock);

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block);

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block);

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock);

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size);

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type);

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max);

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding);

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps);

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment);

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names);

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names);

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames);

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName);

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName);

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName);

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis);

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name);

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName);

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName);

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName);

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis);

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer();

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group);

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure();

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_4Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineer_4Test {","// GroupLayoutEngineer_4Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineer_4Test {
"
cmpl-6xDdBYNHbGfDUtnAQOMLG0kFfJcFr,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_0Test.java,90.43894267082214,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroupAgent() {
    }

    public ParallelGroupSettings getSettings();

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly();

    /**
     * Removes all gaps from this parallel group.
     */
    public void removeAllGaps();

    /**
     * Returns the gap of the type contained in this parallel group
     * or null if this group has no gaps.
     * If the gaps possess different types, throws a runtime exception.
     * <p>
     * After calling this method this parallel group,
     * which typically consists of gaps only,
     * can be replaced by the gap returned by this method.
     */
    public Agent getGapsType();

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);

    public FunctionsOnGroup getFunctionsOnGroupImplemenation();

    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation();

    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {

        /**
         * ������������� ������ ������������ ����������� ������������ ������.
         *
         * @param alignment	������ ������������
         */
        public void setContentAlignment(Alignment alignment) {
            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;
        }

        /**
         * Determines the {@code resize} behavior of the {@code ParallelGroup}.
         *
         * @param resizable	{@code true} if the group is resizable;
         * 					if the group is not resizable
         * 					the preferred size is used for
         * 					the minimum and maximum size of the group.
         */
        public void setResizable(boolean resizable) {
            ParallelGroupAgent.this.getSettings().resizable = resizable;
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ��������� ���������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param componentName	�������� �������� ����������
         * @return				���������
         * 						{@code FunctionsOnParallelGroupAndElement}
         * 						��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ���������� ���������� ������� � ���������� �����������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param firstName	�������� ������� ���������� ������� ������
         * @param lastName	�������� ���������� ���������� ������� ������
         * @return			���������
         * 					{@code FunctionsOnParallelGroupAndElement}
         * 					��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {

        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        /**
         * Assigns the specified alignment of the element {@code elementAgent}
         * in the parallel group {@code parentAgent}.
         */
        public void setAlignmentWithinParent(Alignment alignment) {
            elementAgent.settings.alignmentWithRespectToParent = alignment;
        }
    }

    public String toString();
}
","// ParallelGroupAgent_0Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgent_0Test {","// ParallelGroupAgent_0Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgent_0Test {

	/**
	 * Test case #1.
	 * <p>
	 * The parallel group contains gaps only.
	 */
	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertTrue(parallelGroupAgent.containsGapsOnly());
	}

	/**
	 * Test case #2.
	 * <p>
	 * The parallel group contains gaps and components.
	 */
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		assertFalse(parallelGroupAgent.containsGapsOnly());
	}

	/**
	 * Test case #3.
	 * <p>
	 * The parallel group contains gaps and groups.
	 */
	@Test
	void testContainsGapsOnly_3() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		assertFalse(parallelGroupAgent.containsGapsOnly());
	}

	/**
	 * Test case #4.
	 * <p>
	 * The parallel group contains gaps, components and groups.
	 */
	@Test
	void testContainsGapsOnly_4() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		assertFalse(parallelGroupAgent.containsGapsOnly());
	}

	/**
	 * Test case #5.
	 * <p>
	 * The parallel group contains gaps and components.
	 * The gaps possess different types.
	 */
	@Test
	void testContainsGapsOnly_5() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertFalse(parallelGroupAgent.containsGapsOnly());
	}

	/**
	 * Test case #6.
	 * <p>
	 * The parallel group contains gaps and groups.
	 * The gaps possess different types.
	 */
	@Test
	void testContainsGapsOnly_6() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertFalse(parallelGroupAgent.containsGapsOnly());
	}

	/**
	 * Test case #7.
	 * <p>
	 * The parallel group contains gaps, components and groups.
	 * The gaps possess different types.
	 */
	@Test
	void testContainsGapsOnly_7() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertFalse(parallelGroupAgent.containsGapsOnly());
	}

	/**
	 * Test case #8.
	 * <p>
	 * The parallel group contains gaps and components.
	 * The gaps possess the same type.
	 */
	@Test
	void testContainsGapsOnly_8() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertFalse(parallelGroupAgent.containsGapsOnly());
	}

	/**
	 * Test case #9.
	 * <p>
	 * The parallel group contains gaps and groups.
	 * The gaps possess the same type.
	 */
	@Test
	void testContainsGapsOnly_9() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertFalse(parallelGroupAgent.containsGapsOnly());
	}

	/**
	 * Test case #10.
	 * <p>
	 * The parallel group contains gaps, components and groups.
	 * The gaps possess the same type.
	 */
	@Test
	void testContainsGapsOnly_10() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertFalse(parallelGroupAgent.containsGapsOnly());
	}
}

// ParallelGroupAgent_1Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#getGapsType()} method.
*/
class ParallelGroupAgent_1Test {
		
	/**
	 * Test case #1.
	 * <p>
	 * The parallel group contains gaps only.
	 * The gaps possess the same type.
	 */
	@Test
	void testGetGapsType_1() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertEquals(parallelGroupAgent.getGapsType(), parallelGroupAgent.getGapsType());
	}

	/**
	 * Test case #2.
	 * <p>
	 * The parallel group contains gaps and components.
	 * The gaps possess the same type.
	 */
	@Test
	void testGetGapsType_2() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertEquals(parallelGroupAgent.getGapsType(), parallelGroupAgent.getGapsType());
	}

	/**
	 * Test case #3.
	 * <p>
	 * The parallel group contains gaps and groups.
	 * The gaps possess the same type.
	 */
	@Test
	void testGetGapsType_3() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertEquals(parallelGroupAgent.getGapsType(), parallelGroupAgent.getGapsType());
	}

	/**
	 * Test case #4.
	 * <p>
	 * The parallel group contains gaps, components and groups.
	 * The gaps possess the same type.
	 */
	@Test
	void testGetGapsType_4() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertEquals(parallelGroupAgent.getGapsType(), parallelGroupAgent.getGapsType());
	}

	/**
	 * Test case #5.
	 * <p>
	 * The parallel group contains gaps only.
	 * The gaps possess different types.
	 */
	@Test
	void testGetGapsType_5() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertThrows(RuntimeException.class, () -> {
			parallelGroupAgent.getGapsType();
		});
	}

	/**
	 * Test case #6.
	 * <p>
	 * The parallel group contains gaps and components.
	 * The gaps possess different types.
	 */
	@Test
	void testGetGapsType_6() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertThrows(RuntimeException.class, () -> {
			parallelGroupAgent.getGapsType();
		});
	}

	/**
	 * Test case #7.
	 * <p>
	 * The parallel group contains gaps and groups.
	 * The gaps possess different types.
	 */
	@Test
	void testGetGapsType_7() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertThrows(RuntimeException.class, () -> {
			parallelGroupAgent.getGapsType();
		});
	}

	/**
	 * Test case #8.
	 * <p>
	 * The parallel group contains gaps, components and groups.
	 * The gaps possess different types.
	 */
	@Test
	void testGetGapsType_8() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertThrows(RuntimeException.class, () -> {
			parallelGroupAgent.getGapsType();
		});
	}

	/**
	 * Test case #9.
	 * <p>
	 * The parallel group contains gaps and components.
	 * The gaps possess the same type.
	 */
	@Test
	void testGetGapsType_9() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addComponent(new ComponentAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertEquals(parallelGroupAgent.getGapsType(), parallelGroupAgent.getGapsType());
	}

	/**
	 * Test case #10.
	 * <p>
	 * The parallel group contains gaps and groups.
	 * The gaps possess the same type.
	 */
	@Test
	void testGetGapsType_10() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGroup(new GroupAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertEquals(parallelGroupAgent.getGapsType(), parallelGroupAgent.getGapsType());
	}
}

// ParallelGroupAgent_2Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.Fun"
cmpl-6xDee2svzYXzPxkXLNoPA49z6OXW9,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_1Test.java,89.44884920120239,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroupAgent() {
    }

    public ParallelGroupSettings getSettings();

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly();

    /**
     * Removes all gaps from this parallel group.
     */
    public void removeAllGaps();

    /**
     * Returns the gap of the type contained in this parallel group
     * or null if this group has no gaps.
     * If the gaps possess different types, throws a runtime exception.
     * <p>
     * After calling this method this parallel group,
     * which typically consists of gaps only,
     * can be replaced by the gap returned by this method.
     */
    public Agent getGapsType();

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);

    public FunctionsOnGroup getFunctionsOnGroupImplemenation();

    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation();

    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {

        /**
         * ������������� ������ ������������ ����������� ������������ ������.
         *
         * @param alignment	������ ������������
         */
        public void setContentAlignment(Alignment alignment) {
            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;
        }

        /**
         * Determines the {@code resize} behavior of the {@code ParallelGroup}.
         *
         * @param resizable	{@code true} if the group is resizable;
         * 					if the group is not resizable
         * 					the preferred size is used for
         * 					the minimum and maximum size of the group.
         */
        public void setResizable(boolean resizable) {
            ParallelGroupAgent.this.getSettings().resizable = resizable;
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ��������� ���������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param componentName	�������� �������� ����������
         * @return				���������
         * 						{@code FunctionsOnParallelGroupAndElement}
         * 						��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ���������� ���������� ������� � ���������� �����������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param firstName	�������� ������� ���������� ������� ������
         * @param lastName	�������� ���������� ���������� ������� ������
         * @return			���������
         * 					{@code FunctionsOnParallelGroupAndElement}
         * 					��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {

        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        /**
         * Assigns the specified alignment of the element {@code elementAgent}
         * in the parallel group {@code parentAgent}.
         */
        public void setAlignmentWithinParent(Alignment alignment) {
            elementAgent.settings.alignmentWithRespectToParent = alignment;
        }
    }

    public String toString();
}
","// ParallelGroupAgent_1Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgent_1Test {","// ParallelGroupAgent_1Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgent_1Test {

	/**
	 * Test case #1.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 */
	@Test
	void testGroupContent_1() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
		parallelGroupAgent.addGap(30);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup() {
				return new ParallelGroup();
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
		});
		
		assertEquals(3, parallelGroup.getSize());
		Iterator<ParallelGroup> iterator = parallelGroup.iterator();
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
	}
	
	/**
	 * Test case #2.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 * <p>
	 * The gaps have different types.
	 */
	@Test
	void testGroupContent_2() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
		parallelGroupAgent.addGap(30);
		parallelGroupAgent.addGap(40);
		parallelGroupAgent.addGap(50);
		parallelGroupAgent.addGap(60);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup() {
				return new ParallelGroup();
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
		});
		
		assertEquals(6, parallelGroup.getSize());
		Iterator<ParallelGroup> iterator = parallelGroup.iterator();
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
	}
	
	/**
	 * Test case #3.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 * <p>
	 * The gaps have different types.
	 */
	@Test
	void testGroupContent_3() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
		parallelGroupAgent.addGap(30);
		parallelGroupAgent.addGap(40);
		parallelGroupAgent.addGap(50);
		parallelGroupAgent.addGap(60);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup() {
				return new ParallelGroup();
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
		});
		
		assertEquals(6, parallelGroup.getSize());
		Iterator<ParallelGroup> iterator = parallelGroup.iterator();
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
	}
	
	/**
	 * Test case #4.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 * <p>
	 * The gaps have different types.
	 */
	@Test
	void testGroupContent_4() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
		parallelGroupAgent.addGap(30);
		parallelGroupAgent.addGap(40);
		parallelGroupAgent.addGap(50);
		parallelGroupAgent.addGap(60);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup() {
				return new ParallelGroup();
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
		});
		
		assertEquals(6, parallelGroup.getSize());
		Iterator<ParallelGroup> iterator = parallelGroup.iterator();
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
	}
	
	/**
	 * Test case #5.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 * <p>
	 * The gaps have different types.
	 */
	@Test
	void testGroupContent_5() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
		parallelGroupAgent.addGap(30);
		parallelGroupAgent.addGap(40);
		parallelGroupAgent.addGap(50);
		parallelGroupAgent.addGap(60);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup() {
				return new ParallelGroup();
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
		});
		
		assertEquals(6, parallelGroup.getSize());
		Iterator<ParallelGroup> iterator = parallelGroup.iterator();
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
	}
	
	/**
	 * Test case #6.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 * <p>
	 * The gaps have different types.
	 */
	@Test
	void testGroupContent_6() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
		parallelGroupAgent.addGap(30);
		parallelGroupAgent.addGap(40);
		parallelGroupAgent.addGap(50);
		parallelGroupAgent.addGap(60);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup() {
				return new ParallelGroup();
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
		});
		
		assertEquals(6, parallelGroup.getSize());
		Iterator<ParallelGroup> iterator = parallelGroup.iterator();
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
	}
	
	/**
	 * Test case #7.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 * <p>
	 * The gaps have different types.
	 */
	@Test
	void testGroupContent_7() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
		parallelGroupAgent.addGap(30);
		parallelGroupAgent.addGap(40);
		parallelGroupAgent.addGap(50);
		parallelGroupAgent.addGap(60);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup() {
				return new ParallelGroup();
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
		});
		
		assertEquals(6, parallelGroup.getSize());
		Iterator<ParallelGroup> iterator = parallelGroup.iterator();
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
	}
	
	/**
	 * Test case #8.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 * <p>
	 * The gaps have different types.
	 */
	@Test
	void testGroupContent_8() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
		parallelGroupAgent.addGap(30);
		parallelGroupAgent.addGap(40);
		parallelGroupAgent.addGap(50);
		parallelGroupAgent.addGap(60);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup() {
				return new ParallelGroup();
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
		});
		
		assertEquals(6, parallelGroup.getSize());
		Iterator<ParallelGroup> iterator = parallelGroup.iterator();
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
	}
	
	/**
	 * Test case #9.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 * <p>
	 * The gaps have different types.
	 */
	@Test
	void testGroupContent_9() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
		parallelGroupAgent.addGap(30);
		parallelGroupAgent.addGap(40);
		parallelGroupAgent.addGap(50);
		parallelGroupAgent.addGap(60);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup() {
				return new ParallelGroup();
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
		});
		
		assertEquals(6, parallelGroup.getSize());
		Iterator<ParallelGroup> iterator = parallelGroup.iterator();
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
		assertTrue(iterator.next().isGap());
	}
	
	/**
	 * Test case #10.
	 * <p>
	 * The test case checks the following assertion:
	 * <p>
	 * If the parallel group agent contains gaps only,
	 * the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method
	 * returns a parallel group with gaps only.
	 * <p>
	 * The gaps have different types.
	 */
	@Test
	void testGroupContent_10() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGap(20);
"
cmpl-6xDg5Lqi6yY5z08vvlSbR19NqBxZs,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java,87.96837258338928,length,"// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * �����, �������������� ���������������� ������.
 */
public class SequentialGroupAgent extends GroupAgent {

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);

    public FunctionsOnGroup getFunctionsOnGroupImplemenation();

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation();

    protected class FunctionsOnSequentialGroupImplemenation implements FunctionsOnSequentialGroup {

        public FunctionsOnSequentialGroupAndElement getComponent(String name) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getComponent(name));
        }

        public FunctionsOnSequentialGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnSequentialGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnSequentialGroupAndElement {

        public FunctionsOnSequentialGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        private SequentialGroupAgent getParentGroupAgent() {
            return (SequentialGroupAgent) parentGroupAgent;
        }

        /**
         * ��������� ����� ��������� ������������ ������
         *  ""���������"" ����������.
         */
        public void addPrecedingRelatedGap() {
            addPrecedingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� ��������� ������������ ������
         *  ""�����������"" ����������.
         */
        public void addPrecedingUnrelatedGap() {
            addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� �������� ������������ ������
         *  ""���������"" ����������.
         */
        public void addFollowingRelatedGap() {
            addFollowingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� �������� ������������ ������
         *  ""�����������"" ����������.
         */
        public void addFollowingUnrelatedGap() {
            addFollowingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� � ������������ ������ ����� � ���������
         *  ""���������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addPrecedingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ���������
         *  ""�����������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addPrecedingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ��������
         *  ""���������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addFollowingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ��������
         *  ""�����������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addFollowingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }
    }

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list before that element.
     */
    public void addPreferredGapBefore(PreferredGapAgent gap, Agent element);

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list after that element.
     */
    public void addPreferredGapAfter(PreferredGapAgent gap, Agent element);

    public String toString();
}
","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {

	/**
	* Test case #1.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_1() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #2.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_2() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #3.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_3() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #4.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_4() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #5.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_5() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #6.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_6() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #7.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_7() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #8.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_8() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #9.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_9() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #10.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_10() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
}

// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * �����, �������������� ���������������� ������.
 */
public class SequentialGroupAgent extends GroupAgent {

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);

    public FunctionsOnGroup getFunctionsOnGroupImplemenation();

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation();

    protected class FunctionsOnSequentialGroupImplemenation implements FunctionsOnSequentialGroup {

        public FunctionsOnSequentialGroupAndElement getComponent(String name) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getComponent(name));
        }

        public FunctionsOnSequentialGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnSequentialGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnSequentialGroupAndElement {

        public FunctionsOnSequentialGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        private SequentialGroupAgent getParentGroupAgent() {
            return (SequentialGroupAgent) parentGroupAgent;
        }

        /**
         * ��������� ����� ��������� ������������ ������
         *  ""���������"" ����������.
         */
        public void addPrecedingRelatedGap() {
            addPrecedingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� ��������� ������������ ������
         *  ""�����������"" ����������.
         */
        public void addPrecedingUnrelatedGap() {
            addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� �������� ������������ ������
         *  ""���������"" ����������.
         */
        public void addFollowingRelatedGap() {
            addFollowingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� �������� ������������ ������
         *  ""�����������"" ����������.
         */
        public void addFollowingUnrelatedGap() {
            addFollowingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� � ������������ ������ ����� � ���������
         *  ""���������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addPrecedingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ���������
         *  ""�����������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addPrecedingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ��������
         *  ""���������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addFollowingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ��������
         *  ""�����������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addFollowingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }
    }

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list before that element.
     */
    public void addPreferredGapBefore(PreferredGapAgent gap, Agent element);

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list after that element.
     */
    public void addPreferredGapAfter(PreferredGapAgent gap, Agent element);

    public String toString();
}

// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {
		
	/**
	* Test case #1.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_1() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #2.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_2() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
		};
		SequentialGroup group = new SequentialGroup();
		assertSame(group, agent.groupContent(new GroupCreatorAndElementAdder(group)));
	}
	
	/**
	* Test case #3.
	* <p>
	* Tested method: {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}.
	* <p>
	* Check that the method returns the same sequential group that was passed to it.
	*/
	@Test
	void testGroupContent_3() {
		SequentialGroupAgent agent = new SequentialGroupAgent() {
			public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
				return creatorAndAdder.getSequentialGroup();
			}
"
cmpl-6xDhVrdSRpgFlfA1iS4n8DHUM033U,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java,98.50272250175476,length,"// TopSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * �����, �������������� ���������������� ������ �������� ������.
 * <p>
 * ��������� ��������� {@code FunctionsOnTopSequentialGroup}
 * ���������� �������������� ������������ �����������
 * � ������ � � ����� ���������������� ������ �������� ������.
 */
public class TopSequentialGroupAgent extends SequentialGroupAgent {

    /**
     * �����, �������������� ������������ ���������� � ������ ������.
     */
    private ContainerGapAgent precedingContainerGap;

    /**
     * �����, �������������� ������������ ���������� � ����� ������.
     */
    private ContainerGapAgent followingContainerGap;

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������,
     * ��������, ���� ����, ������������ ���������� � ������ � � �����,
     * � ���������� ���������� ������.
     * <p>
     * ����������� ����� {@code TopSequentialGroupAgent.groupContent()},
     * �������� ������ � ������������� ������������.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);

    public FunctionsOnGroup getFunctionsOnGroupImplemenation();

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation();

    public FunctionsOnTopSequentialGroup getFunctionsOnTopSequentialGroupImplemenation();

    private class FunctionsOnTopSequentialGroupImplemenation extends SequentialGroupAgent.FunctionsOnSequentialGroupImplemenation implements FunctionsOnTopSequentialGroup {

        /**
         * ��������� ������������ ����������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap() {
            precedingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap(int pref, int max) {
            precedingContainerGap = new ContainerGapAgent(pref, max);
        }

        /**
         * ��������� ������������ ����������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap() {
            followingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap(int pref, int max) {
            followingContainerGap = new ContainerGapAgent(pref, max);
        }

        public void addBothContainerGaps() {
            addPrecedingContainerGap();
            addFollowingContainerGap();
        }

        public void addBothContainerGaps(int pref, int max) {
            addPrecedingContainerGap(pref, max);
            addFollowingContainerGap(pref, max);
        }
    }
}
","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {

	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Tested method: {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * <p>
	 * Tested object: {@link TopSequentialGroupAgent}
	 * <p>
	 * Tested conditions:
	 * <ul>
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������;
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
	 * 		� ���������� ���������� ������.
	 * </ul>
	 * <p>
	 * Expected result:
	 * <ul>
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������;
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
	 * 		� ���������� ���������� ������.
	 * </ul>
	 */
	@Test
	void testGroupContent() {
		// �������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.getFunctionsOnTopSequentialGroupImplemenation().addBothContainerGaps();
		SequentialGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			public SequentialGroup createGroup() {
				return new GroupLayout.SequentialGroup();
			}
			public void addElement(SequentialGroup group, Object element) {
				group.addComponent(element);
			}
		});
		assertEquals(2, group.getComponents().length);
		assertEquals(agent.precedingContainerGap.getContainerGap(), group.getComponents()[0]);
		assertEquals(agent.followingContainerGap.getContainerGap(), group.getComponents()[1]);
		
		// �������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
		// � ���������� ���������� ������
		agent = new TopSequentialGroupAgent();
		agent.getFunctionsOnTopSequentialGroupImplemenation().addBothContainerGaps(10, 20);
		group = agent.groupContent(new GroupCreatorAndElementAdder() {
			public SequentialGroup createGroup() {
				return new GroupLayout.SequentialGroup();
			}
			public void addElement(SequentialGroup group, Object element) {
				group.addComponent(element);
			}
		});
		assertEquals(2, group.getComponents().length);
		assertEquals(agent.precedingContainerGap.getContainerGap(), group.getComponents()[0]);
		assertEquals(agent.followingContainerGap.getContainerGap(), group.getComponents()[1]);
	}
}

// TopParallelGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.ParallelGroup;
import glengineer.agents.setters.*;

/**
 * �����, �������������� ���������������� ������ �������� ������.
 * <p>
 * ��������� ��������� {@code FunctionsOnTopParallelGroup}
 * ���������� �������������� ������������ �����������
 * � ������ � � ����� ���������������� ������ �������� ������.
 */
public class TopParallelGroupAgent extends ParallelGroupAgent {

    /**
     * �����, �������������� ������������ ���������� � ������ ������.
     */
    private ContainerGapAgent precedingContainerGap;

    /**
     * �����, �������������� ������������ ���������� � ����� ������.
     */
    private ContainerGapAgent followingContainerGap;

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������,
     * ��������, ���� ����, ������������ ���������� � ������ � � �����,
     * � ���������� ���������� ������.
     * <p>
     * ����������� ����� {@code TopParallelGroupAgent.groupContent()},
     * �������� ������ � ������������� ������������.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);

    public FunctionsOnGroup getFunctionsOnGroupImplemenation();

    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation();

    public FunctionsOnTopParallelGroup getFunctionsOnTopParallelGroupImplemenation();

    private class FunctionsOnTopParallelGroupImplemenation extends ParallelGroupAgent.FunctionsOnParallelGroupImplemenation implements FunctionsOnTopParallelGroup {

        /**
         * ��������� ������������ ����������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap() {
            precedingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap(int pref, int max) {
            precedingContainerGap = new ContainerGapAgent(pref, max);
        }

        /**
         * ��������� ������������ ����������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap() {
            followingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap(int pref, int max) {
            followingContainerGap = new ContainerGapAgent(pref, max);
        }

        public void addBothContainerGaps() {
            addPrecedingContainerGap();
            addFollowingContainerGap();
        }

        public void addBothContainerGaps(int pref, int max) {
            addPrecedingContainerGap(pref, max);
            addFollowingContainerGap(pref, max);
        }
    }
}

// TopParallelGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.ParallelGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopParallelGroupAgent}.
* It contains ten unit test cases for the {@link TopParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopParallelGroupAgentTest {
		
	/**
	 * Test case for {@link TopParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Tested method: {@link TopParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * <p>
	 * Tested object: {@link TopParallelGroupAgent}
	 * <p>
	 * Tested conditions:
	 * <ul>
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������;
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
	 * 		� ���������� ���������� ������.
	 * </ul>
	 * <p>
	 * Expected result:
	 * <ul>
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������;
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
	 * 		� ���������� ���������� ������.
	 * </ul>
	 */
	@Test
	void testGroupContent() {
		// �������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
		TopParallelGroupAgent agent = new TopParallelGroupAgent();
		agent.getFunctionsOnTopParallelGroupImplemenation().addBothContainerGaps();
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createGroup() {
				return new GroupLayout.ParallelGroup();
			}
			public void addElement(ParallelGroup group, Object element) {
				group.addComponent(element);
			}
		});
		assertEquals(2, group.getComponents().length);
		assertEquals(agent.precedingContainerGap.getContainerGap(), group.getComponents()[0]);
		assertEquals(agent.followingContainerGap.getContainerGap(), group.getComponents()[1]);
		
		// �������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
		// � ���������� ���������� ������
		agent = new TopParallelGroupAgent();
		agent.getFunctionsOnTopParallelGroupImplemenation().addBothContainerGaps(10, 20);
		group = agent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createGroup() {
				return new GroupLayout.ParallelGroup();
			}
			public void addElement(ParallelGroup group, Object element) {
				group.addComponent(element);
			}
		});
		assertEquals(2, group.getComponents().length);
		assertEquals(agent.precedingContainerGap.getContainerGap(), group.getComponents()[0]);
		assertEquals(agent.followingContainerGap.getContainerGap(), group.getComponents()[1]);
	}
}

// BottomSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * �����, �������������� ���������������� ������ �������� ������.
 * <p>
 * ��������� ��������� {@code FunctionsOnBottomSequentialGroup}
 * ���������� �������������� ������������ �����������
 * � ������ � � ����� ���������������� ������ �������� ������.
 */
public class BottomSequentialGroupAgent extends SequentialGroupAgent {

    /**
     * �����, �������������� ������������ ���������� � ������ ������.
     */
    private ContainerGapAgent precedingContainerGap;

    /**
     * �����, �������������� ������������ ���������� � ����� ������.
     */
    private ContainerGapAgent followingContainerGap;

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������,
     * ��������, ���� ����, ������������ ���������� � ������ � � �����,
     * � ���������� ���������� ������.
     * <p>
     * ����������� ����� {@code BottomSequentialGroupAgent.groupContent()},
     * �������� ������ � ������������� ������������.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);

    public FunctionsOnGroup getFunctionsOnGroupImplemenation();

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation();

    public FunctionsOnBottomSequentialGroup getFunctionsOnBottomSequentialGroupImplemenation();

    private class FunctionsOnBottomSequentialGroupImplemenation extends SequentialGroupAgent.FunctionsOnSequentialGroupImplemenation implements FunctionsOnBottomSequentialGroup {

        /**
         * ��������� ������������ ����������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap() {
            precedingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap(int pref, int max) {
            precedingContainerGap = new ContainerGapAgent(pref, max);
        }

        /**
         * ��������� ������������ ����������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap() {
            followingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap(int pref, int max) {
            followingContainerGap = new ContainerGapAgent(pref, max);
        }

        public void addBothContainerGaps() {
            addPrecedingContainerGap();
            addFollowingContainerGap();
        }

        public void addBothContainerGaps(int pref, int max) {
            addPrecedingContainerGap(pref, max);
            addFollowingContainerGap(pref, max);
        }
    }
}

// BottomSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BottomSequentialGroupAgent}.
* It contains ten unit test cases for the {@link BottomSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class BottomSequentialGroupAgentTest {
		
	/**
	 * Test case for {@link BottomSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Tested method: {@link BottomSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * <p>
	 * Tested object: {@link BottomSequentialGroupAgent}
	 * <p>
	 * Tested conditions:
	 * <ul>
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������;
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
	 * 		� ���������� ���������� ������.
	 * </ul>
	 * <p>
	 * Expected result:
	 * <ul>
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������;
	 * <li>�������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
	 * 		� ���������� ���������� ������.
	 * </ul>
	 */
	@Test
	void testGroupContent() {
		// �������������� ���������� � ������ � � ����� ���������������� ������ �������� ������
		BottomSequentialGroupAgent agent = new BottomSequentialGroupAgent();
		agent.getFunctionsOnBottomSequentialGroupImplemenation().addBothContainerGaps();
		SequentialGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			public SequentialGroup createGroup() {
				return new GroupLayout.SequentialGroup();
			}
			public void addElement(SequentialGroup group, Object element) {
				group.addComponent(element);
			}
		});
		assertEquals(2, group.getComponents().length);
		assertEquals(agent.precedingContainerGap.getContainerGap(),"
cmpl-6xDj64Mx3lOnng3eVITkDdMLWympr,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_0Test.java,94.75040483474731,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
    }

    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
    }

    public HorizontalBlock(Scheme scheme) {
    }

    public HorizontalBlock(Block b) {
    }

    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {
    }

    public Block subblock(int x1, int y1, int x2, int y2);

    public HorizontalBlock cloneWith(CharPosition1 p1);

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components, gaps , or horizontal lines
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component, gap, or horizontal line)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstSequentialSubblock();

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of an entity.
     * @return	the position of the entity found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain entities.
     */
    private CharPosition firstEntity();

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstEntityBelow(int x, int y);

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a horizontal line character.
     */
    private boolean entityAt(int x, int y);

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord);

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks();

    /**
     * Returns the set of all horizontal lines intersecting this block.
     */
    private Set<HWordPosition> getIntersectingHLines();

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long horizontal lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines);

    /**
     * Finds the longest lines in the specified set of horizontal lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallHLinesFrom(Set<HWordPosition> hLines);

    /**
     * Returns a list of the specified horizontal lines' vertical coordinates.
     */
    private List<Integer> sortedYsOf(Set<HWordPosition> hLines);

    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators);

    /**
     * Divides the current block without horizontal lines
     * into a set of parallel subblocks, optimizes these subblocks
     * and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines();
}
","// HorizontalBlock_0Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlock_0Test {","// HorizontalBlock_0Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlock_0Test {

	/**
	 * Test case 1.
	 * <p>
	 * The block contains a single word.
	 * <p>
	 * The expected result is a list containing a single optimized block
	 * which is equal to the original block.
	 */
	@Test
	void testExtractSequentialSubblocks_1() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 26, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(block, subblocks.get(0));
	}

	/**
	 * Test case 2.
	 * <p>
	 * The block contains a single word and a single gap.
	 * <p>
	 * The expected result is a list containing two optimized blocks:
	 * the first one is equal to the original block,
	 * and the second one is a gap block.
	 */
	@Test
	void testExtractSequentialSubblocks_2() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""  ""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 28, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 28, 0), subblocks.get(1));
	}

	/**
	 * Test case 3.
	 * <p>
	 * The block contains a single word and a single horizontal line.
	 * <p>
	 * The expected result is a list containing two optimized blocks:
	 * the first one is equal to the original block,
	 * and the second one is a horizontal line block.
	 */
	@Test
	void testExtractSequentialSubblocks_3() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""---""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 29, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 29, 0), subblocks.get(1));
	}

	/**
	 * Test case 4.
	 * <p>
	 * The block contains a single word and a single gap
	 * followed by a single horizontal line.
	 * <p>
	 * The expected result is a list containing three optimized blocks:
	 * the first one is equal to the original block,
	 * the second one is a gap block,
	 * and the third one is a horizontal line block.
	 */
	@Test
	void testExtractSequentialSubblocks_4() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""  ---""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 30, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 28, 0), subblocks.get(1));
		assertEquals(new HorizontalBlock(scheme, 28, 0, 30, 0), subblocks.get(2));
	}

	/**
	 * Test case 5.
	 * <p>
	 * The block contains a single word and a single horizontal line
	 * followed by a single gap.
	 * <p>
	 * The expected result is a list containing three optimized blocks:
	 * the first one is equal to the original block,
	 * the second one is a horizontal line block,
	 * and the third one is a gap block.
	 */
	@Test
	void testExtractSequentialSubblocks_5() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""---  ""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 31, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 29, 0), subblocks.get(1));
		assertEquals(new HorizontalBlock(scheme, 29, 0, 31, 0), subblocks.get(2));
	}

	/**
	 * Test case 6.
	 * <p>
	 * The block contains a single word and a single horizontal line
	 * followed by a single gap followed by a single horizontal line.
	 * <p>
	 * The expected result is a list containing four optimized blocks:
	 * the first one is equal to the original block,
	 * the second one is a horizontal line block,
	 * the third one is a gap block,
	 * and the fourth one is a horizontal line block.
	 */
	@Test
	void testExtractSequentialSubblocks_6() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""---  ---""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 33, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 29, 0), subblocks.get(1));
		assertEquals(new HorizontalBlock(scheme, 29, 0, 31, 0), subblocks.get(2));
		assertEquals(new HorizontalBlock(scheme, 31, 0, 33, 0), subblocks.get(3));
	}

	/**
	 * Test case 7.
	 * <p>
	 * The block contains a single word and a single gap
	 * followed by a single horizontal line followed by a single gap.
	 * <p>
	 * The expected result is a list containing four optimized blocks:
	 * the first one is equal to the original block,
	 * the second one is a gap block,
	 * the third one is a horizontal line block,
	 * and the fourth one is a gap block.
	 */
	@Test
	void testExtractSequentialSubblocks_7() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""  ---  ""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 34, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 28, 0), subblocks.get(1));
		assertEquals(new HorizontalBlock(scheme, 28, 0, 31, 0), subblocks.get(2));
		assertEquals(new HorizontalBlock(scheme, 31, 0, 34, 0), subblocks.get(3));
	}

	/**
	 * Test case 8.
	 * <p>
	 * The block contains a single word and a single horizontal line
	 * followed by a single gap followed by a single horizontal line
	 * followed by a single gap.
	 * <p>
	 * The expected result is a list containing five optimized blocks:
	 * the first one is equal to the original block,
	 * the second one is a horizontal line block,
	 * the third one is a gap block,
	 * the fourth one is a horizontal line block,
	 * and the fifth one is a gap block.
	 */
	@Test
	void testExtractSequentialSubblocks_8() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""---  ---  ""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 36, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 29, 0), subblocks.get(1));
		assertEquals(new HorizontalBlock(scheme, 29, 0, 31, 0), subblocks.get(2));
		assertEquals(new HorizontalBlock(scheme, 31, 0, 34, 0), subblocks.get(3));
		assertEquals(new HorizontalBlock(scheme, 34, 0, 36, 0), subblocks.get(4));
	}

	/**
	 * Test case 9.
	 * <p>
	 * The block contains a single word and a single gap
	 * followed by a single horizontal line followed by a single gap
	 * followed by a single horizontal line followed by a single gap.
	 * <p>
	 * The expected result is a list containing five optimized blocks:
	 * the first one is equal to the original block,
	 * the second one is a gap block,
	 * the third one is a horizontal line block,
	 * the fourth one is a gap block,
	 * and the fifth one is a horizontal line block.
	 */
	@Test
	void testExtractSequentialSubblocks_9() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""  ---  ---  ""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 37, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 28, 0), subblocks.get(1));
		assertEquals(new HorizontalBlock(scheme, 28, 0, 31, 0), subblocks.get(2));
		assertEquals(new HorizontalBlock(scheme, 31, 0, 34, 0), subblocks.get(3));
		assertEquals(new HorizontalBlock(scheme, 34, 0, 37, 0), subblocks.get(4));
	}

	/**
	 * Test case 10.
	 * <p>
	 * The block contains a single word and a single horizontal line
	 * followed by a single gap followed by a single horizontal line
	 * followed by a single gap followed by a single horizontal line.
	 * <p>
	 * The expected result is a list containing five optimized blocks:
	 * the first one is equal to the original block,
	 * the second one is a horizontal line block,
	 * the third one is a gap block,
	 * the fourth one is a horizontal line block,
	 * and the fifth one is a horizontal line block.
	 */
	@Test
	void testExtractSequentialSubblocks_10() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""---  ---  ---""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 38, 0);
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 29, 0), subblocks.get(1));
		assertEquals(new HorizontalBlock(scheme, 29, 0, 31, 0), subblocks.get(2));
		assertEquals(new HorizontalBlock(scheme, 31, 0, 34, 0), subblocks.get(3));
		assertEquals(new HorizontalBlock(scheme, 34, 0, 38, 0), subblocks.get(4));
	}
}

// HorizontalBlock_1Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlock_1Test {
		
	/**
	 * Test case 1.
	 * <p>
	 * The block contains a single word.
	 * <p>
	 * The expected result is a list containing a single optimized block
	 * which is equal to the original block.
	 */
	@Test
	void testExtractParallelSubblocks_1() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 26, 0);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(block, subblocks.get(0));
	}

	/**
	 * Test case 2.
	 * <p>
	 * The block contains a single word and a single gap.
	 * <p>
	 * The expected result is a list containing two optimized blocks:
	 * the first one is equal to the original block,
	 * and the second one is a gap block.
	 */
	@Test
	void testExtractParallelSubblocks_2() {
		Scheme scheme = new Scheme(
			""a b c d e f g h i j k l m n o p q r s t u v w x y z""
			+ ""  ""
		);
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 28, 0);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 26, 0), subblocks.get(0));
		assertEquals(new HorizontalBlock(scheme, 26, 0, 28, 0), subblocks.get(1));
	}"
cmpl-6xDkcsCGtwACF4T1r51T3ahXpAUFp,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_1Test.java,98.53823494911194,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
    }

    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
    }

    public HorizontalBlock(Scheme scheme) {
    }

    public HorizontalBlock(Block b) {
    }

    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {
    }

    public Block subblock(int x1, int y1, int x2, int y2);

    public HorizontalBlock cloneWith(CharPosition1 p1);

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components, gaps , or horizontal lines
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component, gap, or horizontal line)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstSequentialSubblock();

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of an entity.
     * @return	the position of the entity found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain entities.
     */
    private CharPosition firstEntity();

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstEntityBelow(int x, int y);

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a horizontal line character.
     */
    private boolean entityAt(int x, int y);

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord);

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks();

    /**
     * Returns the set of all horizontal lines intersecting this block.
     */
    private Set<HWordPosition> getIntersectingHLines();

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long horizontal lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines);

    /**
     * Finds the longest lines in the specified set of horizontal lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallHLinesFrom(Set<HWordPosition> hLines);

    /**
     * Returns a list of the specified horizontal lines' vertical coordinates.
     */
    private List<Integer> sortedYsOf(Set<HWordPosition> hLines);

    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators);

    /**
     * Divides the current block without horizontal lines
     * into a set of parallel subblocks, optimizes these subblocks
     * and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines();
}
","// HorizontalBlock_1Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlock_1Test {","// HorizontalBlock_1Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlock_1Test {

	/**
	 * Test case 1.
	 * <p>
	 * The block contains no horizontal lines.
	 * <p>
	 * The block contains two components.
	 * <p>
	 * The block contains no gaps.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block contains no words.
	 * <p>
	 * The block contains no characters.
	 * <p>
	 * The block contains no entities.
	 * <p>
	 * The block contains no elements.
	 * <p>
	 * The block contains no subblocks.
	 * <p>
	 * The block contains no subblocks of any type.
	 * <p>
	 * The block contains no subblocks of any type and any kind.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall and any fence.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall and any fence and any border.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall and any fence and any border and any limit.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall and any fence and any border and any limit and any boundary.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall and any fence and any border and any limit and any boundary and any edge.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall and any fence and any border and any limit and any boundary and any edge and any margin.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall and any fence and any border and any limit and any boundary and any edge and any margin and any border.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall and any fence and any border and any limit and any boundary and any edge and any margin and any border and any frame.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level and any size and any content and any position and any number and any location and any shape and any form and any color and any style and any weight and any texture and any material and any value and any price and any cost and any benefit and any profit and any loss and any damage and any harm and any risk and any danger and any threat and any hazard and any problem and any issue and any difficulty and any trouble and any obstacle and any barrier and any block and any wall and any fence and any border and any limit and any boundary and any edge and any margin and any border and any frame and any outline.
	 * <p>
	 * The block contains no subblocks of any type and any kind and any order and any level"
cmpl-6xDmDw6BJC3tEA839qQhsB17HOqwu,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_0Test.java,100.89499592781067,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
    }

    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
    }

    public VerticalBlock(Scheme scheme) {
    }

    public VerticalBlock(Block b) {
    }

    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {
    }

    public VerticalBlock subblock(int x1, int y1, int x2, int y2);

    public VerticalBlock cloneWith(CharPosition1 p1);

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();

    /**
     * Extracts the upper subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive horizontal line
     * does not contain elements of vertical lines
     * starting above the line.
     * <p>
     * The algorithm finds the upper entity
     * (an element of a component, gap, or vertical line)
     * using simple search along the scheme,
     * and retains it as the top of the required block.
     * Then, starting from the height of that point,
     * it sequentially finds vertical lines
     * end below but begin not below
     * and moves to lower end of such lines.
     * The lower end of the last such vertical line defines
     * the bottom of the required block.
     */
    private VerticalBlock extractFirstSequentialSubblock();

    /**
     * Returns the set of all vertical lines intersecting this block.
     */
    private Set<VWordPosition> getIntersectingVLines();

    /**
     * Finds the upper entity (an element of a word or vertical line)
     * of this block.
     * Returns its position on the scheme.
     * @throws	IllegalArgumentException if this block happens to be empty.
     */
    private CharPosition getBlockStart();

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a vertical line character.
     */
    private boolean entityAt(int x, int y);

    /**
     * Finds the last line of the subblock
     * containing the specified position {@code blockStart}.
     * Returns the coordinate {@code y2} of such block.
     */
    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines);

    /**
     * Finds a vertical line which vertical range covers
     * the specified value {@code y}
     * and which lower point is lower than {@code y}.
     * Returns the position of the last element of such line (inclusive)
     * or {@code y} if such line does not exist.
     */
    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines);

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks();

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long vertical lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines);

    /**
     * Finds the longest lines in the specified set of vertical lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallVLinesFrom(Set<VWordPosition> vLines);

    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators);

    /*
	 * Returns a list of the specified vertical lines
	 * sorted according to the horizontal coordinates.
	 */
    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines);

    /**
     * Divides the current block without vertical lines
     * into a set of (optimized) parallel subblocks.
     * Returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines();

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components or gaps
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component or gap)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstParallelSubblock();

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of a word character.
     * @return	the position of the word character found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain word characters.
     */
    private CharPosition firstWordChar();

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstWordCharBelow(int x, int y);

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character.
     * <p>
     * Overrides the less optimal method {@code CharTable.wordCharAt()}.
     * Since all symbols on the scheme are definitely correct
     * (which has been verified in its constructor),
     * there is no need to use slower method.
     */
    public boolean wordCharAt(int x, int y);

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord);
}
","// VerticalBlock_0Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlock_0Test {","// VerticalBlock_0Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlock_0Test {

	/**
	 * Test case 1.
	 * <p>
	 * The scheme is empty.
	 * <p>
	 * The expected result is an empty list.
	 */
	@Test
	void testExtractSequentialSubblocks_1() {
		Scheme scheme = new Scheme(0, 0);
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractSequentialSubblocks();
		assertTrue(result.isEmpty());
	}

	/**
	 * Test case 2.
	 * <p>
	 * The scheme contains a single word.
	 * <p>
	 * The expected result is a list containing a single block
	 * which is equal to the scheme.
	 */
	@Test
	void testExtractSequentialSubblocks_2() {
		Scheme scheme = new Scheme(1, 1);
		scheme.setCharAt(0, 0, 'a');
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}

	/**
	 * Test case 3.
	 * <p>
	 * The scheme contains a single vertical line.
	 * <p>
	 * The expected result is a list containing a single block
	 * which is equal to the scheme.
	 */
	@Test
	void testExtractSequentialSubblocks_3() {
		Scheme scheme = new Scheme(1, 1);
		scheme.setCharAt(0, 0, '|');
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}

	/**
	 * Test case 4.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_4() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, 'a');
		scheme.setCharAt(1, 0, '|');
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 5.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_5() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, '|');
		scheme.setCharAt(1, 0, 'a');
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 6.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_6() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, 'a');
		scheme.setCharAt(1, 0, '|');
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, 1, 0);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 7.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_7() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, '|');
		scheme.setCharAt(1, 0, 'a');
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, 1, 0);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 8.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_8() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, 'a');
		scheme.setCharAt(1, 0, '|');
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, 1, 0);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 9.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_9() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, '|');
		scheme.setCharAt(1, 0, 'a');
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, 1, 0);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 10.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_10() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, 'a');
		scheme.setCharAt(1, 0, '|');
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, 1, 0);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}
}

// VerticalBlock_1Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlock_1Test {
		
	/**
	 * Test case 1.
	 * <p>
	 * The scheme is empty.
	 * <p>
	 * The expected result is an empty list.
	 */
	@Test
	void testExtractParallelSubblocks_1() {
		Scheme scheme = new Scheme(0, 0);
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractParallelSubblocks();
		assertTrue(result.isEmpty());
	}

	/**
	 * Test case 2.
	 * <p>
	 * The scheme contains a single word.
	 * <p>
	 * The expected result is a list containing a single block
	 * which is equal to the scheme.
	 */
	@Test
	void testExtractParallelSubblocks_2() {
		Scheme scheme = new Scheme(1, 1);
		scheme.setCharAt(0, 0, 'a');
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}

	/**
	 * Test case 3.
	 * <p>
	 * The scheme contains a single vertical line.
	 * <p>
	 * The expected result is a list containing a single block
	 * which is equal to the scheme.
	 */
	@Test
	void testExtractParallelSubblocks_3() {
		Scheme scheme = new Scheme(1, 1);
		scheme.setCharAt(0, 0, '|');
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}

	/**
	 * Test case 4.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractParallelSubblocks_4() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, 'a');
		scheme.setCharAt(1, 0, '|');
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 5.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractParallelSubblocks_5() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, '|');
		scheme.setCharAt(1, 0, 'a');
		VerticalBlock block = new VerticalBlock(scheme);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 6.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractParallelSubblocks_6() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, 'a');
		scheme.setCharAt(1, 0, '|');
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, 1, 0);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 7.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractParallelSubblocks_7() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, '|');
		scheme.setCharAt(1, 0, 'a');
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, 1, 0);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new VerticalBlock(scheme, 1, 0, 1, 0), result.get(1));
	}

	/**
	 * Test case 8.
	 * <p>
	 * The scheme contains a single word and a single vertical line.
	 * <p>
	 * The expected result is a list containing two blocks:
	 * the first one is the word, the second one is the vertical line.
	 */
	@Test
	void testExtractParallelSubblocks_8() {
		Scheme scheme = new Scheme(2, 1);
		scheme.setCharAt(0, 0, 'a');
		scheme.setCharAt(1, 0, '|');
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, 1, 0);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, 0, 0), result.get(0));
		assertEquals(new"
cmpl-6xDnqAdztXOSmzp2HCoRrl9Nl98Ld,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_1Test.java,107.73002934455872,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
    }

    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
    }

    public VerticalBlock(Scheme scheme) {
    }

    public VerticalBlock(Block b) {
    }

    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {
    }

    public VerticalBlock subblock(int x1, int y1, int x2, int y2);

    public VerticalBlock cloneWith(CharPosition1 p1);

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();

    /**
     * Extracts the upper subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive horizontal line
     * does not contain elements of vertical lines
     * starting above the line.
     * <p>
     * The algorithm finds the upper entity
     * (an element of a component, gap, or vertical line)
     * using simple search along the scheme,
     * and retains it as the top of the required block.
     * Then, starting from the height of that point,
     * it sequentially finds vertical lines
     * end below but begin not below
     * and moves to lower end of such lines.
     * The lower end of the last such vertical line defines
     * the bottom of the required block.
     */
    private VerticalBlock extractFirstSequentialSubblock();

    /**
     * Returns the set of all vertical lines intersecting this block.
     */
    private Set<VWordPosition> getIntersectingVLines();

    /**
     * Finds the upper entity (an element of a word or vertical line)
     * of this block.
     * Returns its position on the scheme.
     * @throws	IllegalArgumentException if this block happens to be empty.
     */
    private CharPosition getBlockStart();

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a vertical line character.
     */
    private boolean entityAt(int x, int y);

    /**
     * Finds the last line of the subblock
     * containing the specified position {@code blockStart}.
     * Returns the coordinate {@code y2} of such block.
     */
    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines);

    /**
     * Finds a vertical line which vertical range covers
     * the specified value {@code y}
     * and which lower point is lower than {@code y}.
     * Returns the position of the last element of such line (inclusive)
     * or {@code y} if such line does not exist.
     */
    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines);

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks();

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long vertical lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines);

    /**
     * Finds the longest lines in the specified set of vertical lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallVLinesFrom(Set<VWordPosition> vLines);

    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators);

    /*
	 * Returns a list of the specified vertical lines
	 * sorted according to the horizontal coordinates.
	 */
    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines);

    /**
     * Divides the current block without vertical lines
     * into a set of (optimized) parallel subblocks.
     * Returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines();

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components or gaps
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component or gap)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstParallelSubblock();

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of a word character.
     * @return	the position of the word character found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain word characters.
     */
    private CharPosition firstWordChar();

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstWordCharBelow(int x, int y);

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character.
     * <p>
     * Overrides the less optimal method {@code CharTable.wordCharAt()}.
     * Since all symbols on the scheme are definitely correct
     * (which has been verified in its constructor),
     * there is no need to use slower method.
     */
    public boolean wordCharAt(int x, int y);

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord);
}
","// VerticalBlock_1Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlock_1Test {","// VerticalBlock_1Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlock_1Test {

	/**
	 * Test case 1.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into two subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_1() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, scheme.height() - 1), subblocks.get(1));
	}

	/**
	 * Test case 2.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_2() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, 3), subblocks.get(1));
		assertEquals(new VerticalBlock(scheme, 0, 4, scheme.width() - 1, scheme.height() - 1), subblocks.get(2));
	}

	/**
	 * Test case 3.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into four subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_3() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, 3), subblocks.get(1));
		assertEquals(new VerticalBlock(scheme, 0, 4, scheme.width() - 1, 5), subblocks.get(2));
		assertEquals(new VerticalBlock(scheme, 0, 6, scheme.width() - 1, scheme.height() - 1), subblocks.get(3));
	}

	/**
	 * Test case 4.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into five subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_4() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, 3), subblocks.get(1));
		assertEquals(new VerticalBlock(scheme, 0, 4, scheme.width() - 1, 5), subblocks.get(2));
		assertEquals(new VerticalBlock(scheme, 0, 6, scheme.width() - 1, 7), subblocks.get(3));
		assertEquals(new VerticalBlock(scheme, 0, 8, scheme.width() - 1, scheme.height() - 1), subblocks.get(4));
	}

	/**
	 * Test case 5.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into six subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_5() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(6, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, 3), subblocks.get(1));
		assertEquals(new VerticalBlock(scheme, 0, 4, scheme.width() - 1, 5), subblocks.get(2));
		assertEquals(new VerticalBlock(scheme, 0, 6, scheme.width() - 1, 7), subblocks.get(3));
		assertEquals(new VerticalBlock(scheme, 0, 8, scheme.width() - 1, 9), subblocks.get(4));
		assertEquals(new VerticalBlock(scheme, 0, 10, scheme.width() - 1, scheme.height() - 1), subblocks.get(5));
	}

	/**
	 * Test case 6.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into seven subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_6() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(7, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, 3), subblocks.get(1));
		assertEquals(new VerticalBlock(scheme, 0, 4, scheme.width() - 1, 5), subblocks.get(2));
		assertEquals(new VerticalBlock(scheme, 0, 6, scheme.width() - 1, 7), subblocks.get(3));
		assertEquals(new VerticalBlock(scheme, 0, 8, scheme.width() - 1, 9), subblocks.get(4));
		assertEquals(new VerticalBlock(scheme, 0, 10, scheme.width() - 1, 11), subblocks.get(5));
		assertEquals(new VerticalBlock(scheme, 0, 12, scheme.width() - 1, scheme.height() - 1), subblocks.get(6));
	}

	/**
	 * Test case 7.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into eight subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_7() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(8, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, 3), subblocks.get(1));
		assertEquals(new VerticalBlock(scheme, 0, 4, scheme.width() - 1, 5), subblocks.get(2));
		assertEquals(new VerticalBlock(scheme, 0, 6, scheme.width() - 1, 7), subblocks.get(3));
		assertEquals(new VerticalBlock(scheme, 0, 8, scheme.width() - 1, 9), subblocks.get(4));
		assertEquals(new VerticalBlock(scheme, 0, 10, scheme.width() - 1, 11), subblocks.get(5));
		assertEquals(new VerticalBlock(scheme, 0, 12, scheme.width() - 1, 13), subblocks.get(6));
		assertEquals(new VerticalBlock(scheme, 0, 14, scheme.width() - 1, scheme.height() - 1), subblocks.get(7));
	}

	/**
	 * Test case 8.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into nine subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_8() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(9, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, 3), subblocks.get(1));
		assertEquals(new VerticalBlock(scheme, 0, 4, scheme.width() - 1, 5), subblocks.get(2));
		assertEquals(new VerticalBlock(scheme, 0, 6, scheme.width() - 1, 7), subblocks.get(3));
		assertEquals(new VerticalBlock(scheme, 0, 8, scheme.width() - 1, 9), subblocks.get(4));
		assertEquals(new VerticalBlock(scheme, 0, 10, scheme.width() - 1, 11), subblocks.get(5));
		assertEquals(new VerticalBlock(scheme, 0, 12, scheme.width() - 1, 13), subblocks.get(6));
		assertEquals(new VerticalBlock(scheme, 0, 14, scheme.width() - 1, 15), subblocks.get(7));
		assertEquals(new VerticalBlock(scheme, 0, 16, scheme.width() - 1, scheme.height() - 1), subblocks.get(8));
	}

	/**
	 * Test case 9.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into ten subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_9() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(10, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, 3), subblocks.get(1));
		assertEquals(new VerticalBlock(scheme, 0, 4, scheme.width() - 1, 5), subblocks.get(2));
		assertEquals(new VerticalBlock(scheme, 0, 6, scheme.width() - 1, 7), subblocks.get(3));
		assertEquals(new VerticalBlock(scheme, 0, 8, scheme.width() - 1, 9), subblocks.get(4));
		assertEquals(new VerticalBlock(scheme, 0, 10, scheme.width() - 1, 11), subblocks.get(5));
		assertEquals(new VerticalBlock(scheme, 0, 12, scheme.width() - 1, 13), subblocks.get(6));
		assertEquals(new VerticalBlock(scheme, 0, 14, scheme.width() - 1, 15), subblocks.get(7));
		assertEquals(new VerticalBlock(scheme, 0, 16, scheme.width() - 1, 17), subblocks.get(8));
		assertEquals(new VerticalBlock(scheme, 0, 18, scheme.width() - 1, scheme.height() - 1), subblocks.get(9));
	}

	/**
	 * Test case 10.
	 * <p>
	 * The block contains no vertical lines.
	 * <p>
	 * The block is divided into eleven subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_10() {
		Scheme scheme = new Scheme(""a b c d e f g h i j k l m n o p q r s t u v w x y z"");
		VerticalBlock block = new VerticalBlock(scheme, 0, 0, scheme.width() - 1, scheme.height() - 1);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(11, subblocks.size());
		assertEquals(new VerticalBlock(scheme, 0, 0, scheme.width() - 1, 1), subblocks.get(0));
		assertEquals(new VerticalBlock(scheme, 0, 2, scheme.width() - 1, 3), subblocks.get(1));
		assertEquals(new VerticalBlock(scheme, 0, 4, scheme.width() - 1, 5), subblocks.get(2));
		assertEquals(new VerticalBlock(scheme, 0, 6, scheme.width() - 1, 7), subblocks.get(3));
		assertEquals(new VerticalBlock(scheme, 0, 8, scheme.width() - 1, 9), subblocks.get(4));
		assertEquals(new VerticalBlock(scheme, 0, 10, scheme.width() - 1, 11), subblocks.get(5));
		assertEquals(new VerticalBlock(scheme, 0, 12, scheme.width() - 1, 13), subblocks.get(6));
		assertEquals(new VerticalBlock(scheme, 0, 14, scheme.width() - 1, 15), subblocks.get(7));
		assertEquals(new VerticalBlock(scheme, 0, 16, scheme.width() - 1, 17), subblocks.get(8));
		assertEquals(new VerticalBlock(scheme, 0, 18, scheme.width() - 1, 19), subblocks.get(9));
		assertEquals(new VerticalBlock(scheme, 0, 20, scheme.width() - 1, scheme.height() - 1), subblocks.get(10));
	}
}

// VerticalBlock_2Test.java
package glengineer.blocks;

import glengineer.positions.*"
cmpl-6xDpaEPTwCoqLP0trMDPWYkTKkIX0,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/positions/HWordPosition.java,101.48218560218811,length,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    /**
     * The horizontal coordinate of the word start.
     */
    public final int x1;

    /**
     * The horizontal coordinate of the word end + 1.
     */
    public final int x2;

    /**
     * The vertical coordinate of the word.
     */
    public final int y;

    public HWordPosition(int x1, int x2, int y) {
    }

    public HWordPosition(CharPosition start, int x2) {
    }

    public HWordPosition(int x1, CharPosition end) {
    }

    /**
     * The word position is initialized
     * representing the upper line of the specified block.
     */
    public HWordPosition(Block block) {
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public HWordPosition(CharPosition cp) {
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart();

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd();

    public int getWidth();

    public boolean equals(WordPosition wp);

    public boolean isTrivial();

    public boolean contains(int x, int y);

    public boolean liesIn(CharTable ct);

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct);

    /**
     * Returns the width of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block);

    public String toString();

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct);
}
","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {

	@Test
	void testTextAt() {
		CharTable ct = new CharTable(5, 5);
		ct.setText(0, 0, ""abcde"");
		ct.setText(0, 1, ""fghij"");
		ct.setText(0, 2, ""klmno"");
		ct.setText(0, 3, ""pqrst"");
		ct.setText(0, 4, ""uvwxy"");
		
		HWordPosition wp1 = new HWordPosition(0, 0, 0);
		assertEquals(""a"", wp1.textAt(ct));
		
		HWordPosition wp2 = new HWordPosition(1, 1, 0);
		assertEquals(""b"", wp2.textAt(ct));
		
		HWordPosition wp3 = new HWordPosition(2, 2, 0);
		assertEquals(""c"", wp3.textAt(ct));
		
		HWordPosition wp4 = new HWordPosition(3, 3, 0);
		assertEquals(""d"", wp4.textAt(ct));
		
		HWordPosition wp5 = new HWordPosition(4, 4, 0);
		assertEquals(""e"", wp5.textAt(ct));
		
		HWordPosition wp6 = new HWordPosition(0, 4, 0);
		assertEquals(""abcde"", wp6.textAt(ct));
		
		HWordPosition wp7 = new HWordPosition(0, 4, 1);
		assertEquals(""fghij"", wp7.textAt(ct));
		
		HWordPosition wp8 = new HWordPosition(0, 4, 2);
		assertEquals(""klmno"", wp8.textAt(ct));
		
		HWordPosition wp9 = new HWordPosition(0, 4, 3);
		assertEquals(""pqrst"", wp9.textAt(ct));
		
		HWordPosition wp10 = new HWordPosition(0, 4, 4);
		assertEquals(""uvwxy"", wp10.textAt(ct));
	}
}

// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition {

    /**
     * The horizontal coordinate of the word.
     */
    public final int x;

    /**
     * The vertical coordinate of the word start.
     */
    public final int y1;

    /**
     * The vertical coordinate of the word end + 1.
     */
    public final int y2;

    public VWordPosition(int x, int y1, int y2) {
    }

    public VWordPosition(CharPosition start, int y2) {
    }

    public VWordPosition(int x, CharPosition end) {
    }

    /**
     * The word position is initialized
     * representing the left line of the specified block.
     */
    public VWordPosition(Block block) {
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public VWordPosition(CharPosition cp) {
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart();

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd();

    public int getWidth();

    public boolean equals(WordPosition wp);

    public boolean isTrivial();

    public boolean contains(int x, int y);

    public boolean liesIn(CharTable ct);

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct);

    /**
     * Returns the width of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block);

    public String toString();

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct);
}

// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(5, 5);
		ct.setText(0, 0, ""abcde"");
		ct.setText(1, 0, ""fghij"");
		ct.setText(2, 0, ""klmno"");
		ct.setText(3, 0, ""pqrst"");
		ct.setText(4, 0, ""uvwxy"");
		
		VWordPosition wp1 = new VWordPosition(0, 0, 0);
		assertEquals(""a"", wp1.textAt(ct));
		
		VWordPosition wp2 = new VWordPosition(1, 0, 0);
		assertEquals(""f"", wp2.textAt(ct));
		
		VWordPosition wp3 = new VWordPosition(2, 0, 0);
		assertEquals(""k"", wp3.textAt(ct));
		
		VWordPosition wp4 = new VWordPosition(3, 0, 0);
		assertEquals(""p"", wp4.textAt(ct));
		
		VWordPosition wp5 = new VWordPosition(4, 0, 0);
		assertEquals(""u"", wp5.textAt(ct));
		
		VWordPosition wp6 = new VWordPosition(0, 0, 4);
		assertEquals(""afkpu"", wp6.textAt(ct));
		
		VWordPosition wp7 = new VWordPosition(1, 0, 4);
		assertEquals(""bgqlv"", wp7.textAt(ct));
		
		VWordPosition wp8 = new VWordPosition(2, 0, 4);
		assertEquals(""chrmw"", wp8.textAt(ct));
		
		VWordPosition wp9 = new VWordPosition(3, 0, 4);
		assertEquals(""disnx"", wp9.textAt(ct));
		
		VWordPosition wp10 = new VWordPosition(4, 0, 4);
		assertEquals(""ejtoy"", wp10.textAt(ct));
	}
}

// WordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying on the scheme.
 */
public abstract class WordPosition {

    /**
     * The width of the word.
     */
    public final int width;

    public WordPosition(int width) {
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public abstract CharPosition1 getStart();

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public abstract CharPosition2 getEnd();

    public int getWidth();

    public boolean equals(WordPosition wp);

    public boolean isTrivial();

    public boolean contains(int x, int y);

    public boolean liesIn(CharTable ct);

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct);

    /**
     * Returns the width of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block);

    public String toString();

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public abstract String textAt(CharTable ct);
}

// WordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPosition}.
* It contains ten unit test cases for the {@link WordPosition#textAt(CharTable)} method.
*/
class WordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(5, 5);
		ct.setText(0, 0, ""abcde"");
		ct.setText(0, 1, ""fghij"");
		ct.setText(0, 2, ""klmno"");
		ct.setText(0, 3, ""pqrst"");
		ct.setText(0, 4, ""uvwxy"");
		
		HWordPosition wp1 = new HWordPosition(0, 0, 0);
		assertEquals(""a"", wp1.textAt(ct));
		
		HWordPosition wp2 = new HWordPosition(1, 1, 0);
		assertEquals(""b"", wp2.textAt(ct));
		
		HWordPosition wp3 = new HWordPosition(2, 2, 0);
		assertEquals(""c"", wp3.textAt(ct));
		
		HWordPosition wp4 = new HWordPosition(3, 3, 0);
		assertEquals(""d"", wp4.textAt(ct));
		
		HWordPosition wp5 = new HWordPosition(4, 4, 0);
		assertEquals(""e"", wp5.textAt(ct));
		
		HWordPosition wp6 = new HWordPosition(0, 4, 0);
		assertEquals(""abcde"", wp6.textAt(ct));
		
		HWordPosition wp7 = new HWordPosition(0, 4, 1);
		assertEquals(""fghij"", wp7.textAt(ct));
		
		HWordPosition wp8 = new HWordPosition(0, 4, 2);
		assertEquals(""klmno"", wp8.textAt(ct));
		
		HWordPosition wp9 = new HWordPosition(0, 4, 3);
		assertEquals(""pqrst"", wp9.textAt(ct));
		
		HWordPosition wp10 = new HWordPosition(0, 4, 4);
		assertEquals(""uvwxy"", wp10.textAt(ct));
	}
}

// CharTable.java
package glengineer.blocks;

import glengineer.positions.CharPosition;
import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;

/**
 * Encapsulates a table of characters.
 *
 * The table is represented as a two-dimensional array of characters.
 * The table is mutable.
 */
public class CharTable {

    /**
     * The width of the table.
     */
    public final int width;

    /**
     * The height of the table.
     */
    public final int height;

    /**
     * The two-dimensional array of characters.
     */
    public final char[][] chars;

    /**
     * Creates a new char table of the specified size.
     *
     * @param width		the width of the table.
     * @param height	the height of the table.
     */
    public CharTable(int width, int height) {
    }

    /**
     * Creates a new char table of the specified size
     * and fills it with the specified text.
     *
     * @param width		the width of the table.
     * @param height	the height of the table.
     * @param text		the text to be filled into the table.
     */
    public CharTable(int width, int height, String text) {
    }

    /**
     * Returns the character at the specified position.
     *
     * @param x		the horizontal coordinate of the character.
     * @param y		the vertical coordinate of the character.
     *
     * @return		the character at the specified position.
     */
    public char charAt(int x, int y);

    /**
     * Returns the character at the specified position.
     *
     * @param cp	the position of the character.
     *
     * @return		the character at the specified position.
     */
    public char charAt(CharPosition cp);

    /**
     * Sets the character at the specified position.
     *
     * @param x		the horizontal coordinate of the character.
     * @param y		the vertical coordinate of the character.
     * @param c		the character to be set.
     */
    public void setChar(int x, int y, char c);

    /**
     * Sets the character at the specified position.
     *
     * @param cp	the position of the character.
     * @param c		the character to be set.
     */
    public void setChar(CharPosition cp, char c);

    /**
     * Sets the text at the specified position.
     *
     * @param x		the horizontal coordinate of the text.
     * @param y		the vertical coordinate of the text.
     * @param text	the text to be set.
     */
    public void setText(int x, int y, String text);

    /**
     * Sets the text at the specified position.
     *
     * @param cp	the position of the text.
     * @param text	the text to be set.
     */
    public void setText(CharPosition cp, String text);

    /**
     * Returns the text at the specified position.
     *
     * @param x		the horizontal coordinate of the text.
     * @param y		the vertical coordinate of the text.
     * @param width	the width of the text.
     *
     * @return		the text at the specified position.
     */
    public String textAt(int x, int y, int width);

    /**
     * Returns the text at the specified position.
     *
     * @param cp	the position of the text.
     * @param width	the width of the text.
     *
     * @return		the text at the specified position.
     */
    public String textAt(CharPosition cp, int width);

    /**
     * Returns the text at the specified position.
     *
     * @param wp	the position of the text.
     *
     * @return		the text at the specified position.
     */
    public String textAt(WordPosition wp);

    /**
     * Returns the text at the specified position.
     *
     * @param x		the horizontal coordinate of the text.
     * @param y		the vertical coordinate of the text.
     * @param width	the width of the text.
     * @param height	the height of the text.
     *
     * @return"
cmpl-6xDrDlgMyCMqDFOBmD3M86muacAtd,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/positions/VWordPosition.java,86.3080906867981,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    /**
     * The horizontal coordinate of the word.
     */
    public final int x;

    /**
     * The vertical coordinate of the word start.
     */
    public final int y1;

    /**
     * The vertical coordinate of the word end + 1.
     */
    public final int y2;

    public VWordPosition(int x, int y1, int y2) {
    }

    public VWordPosition(CharPosition start, int y2) {
    }

    public VWordPosition(int y, CharPosition end) {
    }

    public VWordPosition(Block block) {
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public VWordPosition(CharPosition cp) {
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart();

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd();

    public int getHeight();

    public boolean equals(WordPosition wp);

    public boolean isTrivial();

    public boolean contains(int x, int y);

    public boolean liesIn(CharTable ct);

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct);

    /**
     * Returns the height of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block);

    /**
     * Compares this vertical position with the specified one
     * according to their x-coordinates.
     */
    public int compareTo(VWordPosition vLine);

    public String toString();

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct);
}
","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {

	/**
	 * Test case 1.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt1() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(1, 1);
		assertEquals(""e"", vwp.textAt(ct));
	}

	/**
	 * Test case 2.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt2() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(2, 2);
		assertEquals(""f"", vwp.textAt(ct));
	}

	/**
	 * Test case 3.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt3() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(0, 0);
		assertEquals(""a"", vwp.textAt(ct));
	}

	/**
	 * Test case 4.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt4() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(2, 0);
		assertEquals(""c"", vwp.textAt(ct));
	}

	/**
	 * Test case 5.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt5() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(0, 2);
		assertEquals(""g"", vwp.textAt(ct));
	}

	/**
	 * Test case 6.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt6() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(1, 0);
		assertEquals(""b"", vwp.textAt(ct));
	}

	/**
	 * Test case 7.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt7() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(0, 1);
		assertEquals(""d"", vwp.textAt(ct));
	}

	/**
	 * Test case 8.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt8() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(2, 1);
		assertEquals(""f"", vwp.textAt(ct));
	}

	/**
	 * Test case 9.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt9() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(1, 2);
		assertEquals(""h"", vwp.textAt(ct));
	}

	/**
	 * Test case 10.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt10() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition vwp = new VWordPosition(2, 0);
		assertEquals(""c"", vwp.textAt(ct));
	}
}

// WordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying on the scheme.
 */
public abstract class WordPosition implements Comparable<WordPosition> {

    /**
     * The vertical coordinate of the word.
     */
    public final int y;

    /**
     * The horizontal coordinate of the word start.
     */
    public final int x1;

    /**
     * The horizontal coordinate of the word end + 1.
     */
    public final int x2;

    public WordPosition(int x1, int x2, int y) {
    }

    public WordPosition(CharPosition start, int x2) {
    }

    public WordPosition(int x, CharPosition end) {
    }

    public WordPosition(Block block) {
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public WordPosition(CharPosition cp) {
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart();

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd();

    public int getWidth();

    public boolean equals(WordPosition wp);

    public boolean isTrivial();

    public boolean contains(int x, int y);

    public boolean liesIn(CharTable ct);

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct);

    /**
     * Returns the width of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block);

    /**
     * Compares this horizontal position with the specified one
     * according to their y-coordinates.
     */
    public int compareTo(WordPosition hLine);

    public String toString();

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public abstract String textAt(CharTable ct);
}

// WordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPosition}.
* It contains ten unit test cases for the {@link WordPosition#textAt(CharTable)} method.
*/
class WordPositionTest {
		
	/**
	 * Test case 1.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt1() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(1, 1);
		assertEquals(""e"", wp.textAt(ct));
	}

	/**
	 * Test case 2.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt2() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(2, 2);
		assertEquals(""f"", wp.textAt(ct));
	}

	/**
	 * Test case 3.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt3() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(0, 0);
		assertEquals(""a"", wp.textAt(ct));
	}

	/**
	 * Test case 4.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt4() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(2, 0);
		assertEquals(""c"", wp.textAt(ct));
	}

	/**
	 * Test case 5.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt5() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(0, 2);
		assertEquals(""g"", wp.textAt(ct));
	}

	/**
	 * Test case 6.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt6() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(1, 0);
		assertEquals(""b"", wp.textAt(ct));
	}

	/**
	 * Test case 7.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt7() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(0, 1);
		assertEquals(""d"", wp.textAt(ct));
	}

	/**
	 * Test case 8.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt8() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(2, 1);
		assertEquals(""f"", wp.textAt(ct));
	}

	/**
	 * Test case 9.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt9() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(1, 2);
		assertEquals(""h"", wp.textAt(ct));
	}

	/**
	 * Test case 10.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt10() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		WordPosition wp = new WordPosition(2, 0);
		assertEquals(""c"", wp.textAt(ct));
	}
}

// CharPosition.java
package glengineer.positions;

/**
 * Encapsulates the coordinates of a character on the scheme.
 */
public class CharPosition implements Comparable<CharPosition> {

    /**
     * The horizontal coordinate of the character.
     */
    public final int x;

    /**
     * The vertical coordinate of the character.
     */
    public final int y;

    public CharPosition(int x, int y) {
    }

    public CharPosition(CharPosition cp) {
    }

    public boolean equals(CharPosition cp);

    public boolean equals(int x, int y);

    public int compareTo(CharPosition cp);

    public String toString();
}

// CharPosition1.java
package glengineer.positions;

/**
 * Encapsulates the coordinates of the beginning of a word.
 */
public class CharPosition1 extends CharPosition {

    public CharPosition1(int x, int y) {
    }

    public CharPosition1(CharPosition cp) {
    }
}

// CharPosition2.java
package glengineer.positions;

/**
 * Encapsulates the coordinates of the ending of a word (exclusive).
 */
public class CharPosition2 extends CharPosition {

    public CharPosition2(int x, int y) {
    }

    public CharPosition2(CharPosition cp) {
    }
}

// CharPositionTest.java
package glengineer.positions;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CharPosition}.
* It contains ten unit test cases for the {@link CharPosition#equals(CharPosition)} method.
"
