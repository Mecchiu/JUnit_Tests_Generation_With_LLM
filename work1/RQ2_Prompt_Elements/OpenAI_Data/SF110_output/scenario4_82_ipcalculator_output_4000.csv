ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6xEJFuFVD6KqBpS2AYwYn8xCPFYDs,/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_0Test.java,161.44975090026855,length,"// BinaryCalculate.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;

public class BinaryCalculate {

    boolean isIPv4 = false;

    boolean isIPv6 = false;

    String currentIP = """";

    String fullReassembler = """";

    String DELIMITER = """";

    int lengthOfToken = 0;

    String IPRangeAddress = """";

    String usableRange = """";

    int semiCol = 0;

    String prefix = """";

    BigInteger totalIPAddresses;

    int MAXPREFIX = 0;

    /**
     *  Calculates the sum of two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be added to the starting binary
     *  @return      The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2);

    /**
     *  Subtracts two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be subtracted from the
     *                       starting binary
     *  @return      The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored into an <code>string</code> to be
     *  returned to the method that called it.
     *
     *  @param      IP          The starting IP address (subnet) in binary
     *  @param      IPPrefix    Number of IP addresses in binary
     *  @return     Results string
     */
    public String IPCalculate(String IP, String IPPrefix);

    /**
     *  Adds delimiters back into a given IP address
     *
     *  @param      binaryIP     binary IP address with no delimiters
     *  @return     binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP);

    /**
     *  Gets the netmask from a binary representation of number of IP addresses
     *
     *  @param      binaryIP     binary representation of number of IP addresses
     *  @return     netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored as declared global variables for many
     *  other methods to manipulate or use.
     *  <br>This method also detects if the provided of number of IP addresses
     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and
     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds
     *  the IP addressing bounds.
     *  <br>This method also calculates the prefix size needed to accomodate all
     *  the IP Addresses to be listed and stores it as a global variable for use
     *  in other methods.
     *
     *  @param       subnet              The starting IP address (subnet)
     *  @param       noOfIPAddresses     Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses from the smaller prefix. The results are stored into an array
     *  to be printed using <code><b>Output.java</b></code>.
     *
     *  @param       IP          The starting IP address (subnet)
     *  @param       IPPrefix    Number of IP addresses for smaller prefix
     *  @param       noPrefix    Number of smaller prefixes within the total
     *                           prefix
     *  @param       endPrefix   Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);

    /**
     *  Determines whether an IP Address provided in binary form is an IPv4 or
     *  an IPv6 by the length of the binary string.
     *
     *  @param       size1    Length of binary string
     */
    private void checkIPType(int size1);

    /**
     *  Reconstructs the dotted-decimal or hexidecimal IP address with
     *  seperators from an given binary IP Address. The reconstructed IP address
     *  is stored as a global declared variable, <code>currentIP</code>.
     *
     *  @param   IP  An binary IP Address to be converted back into
     *               dotted-decimal or hexidecimal format
     */
    private String convert(String binaryIP);

    /**
     *  Converts an given IPv4 or IPv6 address into binary format.
     *
     *  @param   IP  An IP Address to be converted back into binary format
     *  @return  Binary representation of given IP Address.
     */
    private String convertToBinary(String IP);

    /**
     *  Gets the starting IP of an IP range.
     *
     *  @return     Starting IP of IP range
     */
    private String getStartIP();
}
","// BinaryCalculate_0Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.
*/
class BinaryCalculate_0Test {","// BinaryCalculate_0Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.
*/
class BinaryCalculate_0Test {

	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_0() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_1() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""1000111"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_2() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_3() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""1000111"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_4() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_5() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""1000111"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_6() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_7() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""1000111"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_8() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_9() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""1000111"";
		String actual = bc.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
}

// BinaryCalculate_1Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.
*/
class BinaryCalculate_1Test {
		
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testSubBinary_0() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""11000"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testSubBinary_1() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""110101"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testSubBinary_2() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""11000"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testSubBinary_3() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""110101"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testSubBinary_4() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""11000"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testSubBinary_5() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""110101"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testSubBinary_6() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""11000"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testSubBinary_7() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""110101"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testSubBinary_8() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""11000"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testSubBinary_9() {
		BinaryCalculate bc = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""110110"";
		String expected = ""110101"";
		String actual = bc.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
}

// BinaryCalculate_2Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.
*/
class BinaryCalculate_2Test {
		
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testIPCalculate_0() {
		BinaryCalculate bc = new BinaryCalculate();
		String IP = ""10101"";
		String IPPrefix = ""11011"";
		String expected = ""11000"";
		String actual = bc.IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testIPCalculate_1() {
		BinaryCalculate bc = new BinaryCalculate();
		String IP = ""10101"";
		String IPPrefix = ""110110"";
		String expected = ""110101"";
		String actual = bc.IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testIPCalculate_2() {
		BinaryCalculate bc = new BinaryCalculate();
		String IP = ""10101"";
		String IPPrefix = ""11011"";
		String expected = ""11000"";
		String actual = bc.IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testIPCalculate_3() {
		BinaryCalculate bc = new BinaryCalculate();
		String IP = ""10101"";
		String IPPrefix = ""110110"";
		String expected = ""110101"";
		String actual = bc.IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testIPCalculate_4() {
		BinaryCalculate bc = new BinaryCalculate();
		String IP = ""10101"";
		String IPPrefix = ""11011"";
		String expected = ""11000"";
		String actual = bc.IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testIPCalculate_5() {
		BinaryCalculate bc = new BinaryCalculate();
		String IP = """
cmpl-6xEL6sUCTQmcEGfLstK9U17ZhZKYb,/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_1Test.java,103.40766048431396,length,"// BinaryCalculate.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;

public class BinaryCalculate {

    boolean isIPv4 = false;

    boolean isIPv6 = false;

    String currentIP = """";

    String fullReassembler = """";

    String DELIMITER = """";

    int lengthOfToken = 0;

    String IPRangeAddress = """";

    String usableRange = """";

    int semiCol = 0;

    String prefix = """";

    BigInteger totalIPAddresses;

    int MAXPREFIX = 0;

    /**
     *  Calculates the sum of two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be added to the starting binary
     *  @return      The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2);

    /**
     *  Subtracts two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be subtracted from the
     *                       starting binary
     *  @return      The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored into an <code>string</code> to be
     *  returned to the method that called it.
     *
     *  @param      IP          The starting IP address (subnet) in binary
     *  @param      IPPrefix    Number of IP addresses in binary
     *  @return     Results string
     */
    public String IPCalculate(String IP, String IPPrefix);

    /**
     *  Adds delimiters back into a given IP address
     *
     *  @param      binaryIP     binary IP address with no delimiters
     *  @return     binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP);

    /**
     *  Gets the netmask from a binary representation of number of IP addresses
     *
     *  @param      binaryIP     binary representation of number of IP addresses
     *  @return     netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored as declared global variables for many
     *  other methods to manipulate or use.
     *  <br>This method also detects if the provided of number of IP addresses
     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and
     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds
     *  the IP addressing bounds.
     *  <br>This method also calculates the prefix size needed to accomodate all
     *  the IP Addresses to be listed and stores it as a global variable for use
     *  in other methods.
     *
     *  @param       subnet              The starting IP address (subnet)
     *  @param       noOfIPAddresses     Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses from the smaller prefix. The results are stored into an array
     *  to be printed using <code><b>Output.java</b></code>.
     *
     *  @param       IP          The starting IP address (subnet)
     *  @param       IPPrefix    Number of IP addresses for smaller prefix
     *  @param       noPrefix    Number of smaller prefixes within the total
     *                           prefix
     *  @param       endPrefix   Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);

    /**
     *  Determines whether an IP Address provided in binary form is an IPv4 or
     *  an IPv6 by the length of the binary string.
     *
     *  @param       size1    Length of binary string
     */
    private void checkIPType(int size1);

    /**
     *  Reconstructs the dotted-decimal or hexidecimal IP address with
     *  seperators from an given binary IP Address. The reconstructed IP address
     *  is stored as a global declared variable, <code>currentIP</code>.
     *
     *  @param   IP  An binary IP Address to be converted back into
     *               dotted-decimal or hexidecimal format
     */
    private String convert(String binaryIP);

    /**
     *  Converts an given IPv4 or IPv6 address into binary format.
     *
     *  @param   IP  An IP Address to be converted back into binary format
     *  @return  Binary representation of given IP Address.
     */
    private String convertToBinary(String IP);

    /**
     *  Gets the starting IP of an IP range.
     *
     *  @return     Starting IP of IP range
     */
    private String getStartIP();
}
","// BinaryCalculate_1Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.
*/
class BinaryCalculate_1Test {","// BinaryCalculate_1Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.
*/
class BinaryCalculate_1Test {

	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* </ul>
	* The expected result is ""0"".
	*/
	@Test
	void testSubBinary_1() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""0"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111111111110""</li>
	* </ul>
	* The expected result is ""1"".
	*/
	@Test
	void testSubBinary_2() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111111111110"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""1"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111111111101""</li>
	* </ul>
	* The expected result is ""10"".
	*/
	@Test
	void testSubBinary_3() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111111111101"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""10"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111111111011""</li>
	* </ul>
	* The expected result is ""100"".
	*/
	@Test
	void testSubBinary_4() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111111111011"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""100"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111111110111""</li>
	* </ul>
	* The expected result is ""1000"".
	*/
	@Test
	void testSubBinary_5() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111111110111"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""1000"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111111101111""</li>
	* </ul>
	* The expected result is ""10000"".
	*/
	@Test
	void testSubBinary_6() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111111101111"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""10000"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111111011111""</li>
	* </ul>
	* The expected result is ""100000"".
	*/
	@Test
	void testSubBinary_7() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111111011111"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""100000"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111110111111""</li>
	* </ul>
	* The expected result is ""1000000"".
	*/
	@Test
	void testSubBinary_8() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111110111111"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""1000000"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111101111111""</li>
	* </ul>
	* The expected result is ""10000000"".
	*/
	@Test
	void testSubBinary_9() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111101111111"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""10000000"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1111111111111111111111111111111111111111111111111111111111111111""</li>
	* <li>num2 = ""1111111111111111111111111111111111111111111111111111111011111111""</li>
	* </ul>
	* The expected result is ""100000000"".
	*/
	@Test
	void testSubBinary_10() {
		String num1 = ""1111111111111111111111111111111111111111111111111111111111111111"";
		String num2 = ""1111111111111111111111111111111111111111111111111111111011111111"";
		String result = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(""100000000"", result);
	}
}

// BinaryCalculate_2Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.
*/
class BinaryCalculate_2Test {
		
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""0""</li>
	* <li>num2 = ""0""</li>
	* </ul>
	* The expected result is ""0"".
	*/
	@Test
	void testAddBinary_1() {
		String num1 = ""0"";
		String num2 = ""0"";
		String result = new BinaryCalculate().addBinary(num1, num2);
		assertEquals(""0"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""0""</li>
	* <li>num2 = ""1""</li>
	* </ul>
	* The expected result is ""1"".
	*/
	@Test
	void testAddBinary_2() {
		String num1 = ""0"";
		String num2 = ""1"";
		String result = new BinaryCalculate().addBinary(num1, num2);
		assertEquals(""1"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1""</li>
	* <li>num2 = ""0""</li>
	* </ul>
	* The expected result is ""1"".
	*/
	@Test
	void testAddBinary_3() {
		String num1 = ""1"";
		String num2 = ""0"";
		String result = new BinaryCalculate().addBinary(num1, num2);
		assertEquals(""1"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""1""</li>
	* <li>num2 = ""1""</li>
	* </ul>
	* The expected result is ""10"".
	*/
	@Test
	void testAddBinary_4() {
		String num1 = ""1"";
		String num2 = ""1"";
		String result = new BinaryCalculate().addBinary(num1, num2);
		assertEquals(""10"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""10""</li>
	* <li>num2 = ""0""</li>
	* </ul>
	* The expected result is ""10"".
	*/
	@Test
	void testAddBinary_5() {
		String num1 = ""10"";
		String num2 = ""0"";
		String result = new BinaryCalculate().addBinary(num1, num2);
		assertEquals(""10"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""10""</li>
	* <li>num2 = ""1""</li>
	* </ul>
	* The expected result is ""11"".
	*/
	@Test
	void testAddBinary_6() {
		String num1 = ""10"";
		String num2 = ""1"";
		String result = new BinaryCalculate().addBinary(num1, num2);
		assertEquals(""11"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""10""</li>
	* <li>num2 = ""10""</li>
	* </ul>
	* The expected result is ""100"".
	*/
	@Test
	void testAddBinary_7() {
		String num1 = ""10"";
		String num2 = ""10"";
		String result = new BinaryCalculate().addBinary(num1, num2);
		assertEquals(""100"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""100""</li>
	* <li>num2 = ""0""</li>
	* </ul>
	* The expected result is ""100"".
	*/
	@Test
	void testAddBinary_8() {
		String num1 = ""100"";
		String num2 = ""0"";
		String result = new BinaryCalculate().addBinary(num1, num2);
		assertEquals(""100"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""100""</li>
	* <li>num2 = ""1""</li>
	* </ul>
	* The expected result is ""101"".
	*/
	@Test
	void testAddBinary_9() {
		String num1 = ""100"";
		String num2 = ""1"";
		String result = new BinaryCalculate().addBinary(num1, num2);
		assertEquals(""101"", result);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>num1 = ""100""</li>
	* <li>num2 = ""10"
cmpl-6xEMln0OY3CwoeMzr9WYDOYXdhKaq,/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_2Test.java,92.28513145446777,length,"// BinaryCalculate.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;

public class BinaryCalculate {

    boolean isIPv4 = false;

    boolean isIPv6 = false;

    String currentIP = """";

    String fullReassembler = """";

    String DELIMITER = """";

    int lengthOfToken = 0;

    String IPRangeAddress = """";

    String usableRange = """";

    int semiCol = 0;

    String prefix = """";

    BigInteger totalIPAddresses;

    int MAXPREFIX = 0;

    /**
     *  Calculates the sum of two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be added to the starting binary
     *  @return      The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2);

    /**
     *  Subtracts two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be subtracted from the
     *                       starting binary
     *  @return      The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored into an <code>string</code> to be
     *  returned to the method that called it.
     *
     *  @param      IP          The starting IP address (subnet) in binary
     *  @param      IPPrefix    Number of IP addresses in binary
     *  @return     Results string
     */
    public String IPCalculate(String IP, String IPPrefix);

    /**
     *  Adds delimiters back into a given IP address
     *
     *  @param      binaryIP     binary IP address with no delimiters
     *  @return     binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP);

    /**
     *  Gets the netmask from a binary representation of number of IP addresses
     *
     *  @param      binaryIP     binary representation of number of IP addresses
     *  @return     netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored as declared global variables for many
     *  other methods to manipulate or use.
     *  <br>This method also detects if the provided of number of IP addresses
     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and
     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds
     *  the IP addressing bounds.
     *  <br>This method also calculates the prefix size needed to accomodate all
     *  the IP Addresses to be listed and stores it as a global variable for use
     *  in other methods.
     *
     *  @param       subnet              The starting IP address (subnet)
     *  @param       noOfIPAddresses     Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses from the smaller prefix. The results are stored into an array
     *  to be printed using <code><b>Output.java</b></code>.
     *
     *  @param       IP          The starting IP address (subnet)
     *  @param       IPPrefix    Number of IP addresses for smaller prefix
     *  @param       noPrefix    Number of smaller prefixes within the total
     *                           prefix
     *  @param       endPrefix   Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);

    /**
     *  Determines whether an IP Address provided in binary form is an IPv4 or
     *  an IPv6 by the length of the binary string.
     *
     *  @param       size1    Length of binary string
     */
    private void checkIPType(int size1);

    /**
     *  Reconstructs the dotted-decimal or hexidecimal IP address with
     *  seperators from an given binary IP Address. The reconstructed IP address
     *  is stored as a global declared variable, <code>currentIP</code>.
     *
     *  @param   IP  An binary IP Address to be converted back into
     *               dotted-decimal or hexidecimal format
     */
    private String convert(String binaryIP);

    /**
     *  Converts an given IPv4 or IPv6 address into binary format.
     *
     *  @param   IP  An IP Address to be converted back into binary format
     *  @return  Binary representation of given IP Address.
     */
    private String convertToBinary(String IP);

    /**
     *  Gets the starting IP of an IP range.
     *
     *  @return     Starting IP of IP range
     */
    private String getStartIP();
}
","// BinaryCalculate_2Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.
*/
class BinaryCalculate_2Test {","// BinaryCalculate_2Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.
*/
class BinaryCalculate_2Test {

	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11111111""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.1""</li>
	* <li>Usable IP Range: ""192.168.1.2 - 192.168.1.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_1() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11111111"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.1\nUsable IP Range: 192.168.1.2 - 192.168.1.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11111110""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.2""</li>
	* <li>Usable IP Range: ""192.168.1.3 - 192.168.1.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_2() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11111110"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.2\nUsable IP Range: 192.168.1.3 - 192.168.1.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11111100""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.4""</li>
	* <li>Usable IP Range: ""192.168.1.5 - 192.168.1.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_3() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11111100"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.4\nUsable IP Range: 192.168.1.5 - 192.168.1.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11111000""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.8""</li>
	* <li>Usable IP Range: ""192.168.1.9 - 192.168.1.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_4() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11111000"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.8\nUsable IP Range: 192.168.1.9 - 192.168.1.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11110000""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.16""</li>
	* <li>Usable IP Range: ""192.168.1.17 - 192.168.1.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_5() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11110000"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.16\nUsable IP Range: 192.168.1.17 - 192.168.1.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11100000""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.32""</li>
	* <li>Usable IP Range: ""192.168.1.33 - 192.168.1.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_6() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11100000"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.32\nUsable IP Range: 192.168.1.33 - 192.168.1.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11000000""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.64""</li>
	* <li>Usable IP Range: ""192.168.1.65 - 192.168.1.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_7() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11000000"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.64\nUsable IP Range: 192.168.1.65 - 192.168.1.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.10000000""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.128""</li>
	* <li>Usable IP Range: ""192.168.1.129 - 192.168.1.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_8() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.10000000"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.128\nUsable IP Range: 192.168.1.129 - 192.168.1.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.00000000""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.254""</li>
	* <li>Usable IP Range: ""192.168.2.1 - 192.168.2.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_9() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.00000000"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.254\nUsable IP Range: 192.168.2.1 - 192.168.2.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111110.00000000""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.3.254""</li>
	* <li>Usable IP Range: ""192.168.4.1 - 192.168.4.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_10() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111110.00000000"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.3.254\nUsable IP Range: 192.168.4.1 - 192.168.4.254\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
}

// BinaryCalculate_3Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.
*/
class BinaryCalculate_3Test {
		
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11111111""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.1""</li>
	* <li>Usable IP Range: ""192.168.1.2 - 192.168.1.254""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_1() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11111111"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.1\nUsable IP Range: 192.168.1.2 - 192.168.1."
