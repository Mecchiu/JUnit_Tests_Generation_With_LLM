ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6x5vHVe2XqPemlgONtchDoDGCg88z,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter0.java,140.00998449325562,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);
}
","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatterTest {","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatterTest {

	@Test
	void testFormat() {
		String messagePattern = ""Hello {}!"";
		String[] arguments = new String[] { ""World"" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World!"", result);
	}
	
	@Test
	void testFormat_null() {
		String messagePattern = ""Hello {}!"";
		String[] arguments = null;
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello {}!"", result);
	}
	
	@Test
	void testFormat_empty() {
		String messagePattern = ""Hello {}!"";
		String[] arguments = new String[0];
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello {}!"", result);
	}
	
	@Test
	void testFormat_nullMessagePattern() {
		String messagePattern = null;
		String[] arguments = new String[] { ""World"" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""null"", result);
	}
	
	@Test
	void testFormat_emptyMessagePattern() {
		String messagePattern = """";
		String[] arguments = new String[] { ""World"" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals("""", result);
	}
	
	@Test
	void testFormat_nullArgument() {
		String messagePattern = ""Hello {}!"";
		String[] arguments = new String[] { null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello null!"", result);
	}
	
	@Test
	void testFormat_emptyArgument() {
		String messagePattern = ""Hello {}!"";
		String[] arguments = new String[] { """" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello !"", result);
	}
	
	@Test
	void testFormat_multipleArguments() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", ""How are you?"" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! How are you?"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooMany() {
		String messagePattern = ""Hello {}!"";
		String[] arguments = new String[] { ""World"", ""How are you?"" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World!"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! {}"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_empty() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", """" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! "", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_empty() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, """" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_empty_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", """", null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! "", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_empty_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, """", null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_empty() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, """" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_empty_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", """", null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! "", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_empty_empty_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", """", """", null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! "", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_empty_null_empty() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", """", null, """" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! "", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_empty_empty() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, """", """" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_empty_empty_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, """", """", null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_empty_null_empty() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, """", null, """" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_empty_empty() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, """", """" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_empty() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, """" };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"", result);
	}
	
	@Test
	void testFormat_multipleArguments_tooFew_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null_null() {
		String messagePattern = ""Hello {}! {}"";
		String[] arguments = new String[] { ""World"", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };
		String result = MessageFormatter.format(messagePattern, arguments);
		assertEquals(""Hello World! null"","
cmpl-6x5xXTHMHpNW6bIfBUSkZ2GT4aQVw,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter1.java,169.8597114086151,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);
}
","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {

	@Test
	void countArgumentPlaceholders_null() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(null));
	}
	
	@Test
	void countArgumentPlaceholders_empty() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""""));
	}
	
	@Test
	void countArgumentPlaceholders_noPlaceholders() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello World!""));
	}
	
	@Test
	void countArgumentPlaceholders_onePlaceholder() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_twoPlaceholders() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {}! {}""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder2() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder3() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder4() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder5() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {} \\{}!""));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {
		
	@Test
	void countArgumentPlaceholders_null() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(null));
	}
	
	@Test
	void countArgumentPlaceholders_empty() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""""));
	}
	
	@Test
	void countArgumentPlaceholders_noPlaceholders() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello World!""));
	}
	
	@Test
	void countArgumentPlaceholders_onePlaceholder() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_twoPlaceholders() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {}! {}""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder2() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder3() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder4() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder5() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {} \\{}!""));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {
		
	@Test
	void countArgumentPlaceholders_null() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(null));
	}
	
	@Test
	void countArgumentPlaceholders_empty() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""""));
	}
	
	@Test
	void countArgumentPlaceholders_noPlaceholders() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello World!""));
	}
	
	@Test
	void countArgumentPlaceholders_onePlaceholder() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_twoPlaceholders() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {}! {}""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder2() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder3() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder4() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder5() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {} \\{}!""));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {
		
	@Test
	void countArgumentPlaceholders_null() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(null));
	}
	
	@Test
	void countArgumentPlaceholders_empty() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""""));
	}
	
	@Test
	void countArgumentPlaceholders_noPlaceholders() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello World!""));
	}
	
	@Test
	void countArgumentPlaceholders_onePlaceholder() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_twoPlaceholders() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {}! {}""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder2() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder3() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder4() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder5() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {} \\{}!""));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {
		
	@Test
	void countArgumentPlaceholders_null() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(null));
	}
	
	@Test
	void countArgumentPlaceholders_empty() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""""));
	}
	
	@Test
	void countArgumentPlaceholders_noPlaceholders() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello World!""));
	}
	
	@Test
	void countArgumentPlaceholders_onePlaceholder() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_twoPlaceholders() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {}! {}""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder2() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder3() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder4() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder5() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {} \\{}!""));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {
		
	@Test
	void countArgumentPlaceholders_null() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(null));
	}
	
	@Test
	void countArgumentPlaceholders_empty() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""""));
	}
	
	@Test
	void countArgumentPlaceholders_noPlaceholders() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello World!""));
	}
	
	@Test
	void countArgumentPlaceholders_onePlaceholder() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_twoPlaceholders() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {}! {}""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(""Hello \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder2() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder3() {
		assertEquals(1, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder4() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello {} \\{} {}!""));
	}
	
	@Test
	void countArgumentPlaceholders_escapedPlaceholder5() {
		assertEquals(2, MessageFormatter.countArgumentPlaceholders(""Hello \\{} {} \\{}!""));
	}
}

// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatterTest {
		
	@Test
	void countArgumentPlaceholders_null() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders(null));
	}
	
	@Test
	void countArgumentPlaceholders_empty() {
		assertEquals(0, MessageFormatter.countArgumentPlaceholders"
cmpl-6x60HtQvThUQUW8mrJG8NlVUf3KsC,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter2.java,150.59348034858704,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);
}
","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatterTest {","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatterTest {

	@Test
	void evaluateArguments_noPlaceholders() {
		String messagePattern = ""This is a test."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", ""baz"" };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(0, result.getArguments().length);
	}
	
	@Test
	void evaluateArguments_onePlaceholder() {
		String messagePattern = ""This is a test: {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", ""baz"" };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(1, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
	}
	
	@Test
	void evaluateArguments_twoPlaceholders() {
		String messagePattern = ""This is a test: {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", ""baz"" };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(2, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
	}
	
	@Test
	void evaluateArguments_threePlaceholders() {
		String messagePattern = ""This is a test: {}, {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", ""baz"" };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(3, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
		assertEquals(""baz"", result.getArguments()[2]);
	}
	
	@Test
	void evaluateArguments_fourPlaceholders() {
		String messagePattern = ""This is a test: {}, {}, {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", ""baz"" };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(3, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
		assertEquals(""baz"", result.getArguments()[2]);
	}
	
	@Test
	void evaluateArguments_onePlaceholder_lastArgumentIsThrowable() {
		String messagePattern = ""This is a test: {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", new Throwable(""Test"") };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(1, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
	}
	
	@Test
	void evaluateArguments_twoPlaceholders_lastArgumentIsThrowable() {
		String messagePattern = ""This is a test: {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", new Throwable(""Test"") };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(2, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
	}
	
	@Test
	void evaluateArguments_threePlaceholders_lastArgumentIsThrowable() {
		String messagePattern = ""This is a test: {}, {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", new Throwable(""Test"") };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(3, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
		assertEquals(""java.lang.Throwable: Test"", result.getArguments()[2]);
	}
	
	@Test
	void evaluateArguments_fourPlaceholders_lastArgumentIsThrowable() {
		String messagePattern = ""This is a test: {}, {}, {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", new Throwable(""Test"") };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(3, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
		assertEquals(""java.lang.Throwable: Test"", result.getArguments()[2]);
	}
	
	@Test
	void evaluateArguments_threePlaceholders_lastArgumentIsThrowable_lastPlaceholderIsThrowable() {
		String messagePattern = ""This is a test: {}, {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", new Throwable(""Test"") };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(3, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
		assertEquals(""java.lang.Throwable: Test"", result.getArguments()[2]);
	}
	
	@Test
	void evaluateArguments_fourPlaceholders_lastArgumentIsThrowable_lastPlaceholderIsThrowable() {
		String messagePattern = ""This is a test: {}, {}, {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", new Throwable(""Test"") };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(3, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
		assertEquals(""java.lang.Throwable: Test"", result.getArguments()[2]);
	}
	
	@Test
	void evaluateArguments_threePlaceholders_lastArgumentIsThrowable_lastPlaceholderIsThrowable_throwableIsReturned() {
		String messagePattern = ""This is a test: {}, {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", new Throwable(""Test"") };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNotNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(2, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
	}
	
	@Test
	void evaluateArguments_fourPlaceholders_lastArgumentIsThrowable_lastPlaceholderIsThrowable_throwableIsReturned() {
		String messagePattern = ""This is a test: {}, {}, {}, {}."";
		Object[] arguments = new Object[] { ""foo"", ""bar"", new Throwable(""Test"") };
		MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
		assertNotNull(result);
		assertNotNull(result.getThrowable());
		assertNotNull(result.getArguments());
		assertEquals(2, result.getArguments().length);
		assertEquals(""foo"", result.getArguments()[0]);
		assertEquals(""bar"", result.getArguments()[1]);
	}
}

// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {
        if (messagePattern == null) {
            return new ArgumentResult(null, null);
        }
        if (arguments == null) {
            return new ArgumentResult(null, null);
        }
        int argumentCount = arguments.length;
        int placeholderCount = countPlaceholders(messagePattern);
        if (argumentCount == placeholderCount) {
            return new ArgumentResult(null, convertArguments(arguments));
        }
        if (argumentCount > placeholderCount) {
            Object lastArgument = arguments[argumentCount - 1];
            if (lastArgument instanceof Throwable) {
                if (argumentCount == placeholderCount + 1) {
                    return new ArgumentResult((Throwable) lastArgument, convertArguments(arguments, 0, argumentCount - 1));
                }
                if (argumentCount == placeholderCount + 2) {
                    Object secondLastArgument = arguments[argumentCount - 2];
                    if (secondLastArgument instanceof Throwable) {
                        return new ArgumentResult((Throwable) secondLastArgument, convertArguments(arguments, 0, argumentCount - 2));
                    }
                }
            }
        }
        return new ArgumentResult(null, convertArguments(arguments));
    }

    private static String[] convertArguments(Object[] arguments) {
        return convertArguments(arguments, 0, arguments.length);
    }

    private static String[] convertArguments(Object[] arguments, int start, int end) {
        String[] result = new String[end - start];
        for (int i = start; i < end; i++) {
            result[i - start] = convertArgument(arguments[i]);
        }
        return result;
    }

    private static String convertArgument(Object argument) {
        if (argument == null) {
            return ""null"";
        }
        if (argument instanceof String) {
            return (String) argument;
        }
        if (argument instanceof Date) {
            return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSS"").format((Date) argument);
        }
        if (argument instanceof Collection) {
            return convertCollection((Collection) argument);
        }
        if (argument instanceof Map) {
            return convertMap((Map) argument);
        }
        if (argument instanceof Object[]) {
            return convertArray((Object[]) argument);
        }
        return argument.toString();
    }

    private static String convertArray(Object[] argument) {
        StringBuilder result = new StringBuilder();
        result.append(""["");
        for (int i = 0; i < argument.length; i++) {
            if (i > 0) {
                result.append("", "");
            }
            result.append(convertArgument(argument[i]));
        }
        result.append(""]"");
        return result.toString();
    }

    private static String convertMap(Map argument) {
        StringBuilder result = new StringBuilder();
        result.append(""{"");
        Set<Map.Entry> entries = new HashSet<Map.Entry>(argument.entrySet());
        for (Map.Entry entry : entries) {
            if (result.length() > 1) {
                result.append("", "");
            }
            result.append(convertArgument(entry.getKey()));
            result.append(""="");
            result.append(convertArgument(entry.getValue()));
        }
        result.append(""}"");
        return result.toString();
    }

    private static String convertCollection(Collection argument) {
        StringBuilder result = new StringBuilder();
        result.append(""["");
        for (Object o : argument) {
            if (result.length() > 1) {
                result.append("", "");
            }
            result.append(convertArgument(o));
        }
        result.append(""]"");
        return result.toString();
    }

    private static int countPlaceholders(String messagePattern) {
        int result = 0;
        int index = 0;
        while (index < messagePattern.length()) {
            index = messagePattern.indexOf('{', index);
            if (index == -1) {
                break;
            }
            index++;
            if (index < messagePattern.length() && messagePattern.charAt(index) == '{') {"
cmpl-6x62huTOEf8x6c4OgGiQ7qGseJo7q,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter3.java,133.13821649551392,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);
}
","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatterTest {","// MessageFormatterTest.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatterTest {
@Test
		void identityToString_null() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
		}

		@Test
		void identityToString_string() {
				assertEquals(""\""foo\"""", MessageFormatter.identityToString(""foo""));
		}

		@Test
		void identityToString_string_empty() {
				assertEquals(""\""\"""", MessageFormatter.identityToString(""""));
		}

		@Test
		void identityToString_string_null() {
				assertEquals(""\""null\"""", MessageFormatter.identityToString(""null""));
		}

		@Test
		void identityToString_string_quotes() {
				assertEquals(""\""\\\""foo\\\""\"""", MessageFormatter.identityToString(""\""foo\""""));
		}

		@Test
		void identityToString_string_backslash() {
				assertEquals(""\""\\\\foo\"""", MessageFormatter.identityToString(""\\foo""));
		}

		@Test
		void identityToString_string_newline() {
				assertEquals(""\""\\nfoo\"""", MessageFormatter.identityToString(""\nfoo""));
		}

		@Test
		void identityToString_string_tab() {
				assertEquals(""\""\\tfoo\"""", MessageFormatter.identityToString(""\tfoo""));
		}

		@Test
		void identityToString_string_carriageReturn() {
				assertEquals(""\""\\rfoo\"""", MessageFormatter.identityToString(""\rfoo""));
		}

		@Test
		void identityToString_string_formFeed() {
				assertEquals(""\""\\ffoo\"""", MessageFormatter.identityToString(""\ffoo""));
		}

		@Test
		void identityToString_string_backspace() {
				assertEquals(""\""\\bfoo\"""", MessageFormatter.identityToString(""\bfoo""));
		}

		@Test
		void identityToString_string_unicode() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\u00e4\u00f6\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid2() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid3() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid4() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid5() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid6() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid7() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid8() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid9() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid10() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid11() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid12() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid13() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid14() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid15() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid16() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid17() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid18() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid19() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid20() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid21() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid22() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid23() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid24() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid25() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid26() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid27() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid28() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid29() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid30() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid31() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid32() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid33() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid34() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid35() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid36() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid37() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid38() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid39() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid40() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00f6\\u00fc""));
		}

		@Test
		void identityToString_string_unicode_escaped_invalid41() {
				assertEquals(""\""\\u00e4\\u00f6\\u00fc\"""", MessageFormatter.identityToString(""\\u00e4\\u00"
cmpl-6x65QMZlhreySmLnbNCWdSaz1kL0U,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/logback/classic/NDC.java,168.94641780853271,length,"// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}
","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {

	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
		
	@Test
	void testGetContextStack() {
		NDC.push(""Test"");
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Test"", contextStack[0].getMessage());
		NDC.pop();
	}
}

// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}

// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;"
cmpl-6x67ZGaKR9n2widmciFFj1LCiGasF,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/AboutPanel.java,65.12341117858887,stop,"// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt);
}
","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {

		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is outside the scroll-area.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_OutsideScrollArea() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_EmptyScrollArea() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_ScrollAreaNotEmpty() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_ScrollAreaNotEmpty_ScrollAreaToolTipTextNotEmpty() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_ScrollAreaNotEmpty_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_ScrollAreaNotEmpty_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_ScrollAreaNotEmpty_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_ScrollAreaNotEmpty_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_ScrollAreaNotEmpty_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_ScrollAreaNotEmpty_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
		/**
		* Test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
		* It tests if the method returns <code>null</code> if the point of the <code>MouseEvent</code>
		* is inside the scroll-area but the scroll-area is empty.
		*/
		@Test
		public void testGetToolTipText_MouseEvent_InsideScrollArea_ScrollAreaNotEmpty_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull_ScrollAreaToolTipTextNotEmpty_ScrollAreaToolTipTextNotNull() {
				AboutPanel aboutPanel = new AboutPanel();
				MouseEvent mouseEvent = new MouseEvent(aboutPanel, 0, 0, 0, 0, 0, 0, false);
				String toolTipText = aboutPanel.getToolTipText(mouseEvent);
				assertNull(toolTipText);
		}
		
}"
cmpl-6x68c5LEMTCY1cTfsdRZUIS77WESZ,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/ApplicationPreferences.java,128.55968046188354,length,"// ApplicationPreferences.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;

public class ApplicationPreferences {

    /**
     * Quick & dirty MD5 checksum function.
     * Returns null in case of error.
     *
     * @param input the input
     * @return the checksum
     */
    public static byte[] getMD5(InputStream input);
}
","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {

	/**
	 * Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
	 * It tests the case when the input stream is null.
	 */
	@Test
	void testGetMD5_NullInputStream() {
		InputStream input = null;
		byte[] result = ApplicationPreferences.getMD5(input);
		assertNull(result);
	}
	
	/**
	 * Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
	 * It tests the case when the input stream is empty.
	 */
	@Test
	void testGetMD5_EmptyInputStream() {
		InputStream input = new ByteArrayInputStream(new byte[0]);
		byte[] result = ApplicationPreferences.getMD5(input);
		assertNotNull(result);
		assertEquals(16, result.length);
		assertEquals(0, result[0]);
		assertEquals(0, result[1]);
		assertEquals(0, result[2]);
		assertEquals(0, result[3]);
		assertEquals(0, result[4]);
		assertEquals(0, result[5]);
		assertEquals(0, result[6]);
		assertEquals(0, result[7]);
		assertEquals(0, result[8]);
		assertEquals(0, result[9]);
		assertEquals(0, result[10]);
		assertEquals(0, result[11]);
		assertEquals(0, result[12]);
		assertEquals(0, result[13]);
		assertEquals(0, result[14]);
		assertEquals(0, result[15]);
	}
	
	/**
	 * Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
	 * It tests the case when the input stream is not empty.
	 */
	@Test
	void testGetMD5_NotEmptyInputStream() {
		InputStream input = new ByteArrayInputStream(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16});
		byte[] result = ApplicationPreferences.getMD5(input);
		assertNotNull(result);
		assertEquals(16, result.length);
		assertEquals(0, result[0]);
		assertEquals(0, result[1]);
		assertEquals(0, result[2]);
		assertEquals(0, result[3]);
		assertEquals(0, result[4]);
		assertEquals(0, result[5]);
		assertEquals(0, result[6]);
		assertEquals(0, result[7]);
		assertEquals(0, result[8]);
		assertEquals(0, result[9]);
		assertEquals(0, result[10]);
		assertEquals(0, result[11]);
		assertEquals(0, result[12]);
		assertEquals(0, result[13]);
		assertEquals(0, result[14]);
		assertEquals(0, result[15]);
	}
	
	/**
	 * Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
	 * It tests the case when the input stream is not empty.
	 */
	@Test
	void testGetMD5_NotEmptyInputStream2() {
		InputStream input = new ByteArrayInputStream(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32});
		byte[] result = ApplicationPreferences.getMD5(input);
		assertNotNull(result);
		assertEquals(16, result.length);
		assertEquals(0, result[0]);
		assertEquals(0, result[1]);
		assertEquals(0, result[2]);
		assertEquals(0, result[3]);
		assertEquals(0, result[4]);
		assertEquals(0, result[5]);
		assertEquals(0, result[6]);
		assertEquals(0, result[7]);
		assertEquals(0, result[8]);
		assertEquals(0, result[9]);
		assertEquals(0, result[10]);
		assertEquals(0, result[11]);
		assertEquals(0, result[12]);
		assertEquals(0, result[13]);
		assertEquals(0, result[14]);
		assertEquals(0, result[15]);
	}
	
	/**
	 * Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
	 * It tests the case when the input stream is not empty.
	 */
	@Test
	void testGetMD5_NotEmptyInputStream3() {
		InputStream input = new ByteArrayInputStream(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64});
		byte[] result = ApplicationPreferences.getMD5(input);
		assertNotNull(result);
		assertEquals(16, result.length);
		assertEquals(0, result[0]);
		assertEquals(0, result[1]);
		assertEquals(0, result[2]);
		assertEquals(0, result[3]);
		assertEquals(0, result[4]);
		assertEquals(0, result[5]);
		assertEquals(0, result[6]);
		assertEquals(0, result[7]);
		assertEquals(0, result[8]);
		assertEquals(0, result[9]);
		assertEquals(0, result[10]);
		assertEquals(0, result[11]);
		assertEquals(0, result[12]);
		assertEquals(0, result[13]);
		assertEquals(0, result[14]);
		assertEquals(0, result[15]);
	}
	
	/**
	 * Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
	 * It tests the case when the input stream is not empty.
	 */
	@Test
	void testGetMD5_NotEmptyInputStream4() {
		InputStream input = new ByteArrayInputStream(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128});
		byte[] result = ApplicationPreferences.getMD5(input);
		assertNotNull(result);
		assertEquals(16, result.length);
		assertEquals(0, result[0]);
		assertEquals(0, result[1]);
		assertEquals(0, result[2]);
		assertEquals(0, result[3]);
		assertEquals(0, result[4]);
		assertEquals(0, result[5]);
		assertEquals(0, result[6]);
		assertEquals(0, result[7]);
		assertEquals(0, result[8]);
		assertEquals(0, result[9]);
		assertEquals(0, result[10]);
		assertEquals(0, result[11]);
		assertEquals(0, result[12]);
		assertEquals(0, result[13]);
		assertEquals(0, result[14]);
		assertEquals(0, result[15]);
	}
	
	/**
	 * Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
	 * It tests the case when the input stream is not empty.
	 */
	@Test
	void testGetMD5_NotEmptyInputStream5() {
		InputStream input = new ByteArrayInputStream(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256});
		byte[] result = ApplicationPreferences.getMD5(input);
		assertNotNull(result);
		assertEquals(16, result.length);
		assertEquals(0, result[0]);
		assertEquals(0, result[1]);
		assertEquals(0, result[2]);
		assertEquals(0, result[3]);
		assertEquals(0, result[4]);
		assertEquals(0, result[5]);
		assertEquals(0, result[6]);
		assertEquals(0, result[7]);
		assertEquals(0, result[8]);
		assertEquals(0, result[9]);
		assertEquals(0, result[10]);
		assertEquals(0, result[11]);
		assertEquals(0, result[12]);
		assertEquals(0, result[13]);
		assertEquals(0, result[14]);
		assertEquals(0, result[15]);
	}
	
	/**
	 * Test case for {@link ApplicationPreferences#getMD5(InputStream)} method.
	 * It tests the case when the input stream is not empty.
	 */
	@Test
	void testGetMD5_NotEmptyInputStream6() {
		InputStream input = new ByteArrayInputStream(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421"
cmpl-6x6Ah4pQzW3DxrFSN71iXo5rDR2uO,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/callables/IndexingCallable.java,171.2659592628479,length,"// IndexingCallable.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

/**
 * Should only be executed on inactive files.
 */
public class IndexingCallable extends AbstractProgressingCallable<Long> {

    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    public Long call() throws Exception;
}
","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains ten unit test cases for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains ten unit test cases for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {

		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is null.
		* Expected result: {@link NullPointerException}.
		*/
		@Test
		public void testCall_fileIsNull() throws Exception {
				// GIVEN
				File file = null;
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(NullPointerException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but does not exist.
		* Expected result: {@link FileNotFoundException}.
		*/
		@Test
		public void testCall_fileDoesNotExist() throws Exception {
				// GIVEN
				File file = new File(""test.log"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(FileNotFoundException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is a directory.
		* Expected result: {@link FileNotFoundException}.
		*/
		@Test
		public void testCall_fileIsDirectory() throws Exception {
				// GIVEN
				File file = new File(""."");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(FileNotFoundException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is not a file.
		* Expected result: {@link FileNotFoundException}.
		*/
		@Test
		public void testCall_fileIsNotFile() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(FileNotFoundException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is not readable.
		* Expected result: {@link FileNotFoundException}.
		*/
		@Test
		public void testCall_fileIsNotReadable() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(FileNotFoundException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is not writable.
		* Expected result: {@link FileNotFoundException}.
		*/
		@Test
		public void testCall_fileIsNotWritable() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(FileNotFoundException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is not a file buffer.
		* Expected result: {@link IOException}.
		*/
		@Test
		public void testCall_fileIsNotFileBuffer() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(IOException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is a file buffer, but is not inactive.
		* Expected result: {@link IOException}.
		*/
		@Test
		public void testCall_fileIsNotInactive() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(IOException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is a file buffer, but is inactive, but is not readable.
		* Expected result: {@link IOException}.
		*/
		@Test
		public void testCall_fileIsNotReadable2() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(IOException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is a file buffer, but is inactive, but is not writable.
		* Expected result: {@link IOException}.
		*/
		@Test
		public void testCall_fileIsNotWritable2() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(IOException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is a file buffer, but is inactive, but is not readable, but is not writable.
		* Expected result: {@link IOException}.
		*/
		@Test
		public void testCall_fileIsNotReadableAndNotWritable() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(IOException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is a file buffer, but is inactive, but is readable, but is not writable.
		* Expected result: {@link IOException}.
		*/
		@Test
		public void testCall_fileIsReadableAndNotWritable() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(IOException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is a file buffer, but is inactive, but is not readable, but is writable.
		* Expected result: {@link IOException}.
		*/
		@Test
		public void testCall_fileIsNotReadableAndWritable() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(IOException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
		
		/**
		* Test case for {@link IndexingCallable#call()} method.
		* Test data: file is not null, but is a file buffer, but is inactive, but is readable, but is writable.
		* Expected result: {@link IOException}.
		*/
		@Test
		public void testCall_fileIsReadableAndWritable() throws Exception {
				// GIVEN
				File file = new File(""/dev/null"");
				IndexingCallable indexingCallable = new IndexingCallable(file);
				// WHEN
				Throwable thrown = assertThrows(IOException.class, indexingCallable::call);
				// THEN
				assertNotNull(thrown);
		}
}

// IndexingTask.java
package de.huxhorn.lilith.swing.taskmanager;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import javax.swing.SwingWorker;

/**
 *
 */
public class IndexingTask
		extends SwingWorker<Long, Void>
{
		private final Logger logger = LoggerFactory.getLogger(IndexingTask.class);
		private final File file;
		private final Future<Long> future;

		public IndexingTask(File file, Future<Long> future)
		{
				this.file = file;
				this.future = future;
		}

		public File getFile()
		{
				return file;
		}

		public Future<Long> getFuture()
		{
				return future;
		}

		/**
		 * Computes a result, or throws an exception if unable to do so.
		 *
		 * @return computed result
		 * @throws Exception if unable to compute a result
		 */
		@Override
		protected Long doInBackground()
				throws Exception
		{
				try
				{
						return future.get(1, TimeUnit.SECONDS);
				}
				catch (TimeoutException ex)
				{
						logger.debug(""Timeout while waiting for indexing of {}."", file);
				}
				catch (InterruptedException ex)
				{
						logger.debug(""Interrupted while waiting for indexing of {}."", file);
				}
				catch (ExecutionException ex)
				{
						logger.error(""Error while indexing {}!"", file, ex);
				}
				return null;
		}
}

// IndexingTaskTest.java
package de.huxhorn.lilith.swing.taskmanager;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import javax.swing.SwingWorker;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingTask}.
* It contains ten unit test cases for the {@link IndexingTask#doInBackground()} method.
*/
class IndexingTaskTest {
		
		/**
		* Test case for {@link IndexingTask#doInBackground()} method.
		* Test data: file is null.
		* Expected result: {@link NullPointerException}.
		*/
		@Test
		public void testDoInBackground_fileIsNull() throws Exception {
"
cmpl-6x6DSjkg2HBAuwEpZilpMqoDv1ErK,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/preferences/GenericSortedListModel.java,9.690810680389404,,"// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index);
}
","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {

	@Test
	public void testGetElementAt() {
		List<String> list = new ArrayList<String>();
		list.add(""a"");
		list.add(""b"");
		list.add(""c"");
		list.add(""d"");
		list.add(""e"");
		list.add(""f"");
		list.add(""g"");
		list.add(""h"");
		list.add(""i"");
		list.add(""j"");
		
		GenericSortedListModel<String> model = new GenericSortedListModel<String>(list);
		
		assertEquals(""a"", model.getElementAt(0));
		assertEquals(""b"", model.getElementAt(1));
		assertEquals(""c"", model.getElementAt(2));
		assertEquals(""d"", model.getElementAt(3));
		assertEquals(""e"", model.getElementAt(4));
		assertEquals(""f"", model.getElementAt(5));
		assertEquals(""g"", model.getElementAt(6));
		assertEquals(""h"", model.getElementAt(7));
		assertEquals(""i"", model.getElementAt(8));
		assertEquals(""j"", model.getElementAt(9));
	}
}"
cmpl-6x6EVoT8f1rF2c6dzUTrOxtupZDiR,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel0.java,87.26784682273865,stop,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);
}
","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModelTest {","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModelTest {

	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a null value.
	 */
	@Test
	public void testIsColumnVisibleNull() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		assertFalse(model.isColumnVisible(null));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is not in the model.
	 */
	@Test
	public void testIsColumnVisibleNotInModel() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		assertFalse(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model but not visible.
	 */
	@Test
	public void testIsColumnVisibleInModelNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		assertFalse(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible.
	 */
	@Test
	public void testIsColumnVisibleInModelVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 0);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirst() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the last column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotLast() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, model.getColumnCount()-1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast2() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, model.getColumnCount()-1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast3() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast4() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, model.getColumnCount()-1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast5() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast6() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, model.getColumnCount()-1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast7() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast8() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, model.getColumnCount()-1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast9() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, 1);
		assertTrue(model.isColumnVisible(column));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}
	 * with a column that is in the model and visible but not the first column.
	 */
	@Test
	public void testIsColumnVisibleInModelVisibleNotFirstNotLast10() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		model.addColumn(column);
		model.moveColumn(0, model.getColumnCount()-1);
		assertTrue(model.isColumnVisible(column));
	}
}"
cmpl-6x6FvBehLOpgaFJ4jPzjyrOTbWYxY,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel1.java,120.46903133392334,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see #getColumns
     */
    public int getColumnCount(boolean onlyVisible);
}
","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModelTest {","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModelTest {

	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to true.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_true() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		assertEquals(1, model.getColumnCount(true));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to false.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_false() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		assertEquals(1, model.getColumnCount(false));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to true and a column that is not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_true_notVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(false);
		model.addColumn(column);
		assertEquals(0, model.getColumnCount(true));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to false and a column that is not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_false_notVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(false);
		model.addColumn(column);
		assertEquals(1, model.getColumnCount(false));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to true and two columns, one of them is not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_true_twoColumns_oneNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(false);
		model.addColumn(column2);
		assertEquals(1, model.getColumnCount(true));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to false and two columns, one of them is not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_false_twoColumns_oneNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(false);
		model.addColumn(column2);
		assertEquals(2, model.getColumnCount(false));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to true and two columns, both of them are not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_true_twoColumns_bothNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(false);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(false);
		model.addColumn(column2);
		assertEquals(0, model.getColumnCount(true));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to false and two columns, both of them are not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_false_twoColumns_bothNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(false);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(false);
		model.addColumn(column2);
		assertEquals(2, model.getColumnCount(false));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to true and two columns, both of them are visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_true_twoColumns_bothVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(true);
		model.addColumn(column2);
		assertEquals(2, model.getColumnCount(true));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to false and two columns, both of them are visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_false_twoColumns_bothVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(true);
		model.addColumn(column2);
		assertEquals(2, model.getColumnCount(false));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to true and three columns, one of them is not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_true_threeColumns_oneNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(true);
		model.addColumn(column2);
		TableColumn column3 = new TableColumn();
		column3.setIdentifier(""column3"");
		column3.setVisible(false);
		model.addColumn(column3);
		assertEquals(2, model.getColumnCount(true));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to false and three columns, one of them is not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_false_threeColumns_oneNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(true);
		model.addColumn(column2);
		TableColumn column3 = new TableColumn();
		column3.setIdentifier(""column3"");
		column3.setVisible(false);
		model.addColumn(column3);
		assertEquals(3, model.getColumnCount(false));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to true and three columns, two of them are not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_true_threeColumns_twoNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(false);
		model.addColumn(column2);
		TableColumn column3 = new TableColumn();
		column3.setIdentifier(""column3"");
		column3.setVisible(false);
		model.addColumn(column3);
		assertEquals(1, model.getColumnCount(true));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to false and three columns, two of them are not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_false_threeColumns_twoNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(false);
		model.addColumn(column2);
		TableColumn column3 = new TableColumn();
		column3.setIdentifier(""column3"");
		column3.setVisible(false);
		model.addColumn(column3);
		assertEquals(3, model.getColumnCount(false));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to true and three columns, all of them are not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_true_threeColumns_allNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(false);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(false);
		model.addColumn(column2);
		TableColumn column3 = new TableColumn();
		column3.setIdentifier(""column3"");
		column3.setVisible(false);
		model.addColumn(column3);
		assertEquals(0, model.getColumnCount(true));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to false and three columns, all of them are not visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_false_threeColumns_allNotVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(false);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(false);
		model.addColumn(column2);
		TableColumn column3 = new TableColumn();
		column3.setIdentifier(""column3"");
		column3.setVisible(false);
		model.addColumn(column3);
		assertEquals(3, model.getColumnCount(false));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to true and three columns, all of them are visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_true_threeColumns_allVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(true);
		model.addColumn(column2);
		TableColumn column3 = new TableColumn();
		column3.setIdentifier(""column3"");
		column3.setVisible(true);
		model.addColumn(column3);
		assertEquals(3, model.getColumnCount(true));
	}
	
	/**
	 * Test case for {@link PersistentTableColumnModel#getColumnCount(boolean)}
	 * with onlyVisible set to false and three columns, all of them are visible.
	 */
	@Test
	public void testGetColumnCount_onlyVisible_false_threeColumns_allVisible() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		column.setVisible(true);
		model.addColumn(column);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		column2.setVisible(true);
		model.addColumn(column2);
		TableColumn column3 = new TableColumn();
		column3.setIdentifier(""column3"");
		column3.setVisible(true);
		model.addColumn(column3);
		assertEquals(3, model.getColumnCount(false));
	}
}

// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
"
cmpl-6x6Ih4psFyNsAzGAL7C5boLGgaiTu,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel2.java,168.8947491645813,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);
}
","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModelTest {","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModelTest {

	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>true</code>.
	* The test case is successful if the method returns an <code>Enumeration</code> of all the visible columns in the model.
	*/
	@Test
	public void testGetColumns_onlyVisible_true() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn(0);
		TableColumn column2 = new TableColumn(1);
		TableColumn column3 = new TableColumn(2);
		TableColumn column4 = new TableColumn(3);
		TableColumn column5 = new TableColumn(4);
		TableColumn column6 = new TableColumn(5);
		TableColumn column7 = new TableColumn(6);
		TableColumn column8 = new TableColumn(7);
		TableColumn column9 = new TableColumn(8);
		TableColumn column10 = new TableColumn(9);
		model.addColumn(column1);
		model.addColumn(column2);
		model.addColumn(column3);
		model.addColumn(column4);
		model.addColumn(column5);
		model.addColumn(column6);
		model.addColumn(column7);
		model.addColumn(column8);
		model.addColumn(column9);
		model.addColumn(column10);
		column1.setMinWidth(0);
		column1.setMaxWidth(0);
		column2.setMinWidth(0);
		column2.setMaxWidth(0);
		column3.setMinWidth(0);
		column3.setMaxWidth(0);
		column4.setMinWidth(0);
		column4.setMaxWidth(0);
		column5.setMinWidth(0);
		column5.setMaxWidth(0);
		column6.setMinWidth(0);
		column6.setMaxWidth(0);
		column7.setMinWidth(0);
		column7.setMaxWidth(0);
		column8.setMinWidth(0);
		column8.setMaxWidth(0);
		column9.setMinWidth(0);
		column9.setMaxWidth(0);
		column10.setMinWidth(0);
		column10.setMaxWidth(0);
		List<TableColumn> expected = new ArrayList<TableColumn>();
		expected.add(column1);
		expected.add(column2);
		expected.add(column3);
		expected.add(column4);
		expected.add(column5);
		expected.add(column6);
		expected.add(column7);
		expected.add(column8);
		expected.add(column9);
		expected.add(column10);
		Iterator<TableColumn> actual = model.getColumns(true);
		assertEquals(expected.size(), count(actual));
		for (TableColumn column : expected) {
			assertTrue(actual.hasNext());
			assertEquals(column, actual.next());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>false</code>.
	* The test case is successful if the method returns an <code>Enumeration</code> of all the columns in the model.
	*/
	@Test
	public void testGetColumns_onlyVisible_false() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn(0);
		TableColumn column2 = new TableColumn(1);
		TableColumn column3 = new TableColumn(2);
		TableColumn column4 = new TableColumn(3);
		TableColumn column5 = new TableColumn(4);
		TableColumn column6 = new TableColumn(5);
		TableColumn column7 = new TableColumn(6);
		TableColumn column8 = new TableColumn(7);
		TableColumn column9 = new TableColumn(8);
		TableColumn column10 = new TableColumn(9);
		model.addColumn(column1);
		model.addColumn(column2);
		model.addColumn(column3);
		model.addColumn(column4);
		model.addColumn(column5);
		model.addColumn(column6);
		model.addColumn(column7);
		model.addColumn(column8);
		model.addColumn(column9);
		model.addColumn(column10);
		column1.setMinWidth(0);
		column1.setMaxWidth(0);
		column2.setMinWidth(0);
		column2.setMaxWidth(0);
		column3.setMinWidth(0);
		column3.setMaxWidth(0);
		column4.setMinWidth(0);
		column4.setMaxWidth(0);
		column5.setMinWidth(0);
		column5.setMaxWidth(0);
		column6.setMinWidth(0);
		column6.setMaxWidth(0);
		column7.setMinWidth(0);
		column7.setMaxWidth(0);
		column8.setMinWidth(0);
		column8.setMaxWidth(0);
		column9.setMinWidth(0);
		column9.setMaxWidth(0);
		column10.setMinWidth(0);
		column10.setMaxWidth(0);
		List<TableColumn> expected = new ArrayList<TableColumn>();
		expected.add(column1);
		expected.add(column2);
		expected.add(column3);
		expected.add(column4);
		expected.add(column5);
		expected.add(column6);
		expected.add(column7);
		expected.add(column8);
		expected.add(column9);
		expected.add(column10);
		Iterator<TableColumn> actual = model.getColumns(false);
		assertEquals(expected.size(), count(actual));
		for (TableColumn column : expected) {
			assertTrue(actual.hasNext());
			assertEquals(column, actual.next());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>true</code> and the model contains no columns.
	* The test case is successful if the method returns an <code>Enumeration</code> of all the visible columns in the model.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_emptyModel() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		List<TableColumn> expected = new ArrayList<TableColumn>();
		Iterator<TableColumn> actual = model.getColumns(true);
		assertEquals(expected.size(), count(actual));
		for (TableColumn column : expected) {
			assertTrue(actual.hasNext());
			assertEquals(column, actual.next());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>false</code> and the model contains no columns.
	* The test case is successful if the method returns an <code>Enumeration</code> of all the columns in the model.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_emptyModel() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		List<TableColumn> expected = new ArrayList<TableColumn>();
		Iterator<TableColumn> actual = model.getColumns(false);
		assertEquals(expected.size(), count(actual));
		for (TableColumn column : expected) {
			assertTrue(actual.hasNext());
			assertEquals(column, actual.next());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>true</code> and the model contains only visible columns.
	* The test case is successful if the method returns an <code>Enumeration</code> of all the visible columns in the model.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_onlyVisibleColumns() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn(0);
		TableColumn column2 = new TableColumn(1);
		TableColumn column3 = new TableColumn(2);
		TableColumn column4 = new TableColumn(3);
		TableColumn column5 = new TableColumn(4);
		TableColumn column6 = new TableColumn(5);
		TableColumn column7 = new TableColumn(6);
		TableColumn column8 = new TableColumn(7);
		TableColumn column9 = new TableColumn(8);
		TableColumn column10 = new TableColumn(9);
		model.addColumn(column1);
		model.addColumn(column2);
		model.addColumn(column3);
		model.addColumn(column4);
		model.addColumn(column5);
		model.addColumn(column6);
		model.addColumn(column7);
		model.addColumn(column8);
		model.addColumn(column9);
		model.addColumn(column10);
		List<TableColumn> expected = new ArrayList<TableColumn>();
		expected.add(column1);
		expected.add(column2);
		expected.add(column3);
		expected.add(column4);
		expected.add(column5);
		expected.add(column6);
		expected.add(column7);
		expected.add(column8);
		expected.add(column9);
		expected.add(column10);
		Iterator<TableColumn> actual = model.getColumns(true);
		assertEquals(expected.size(), count(actual));
		for (TableColumn column : expected) {
			assertTrue(actual.hasNext());
			assertEquals(column, actual.next());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>false</code> and the model contains only visible columns.
	* The test case is successful if the method returns an <code>Enumeration</code> of all the columns in the model.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_onlyVisibleColumns() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn(0);
		TableColumn column2 = new TableColumn(1);
		TableColumn column3 = new TableColumn(2);
		TableColumn column4 = new TableColumn(3);
		TableColumn column5 = new TableColumn(4);
		TableColumn column6 = new TableColumn(5);
		TableColumn column7 = new TableColumn(6);
		TableColumn column8 = new TableColumn(7);
		TableColumn column9 = new TableColumn(8);
		TableColumn column10 = new TableColumn(9);
		model.addColumn(column1);
		model.addColumn(column2);
		model.addColumn(column3);
		model.addColumn(column4);
		model.addColumn(column5);
		model.addColumn(column6);
		model.addColumn(column7);
		model.addColumn(column8);
		model.addColumn(column9);
		model.addColumn(column10);
		List<TableColumn> expected = new ArrayList<TableColumn>();
		expected.add(column1);
		expected.add(column2);
		expected.add(column3);
		expected.add(column4);
		expected.add(column5);
		expected.add(column6);
		expected.add(column7);
		expected.add(column8);
		expected.add(column9);
		expected.add(column10);
		Iterator<TableColumn> actual = model.getColumns(false);
		assertEquals(expected.size(), count(actual));
		for (TableColumn column : expected) {
			assertTrue(actual.hasNext());
			assertEquals(column, actual.next());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* It tests the case when the parameter <code>onlyVisible</code> is set to <code>true</code> and the model contains only invisible columns.
	* The test case is successful if the method returns an <code>Enumeration</code> of all the visible columns in the model.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_onlyInvisibleColumns() {
		PersistentTableColumnModel model = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn(0);
		TableColumn column2 = new TableColumn(1);
		TableColumn column3 = new TableColumn(2);
		TableColumn column4 = new TableColumn(3);
		TableColumn column5 = new TableColumn(4);
		TableColumn column6 = new TableColumn(5);
		TableColumn column7 = new TableColumn(6);
		TableColumn column8 = new TableColumn(7);
		TableColumn column9 = new TableColumn(8);
		TableColumn column10 = new TableColumn(9);
		model.addColumn(column1);
		model.addColumn(column2);
		model.addColumn(column3);
		model.addColumn(column4);
		model.addColumn(column5);
		model.addColumn(column6);
		model.addColumn(column7);
		model.addColumn(column8);
		model.addColumn(column9);
		model.addColumn(column10);
		column1.setMinWidth(0);
		column1.setMaxWidth(0);
		column2.setMinWidth(0);
		column2.setMaxWidth(0);
		column3.setMinWidth(0);
		column3.setMaxWidth(0);
		column4.setMinWidth(0);
		column4.setMaxWidth(0);
		column5.setMinWidth(0);
		column5.setMaxWidth(0);
		column6.setMinWidth(0);
		column6.setMaxWidth(0);
		column7.setMinWidth(0);
		column7.setMaxWidth(0);
		column8.setMinWidth(0);
		column8.setMaxWidth(0);
		column9.setMinWidth(0);
		column9.setMaxWidth(0);
		column10.setMinWidth(0);
		column10.setMaxWidth(0);
		List<TableColumn> expected = new ArrayList<TableColumn>();
		Iterator<TableColumn> actual = model.getColumns(true);
		assertEquals(expected.size(), count(actual));
		for (TableColumn column : expected) {
			assertTrue(actual.hasNext());
			assertEquals(column, actual.next());
		}
"
cmpl-6x6Ka6m9R3Tx1VM0ECfyUrYsfdLK8,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel3.java,77.6712327003479,stop,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param identifier the identifier object to search for
     * @param onlyVisible if set searches only visible columns
     * @see #getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);
}
","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModelTest {","// PersistentTableColumnModelTest.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModelTest {

	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: null</li>
	* <li>onlyVisible: false</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_1() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = null;
		boolean onlyVisible = false;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier is null."", e.getMessage());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: ""test""</li>
	* <li>onlyVisible: false</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_2() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = ""test"";
		boolean onlyVisible = false;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier not found: test"", e.getMessage());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: ""test""</li>
	* <li>onlyVisible: true</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_3() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = ""test"";
		boolean onlyVisible = true;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier not found: test"", e.getMessage());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: ""test""</li>
	* <li>onlyVisible: false</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_4() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = ""test"";
		boolean onlyVisible = false;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier not found: test"", e.getMessage());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: ""test""</li>
	* <li>onlyVisible: true</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_5() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = ""test"";
		boolean onlyVisible = true;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier not found: test"", e.getMessage());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: ""test""</li>
	* <li>onlyVisible: false</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_6() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = ""test"";
		boolean onlyVisible = false;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier not found: test"", e.getMessage());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: ""test""</li>
	* <li>onlyVisible: true</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_7() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = ""test"";
		boolean onlyVisible = true;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier not found: test"", e.getMessage());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: ""test""</li>
	* <li>onlyVisible: false</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_8() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = ""test"";
		boolean onlyVisible = false;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier not found: test"", e.getMessage());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: ""test""</li>
	* <li>onlyVisible: true</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_9() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = ""test"";
		boolean onlyVisible = true;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier not found: test"", e.getMessage());
		}
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)}
	* with the following parameters:
	* <ul>
	* <li>identifier: ""test""</li>
	* <li>onlyVisible: false</li>
	* </ul>
	*
	* @throws IllegalArgumentException if <code>identifier</code>
	*                                  is <code>null</code>, or if no
	*                                  <code>TableColumn</code> has this
	*                                  <code>identifier</code>
	*/
	@Test
	public void testGetColumnIndex_10() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		Object identifier = ""test"";
		boolean onlyVisible = false;
		try {
			persistentTableColumnModel.getColumnIndex(identifier, onlyVisible);
			fail(""Expected IllegalArgumentException"");
		} catch (IllegalArgumentException e) {
			assertEquals(""Identifier not found: test"", e.getMessage());
		}
	}
}"
cmpl-6x6LqHVBl7t64dWeFPLMG8ounsavG,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder0.java,180.59176230430603,length,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);
}
","// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {","// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {

	@Test
	void testGetBorderInsets() {
		ConditionalBorder border = new ConditionalBorder();
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
		border.setTop(true);
		assertEquals(new Insets(1, 0, 0, 0), border.getBorderInsets(null));
		border.setLeft(true);
		assertEquals(new Insets(1, 1, 0, 0), border.getBorderInsets(null));
		border.setBottom(true);
		assertEquals(new Insets(1, 1, 1, 0), border.getBorderInsets(null));
		border.setRight(true);
		assertEquals(new Insets(1, 1, 1, 1), border.getBorderInsets(null));
		border.setTop(false);
		assertEquals(new Insets(0, 1, 1, 1), border.getBorderInsets(null));
		border.setLeft(false);
		assertEquals(new Insets(0, 0, 1, 1), border.getBorderInsets(null));
		border.setBottom(false);
		assertEquals(new Insets(0, 0, 0, 1), border.getBorderInsets(null));
		border.setRight(false);
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {
		
	@Test
	void testGetBorderInsets() {
		ConditionalBorder border = new ConditionalBorder();
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
		border.setTop(true);
		assertEquals(new Insets(1, 0, 0, 0), border.getBorderInsets(null));
		border.setLeft(true);
		assertEquals(new Insets(1, 1, 0, 0), border.getBorderInsets(null));
		border.setBottom(true);
		assertEquals(new Insets(1, 1, 1, 0), border.getBorderInsets(null));
		border.setRight(true);
		assertEquals(new Insets(1, 1, 1, 1), border.getBorderInsets(null));
		border.setTop(false);
		assertEquals(new Insets(0, 1, 1, 1), border.getBorderInsets(null));
		border.setLeft(false);
		assertEquals(new Insets(0, 0, 1, 1), border.getBorderInsets(null));
		border.setBottom(false);
		assertEquals(new Insets(0, 0, 0, 1), border.getBorderInsets(null));
		border.setRight(false);
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {
		
	@Test
	void testGetBorderInsets() {
		ConditionalBorder border = new ConditionalBorder();
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
		border.setTop(true);
		assertEquals(new Insets(1, 0, 0, 0), border.getBorderInsets(null));
		border.setLeft(true);
		assertEquals(new Insets(1, 1, 0, 0), border.getBorderInsets(null));
		border.setBottom(true);
		assertEquals(new Insets(1, 1, 1, 0), border.getBorderInsets(null));
		border.setRight(true);
		assertEquals(new Insets(1, 1, 1, 1), border.getBorderInsets(null));
		border.setTop(false);
		assertEquals(new Insets(0, 1, 1, 1), border.getBorderInsets(null));
		border.setLeft(false);
		assertEquals(new Insets(0, 0, 1, 1), border.getBorderInsets(null));
		border.setBottom(false);
		assertEquals(new Insets(0, 0, 0, 1), border.getBorderInsets(null));
		border.setRight(false);
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {
		
	@Test
	void testGetBorderInsets() {
		ConditionalBorder border = new ConditionalBorder();
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
		border.setTop(true);
		assertEquals(new Insets(1, 0, 0, 0), border.getBorderInsets(null));
		border.setLeft(true);
		assertEquals(new Insets(1, 1, 0, 0), border.getBorderInsets(null));
		border.setBottom(true);
		assertEquals(new Insets(1, 1, 1, 0), border.getBorderInsets(null));
		border.setRight(true);
		assertEquals(new Insets(1, 1, 1, 1), border.getBorderInsets(null));
		border.setTop(false);
		assertEquals(new Insets(0, 1, 1, 1), border.getBorderInsets(null));
		border.setLeft(false);
		assertEquals(new Insets(0, 0, 1, 1), border.getBorderInsets(null));
		border.setBottom(false);
		assertEquals(new Insets(0, 0, 0, 1), border.getBorderInsets(null));
		border.setRight(false);
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {
		
	@Test
	void testGetBorderInsets() {
		ConditionalBorder border = new ConditionalBorder();
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
		border.setTop(true);
		assertEquals(new Insets(1, 0, 0, 0), border.getBorderInsets(null));
		border.setLeft(true);
		assertEquals(new Insets(1, 1, 0, 0), border.getBorderInsets(null));
		border.setBottom(true);
		assertEquals(new Insets(1, 1, 1, 0), border.getBorderInsets(null));
		border.setRight(true);
		assertEquals(new Insets(1, 1, 1, 1), border.getBorderInsets(null));
		border.setTop(false);
		assertEquals(new Insets(0, 1, 1, 1), border.getBorderInsets(null));
		border.setLeft(false);
		assertEquals(new Insets(0, 0, 1, 1), border.getBorderInsets(null));
		border.setBottom(false);
		assertEquals(new Insets(0, 0, 0, 1), border.getBorderInsets(null));
		border.setRight(false);
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {
		
	@Test
	void testGetBorderInsets() {
		ConditionalBorder border = new ConditionalBorder();
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
		border.setTop(true);
		assertEquals(new Insets(1, 0, 0, 0), border.getBorderInsets(null));
		border.setLeft(true);
		assertEquals(new Insets(1, 1, 0, 0), border.getBorderInsets(null));
		border.setBottom(true);
		assertEquals(new Insets(1, 1, 1, 0), border.getBorderInsets(null));
		border.setRight(true);
		assertEquals(new Insets(1, 1, 1, 1), border.getBorderInsets(null));
		border.setTop(false);
		assertEquals(new Insets(0, 1, 1, 1), border.getBorderInsets(null));
		border.setLeft(false);
		assertEquals(new Insets(0, 0, 1, 1), border.getBorderInsets(null));
		border.setBottom(false);
		assertEquals(new Insets(0, 0, 0, 1), border.getBorderInsets(null));
		border.setRight(false);
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorderTest {
		
	@Test
	void testGetBorderInsets() {
		ConditionalBorder border = new ConditionalBorder();
		assertEquals(new Insets(0, 0, 0, 0), border.getBorderInsets(null));
		border.setTop(true);
		assertEquals(new Insets(1, 0, 0, 0), border.getBorderInsets(null));
		border.setLeft(true);
		assertEquals(new Insets(1, 1, 0, 0), border.getBorderInsets(null));
		border.setBottom(true);
		assertEquals(new Insets(1, 1, 1, 0), border.getBorderInsets(null));
		border.setRight(true);
		assertEquals(new Insets(1, 1, 1, 1), border.getBorderInsets(null));
		border.setTop"
cmpl-6x6OkL5LA2Evm4kKY9AdGtzv6Zk75,/EvoSuiteBenchmark/scenario3/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder1.java,100.59664702415466,length,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}
","// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {","// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {

	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {
		
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {
		
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {
		
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {
		
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {
		
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {
		
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {
		
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {
		
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}

// ConditionalBorderTest.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorderTest {
		
	/**
	* Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Test data: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	* Expected result: {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
	*/
	@Test
	public void testGetBorderInsets() {
		// TODO: implement this test case
		// Ensure that the resulting value is correct
		assertTrue(true);
	}
}

// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.rend"
