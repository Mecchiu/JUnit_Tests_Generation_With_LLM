[
{
    "id": "cmpl-6xHnA9pza2sbsdPHrcTizSikE97bK",
    "object": "text_completion",
    "created": 1679587764,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\tprivate static final Logger logger = Logger.getLogger(QSAdminAPITest.class.getName());\n\t\n\tprivate static final String HOST = \"localhost\";\n\tprivate static final int PORT = 9877;\n\tprivate static final String USERNAME = \"Admin\";\n\tprivate static final String PASSWORD = \"QsAdm1n\";\n\t\n\tprivate static final String BAD_USERNAME = \"BadAdmin\";\n\tprivate static final String BAD_PASSWORD = \"BadQsAdm1n\";\n\t\n\tprivate static final String BAD_HOST = \"badhost\";\n\tprivate static final int BAD_PORT = 9876;\n\t\n\tprivate static final String BAD_COMMAND = \"badcommand\";\n\t\n\tprivate static final String GOOD_COMMAND = \"info server\";\n\t\n\tprivate static final String GOOD_RESPONSE = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_PREFIX = \"QSAdminServer\";\n\t\n\tprivate static final String BAD_RESPONSE_PREFIX = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_SUFFIX = \"v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_SUFFIX = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_CONTAINS = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_CONTAINS = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_MATCHES = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_MATCHES = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_STARTS_WITH = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_STARTS_WITH = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_ENDS_WITH = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_ENDS_WITH = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_EQUALS = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_EQUALS = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_EQUALS_IGNORE_CASE = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_EQUALS_IGNORE_CASE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_EMPTY = \"\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_EMPTY = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_NULL = null;\n\t\n\tprivate static final String BAD_RESPONSE_IS_NULL = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_NOT_EMPTY = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_NOT_EMPTY = \"\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_NOT_NULL = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_NOT_NULL = null;\n\t\n\tprivate static final String GOOD_RESPONSE_IS_BLANK = \"\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_BLANK = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_NOT_BLANK = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_NOT_BLANK = \"\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_ALL_LOWER_CASE = \"qsadminserver v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_ALL_LOWER_CASE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_ALL_UPPER_CASE = \"QSADMINSERVER V1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_ALL_UPPER_CASE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_ALPHA = \"QSAdminServerv\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_ALPHA = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_ALPHANUMERIC = \"QSAdminServerv\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_ALPHANUMERIC = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_ASCII_PRINTABLE = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_ASCII_PRINTABLE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_BASE64 = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_BASE64 = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_BLANK_SPACE = \" \";\n\t\n\tprivate static final String BAD_RESPONSE_IS_BLANK_SPACE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_DECIMAL_NUMBER = \"1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_DECIMAL_NUMBER = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_DIGITS = \"140\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_DIGITS = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_EMAIL = \"qsadmin@quickserver.org\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_EMAIL = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_HEXADECIMAL = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_HEXADECIMAL = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_ISO_CONTROL = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_ISO_CONTROL = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_JAVA_IDENTIFIER = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_JAVA_IDENTIFIER = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_JAVA_IDENTIFIER_START = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_JAVA_IDENTIFIER_START = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_JAVA_IDENTIFIER_PART = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_JAVA_IDENTIFIER_PART = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_LOWER_CASE = \"qsadminserver v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_LOWER_CASE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_NUMERIC = \"140\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_NUMERIC = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_UPPER_CASE = \"QSADMINSERVER V1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_UPPER_CASE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_WHITESPACE = \" \";\n\t\n\tprivate static final String BAD_RESPONSE_IS_WHITESPACE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_START = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_START = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_END = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_END = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER_DIGIT = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER_DIGIT = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER_DIGIT_NAME_CHAR = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER_DIGIT_NAME_CHAR = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER_DIGIT_NAME_CHAR_NAME_START_CHAR = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER_DIGIT_NAME_CHAR_NAME_START_CHAR = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER_DIGIT_NAME_CHAR_NAME_START_CHAR_NAME_CHAR = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static final String BAD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER_DIGIT_NAME_CHAR_NAME_START_CHAR_NAME_CHAR = \"Bad Response\";\n\t\n\tprivate static final String GOOD_RESPONSE_IS_XML_NAME_PART_START_END_DASH_DOT_UNDERSCORE_COLON_COMBINING_CHAR_EXTENDER_LETTER_DIGIT_NAME_CHAR_NAME_START_CHAR_NAME_CHAR_NAME_START_CHAR = \"QSAdminServer v1.4.0\";\n\t\n\tprivate static",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 777,
        "completion_tokens": 4000,
        "total_tokens": 4777
    },
    "time_taken": 118.28458094596863,
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/qsadmin/QSAdminAPI.java",
    "original_code": "// QSAdminAPI.java\npackage org.quickserver.net.qsadmin;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.logging.*;\n\n/**\n * QSAdminAPI class to communicate to QsAdmin from java applications.\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * \tQSAdminAPI qsAdminApi = new QSAdminAPI(\"127.0.0.1\", 9080);\n * \tif(qsAdminApi.logon()) {\n * \t\tSystem.out.println(\"Logged in\");\n * \t\tString info = qsAdminApi.sendCommand(\"info server\");\n * \t\tSystem.out.println(\"Info on Server :\\n\"+info);\n * \t\tqsAdminApi.logoff();\n * \t} else {\n * \t\tSystem.out.println(\"Bad Login\");\n * \t\tqsAdminApi.close();\n * \t}\n * </pre></BLOCKQUOTE></code></p>\n *\n * @see QSAdminServer\n * @since 1.4\n * @author Akshathkumar Shetty\n */\npublic class QSAdminAPI {\n\n    private static final Logger logger = Logger.getLogger(QSAdminAPI.class.getName());\n\n    private String username = \"Admin\";\n\n    private String password = \"QsAdm1n\";\n\n    private String host = \"localhost\";\n\n    private int port = 9877;\n\n    private Socket socket;\n\n    private InputStream in;\n\n    private OutputStream out;\n\n    private BufferedReader br;\n\n    private BufferedWriter bw;\n\n    /**\n     * Creates QSAdminAPI object that will communicate with the\n     * passed host and port.\n     */\n    public QSAdminAPI(String host, int port) {\n    }\n\n    /**\n     * Will attempt to connect and logon to the remote QsAdminServer.\n     */\n    public boolean logon() throws IOException;\n\n    /**\n     * Will attempt to connect and logon to the remote QsAdminServer.\n     */\n    public boolean logon(String username, String password) throws IOException;\n\n    /**\n     * Sends the given command to QSAdmin and gives the response back.\n     */\n    public String sendCommand(String data) throws IOException;\n\n    private String readResponse() throws IOException;\n\n    /**\n     * Logoff the QSAdminServer and closed the socket associated.\n     */\n    public void logoff() throws IOException;\n\n    /**\n     * Closes the socket associated.\n     */\n    public void close() throws IOException;\n\n    public static void main(String[] args) throws Exception;\n}\n",
    "test_prompt": "// QSAdminAPITest.java\npackage org.quickserver.net.qsadmin;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QSAdminAPI}.\n* It contains ten unit test cases for the {@link QSAdminAPI#logon()} method.\n*/\nclass QSAdminAPITest {"
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17007 tokens (13007 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "c3c5d0fb-5fbb-45ee-a59d-9acdba24bb26",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_0Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_0Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getVersion()} method.\n*/\nclass QuickServer_0Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17008 tokens (13008 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "9eded1cd-59bc-4487-89cd-5c327bfd3238",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_10Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_10Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#findAllClient()} method.\n*/\nclass QuickServer_10Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17009 tokens (13009 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "a0c60774-a29c-4c3d-ac3f-b548f8deada7",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_11Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_11Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getSSLContext(String)} method.\n*/\nclass QuickServer_11Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17011 tokens (13011 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "f0a53e3d-6af5-4a17-bb4b-3ec33a2b23d7",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_12Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_12Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getSSLSocketFactory(String)} method.\n*/\nclass QuickServer_12Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17008 tokens (13008 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "5fd39ae2-9165-486b-9829-70bab7c13578",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_13Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_13Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getPID()} method.\n*/\nclass QuickServer_13Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17008 tokens (13008 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "1e11165a-83b4-486a-81e5-22f60bbfc8fc",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_1Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_1Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getVersionNo()} method.\n*/\nclass QuickServer_1Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17008 tokens (13008 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "29edd612-8def-4748-a393-21796d78f42c",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_2Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_2Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getNewLine()} method.\n*/\nclass QuickServer_2Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17010 tokens (13010 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "ec9cbe9c-5118-4fc2-8223-9c4b0532549e",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_3Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_3Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#initService(Object[])} method.\n*/\nclass QuickServer_3Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17010 tokens (13010 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "36d0cbdb-1d64-4754-ac35-072fc5092c40",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_4Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_4Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#initService(QuickServerConfig)} method.\n*/\nclass QuickServer_4Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17007 tokens (13007 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "4aa89c66-4e14-46c2-b8f6-7173c3242128",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_5Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_5Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#startService()} method.\n*/\nclass QuickServer_5Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17007 tokens (13007 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "74d07752-37dd-496a-9ef8-ca5ca5f13330",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_6Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_6Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#stopService()} method.\n*/\nclass QuickServer_6Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17008 tokens (13008 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "2970900f-94d5-438d-9b42-8a06eb0b433f",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_7Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_7Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#suspendService()} method.\n*/\nclass QuickServer_7Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17008 tokens (13008 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "a31527a0-b667-4f4d-beb2-d1b3cf20a9db",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_8Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_8Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#resumeService()} method.\n*/\nclass QuickServer_8Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 17006 tokens (13006 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "339bfd47-7fbf-4fa5-9094-23373e1ba776",
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_9Test.java",
    "original_code": "// QuickServer.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n * Main class of QuickServer library. This class is used to create\n * multi client servers quickly.\n * <p>\n * Ones a client is connected, it creates {@link ClientHandler} object,\n * which is run using any thread available from the pool of threads\n * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n * handles the client. <br/>\n * QuickServer divides the application logic of its developer over eight\n * class, <br>\n * \t<ul>\n * \t<li>ClientEventHandler<br>\n * \t\t   &nbsp;Handles client events [Optional Class].\n * \t\t<li>ClientCommandHandler [#]<br>\n * \t\t   &nbsp;Handles client character/string commands.\n * \t\t<li>ClientObjectHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - Object commands.\n * \t<li>ClientBinaryHandler [#]<br>\n * \t\t   &nbsp;Handles client interaction - binary data.\n * \t<li>ClientWriteHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n * \t\t<li>ClientAuthenticationHandler [Optional Class]<br>\n * \t\t\t&nbsp;Used to Authencatet a client.\n * \t\t<li>ClientData [Optional Class]<br>\n * \t\t\t&nbsp;Client data carrier (support class)\n * \t<li>ClientExtendedEventHandler [Optional Class]<br>\n * \t\t   &nbsp;Handles extended client events.\n * \t</ul>\n *\n * [#] = Any one of these have to be set based on default DataMode for input.\n * The default DataMode for input is String so if not changes you will\n * have to set ClientCommandHandler.\n * </p>\n * <p>\n *  Eg:\n * <code><BLOCKQUOTE><pre>\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle = \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer = new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * </pre></BLOCKQUOTE></code></p>\n *\n * @version 1.4.8\n * @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //change also in QSAdminMain\n    private final static String VER = \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort = 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName = \"QuickServer\";\n\n    private long maxConnection = -1;\n\n    //1 min socket timeout\n    private int socketTimeout = 60 * 1000;\n\n    private String maxConnectionMsg = \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg = \"-ERR Timeout\";\n\n    private String maxAuthTryMsg = \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry = 5;\n\n    static {\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //Logger for QuickServer\n    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState = Service.UNKNOWN;\n\n    static {\n    }\n\n    //--v1.3\n    private QuickServerConfig config = new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel = \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel = \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation = false;\n\n    private boolean communicationLogging = true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig = config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km = null;\n\n    private TrustManager[] tm = null;\n\n    private boolean runningSecure = false;\n\n    private SecureStoreManager secureStoreManager = null;\n\n    private Exception exceptionInRun = null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode = true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN = DataMode.STRING;\n\n    private DataMode defaultDataModeOUT = DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging = false;\n\n    private int rawCommunicationMaxLength = 100;\n\n    static {\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo();\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver);\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine();\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString();\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n    }\n\n    /**\n     * Creates a new server at <code>port</code> with the specified\n     * <code>commandHandler</code> has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException;\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException;\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException;\n\n    /**\n     * Returns the name of the QuickServer. Default is 'QuickServer'.\n     * @see #setName\n     */\n    public String getName();\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner();\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. <br>&nbsp;<br>\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner);\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port);\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort();\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler);\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler();\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator);\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler();\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator();\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data);\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData();\n\n    /**\n     * Sets the client socket's timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time);\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout();\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry);\n\n    /**\n     * Returns max allowed login attempts. Default is <code>5</code>.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry();\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg);\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg();\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg);\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg();\n\n    private TheClient initTheClient();\n\n    public void run();\n\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection);\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection();\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount();\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg);\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg();\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException;\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr();\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects);\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return <code>null</code>.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects();\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port);\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort();\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator);\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator();\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException;\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException;\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer();\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer);\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed();\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer's own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger();\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger);\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler);\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler();\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini();\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro();\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level);\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel();\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level);\n\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError();\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param);\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig);\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService();\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService();\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService();\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService();\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info();\n\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException;\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState();\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state);\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp);\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception;\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception;\n\n    /**\n     * Usage: QuickServer [-options]<br/>\n     * Where options include:<br/>\n     *   -about\t\tOpens About Dialogbox<br/>\n     *   -load <xml_config_file> [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File <new_file_name>\n     */\n    public static void main(String[] args);\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException;\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage();\n\n    private static void handleOptions(String[] args, QuickServer quickserver);\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception;\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception;\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception;\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool();\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool();\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config);\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig();\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool();\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil();\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception;\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id);\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  <code><pre>\n     *    Eg:\n     *\n     * \tClientData foundClientData = null;\n     * \tObject syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator = quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData = null;\n     * \tClientIdentifier clientIdentifier = quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator = clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler = (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    </code></pre>\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient();\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern);\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key);\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  <p>\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. <pre>\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime = foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!=newTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler = handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}</pre>\n     *  </p>\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else <code>null</code>\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern);\n\n    /**\n     * Sets next client has a trusted client.\n     * <p>This will skip any authentication and will not set any timeout.</p>\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation();\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation);\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging);\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging();\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass);\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass();\n\n    public SecurityManager getSecurityManager() throws AppException;\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);\n\n    /**\n     * Returns Access constraints if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig();\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader);\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader();\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException;\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath);\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath();\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks);\n\n    /**\n     * Returns ServerHooks if present else <code>null</code>.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks();\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses();\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event);\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone();\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure);\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure();\n\n    /**\n     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure();\n\n    /**\n     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure);\n\n    private File makeAbsoluteToConfig(String fileName);\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException;\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig();\n\n    /**\n     * Loads the <code>SSLContext</code> from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException;\n\n    /**\n     * Returns the <code>SSLContext</code> from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns the <code>SSLContext</code> object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * <code>null</code> will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler);\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler();\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector);\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector();\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception;\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception;\n\n    private boolean checkAccessConstraint(Socket socket);\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig);\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool();\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception;\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler);\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler();\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be <code>null</code> if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime();\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag);\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier();\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode();\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception;\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler);\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler();\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType);\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler);\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler();\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception;\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID();\n\n    public boolean isRawCommunicationLogging();\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging);\n\n    public int getRawCommunicationMaxLength();\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);\n}\n",
    "test_prompt": "// QuickServer_9Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#info()} method.\n*/\nclass QuickServer_9Test {",
    "time_taken": -1
},
{
    "id": "cmpl-6xI2hQFwWmJrEWxDy1Dg3Tt1rdaOO",
    "object": "text_completion",
    "created": 1679588727,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t@Test\n\tvoid testGetWakeupSelectorAfterRegisterWrite() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertTrue(nonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite());\n\t}\n}\n\n// NonBlockingClientHandler_1Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setWakeupSelectorAfterRegisterWrite(boolean)} method.\n*/\nclass NonBlockingClientHandler_1Test {\n\t\t\n\t@Test\n\tvoid testSetWakeupSelectorAfterRegisterWrite() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);\n\t\tassertFalse(nonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite());\n\t}\n}\n\n// NonBlockingClientHandler_2Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterRead()} method.\n*/\nclass NonBlockingClientHandler_2Test {\n\t\t\n\t@Test\n\tvoid testGetWakeupSelectorAfterRegisterRead() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertTrue(nonBlockingClientHandler.getWakeupSelectorAfterRegisterRead());\n\t}\n}\n\n// NonBlockingClientHandler_3Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setWakeupSelectorAfterRegisterRead(boolean)} method.\n*/\nclass NonBlockingClientHandler_3Test {\n\t\t\n\t@Test\n\tvoid testSetWakeupSelectorAfterRegisterRead() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(false);\n\t\tassertFalse(nonBlockingClientHandler.getWakeupSelectorAfterRegisterRead());\n\t}\n}\n\n// NonBlockingClientHandler_4Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getMaxThreadAccessCount()} method.\n*/\nclass NonBlockingClientHandler_4Test {\n\t\t\n\t@Test\n\tvoid testGetMaxThreadAccessCount() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertEquals(5, nonBlockingClientHandler.getMaxThreadAccessCount());\n\t}\n}\n\n// NonBlockingClientHandler_5Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setMaxThreadAccessCount(int)} method.\n*/\nclass NonBlockingClientHandler_5Test {\n\t\t\n\t@Test\n\tvoid testSetMaxThreadAccessCount() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.setMaxThreadAccessCount(10);\n\t\tassertEquals(10, nonBlockingClientHandler.getMaxThreadAccessCount());\n\t}\n}\n\n// NonBlockingClientHandler_6Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getThreadAccessCount()} method.\n*/\nclass NonBlockingClientHandler_6Test {\n\t\t\n\t@Test\n\tvoid testGetThreadAccessCount() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertEquals(0, nonBlockingClientHandler.getThreadAccessCount());\n\t}\n}\n\n// NonBlockingClientHandler_7Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getInitialHandshakeStatus()} method.\n*/\nclass NonBlockingClientHandler_7Test {\n\t\t\n\t@Test\n\tvoid testGetInitialHandshakeStatus() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertFalse(nonBlockingClientHandler.getInitialHandshakeStatus());\n\t}\n}\n\n// NonBlockingClientHandler_8Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#encrypt(ByteBuffer)} method.\n*/\nclass NonBlockingClientHandler_8Test {\n\t\t\n\t@Test\n\tvoid testEncrypt() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tByteBuffer src = ByteBuffer.allocate(0);\n\t\tassertThrows(IOException.class, () -> nonBlockingClientHandler.encrypt(src));\n\t}\n}\n\n// NonBlockingClientHandler_9Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#clean()} method.\n*/\nclass NonBlockingClientHandler_9Test {\n\t\t\n\t@Test\n\tvoid testClean() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.clean();\n\t}\n}\n\n// NonBlockingClientHandler_10Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#finalize()} method.\n*/\nclass NonBlockingClientHandler_10Test {\n\t\t\n\t@Test\n\tvoid testFinalize() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertThrows(Throwable.class, () -> nonBlockingClientHandler.finalize());\n\t}\n}\n\n// NonBlockingClientHandler_11Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#handleClient(TheClient)} method.\n*/\nclass NonBlockingClientHandler_11Test {\n\t\t\n\t@Test\n\tvoid testHandleClient() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tTheClient theClient = new TheClient();\n\t\tassertThrows(Exception.class, () -> nonBlockingClientHandler.handleClient(theClient));\n\t}\n}\n\n// NonBlockingClientHandler_12Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setInputStream(InputStream)} method.\n*/\nclass NonBlockingClientHandler_12Test {\n\t\t\n\t@Test\n\tvoid testSetInputStream() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tInputStream in = new InputStream();\n\t\tassertThrows(IOException.class, () -> nonBlockingClientHandler.setInputStream(in));\n\t}\n}\n\n// NonBlockingClientHandler_13Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getBufferedReader()} method.\n*/\nclass NonBlockingClientHandler_13Test {\n\t\t\n\t@Test\n\tvoid testGetBufferedReader() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertNull(nonBlockingClientHandler.getBufferedReader());\n\t}\n}\n\n// NonBlockingClientHandler_14Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1584,
        "completion_tokens": 4000,
        "total_tokens": 5584
    },
    "time_taken": 129.05925273895264,
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_0Test.java",
    "original_code": "// NonBlockingClientHandler.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\n\npublic class NonBlockingClientHandler extends BasicClientHandler {\n\n    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());\n\n    //v1.4.5\n    protected ClientWriteHandler clientWriteHandler;\n\n    private SocketChannel socketChannel;\n\n    protected ArrayList readByteBuffer = new ArrayList();\n\n    protected ArrayList writeByteBuffer = new ArrayList();\n\n    protected SelectionKey selectionKey;\n\n    protected volatile int threadAccessCount = 0;\n\n    protected volatile boolean willReturn;\n\n    protected volatile boolean waitingForFinalWrite;\n\n    //one for each event ACCEPT, WRITE, READ\n    private static int maxThreadAccessCount = 5;\n\n    private static boolean wakeupSelectorAfterRegisterWrite = true;\n\n    private static boolean wakeupSelectorAfterRegisterRead = true;\n\n    //private final SSLSession session;\n    private boolean initialHandshakeStatus = false;\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n\n    private SSLEngineResult.Status status = null;\n\n    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);\n\n    private ByteBuffer peerNetData = null;\n\n    private boolean sslShutdown = false;\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterWrite(boolean flag);\n\n    /**\n     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector\n     * after RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterWrite();\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterRead(boolean flag);\n\n    /**\n     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector\n     * after RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterRead();\n\n    /**\n     * Sets the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static void setMaxThreadAccessCount(int count);\n\n    /**\n     * Returns the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static int getMaxThreadAccessCount();\n\n    //v1.4.7\n    private ByteBufferOutputStream byteBufferOutputStream;\n\n    public NonBlockingClientHandler(int instanceCount) {\n    }\n\n    public NonBlockingClientHandler() {\n    }\n\n    public void clean();\n\n    protected void finalize() throws Throwable;\n\n    public void handleClient(TheClient theClient) throws Exception;\n\n    protected void setInputStream(InputStream in) throws IOException;\n\n    public BufferedReader getBufferedReader();\n\n    public void closeConnection();\n\n    private void doPostCloseActivity() throws IOException;\n\n    public boolean closeIfSSLOutboundDone();\n\n    /**\n     * waitTillFullyWritten\n     * @since 1.4.7\n     */\n    public void waitTillFullyWritten();\n\n    public void run();\n\n    protected boolean checkReturnClientHandler();\n\n    /**\n     * Process read\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processRead() throws Exception;\n\n    private boolean doRead() throws Exception;\n\n    /**\n     * Process write\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processWrite() throws IOException;\n\n    private boolean doWrite() throws IOException;\n\n    protected void returnThread();\n\n    protected void returnClientHandler();\n\n    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException;\n\n    protected byte[] readInputStream() throws IOException;\n\n    public void updateInputOutputStreams() throws IOException;\n\n    public boolean getBlockingMode();\n\n    public void setSocketChannel(SocketChannel socketChannel);\n\n    public SocketChannel getSocketChannel();\n\n    public void setSelectionKey(SelectionKey selectionKey);\n\n    public SelectionKey getSelectionKey();\n\n    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException;\n\n    public void registerForRead() throws IOException, ClosedChannelException;\n\n    public void registerForWrite() throws IOException, ClosedChannelException;\n\n    public void registerWrite() throws IOException;\n\n    protected void setClientWriteHandler(ClientWriteHandler handler);\n\n    /**\n     * Returns number of thread currently in this object.\n     * @since 1.4.6\n     */\n    public int getThreadAccessCount();\n\n    private void doHandshake() throws Exception;\n\n    private void doTasks();\n\n    private void finishInitialHandshake() throws IOException;\n\n    public boolean getInitialHandshakeStatus();\n\n    public ByteBuffer encrypt(ByteBuffer src) throws IOException;\n}\n",
    "test_prompt": "// NonBlockingClientHandler_0Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterWrite()} method.\n*/\nclass NonBlockingClientHandler_0Test {"
},
{
    "id": "cmpl-6xI4mjIh5Std0YYZGnHLz2V9F8SZn",
    "object": "text_completion",
    "created": 1679588856,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t@Test\n\tvoid testGetWakeupSelectorAfterRegisterRead() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertTrue(nonBlockingClientHandler.getWakeupSelectorAfterRegisterRead());\n\t}\n}\n\n// NonBlockingClientHandler_2Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setWakeupSelectorAfterRegisterRead(boolean)} method.\n*/\nclass NonBlockingClientHandler_2Test {\n\t\t\n\t@Test\n\tvoid testSetWakeupSelectorAfterRegisterRead() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(false);\n\t\tassertFalse(nonBlockingClientHandler.getWakeupSelectorAfterRegisterRead());\n\t}\n}\n\n// NonBlockingClientHandler_3Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterWrite()} method.\n*/\nclass NonBlockingClientHandler_3Test {\n\t\t\n\t@Test\n\tvoid testGetWakeupSelectorAfterRegisterWrite() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertTrue(nonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite());\n\t}\n}\n\n// NonBlockingClientHandler_4Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setWakeupSelectorAfterRegisterWrite(boolean)} method.\n*/\nclass NonBlockingClientHandler_4Test {\n\t\t\n\t@Test\n\tvoid testSetWakeupSelectorAfterRegisterWrite() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);\n\t\tassertFalse(nonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite());\n\t}\n}\n\n// NonBlockingClientHandler_5Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getMaxThreadAccessCount()} method.\n*/\nclass NonBlockingClientHandler_5Test {\n\t\t\n\t@Test\n\tvoid testGetMaxThreadAccessCount() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertEquals(5, nonBlockingClientHandler.getMaxThreadAccessCount());\n\t}\n}\n\n// NonBlockingClientHandler_6Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setMaxThreadAccessCount(int)} method.\n*/\nclass NonBlockingClientHandler_6Test {\n\t\t\n\t@Test\n\tvoid testSetMaxThreadAccessCount() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.setMaxThreadAccessCount(10);\n\t\tassertEquals(10, nonBlockingClientHandler.getMaxThreadAccessCount());\n\t}\n}\n\n// NonBlockingClientHandler_7Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getThreadAccessCount()} method.\n*/\nclass NonBlockingClientHandler_7Test {\n\t\t\n\t@Test\n\tvoid testGetThreadAccessCount() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertEquals(0, nonBlockingClientHandler.getThreadAccessCount());\n\t}\n}\n\n// NonBlockingClientHandler_8Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getInitialHandshakeStatus()} method.\n*/\nclass NonBlockingClientHandler_8Test {\n\t\t\n\t@Test\n\tvoid testGetInitialHandshakeStatus() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertFalse(nonBlockingClientHandler.getInitialHandshakeStatus());\n\t}\n}\n\n// NonBlockingClientHandler_9Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#encrypt(ByteBuffer)} method.\n*/\nclass NonBlockingClientHandler_9Test {\n\t\t\n\t@Test\n\tvoid testEncrypt() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tByteBuffer src = ByteBuffer.allocate(0);\n\t\tassertThrows(IOException.class, () -> nonBlockingClientHandler.encrypt(src));\n\t}\n}\n\n// NonBlockingClientHandler_10Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#clean()} method.\n*/\nclass NonBlockingClientHandler_10Test {\n\t\t\n\t@Test\n\tvoid testClean() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.clean();\n\t}\n}\n\n// NonBlockingClientHandler_11Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#finalize()} method.\n*/\nclass NonBlockingClientHandler_11Test {\n\t\t\n\t@Test\n\tvoid testFinalize() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertThrows(Throwable.class, () -> nonBlockingClientHandler.finalize());\n\t}\n}\n\n// NonBlockingClientHandler_12Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#handleClient(TheClient)} method.\n*/\nclass NonBlockingClientHandler_12Test {\n\t\t\n\t@Test\n\tvoid testHandleClient() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tTheClient theClient = new TheClient();\n\t\tassertThrows(Exception.class, () -> nonBlockingClientHandler.handleClient(theClient));\n\t}\n}\n\n// NonBlockingClientHandler_13Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setInputStream(InputStream)} method.\n*/\nclass NonBlockingClientHandler_13Test {\n\t\t\n\t@Test\n\tvoid testSetInputStream() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tInputStream in = new InputStream();\n\t\tassertThrows(IOException.class, () -> nonBlockingClientHandler.setInputStream(in));\n\t}\n}\n\n// NonBlockingClientHandler_14Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getBufferedReader()} method.\n*/\nclass NonBlockingClientHandler_14Test {\n\t\t\n\t@Test\n\tvoid testGetBufferedReader() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tassertNull(nonBlockingClientHandler.getBufferedReader());\n\t}\n}\n\n// NonBlockingClientHandler_15Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1584,
        "completion_tokens": 4000,
        "total_tokens": 5584
    },
    "time_taken": 119.54178977012634,
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_1Test.java",
    "original_code": "// NonBlockingClientHandler.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\n\npublic class NonBlockingClientHandler extends BasicClientHandler {\n\n    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());\n\n    //v1.4.5\n    protected ClientWriteHandler clientWriteHandler;\n\n    private SocketChannel socketChannel;\n\n    protected ArrayList readByteBuffer = new ArrayList();\n\n    protected ArrayList writeByteBuffer = new ArrayList();\n\n    protected SelectionKey selectionKey;\n\n    protected volatile int threadAccessCount = 0;\n\n    protected volatile boolean willReturn;\n\n    protected volatile boolean waitingForFinalWrite;\n\n    //one for each event ACCEPT, WRITE, READ\n    private static int maxThreadAccessCount = 5;\n\n    private static boolean wakeupSelectorAfterRegisterWrite = true;\n\n    private static boolean wakeupSelectorAfterRegisterRead = true;\n\n    //private final SSLSession session;\n    private boolean initialHandshakeStatus = false;\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n\n    private SSLEngineResult.Status status = null;\n\n    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);\n\n    private ByteBuffer peerNetData = null;\n\n    private boolean sslShutdown = false;\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterWrite(boolean flag);\n\n    /**\n     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector\n     * after RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterWrite();\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterRead(boolean flag);\n\n    /**\n     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector\n     * after RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterRead();\n\n    /**\n     * Sets the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static void setMaxThreadAccessCount(int count);\n\n    /**\n     * Returns the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static int getMaxThreadAccessCount();\n\n    //v1.4.7\n    private ByteBufferOutputStream byteBufferOutputStream;\n\n    public NonBlockingClientHandler(int instanceCount) {\n    }\n\n    public NonBlockingClientHandler() {\n    }\n\n    public void clean();\n\n    protected void finalize() throws Throwable;\n\n    public void handleClient(TheClient theClient) throws Exception;\n\n    protected void setInputStream(InputStream in) throws IOException;\n\n    public BufferedReader getBufferedReader();\n\n    public void closeConnection();\n\n    private void doPostCloseActivity() throws IOException;\n\n    public boolean closeIfSSLOutboundDone();\n\n    /**\n     * waitTillFullyWritten\n     * @since 1.4.7\n     */\n    public void waitTillFullyWritten();\n\n    public void run();\n\n    protected boolean checkReturnClientHandler();\n\n    /**\n     * Process read\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processRead() throws Exception;\n\n    private boolean doRead() throws Exception;\n\n    /**\n     * Process write\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processWrite() throws IOException;\n\n    private boolean doWrite() throws IOException;\n\n    protected void returnThread();\n\n    protected void returnClientHandler();\n\n    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException;\n\n    protected byte[] readInputStream() throws IOException;\n\n    public void updateInputOutputStreams() throws IOException;\n\n    public boolean getBlockingMode();\n\n    public void setSocketChannel(SocketChannel socketChannel);\n\n    public SocketChannel getSocketChannel();\n\n    public void setSelectionKey(SelectionKey selectionKey);\n\n    public SelectionKey getSelectionKey();\n\n    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException;\n\n    public void registerForRead() throws IOException, ClosedChannelException;\n\n    public void registerForWrite() throws IOException, ClosedChannelException;\n\n    public void registerWrite() throws IOException;\n\n    protected void setClientWriteHandler(ClientWriteHandler handler);\n\n    /**\n     * Returns number of thread currently in this object.\n     * @since 1.4.6\n     */\n    public int getThreadAccessCount();\n\n    private void doHandshake() throws Exception;\n\n    private void doTasks();\n\n    private void finishInitialHandshake() throws IOException;\n\n    public boolean getInitialHandshakeStatus();\n\n    public ByteBuffer encrypt(ByteBuffer src) throws IOException;\n}\n",
    "test_prompt": "// NonBlockingClientHandler_1Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterRead()} method.\n*/\nclass NonBlockingClientHandler_1Test {"
},
{
    "id": "cmpl-6xI8fBLOWtv3OfHtwqnOrEMQ64lii",
    "object": "text_completion",
    "created": 1679589097,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t@Test\n\tvoid testGetMaxThreadAccessCount() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tint result = nonBlockingClientHandler.getMaxThreadAccessCount();\n\t\tassertEquals(5, result);\n\t}\n}\n\n// NonBlockingClientHandler_3Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setMaxThreadAccessCount(int)} method.\n*/\nclass NonBlockingClientHandler_3Test {\n\t\t\n\t@Test\n\tvoid testSetMaxThreadAccessCount() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.setMaxThreadAccessCount(5);\n\t}\n}\n\n// NonBlockingClientHandler_4Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterWrite()} method.\n*/\nclass NonBlockingClientHandler_4Test {\n\t\t\n\t@Test\n\tvoid testGetWakeupSelectorAfterRegisterWrite() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tboolean result = nonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();\n\t\tassertEquals(true, result);\n\t}\n}\n\n// NonBlockingClientHandler_5Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setWakeupSelectorAfterRegisterWrite(boolean)} method.\n*/\nclass NonBlockingClientHandler_5Test {\n\t\t\n\t@Test\n\tvoid testSetWakeupSelectorAfterRegisterWrite() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(true);\n\t}\n}\n\n// NonBlockingClientHandler_6Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterRead()} method.\n*/\nclass NonBlockingClientHandler_6Test {\n\t\t\n\t@Test\n\tvoid testGetWakeupSelectorAfterRegisterRead() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tboolean result = nonBlockingClientHandler.getWakeupSelectorAfterRegisterRead();\n\t\tassertEquals(true, result);\n\t}\n}\n\n// NonBlockingClientHandler_7Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setWakeupSelectorAfterRegisterRead(boolean)} method.\n*/\nclass NonBlockingClientHandler_7Test {\n\t\t\n\t@Test\n\tvoid testSetWakeupSelectorAfterRegisterRead() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(true);\n\t}\n}\n\n// NonBlockingClientHandler_8Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getThreadAccessCount()} method.\n*/\nclass NonBlockingClientHandler_8Test {\n\t\t\n\t@Test\n\tvoid testGetThreadAccessCount() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tint result = nonBlockingClientHandler.getThreadAccessCount();\n\t\tassertEquals(0, result);\n\t}\n}\n\n// NonBlockingClientHandler_9Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#clean()} method.\n*/\nclass NonBlockingClientHandler_9Test {\n\t\t\n\t@Test\n\tvoid testClean() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.clean();\n\t}\n}\n\n// NonBlockingClientHandler_10Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#finalize()} method.\n*/\nclass NonBlockingClientHandler_10Test {\n\t\t\n\t@Test\n\tvoid testFinalize() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.finalize();\n\t}\n}\n\n// NonBlockingClientHandler_11Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#handleClient(TheClient)} method.\n*/\nclass NonBlockingClientHandler_11Test {\n\t\t\n\t@Test\n\tvoid testHandleClient() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tTheClient theClient = new TheClient();\n\t\tnonBlockingClientHandler.handleClient(theClient);\n\t}\n}\n\n// NonBlockingClientHandler_12Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#setInputStream(InputStream)} method.\n*/\nclass NonBlockingClientHandler_12Test {\n\t\t\n\t@Test\n\tvoid testSetInputStream() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tInputStream in = new InputStream();\n\t\tnonBlockingClientHandler.setInputStream(in);\n\t}\n}\n\n// NonBlockingClientHandler_13Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getBufferedReader()} method.\n*/\nclass NonBlockingClientHandler_13Test {\n\t\t\n\t@Test\n\tvoid testGetBufferedReader() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tBufferedReader result = nonBlockingClientHandler.getBufferedReader();\n\t\tassertEquals(null, result);\n\t}\n}\n\n// NonBlockingClientHandler_14Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#closeConnection()} method.\n*/\nclass NonBlockingClientHandler_14Test {\n\t\t\n\t@Test\n\tvoid testCloseConnection() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tnonBlockingClientHandler.closeConnection();\n\t}\n}\n\n// NonBlockingClientHandler_15Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#closeIfSSLOutboundDone()} method.\n*/\nclass NonBlockingClientHandler_15Test {\n\t\t\n\t@Test\n\tvoid testCloseIfSSLOutboundDone() {\n\t\tNonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();\n\t\tboolean result = nonBlockingClientHandler.closeIfSSLOutboundDone();\n\t\tassertEquals(false, result);\n\t}\n}\n\n// NonBlockingClientHandler_16Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1580,
        "completion_tokens": 4000,
        "total_tokens": 5580
    },
    "time_taken": 239.40390348434448,
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_2Test.java",
    "original_code": "// NonBlockingClientHandler.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\n\npublic class NonBlockingClientHandler extends BasicClientHandler {\n\n    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());\n\n    //v1.4.5\n    protected ClientWriteHandler clientWriteHandler;\n\n    private SocketChannel socketChannel;\n\n    protected ArrayList readByteBuffer = new ArrayList();\n\n    protected ArrayList writeByteBuffer = new ArrayList();\n\n    protected SelectionKey selectionKey;\n\n    protected volatile int threadAccessCount = 0;\n\n    protected volatile boolean willReturn;\n\n    protected volatile boolean waitingForFinalWrite;\n\n    //one for each event ACCEPT, WRITE, READ\n    private static int maxThreadAccessCount = 5;\n\n    private static boolean wakeupSelectorAfterRegisterWrite = true;\n\n    private static boolean wakeupSelectorAfterRegisterRead = true;\n\n    //private final SSLSession session;\n    private boolean initialHandshakeStatus = false;\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n\n    private SSLEngineResult.Status status = null;\n\n    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);\n\n    private ByteBuffer peerNetData = null;\n\n    private boolean sslShutdown = false;\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterWrite(boolean flag);\n\n    /**\n     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector\n     * after RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterWrite();\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterRead(boolean flag);\n\n    /**\n     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector\n     * after RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterRead();\n\n    /**\n     * Sets the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static void setMaxThreadAccessCount(int count);\n\n    /**\n     * Returns the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static int getMaxThreadAccessCount();\n\n    //v1.4.7\n    private ByteBufferOutputStream byteBufferOutputStream;\n\n    public NonBlockingClientHandler(int instanceCount) {\n    }\n\n    public NonBlockingClientHandler() {\n    }\n\n    public void clean();\n\n    protected void finalize() throws Throwable;\n\n    public void handleClient(TheClient theClient) throws Exception;\n\n    protected void setInputStream(InputStream in) throws IOException;\n\n    public BufferedReader getBufferedReader();\n\n    public void closeConnection();\n\n    private void doPostCloseActivity() throws IOException;\n\n    public boolean closeIfSSLOutboundDone();\n\n    /**\n     * waitTillFullyWritten\n     * @since 1.4.7\n     */\n    public void waitTillFullyWritten();\n\n    public void run();\n\n    protected boolean checkReturnClientHandler();\n\n    /**\n     * Process read\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processRead() throws Exception;\n\n    private boolean doRead() throws Exception;\n\n    /**\n     * Process write\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processWrite() throws IOException;\n\n    private boolean doWrite() throws IOException;\n\n    protected void returnThread();\n\n    protected void returnClientHandler();\n\n    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException;\n\n    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException;\n\n    protected byte[] readInputStream() throws IOException;\n\n    public void updateInputOutputStreams() throws IOException;\n\n    public boolean getBlockingMode();\n\n    public void setSocketChannel(SocketChannel socketChannel);\n\n    public SocketChannel getSocketChannel();\n\n    public void setSelectionKey(SelectionKey selectionKey);\n\n    public SelectionKey getSelectionKey();\n\n    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException;\n\n    public void registerForRead() throws IOException, ClosedChannelException;\n\n    public void registerForWrite() throws IOException, ClosedChannelException;\n\n    public void registerWrite() throws IOException;\n\n    protected void setClientWriteHandler(ClientWriteHandler handler);\n\n    /**\n     * Returns number of thread currently in this object.\n     * @since 1.4.6\n     */\n    public int getThreadAccessCount();\n\n    private void doHandshake() throws Exception;\n\n    private void doTasks();\n\n    private void finishInitialHandshake() throws IOException;\n\n    public boolean getInitialHandshakeStatus();\n\n    public ByteBuffer encrypt(ByteBuffer src) throws IOException;\n}\n",
    "test_prompt": "// NonBlockingClientHandler_2Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getMaxThreadAccessCount()} method.\n*/\nclass NonBlockingClientHandler_2Test {"
},
{
    "id": "cmpl-6xIAZI2wxPkqcgTB03V8MFYSh32at",
    "object": "text_completion",
    "created": 1679589215,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t@Test\n\tpublic void testGetClassLoaderFromJars() throws Exception {\n\t\tString jarDir = \"./lib\";\n\t\tClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);\n\t\tassertNotNull(classLoader);\n\t}\n}\n\n// ClassUtil.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\n\n/**\n * A utility class to load class.\n *\n * @author Akshathkumar Shetty\n * @since 1.3.2\n */\npublic class ClassUtil {\n\n    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());\n\n    /**\n     * Tries to load the classes present in the array\n     * passed has second parameter from\n     * the ClassLoader passed has first parameter.\n     * Returns the HashMap of all the classed successfully loaded.\n     * @param classLoader ClassLoader used to find the class\n     * @param classes[] array of classes to load.\n     */\n    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception;\n\n    /**\n     * Returns the ClassLoader to all the jars present in the\n     * dir passed has first parameter.\n     * @param jarDir path to the directory containing the jars\n     */\n    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception;\n\n    /**\n     * Returns the ClassLoader to a jar\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception;\n\n    /**\n     * Returns the ClassLoader\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoader(String path) throws Exception;\n}\n\n// ClassUtilTest.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtil}.\n* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.\n*/\nclass ClassUtilTest {\n\t\t\n\t@Test\n\tpublic void testGetClassLoaderFromJars() throws Exception {\n\t\tString jarDir = \"./lib\";\n\t\tClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);\n\t\tassertNotNull(classLoader);\n\t}\n}\n\n// ClassUtil.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\n\n/**\n * A utility class to load class.\n *\n * @author Akshathkumar Shetty\n * @since 1.3.2\n */\npublic class ClassUtil {\n\n    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());\n\n    /**\n     * Tries to load the classes present in the array\n     * passed has second parameter from\n     * the ClassLoader passed has first parameter.\n     * Returns the HashMap of all the classed successfully loaded.\n     * @param classLoader ClassLoader used to find the class\n     * @param classes[] array of classes to load.\n     */\n    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception;\n\n    /**\n     * Returns the ClassLoader to all the jars present in the\n     * dir passed has first parameter.\n     * @param jarDir path to the directory containing the jars\n     */\n    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception;\n\n    /**\n     * Returns the ClassLoader to a jar\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception;\n\n    /**\n     * Returns the ClassLoader\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoader(String path) throws Exception;\n}\n\n// ClassUtilTest.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtil}.\n* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.\n*/\nclass ClassUtilTest {\n\t\t\n\t@Test\n\tpublic void testGetClassLoaderFromJars() throws Exception {\n\t\tString jarDir = \"./lib\";\n\t\tClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);\n\t\tassertNotNull(classLoader);\n\t}\n}\n\n// ClassUtil.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\n\n/**\n * A utility class to load class.\n *\n * @author Akshathkumar Shetty\n * @since 1.3.2\n */\npublic class ClassUtil {\n\n    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());\n\n    /**\n     * Tries to load the classes present in the array\n     * passed has second parameter from\n     * the ClassLoader passed has first parameter.\n     * Returns the HashMap of all the classed successfully loaded.\n     * @param classLoader ClassLoader used to find the class\n     * @param classes[] array of classes to load.\n     */\n    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception;\n\n    /**\n     * Returns the ClassLoader to all the jars present in the\n     * dir passed has first parameter.\n     * @param jarDir path to the directory containing the jars\n     */\n    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception;\n\n    /**\n     * Returns the ClassLoader to a jar\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception;\n\n    /**\n     * Returns the ClassLoader\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoader(String path) throws Exception;\n}\n\n// ClassUtilTest.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtil}.\n* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.\n*/\nclass ClassUtilTest {\n\t\t\n\t@Test\n\tpublic void testGetClassLoaderFromJars() throws Exception {\n\t\tString jarDir = \"./lib\";\n\t\tClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);\n\t\tassertNotNull(classLoader);\n\t}\n}\n\n// ClassUtil.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\n\n/**\n * A utility class to load class.\n *\n * @author Akshathkumar Shetty\n * @since 1.3.2\n */\npublic class ClassUtil {\n\n    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());\n\n    /**\n     * Tries to load the classes present in the array\n     * passed has second parameter from\n     * the ClassLoader passed has first parameter.\n     * Returns the HashMap of all the classed successfully loaded.\n     * @param classLoader ClassLoader used to find the class\n     * @param classes[] array of classes to load.\n     */\n    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception;\n\n    /**\n     * Returns the ClassLoader to all the jars present in the\n     * dir passed has first parameter.\n     * @param jarDir path to the directory containing the jars\n     */\n    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception;\n\n    /**\n     * Returns the ClassLoader to a jar\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception;\n\n    /**\n     * Returns the ClassLoader\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoader(String path) throws Exception;\n}\n\n// ClassUtilTest.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtil}.\n* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.\n*/\nclass ClassUtilTest {\n\t\t\n\t@Test\n\tpublic void testGetClassLoaderFromJars() throws Exception {\n\t\tString jarDir = \"./lib\";\n\t\tClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);\n\t\tassertNotNull(classLoader);\n\t}\n}\n\n// ClassUtil.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\n\n/**\n * A utility class to load class.\n *\n * @author Akshathkumar Shetty\n * @since 1.3.2\n */\npublic class ClassUtil {\n\n    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());\n\n    /**\n     * Tries to load the classes present in the array\n     * passed has second parameter from\n     * the ClassLoader passed has first parameter.\n     * Returns the HashMap of all the classed successfully loaded.\n     * @param classLoader ClassLoader used to find the class\n     * @param classes[] array of classes to load.\n     */\n    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception;\n\n    /**\n     * Returns the ClassLoader to all the jars present in the\n     * dir passed has first parameter.\n     * @param jarDir path to the directory containing the jars\n     */\n    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception;\n\n    /**\n     * Returns the ClassLoader to a jar\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception;\n\n    /**\n     * Returns the ClassLoader\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoader(String path) throws Exception;\n}\n\n// ClassUtilTest.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtil}.\n* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.\n*/\nclass ClassUtilTest {\n\t\t\n\t@Test\n\tpublic void testGetClassLoaderFromJars() throws Exception {\n\t\tString jarDir = \"./lib\";\n\t\tClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);\n\t\tassertNotNull(classLoader);\n\t}\n}\n\n// ClassUtil.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\n\n/**\n * A utility class to load class.\n *\n * @author Akshathkumar Shetty\n * @since 1.3.2\n */\npublic class ClassUtil {\n\n    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());\n\n    /**\n     * Tries to load the classes present in the array\n     * passed has second parameter from\n     * the ClassLoader passed has first parameter.\n     * Returns the HashMap of all the classed successfully loaded.\n     * @param classLoader ClassLoader used to find the class\n     * @param classes[] array of classes to load.\n     */\n    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception;\n\n    /**\n     * Returns the ClassLoader to all the jars present in the\n     * dir passed has first parameter.\n     * @param jarDir path to the directory containing the jars\n     */\n    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception;\n\n    /**\n     * Returns the ClassLoader to a jar\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception;\n\n    /**\n     * Returns the ClassLoader\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoader(String path) throws Exception;\n}\n\n// ClassUtilTest.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtil}.\n* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.\n*/\nclass ClassUtilTest {\n\t\t\n\t@Test\n\tpublic void testGetClassLoaderFromJars() throws Exception {\n\t\tString jarDir = \"./lib\";\n\t\tClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);\n\t\tassertNotNull(classLoader);\n\t}\n}\n\n// ClassUtil.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\n\n/**\n * A utility class to load class.\n *\n * @author Akshathkumar Shetty\n * @since 1.3.2\n */\npublic class ClassUtil {\n\n    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());\n\n    /**\n     * Tries to load the classes present in the array\n     * passed has second parameter from\n     * the ClassLoader passed has first parameter.\n     * Returns the HashMap of all the classed successfully loaded.\n     * @param classLoader ClassLoader used to find the class\n     * @param classes[] array of classes to load.\n     */\n    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception;\n\n    /**\n     * Returns the ClassLoader to all the jars present in the\n     * dir passed has first parameter.\n     * @param jarDir path to the directory containing the jars\n     */\n    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception;\n\n    /**\n     * Returns the ClassLoader to a jar\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception;\n\n    /**\n     *",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 529,
        "completion_tokens": 4000,
        "total_tokens": 4529
    },
    "time_taken": 121.02145218849182,
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/ClassUtil.java",
    "original_code": "// ClassUtil.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\n\n/**\n * A utility class to load class.\n *\n * @author Akshathkumar Shetty\n * @since 1.3.2\n */\npublic class ClassUtil {\n\n    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());\n\n    /**\n     * Tries to load the classes present in the array\n     * passed has second parameter from\n     * the ClassLoader passed has first parameter.\n     * Returns the HashMap of all the classed successfully loaded.\n     * @param classLoader ClassLoader used to find the class\n     * @param classes[] array of classes to load.\n     */\n    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception;\n\n    /**\n     * Returns the ClassLoader to all the jars present in the\n     * dir passed has first parameter.\n     * @param jarDir path to the directory containing the jars\n     */\n    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception;\n\n    /**\n     * Returns the ClassLoader to a jar\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception;\n\n    /**\n     * Returns the ClassLoader\n     * @since 1.3.3\n     */\n    public static ClassLoader getClassLoader(String path) throws Exception;\n}\n",
    "test_prompt": "// ClassUtilTest.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtil}.\n* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.\n*/\nclass ClassUtilTest {"
},
{
    "id": "cmpl-6xICWIShT1m7k8Jfbg8gB3D2oYryA",
    "object": "text_completion",
    "created": 1679589336,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t@Test\n\tvoid testReadLine() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t}\n\t\n\t@Test\n\tvoid testReadLine2() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t}\n\t\n\t@Test\n\tvoid testReadLine3() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t}\n\t\n\t@Test\n\tvoid testReadLine4() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t}\n\t\n\t@Test\n\tvoid testReadLine5() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t}\n\t\n\t@Test\n\tvoid testReadLine6() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t}\n\t\n\t@Test\n\tvoid testReadLine7() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t}\n\t\n\t@Test\n\tvoid testReadLine8() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t}\n\t\n\t@Test\n\tvoid testReadLine9() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t}\n\t\n\t@Test\n\tvoid testReadLine10() throws IOException {\n\t\tArrayList bufferList = new ArrayList();\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tByteBufferInputStream in = new ByteBufferInputStream(bufferList, null, \"UTF-8\");\n\t\tString line = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t\tline = in.readLine();\n\t\tassertNull(line);\n\t\tbyteBuffer = ByteBuffer.wrap(\"Hello World\\r\\n\".getBytes());\n\t\tbufferList.add(byteBuffer);\n\t\tline = in.readLine();\n\t\tassertEquals(\"Hello World\", line);\n\t}\n}\n\n// ByteBufferOutputStream.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.nio.*;\nimport java.nio.charset.*;\nimport java.util.*;\nimport org.quickserver.net.server.ClientHandler;\nimport java.util.logging.*;\nimport org.quickserver.util.*;\n\n/**\n * This is an OutputStream constructed from list of ByteBuffers. This is\n * used in non-blocking mode.\n *\n * @since 1.4.5\n * @author Akshathkumar Shetty\n */\npublic class ByteBufferOutputStream extends OutputStream {\n\n    private static final Logger logger = Logger.getLogger(ByteBufferOutputStream.class.getName());\n\n    static {\n    }\n\n    /**\n     * Sets the debug flag.\n     */\n    public static void setDebug(boolean flag);\n\n    /**\n     * @since 1.4.7\n     */\n    public static boolean isLoggable(",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 794,
        "completion_tokens": 4000,
        "total_tokens": 4794
    },
    "time_taken": 121.33639764785767,
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/ByteBufferInputStream.java",
    "original_code": "// ByteBufferInputStream.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.nio.*;\nimport java.nio.charset.*;\nimport java.util.*;\nimport org.quickserver.net.server.ClientHandler;\nimport java.util.logging.*;\nimport org.quickserver.util.*;\n\n/**\n * This is an InputStream constructed from list of ByteBuffers. This is\n * used in non-blocking mode.\n *\n * @since 1.4.5\n * @author Akshathkumar Shetty\n */\npublic class ByteBufferInputStream extends InputStream {\n\n    private static final Logger logger = Logger.getLogger(ByteBufferInputStream.class.getName());\n\n    static {\n    }\n\n    /**\n     * Sets the debug flag.\n     */\n    public static void setDebug(boolean flag);\n\n    /**\n     * @since 1.4.7\n     */\n    public static boolean isLoggable(Level level);\n\n    private final ArrayList bufferList;\n\n    private ClientHandler handler;\n\n    private CharsetDecoder decoder;\n\n    private CharsetEncoder encoder;\n\n    private StringBuilder strings;\n\n    private int pos = 0;\n\n    private int index = -1;\n\n    private int start = 0;\n\n    private boolean lookingForLineFeed = false;\n\n    public ByteBufferInputStream(ArrayList bufferList, ClientHandler handler, String charset) {\n    }\n\n    public synchronized int availableOnlyInByteBuffer();\n\n    public synchronized int available();\n\n    public synchronized void close() throws IOException;\n\n    public boolean markSupported();\n\n    public synchronized int read() throws IOException;\n\n    public int read(byte[] b) throws IOException;\n\n    public synchronized int read(byte[] b, int off, int len) throws IOException;\n\n    public long skip(long n) throws IOException;\n\n    private void addStringsBackAsBuffer();\n\n    private void returnBufferBack();\n\n    private void returnBufferBack(ByteBuffer byteBuffer);\n\n    /**\n     * Checks if a line of String is ready to be read.\n     * @throws IOException if connection is lost or closed.\n     */\n    public synchronized boolean isLineReady() throws IOException;\n\n    private boolean isLineReadyForStringBuilder();\n\n    /**\n     * Reads a line of String if ready. If line is not yet ready this will\n     * block. To find out if the line is ready use <code>isLineReady()</code>\n     * @see #isLineReady()\n     */\n    public synchronized String readLine() throws IOException;\n\n    public void dumpContent();\n}\n",
    "test_prompt": "// ByteBufferInputStreamTest.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.nio.*;\nimport java.nio.charset.*;\nimport java.util.*;\nimport org.quickserver.net.server.ClientHandler;\nimport java.util.logging.*;\nimport org.quickserver.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteBufferInputStream}.\n* It contains ten unit test cases for the {@link ByteBufferInputStream#readLine()} method.\n*/\nclass ByteBufferInputStreamTest {"
},
{
    "id": "cmpl-6xIET73PoUwDPYs7cBOVrRJJmsazv",
    "object": "text_completion",
    "created": 1679589457,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not null.\n\t */\n\t@Test\n\tpublic void testGetPassword_0() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotNull(password);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_1() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_2() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_3() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_4() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_5() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_6() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_7() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_8() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_9() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(\"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n}\n\n// PasswordField_1Test.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordField}.\n* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.\n*/\nclass PasswordField_1Test {\n\t\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not null.\n\t */\n\t@Test\n\tpublic void testGetPassword_0() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotNull(password);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_1() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_2() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_3() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_4() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_5() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_6() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_7() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_8() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_9() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n}\n\n// PasswordField_2Test.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordField}.\n* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.\n*/\nclass PasswordField_2Test {\n\t\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not null.\n\t */\n\t@Test\n\tpublic void testGetPassword_0() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotNull(password);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_1() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_2() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_3() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_4() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_5() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_6() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_7() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_8() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_9() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n}\n\n// PasswordField_3Test.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordField}.\n* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.\n*/\nclass PasswordField_3Test {\n\t\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not null.\n\t */\n\t@Test\n\tpublic void testGetPassword_0() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotNull(password);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_1() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_2() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_3() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_4() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_5() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t@Test\n\tpublic void testGetPassword_6() throws IOException {\n\t\tchar[] password = PasswordField.getPassword(System.in, \"Enter password: \");\n\t\tassertNotEquals(0, password.length);\n\t}\n\t\n\t/**\n\t * Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t * It tests the password is not empty.\n\t */\n\t",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 358,
        "completion_tokens": 4000,
        "total_tokens": 4358
    },
    "time_taken": 123.04504179954529,
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_0Test.java",
    "original_code": "// PasswordField.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\n\n/**\n * This class prompts the user for a password and attempts to mask\n * input.\n *\n * @since 1.4\n */\npublic class PasswordField {\n\n    private static Logger logger = Logger.getLogger(PasswordField.class.getName());\n\n    /**\n     * @param prompt The prompt to display to the user.\n     * @return The password as entered by the user.\n     */\n    public static final char[] getPassword(String prompt) throws IOException;\n\n    /**\n     * @param in input stream to be used (e.g. System.in)\n     * @param prompt The prompt to display to the user.\n     * @return The password as entered by the user.\n     */\n    public static final char[] getPassword(InputStream in, String prompt) throws IOException;\n}\n",
    "test_prompt": "// PasswordField_0Test.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordField}.\n* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.\n*/\nclass PasswordField_0Test {"
},
{
    "id": "cmpl-6xIGSdJzSEBkWlNK6K7wIamNp6na9",
    "object": "text_completion",
    "created": 1679589580,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_1() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_2() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_3() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_4() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_5() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_6() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_7() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_8() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_9() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(InputStream, String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_10() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n}\n\n// PasswordField_2Test.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordField}.\n* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.\n*/\nclass PasswordField_2Test {\n\t\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_1() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_2() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_3() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_4() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_5() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_6() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_7() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_8() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_9() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link PasswordField#getPassword(String)} method.\n\t* Test data for this test case is a {@link ByteArrayInputStream} object.\n\t* Expected result is that the method returns a char array with the same length as the input stream.\n\t*/\n\t@Test\n\tpublic void testGetPassword_10() throws IOException {\n\t\tString input = \"test\";\n\t\tByteArrayInputStream in = new ByteArrayInputStream(input.getBytes());\n\t\tchar[] result = PasswordField.getPassword(in, \"test\");\n\t\tassertEquals(input.length(), result.length);\n\t}\n}",
            "index": 0,
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 361,
        "completion_tokens": 3239,
        "total_tokens": 3600
    },
    "time_taken": 86.73912978172302,
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_1Test.java",
    "original_code": "// PasswordField.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\n\n/**\n * This class prompts the user for a password and attempts to mask\n * input.\n *\n * @since 1.4\n */\npublic class PasswordField {\n\n    private static Logger logger = Logger.getLogger(PasswordField.class.getName());\n\n    /**\n     * @param prompt The prompt to display to the user.\n     * @return The password as entered by the user.\n     */\n    public static final char[] getPassword(String prompt) throws IOException;\n\n    /**\n     * @param in input stream to be used (e.g. System.in)\n     * @param prompt The prompt to display to the user.\n     * @return The password as entered by the user.\n     */\n    public static final char[] getPassword(InputStream in, String prompt) throws IOException;\n}\n",
    "test_prompt": "// PasswordField_1Test.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordField}.\n* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.\n*/\nclass PasswordField_1Test {"
},
{
    "id": "cmpl-6xIHrrs6eG4IjGlXsK6RZojlXOjDq",
    "object": "text_completion",
    "created": 1679589667,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t@Test\n\tvoid testShouldNioWriteHappen() {\n\t\tClientPool clientPool = new ClientPool();\n\t\tclientPool.setMaxThreadsForNioWrite(10);\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteStart();\n\t\tassertFalse(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(clientPool.shouldNioWriteHappen());\n\t\tclientPool.nioWriteEnd();\n\t\tassertTrue(",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 946,
        "completion_tokens": 4000,
        "total_tokens": 4946
    },
    "time_taken": 130.05357766151428,
    "prompt_id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/pool/thread/ClientPool.java",
    "original_code": "// ClientPool.java\npackage org.quickserver.util.pool.thread;\n\nimport java.util.*;\nimport org.quickserver.util.pool.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.net.server.*;\nimport org.quickserver.util.xmlreader.PoolConfig;\nimport java.util.logging.*;\n\n/**\n * This is a class for managing the pool of threads for\n * handling clients.\n *\n * @author Akshathkumar Shetty\n * @since 1.3\n */\npublic class ClientPool {\n\n    private static final Logger logger = Logger.getLogger(ClientPool.class.getName());\n\n    protected List clients = new ArrayList(3);\n\n    protected ObjectPool pool;\n\n    protected PoolConfig poolConfig;\n\n    //v1.4.6\n    private int countNioWriteThreads;\n\n    private int maxThreadsForNioWrite = 10;\n\n    public ClientPool(QSObjectPool objectPool, PoolConfig poolConfig) {\n    }\n\n    public ObjectPool getObjectPool();\n\n    public void addClient(Runnable r) throws NoSuchElementException;\n\n    public synchronized void addClient(Runnable r, boolean keepObjOnFail) throws NoSuchElementException;\n\n    public synchronized void returnObject(Object object);\n\n    public synchronized Runnable getClient();\n\n    /**\n     * @since 1.4.5\n     */\n    public boolean isClientAvailable();\n\n    protected void finalize() throws Throwable;\n\n    public void close() throws Exception;\n\n    public void clear() throws Exception;\n\n    /**\n     * Return the number of instances currently borrowed from my pool.\n     * @since 1.4.1\n     */\n    public int getNumActive();\n\n    /**\n     * Return the number of instances currently idle in my pool.\n     * @since 1.4.1\n     */\n    public int getNumIdle();\n\n    /**\n     * Returns iterator containing all the active\n     * threads i.e ClientHandler handling connected clients.\n     * @since 1.3.1\n     */\n    public final Iterator getAllClientThread();\n\n    public Object getObjectToSynchronize();\n\n    /**\n     * Returns PoolConfig object that configured this pool\n     * @since 1.4.5\n     */\n    public PoolConfig getPoolConfig();\n\n    /**\n     * Sets the maximum threads allowed for nio write. If set to 0 or less no limit is\n     * imposed.\n     * @since 1.4.6\n     */\n    public void setMaxThreadsForNioWrite(int count);\n\n    /**\n     * Returns the maximum threads allowed for nio write\n     * @since 1.4.6\n     */\n    public int getMaxThreadsForNioWrite();\n\n    /**\n     * Notifies when NIO write is complete.\n     * @since 1.4.6\n     */\n    protected void nioWriteEnd();\n\n    /**\n     * Notifies when NIO write is about to start.\n     * @since 1.4.6\n     */\n    protected void nioWriteStart();\n\n    /**\n     * Method to suggest if nio write should be sent for processing.\n     * @since 1.4.6\n     */\n    public boolean shouldNioWriteHappen();\n}\n",
    "test_prompt": "// ClientPoolTest.java\npackage org.quickserver.util.pool.thread;\n\nimport java.util.*;\nimport org.quickserver.util.pool.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.net.server.*;\nimport org.quickserver.util.xmlreader.PoolConfig;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClientPool}.\n* It contains ten unit test cases for the {@link ClientPool#shouldNioWriteHappen()} method.\n*/\nclass ClientPoolTest {"
}
]