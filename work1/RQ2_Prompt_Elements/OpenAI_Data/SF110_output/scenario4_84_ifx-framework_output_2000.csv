ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6x56H3WTecDZ24Hhg1FlLLEKRb00n,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_0Test.java,71.8356192111969,length,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    private String packageName = null;

    private String classJavadocs = null;

    private String className = null;

    private String superClass = null;

    private String interfaceName = null;

    private List memberVariables = new ArrayList();

    private boolean hasSuperClass = false;

    private boolean isInterface = false;

    /**
     * Returns the package name for the class.
     * @return the package name for the class.
     */
    public String getPackageName();

    /**
     * Allows setting the package name for the class.
     * @param packageName the package name to set.
     */
    public void setPackageName(String packageName);

    /**
     * Returns the class javadocs for this class.
     * @return the class javadocs for this class.
     */
    public String getClassJavadocs();

    /**
     * Allows setting the class javadocs for this class.
     * @param classJavadocs the class level javadocs to set.
     */
    public void setClassJavadocs(String classJavadocs);

    /**
     * Returns the class name.
     * @return the class name.
     */
    public String getClassName();

    /**
     * Sets the class name.
     * @param className the class name.
     */
    public void setClassName(String className);

    /**
     * Gets the superclass name for this class.
     * @return the superclass for this class.
     */
    public String getSuperClass();

    /**
     * Sets the superclass name if applicable.
     * @param superClass the super class name to set.
     */
    public void setSuperClass(String superClass);

    /**
     * Gets the fully qualified interface for this class if specified,
     * @return the interface name for this class.
     */
    public String getInterface();

    /**
     * Sets the fully qualified interface name for this class.
     * @param interfaceName the fully qualified interface name for this class.
     */
    public void setInterface(String interfaceName);

    /**
     * Returns a list of member variable objects in this class.
     * @return a list of member variable objects in this class.
     */
    public List getMemberVariables();

    /**
     * Returns the number of member variables for this class.
     * @return the number of member variables.
     */
    public int getNumberOfMemberVariables();

    /**
     * Adds a new member variable object for the class. Deduces a variable
     * name from the class name.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarClass, boolean isArray);

    /**
     * Adds a new member variable for the class.
     * @param mVarName the name of the member variable.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarName, String mVarClass, boolean isArray);

    /**
     * Convenience methods since velocity does not understand the conditional
     * ""== null"". Returns true if this class implements an interface.
     * @return true if this class implements an interface else false.
     */
    public boolean hasInterface();

    /**
     * Convenience method since velocity does not understand the conditional
     * ""== null"". Returns true if this class inherits from a superclass.
     * @return true if this class has a superclass, else false.
     */
    public boolean hasSuperClass();
}
","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {

	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with a null interface name.
	* The method should return false.
	*/
	@Test
	void testHasInterface_0() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(null);
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with an empty interface name.
	* The method should return false.
	*/
	@Test
	void testHasInterface_1() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface("""");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with a whitespace interface name.
	* The method should return false.
	*/
	@Test
	void testHasInterface_2() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface("" "");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with a tab interface name.
	* The method should return false.
	*/
	@Test
	void testHasInterface_3() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""\t"");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with a newline interface name.
	* The method should return false.
	*/
	@Test
	void testHasInterface_4() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""\n"");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with a carriage return interface name.
	* The method should return false.
	*/
	@Test
	void testHasInterface_5() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""\r"");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with a form feed interface name.
	* The method should return false.
	*/
	@Test
	void testHasInterface_6() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""\f"");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with a backspace interface name.
	* The method should return false.
	*/
	@Test
	void testHasInterface_7() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""\b"");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with a non-empty interface name.
	* The method should return true.
	*/
	@Test
	void testHasInterface_8() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""java.lang.Runnable"");
		assertTrue(javaSource.hasInterface());
	}
	
	/**
	* Test case for the {@link JavaSource#hasInterface()} method.
	* The test case tests the method with a non-empty interface name.
	* The method should return true.
	*/
	@Test
	void testHasInterface_9() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""java.lang.Runnable"");
		assertTrue(javaSource.hasInterface());
	}
}

// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {
		
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* The test case tests the method with a null superclass name.
	* The method should return false.
	*/
	@Test
	void testHasSuperClass_0() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(null);
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* The test case tests the method with an empty superclass name.
	* The method should return false.
	*/
	@Test
	void testHasSuperClass_1() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass("""");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* The test case tests the method with a whitespace superclass name.
	* The method should return false.
	*/
	@Test
	void testHasSuperClass_2() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass("" "");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* The test case tests the method with a tab superclass name.
	* The method should return false.
	*/
	@Test
	void testHasSuperClass_3() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""\t"");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* The test case tests the method with a newline superclass name.
	* The method should return false.
	*/
	@Test
	void testHasSuperClass_4() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""\n"");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* The test case tests the method with a carriage return superclass name.
	* The method should return false.
	*/
	@Test
	void testHasSuperClass_5() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""\r"");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* The test case tests the method with a form feed superclass name.
	* The method should return false.
	*/
	@Test
	void testHasSuperClass_6() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""\f"");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* The test case tests the method with a backspace superclass name.
	"
cmpl-6x57RvsRKlJabDRAcT7XDjvZZfhT9,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_1Test.java,56.55882692337036,length,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    private String packageName = null;

    private String classJavadocs = null;

    private String className = null;

    private String superClass = null;

    private String interfaceName = null;

    private List memberVariables = new ArrayList();

    private boolean hasSuperClass = false;

    private boolean isInterface = false;

    /**
     * Returns the package name for the class.
     * @return the package name for the class.
     */
    public String getPackageName();

    /**
     * Allows setting the package name for the class.
     * @param packageName the package name to set.
     */
    public void setPackageName(String packageName);

    /**
     * Returns the class javadocs for this class.
     * @return the class javadocs for this class.
     */
    public String getClassJavadocs();

    /**
     * Allows setting the class javadocs for this class.
     * @param classJavadocs the class level javadocs to set.
     */
    public void setClassJavadocs(String classJavadocs);

    /**
     * Returns the class name.
     * @return the class name.
     */
    public String getClassName();

    /**
     * Sets the class name.
     * @param className the class name.
     */
    public void setClassName(String className);

    /**
     * Gets the superclass name for this class.
     * @return the superclass for this class.
     */
    public String getSuperClass();

    /**
     * Sets the superclass name if applicable.
     * @param superClass the super class name to set.
     */
    public void setSuperClass(String superClass);

    /**
     * Gets the fully qualified interface for this class if specified,
     * @return the interface name for this class.
     */
    public String getInterface();

    /**
     * Sets the fully qualified interface name for this class.
     * @param interfaceName the fully qualified interface name for this class.
     */
    public void setInterface(String interfaceName);

    /**
     * Returns a list of member variable objects in this class.
     * @return a list of member variable objects in this class.
     */
    public List getMemberVariables();

    /**
     * Returns the number of member variables for this class.
     * @return the number of member variables.
     */
    public int getNumberOfMemberVariables();

    /**
     * Adds a new member variable object for the class. Deduces a variable
     * name from the class name.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarClass, boolean isArray);

    /**
     * Adds a new member variable for the class.
     * @param mVarName the name of the member variable.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarName, String mVarClass, boolean isArray);

    /**
     * Convenience methods since velocity does not understand the conditional
     * ""== null"". Returns true if this class implements an interface.
     * @return true if this class implements an interface else false.
     */
    public boolean hasInterface();

    /**
     * Convenience method since velocity does not understand the conditional
     * ""== null"". Returns true if this class inherits from a superclass.
     * @return true if this class has a superclass, else false.
     */
    public boolean hasSuperClass();
}
","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {

	/**
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	* Test case 1 for method {@link JavaSource#hasSuperClass()}.
	"
cmpl-6x58U8DP0cIQ1gb7WcizdlG2kbVzD,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDecoder.java,70.69687414169312,length,"// IFXDecoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;

/**
 * Decodes an IFX XML String to its equivalent Framework bean.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXDecoder {

    private ResourceBundle bundle;

    /**
     * Creates an IFXDecoder object.
     */
    public IFXDecoder() {
    }

    /**
     * Decodes the element into its equivalent IFX XML representation.
     * @param element the Element to decode.
     * @return an IFXObject.
     * @exception IFXException wrapper for underlying exception.
     */
    public IFXObject decode(Element element) throws IFXException;

    /**
     * Returns a single setXXX Method object corresponding to the IFXObject
     * and childElement.
     * @param obj the IFXObject.
     * @param childElement the element corresponding to the mutator method.
     * @return a setXXX method object.
     * @exception IFXException if there was a problem getting the mutators.
     */
    private Method getMutator(IFXObject obj, Element childElement) throws IFXException;

    /**
     * Returns a single setXXX Method object corresponding to the IFXObject
     * and childElement name.
     * @param obj the IFXObject.
     * @param childElementName the element name for the mutator method.
     * @return a setXXX method object.
     * @exception IFXException if there was a problem getting the mutators.
     */
    private Method getMutator(IFXObject obj, String elementName) throws IFXException;

    /**
     * Returns the accessor method associated with the given element name.
     * @param obj an IFXObject.
     * @param element the element object.
     * @return a getXXX Method object associated with the element.
     * @exception IFXException wraps the original exception thrown.
     */
    private Method getAccessor(IFXObject obj, Element element) throws IFXException;

    /**
     * Returns the element name from a bean name.
     * @param element the Element representing the bean.
     * @return the element name.
     * @exception IFXException if bean class name could not be found.
     */
    private String getBeanClassName(Element element) throws IFXException;
}
","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains ten unit test cases for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains ten unit test cases for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {

	/**
	* Test case for {@link IFXDecoder#decode(Element)} method.
	* It tests the decoding of an IFX XML String to its equivalent Framework bean.
	* @exception IFXException if there was a problem decoding the IFX XML String.
	*/
	@Test
	public void testDecode() throws IFXException {
		IFXDecoder decoder = new IFXDecoder();
		IFXObject obj = decoder.decode(element);
		assertNotNull(obj);
	}
}

// IFXEncoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;

/**
 * Encodes an IFX Framework bean to its equivalent XML String.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXEncoder {

    private ResourceBundle bundle;

    /**
     * Creates an IFXEncoder object.
     */
    public IFXEncoder() {
    }

    /**
     * Encodes the IFXObject into its equivalent XML String.
     * @param obj the IFXObject to encode.
     * @return an Element.
     * @exception IFXException wrapper for underlying exception.
     */
    public Element encode(IFXObject obj) throws IFXException;

    /**
     * Returns a single getXXX Method object corresponding to the IFXObject
     * and childElement.
     * @param obj the IFXObject.
     * @param childElement the element corresponding to the accessor method.
     * @return a getXXX method object.
     * @exception IFXException if there was a problem getting the accessors.
     */
    private Method getAccessor(IFXObject obj, Element childElement) throws IFXException;

    /**
     * Returns a single getXXX Method object corresponding to the IFXObject
     * and childElement name.
     * @param obj the IFXObject.
     * @param childElementName the element name for the accessor method.
     * @return a getXXX method object.
     * @exception IFXException if there was a problem getting the accessors.
     */
    private Method getAccessor(IFXObject obj, String elementName) throws IFXException;

    /**
     * Returns the element name from a bean name.
     * @param element the Element representing the bean.
     * @return the element name.
     * @exception IFXException if bean class name could not be found.
     */
    private String getBeanClassName(Element element) throws IFXException;
}

// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains ten unit test cases for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {
		
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of an IFX Framework bean to its equivalent XML String.
	* @exception IFXException if there was a problem encoding the IFX Framework bean.
	*/
	@Test
	public void testEncode() throws IFXException {
		IFXEncoder encoder = new IFXEncoder();
		Element element = encoder.encode(obj);
		assertNotNull(element);
	}
}

// IFXException.java
package org.sourceforge.ifx.utils;

/**
 * Wrapper for all exceptions thrown by the IFX Framework.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXException extends Exception {

    /**
     * Creates an IFXException object.
     */
    public IFXException() {
        super();
    }

    /**
     * Creates an IFXException object.
     * @param message the exception message.
     */
    public IFXException(String message) {
        super(message);
    }

    /**
     * Creates an IFXException object.
     * @param message the exception message.
     * @param cause the original exception.
     */
    public IFXException(String message, Throwable cause) {
        super(message, cause);
    }

    /**
     * Creates an IFXException object.
     * @param cause the original exception.
     */
    public IFXException(Throwable cause) {
        super(cause);
    }
}

// IFXExceptionTest.java
package org.sourceforge.ifx.utils;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXException}.
* It contains ten unit test cases for the {@link IFXException#IFXException()} method.
*/
class IFXExceptionTest {
		
	/**
	* Test case for {@link IFXException#IFXException()} method.
	* It tests the creation of an IFXException object.
	*/
	@Test
	public void testIFXException() {
		IFXException exception = new IFXException();
		assertNotNull(exception);
	}
}

// IFXObject.java
package org.sourceforge.ifx.basetypes;

import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.jdom.Element;

/**
 * Base class for all IFX Framework beans.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXObject {

    private ResourceBundle bundle;

    /**
     * Creates an IFXObject object.
     */
    public IFXObject() {
    }

    /**
     * Returns the element name from a bean name.
     * @param element the Element representing the bean.
     * @return the element name.
     * @exception IFXException if bean class name could not be found.
     */
    private String getBeanClassName(Element element) throws IFXException;
}

// IFXObjectTest.java
package org.sourceforge.ifx.basetypes;

import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXObject}.
* It contains ten unit test cases for the {@link IFXObject#IFXObject()} method.
*/
class IFXObjectTest {
		
	/**
	* Test case for {@link IFXObject#IFXObject()} method.
	* It tests the creation of an IFXObject object.
	*/
	@Test
	public void testIFXObject() {
		"
cmpl-6x59cwglMjgBG6l3XyI8dH4K5eIKm,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_0Test.java,60.126436948776245,length,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * System default Line separator string.
     */
    public static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");

    /**
     * Builds a JDOM Document object from an IFXObject.
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException;

    /**
     * Writes a Document object to the specified output stream.
     * @param doc a JDOM Document object.
     * @param indentSize the size of the indent in the output. A value of
     * zero implies no indentation.
     * @param lineSeparator the line separator for the output. A value of
     * null implies no line separators and no newlines in the output. To use
     * the system default, use DEFAULT_LINE_SEPARATOR.
     * @param ostream the OutputStream to write the formatted output to.
     * @exception IFXException if there was a problem writing the Document.
     */
    public static void write(Document doc, int indentSize, String lineSeparator, OutputStream ostream) throws IFXException;

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException;

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException;
}
","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {

	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_0() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = null;
		String namespaceURI = null;
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_1() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_2() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = """";
		String namespaceURI = null;
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_3() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = null;
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_4() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_5() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = """";
		String namespaceURI = null;
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_6() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = null;
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_7() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_8() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = """";
		String namespaceURI = null;
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_9() throws IFXException {
		IFXObject obj = null;
		String namespacePrefix = null;
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
}

// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
*/
class IFXDocumentHandler_1Test {
		
	/**
	* Test case for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* @throws IFXException if there was a problem writing the Document.
	*/
	@Test
	void testWrite_0() throws IFXException {
		Document doc = null;
		int indentSize = 0;
		String lineSeparator = null;
		OutputStream ostream = null;
		IFXDocumentHandler.write(doc, indentSize, lineSeparator, ostream);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* @throws IFXException if there was a problem writing the Document.
	*/
	@Test
	void testWrite_1() throws IFXException {
		Document doc = null;
		int indentSize = 0;
		String lineSeparator = """";
		OutputStream ostream = null;
		IFXDocumentHandler.write(doc, indentSize, lineSeparator, ostream);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* @throws IFXException if there was a problem writing the Document.
	*/
	@Test
	void testWrite_2() throws IFXException {
		Document doc = null;
		int indentSize = 0;
		String lineSeparator = null;
		OutputStream ostream = null;
		IFXDocumentHandler.write(doc, indentSize, lineSeparator, ostream);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method"
cmpl-6x5AbvUcJUh8UdSY98Q1URuB8kx4p,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_1Test.java,45.22964000701904,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * System default Line separator string.
     */
    public static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");

    /**
     * Builds a JDOM Document object from an IFXObject.
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException;

    /**
     * Writes a Document object to the specified output stream.
     * @param doc a JDOM Document object.
     * @param indentSize the size of the indent in the output. A value of
     * zero implies no indentation.
     * @param lineSeparator the line separator for the output. A value of
     * null implies no line separators and no newlines in the output. To use
     * the system default, use DEFAULT_LINE_SEPARATOR.
     * @param ostream the OutputStream to write the formatted output to.
     * @exception IFXException if there was a problem writing the Document.
     */
    public static void write(Document doc, int indentSize, String lineSeparator, OutputStream ostream) throws IFXException;

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException;

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException;
}
","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {

	/**
	* Test case for {@link IFXDocumentHandler#parse(Document)} method.
	* @throws IFXException if any problems were encountered in parsing.
	*/
	@Test
	void testParse() throws IFXException {
		IFXObject ifxObject = IFXDocumentHandler.parse(new Document());
		assertNotNull(ifxObject);
	}
}

// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {
		
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* @throws IFXExveption if there was a problem reading the document.
	*/
	@Test
	void testRead() throws IFXException {
		Document document = IFXDocumentHandler.read(new InputStream(), true, new Map());
		assertNotNull(document);
	}
}

// IFXDocumentHandler_3Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
*/
class IFXDocumentHandler_3Test {
		
	/**
	* Test case for {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* @throws IFXException if there was a problem writing the Document.
	*/
	@Test
	void testWrite() throws IFXException {
		IFXDocumentHandler.write(new Document(), 0, """", new OutputStream());
	}
}

// IFXDocumentHandler_4Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_4Test {
		
	/**
	* Test case for {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild() throws IFXException {
		Document document = IFXDocumentHandler.build(new IFXObject(), """", """");
		assertNotNull(document);
	}
}"
cmpl-6x5C5CuEYfvzS8pz4ZWLatFfKEvc3,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_2Test.java,115.65850639343262,length,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * System default Line separator string.
     */
    public static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");

    /**
     * Builds a JDOM Document object from an IFXObject.
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException;

    /**
     * Writes a Document object to the specified output stream.
     * @param doc a JDOM Document object.
     * @param indentSize the size of the indent in the output. A value of
     * zero implies no indentation.
     * @param lineSeparator the line separator for the output. A value of
     * null implies no line separators and no newlines in the output. To use
     * the system default, use DEFAULT_LINE_SEPARATOR.
     * @param ostream the OutputStream to write the formatted output to.
     * @exception IFXException if there was a problem writing the Document.
     */
    public static void write(Document doc, int indentSize, String lineSeparator, OutputStream ostream) throws IFXException;

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException;

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException;
}
","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {

	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_1() throws Exception {
		try {
			IFXDocumentHandler.read(null, false, null);
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_2() throws Exception {
		try {
			IFXDocumentHandler.read(null, true, null);
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_3() throws Exception {
		try {
			IFXDocumentHandler.read(null, false, new java.util.HashMap());
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_4() throws Exception {
		try {
			IFXDocumentHandler.read(null, true, new java.util.HashMap());
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_5() throws Exception {
		try {
			IFXDocumentHandler.read(new java.io.ByteArrayInputStream(new byte[0]), false, null);
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_6() throws Exception {
		try {
			IFXDocumentHandler.read(new java.io.ByteArrayInputStream(new byte[0]), true, null);
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_7() throws Exception {
		try {
			IFXDocumentHandler.read(new java.io.ByteArrayInputStream(new byte[0]), false, new java.util.HashMap());
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_8() throws Exception {
		try {
			IFXDocumentHandler.read(new java.io.ByteArrayInputStream(new byte[0]), true, new java.util.HashMap());
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_9() throws Exception {
		try {
			IFXDocumentHandler.read(new java.io.ByteArrayInputStream(new byte[0]), false, new java.util.HashMap());
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testRead_10() throws Exception {
		try {
			IFXDocumentHandler.read(new java.io.ByteArrayInputStream(new byte[0]), true, new java.util.HashMap());
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
}

// IFXDocumentHandler_3Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
*/
class IFXDocumentHandler_3Test {
		
	/**
	* Test case for {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testWrite_1() throws Exception {
		try {
			IFXDocumentHandler.write(null, 0, null, null);
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* Test data: {@code null}.
	* Expected result: {@code NullPointerException}.
	*/
	@Test
	public void testWrite_2() throws Exception {
		try {
			IFXDocumentHandler.write(null, 0, """", null);
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link IFXDocumentHandler#write(Document, int,"
cmpl-6x5DVn0QFK1VbMLOvm3U5V8dxSV1I,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXEncoder.java,76.18900752067566,length,"// IFXEncoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;

/**
 * Encodes an IFXObject to its equivalent IFX XML Element.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXEncoder {

    private ResourceBundle bundle;

    private int xmlIndentSize = 2;

    private String lineSeparator = System.getProperty(""line.separator"");

    private Namespace namespace = Namespace.NO_NAMESPACE;

    /**
     * Creates an IFXEncoder object in the default namespace.
     */
    public IFXEncoder() {
    }

    /**
     * Creates an IFXEncoder in the specified namespace.
     * @param namespacePrefix the namespace prefix to use. If set to null,
     * then the element will be considered to be in the default namespace.
     * @param namespaceURI the URI of the namespace.
     */
    public IFXEncoder(String namespacePrefix, String namespaceURI) {
    }

    /**
     * Builds a JDOM Element for the IFXObject supplied. No validation is
     * performed, regardless of the setting. To validate, use the encode()
     * methods instead.
     * @param obj an IFXObject.
     * @return a JDOM Element.
     * @exception IFXException if an exception was encountered in encoding.
     */
    public Element encode(IFXObject obj) throws IFXException;

    /**
     * Sets the name space for this Document.
     * @param prefix the namespace prefix to use. If null, this namespace
     * will be set to the default namespace.
     * @param nameSpaceURI the String URI of this namespace.
     */
    private void setNamespace(String prefix, String nameSpaceURI);

    /**
     * Return a List of accessor methods for a given IFXObject. The
     * accessors will be ordered in the same order expected by the IFX
     * schema. This ordering is dictated by the ELEMENTS String[] variable.
     * @param obj an IFXObject.
     * @return a List of getXXX Method objects.
     * @exception IFXException wraps the original exception thrown.
     */
    private List getAccessors(IFXObject obj) throws IFXException;

    /**
     * Gets the element name from the object class name. It retrieves the
     * class name portion from the fully qualified class name for the bean,
     * then applies transformations to convert back to dotted form for
     * certain elements.
     * @param obj an IFXObject.
     * @return the name of the element that is represented by this object.
     * @exception IFXException if element name was not found.
     */
    private String getElementName(IFXObject obj) throws IFXException;
}
","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains ten unit test cases for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains ten unit test cases for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {

	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of an IFXObject to its equivalent IFX XML Element.
	* @throws IFXException if an exception was encountered in encoding.
	*/
	@Test
	void testEncode() throws IFXException {
		IFXEncoder encoder = new IFXEncoder();
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertNotNull(element);
	}
}

// IFXException.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;

/**
 * Exception class for IFX.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXException extends Exception {

    private Throwable cause;

    /**
     * Creates an IFXException with the specified message.
     * @param message the message for this exception.
     */
    public IFXException(String message) {
    }

    /**
     * Creates an IFXException with the specified message and cause.
     * @param message the message for this exception.
     * @param cause the cause of this exception.
     */
    public IFXException(String message, Throwable cause) {
    }

    /**
     * Returns the cause of this exception.
     * @return the cause of this exception.
     */
    public Throwable getCause() {
    }
}

// IFXObject.java
package org.sourceforge.ifx.basetypes;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;

/**
 * Base class for all IFX objects.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXObject {

    /**
     * Returns a String representation of this object.
     * @return a String representation of this object.
     */
    public String toString() {
    }
}

// IFXObjectTest.java
package org.sourceforge.ifx.basetypes;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXObject}.
* It contains one unit test case for the {@link IFXObject#toString()} method.
*/
class IFXObjectTest {
		
	/**
	* Test case for {@link IFXObject#toString()} method.
	* It tests the conversion of an IFXObject to its String representation.
	*/
	@Test
	void testToString() {
		IFXObject obj = new IFXObject();
		String str = obj.toString();
		assertNotNull(str);
	}
}

// IFXValidator.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;

/**
 * Validates an IFXObject against the IFX schema.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXValidator {

    private ResourceBundle bundle;

    private int xmlIndentSize = 2;

    private String lineSeparator = System.getProperty(""line.separator"");

    private Namespace namespace = Namespace.NO_NAMESPACE;

    /**
     * Creates an IFXValidator object in the default namespace.
     */
    public IFXValidator() {
    }

    /**
     * Creates an IFXValidator in the specified namespace.
     * @param namespacePrefix the namespace prefix to use. If set to null,
     * then the element will be considered to be in the default namespace.
     * @param namespaceURI the URI of the namespace.
     */
    public IFXValidator(String namespacePrefix, String namespaceURI) {
    }

    /**
     * Validates an IFXObject against the IFX schema.
     * @param obj an IFXObject.
     * @return true if the object is valid, false otherwise.
     * @exception IFXException if an exception was encountered in validation.
     */
    public boolean validate(IFXObject obj) throws IFXException;

    /**
     * Sets the name space for this Document.
     * @param prefix the namespace prefix to use. If null, this namespace
     * will be set to the default namespace.
     * @param nameSpaceURI the String URI of this namespace.
     */
    private void setNamespace(String prefix, String nameSpaceURI);

    /**
     * Return a List of accessor methods for a given IFXObject. The
     * accessors will be ordered in the same order expected by the IFX
     * schema. This ordering is dictated by the ELEMENTS String[] variable.
     * @param obj an IFXObject.
     * @return a List of getXXX Method objects.
     * @exception IFXException wraps the original exception thrown.
     */
    private List getAccessors(IFXObject obj) throws IFXException;

    /**
     * Gets the"
