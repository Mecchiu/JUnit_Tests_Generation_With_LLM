ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wvetHyJQkxIOkmM7fU9yOKD5BDeE,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer0.java,152.31416177749634,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis layout direction
     * @param componentName the name of the component to be found
     * @return an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {

	/**
	 * Test case 1.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component.
	 */
	@Test
	void testGetComponent1() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""FINDLABEL"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JLabel(""Find What:""));
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component.
	 */
	@Test
	void testGetComponent2() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""TEXTFIELD"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JTextField());
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component.
	 */
	@Test
	void testGetComponent3() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""FINDBUTTON"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JButton(""Find""));
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component.
	 */
	@Test
	void testGetComponent4() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""CB11"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Match Case""));
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component.
	 */
	@Test
	void testGetComponent5() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""CB12"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Wrap Around""));
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component.
	 */
	@Test
	void testGetComponent6() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""CB21"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Whole Words""));
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component.
	 */
	@Test
	void testGetComponent7() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""CB22"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Search Backwards""));
	}
	
	/**
	 * Test case 8.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component.
	 */
	@Test
	void testGetComponent8() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""CANSELBUTTON"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JButton(""Cancel""));
	}
	
	/**
	 * Test case 9.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component.
	 */
	@Test
	void testGetComponent9() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());"
cmpl-6wvhMeCZadr4X4N8vS7YhrbWJXeYN,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer1.java,123.97367286682129,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis layout direction
     * @param firstName the name of the first component in the group
     * @param lastName the name of the last component in the group
     * @return an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

	/**
	 * Test case 1.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 */
	@Test
	void test1() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.associate(""D"", new JLabel(""D""));
		gle.associate(""E"", new JLabel(""E""));
		gle.associate(""F"", new JLabel(""F""));
		gle.associate(""G"", new JLabel(""G""));
		gle.associate(""H"", new JLabel(""H""));
		gle.associate(""I"", new JLabel(""I""));
		gle.associate(""J"", new JLabel(""J""));
		gle.associate(""K"", new JLabel(""K""));
		gle.associate(""L"", new JLabel(""L""));
		gle.associate(""M"", new JLabel(""M""));
		gle.associate(""N"", new JLabel(""N""));
		gle.associate(""O"", new JLabel(""O""));
		gle.associate(""P"", new JLabel(""P""));
		gle.associate(""Q"", new JLabel(""Q""));
		gle.associate(""R"", new JLabel(""R""));
		gle.associate(""S"", new JLabel(""S""));
		gle.associate(""T"", new JLabel(""T""));
		gle.associate(""U"", new JLabel(""U""));
		gle.associate(""V"", new JLabel(""V""));
		gle.associate(""W"", new JLabel(""W""));
		gle.associate(""X"", new JLabel(""X""));
		gle.associate(""Y"", new JLabel(""Y""));
		gle.associate(""Z"", new JLabel(""Z""));
		gle.engineer();
		
		FunctionsOnGroup fog = gle.getGroup(Axis.HORIZONTAL, ""A"", ""Z"");
		assertEquals(fog.getFirstName(), ""A"");
		assertEquals(fog.getLastName(), ""Z"");
		assertEquals(fog.getFirstIndex(), 0);
		assertEquals(fog.getLastIndex(), 25);
		assertEquals(fog.getSize(), 26);
		assertEquals(fog.getNames(), ""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		assertEquals(fog.getIndices(), ""0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"");
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 */
	@Test
	void test2() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.associate(""D"", new JLabel(""D""));
		gle.associate(""E"", new JLabel(""E""));
		gle.associate(""F"", new JLabel(""F""));
		gle.associate(""G"", new JLabel(""G""));
		gle.associate(""H"", new JLabel(""H""));
		gle.associate(""I"", new JLabel(""I""));
		gle.associate(""J"", new JLabel(""J""));
		gle.associate(""K"", new JLabel(""K""));
		gle.associate(""L"", new JLabel(""L""));
		gle.associate(""M"", new JLabel(""M""));
		gle.associate(""N"", new JLabel(""N""));
		gle.associate(""O"", new JLabel(""O""));
		gle.associate(""P"", new JLabel(""P""));
		gle.associate(""Q"", new JLabel(""Q""));
		gle.associate(""R"", new JLabel(""R""));
		gle.associate(""S"", new JLabel(""S""));
		gle.associate(""T"", new JLabel(""T""));
		gle.associate(""U"", new JLabel(""U""));
		gle.associate(""V"", new JLabel(""V""));
		gle.associate(""W"", new JLabel(""W""));
		gle.associate(""X"", new JLabel(""X""));
		gle.associate(""Y"", new JLabel(""Y""));
		gle.associate(""Z"", new JLabel(""Z""));
		gle.engineer();
		
		FunctionsOnGroup fog = gle.getGroup(Axis.HORIZONTAL, ""A"", ""Z"");
		assertEquals(fog.getFirstName(), ""A"");
		assertEquals(fog.getLastName(), ""Z"");
		assertEquals(fog.getFirstIndex(), 0);
		assertEquals(fog.getLastIndex(), 25);
		assertEquals(fog.getSize(), 26);
		assertEquals(fog.getNames(), ""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		assertEquals(fog.getIndices(), ""0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"");
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 */
	@Test
	void test3() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.associate(""D"", new JLabel(""D""));
		gle.associate(""E"", new JLabel(""E""));
		gle.associate(""F"", new JLabel(""F""));
		gle.associate(""G"", new JLabel(""G""));
		gle.associate(""H"", new JLabel(""H""));
		gle.associate(""I"", new JLabel(""I""));
		gle.associate(""J"", new JLabel(""J""));
		gle.associate(""K"", new JLabel(""K""));
		gle.associate(""L"", new JLabel(""L""));
		gle.associate(""M"", new JLabel(""M""));
		gle.associate(""N"", new JLabel(""N""));
		gle.associate(""O"", new JLabel(""O""));
		gle.associate(""P"", new JLabel(""P""));
		gle.associate(""Q"", new JLabel(""Q""));
		gle.associate(""R"", new JLabel(""R""));
		gle.associate(""S"", new JLabel(""S""));
		gle.associate(""T"", new JLabel(""T""));
		gle.associate(""U"", new JLabel(""U""));
		gle.associate(""V"", new JLabel(""V""));
		gle.associate(""W"", new JLabel(""W""));
		gle.associate(""X"", new JLabel(""X""));
		gle.associate(""Y"", new JLabel(""Y""));
		gle.associate(""Z"", new JLabel(""Z""));
		gle.engineer();
		
		FunctionsOnGroup fog = gle.getGroup(Axis.HORIZONTAL, ""A"", ""Z"");
		assertEquals(fog.getFirstName(), ""A"");
		assertEquals(fog.getLastName(), ""Z"");
		assertEquals(fog.getFirstIndex(), 0);
		assertEquals(fog.getLastIndex(), 25);
		assertEquals(fog.getSize(), 26);
		assertEquals(fog.getNames(), ""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		assertEquals(fog.getIndices(), ""0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"");
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 */
	@Test
	void test4() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.associate(""D"", new JLabel(""D""));
		gle.associate(""E"", new JLabel(""E""));
		gle.associate(""F"", new JLabel(""F""));
		gle.associate(""G"", new JLabel(""G""));
		gle.associate(""H"", new JLabel(""H""));
		gle.associate(""I"", new JLabel(""I""));
		gle.associate(""J"", new JLabel(""J""));
		gle.associate(""K"", new JLabel(""K""));
		gle.associate(""L"", new JLabel(""L""));
		gle.associate(""M"", new JLabel(""M""));
		gle.associate(""N"", new JLabel(""N""));
		gle.associate(""O"", new JLabel(""O""));
		gle.associate(""P"", new JLabel(""P""));
		gle.associate(""Q"", new JLabel(""Q""));
		gle.associate(""R"", new JLabel(""R""));
		gle.associate(""S"", new JLabel(""S""));
		gle.associate(""T"", new JLabel(""T""));
		gle.associate(""U"", new JLabel(""U""));
		gle.associate(""V"", new JLabel(""V""));
		gle.associate(""W"", new JLabel(""W""));
		gle.associate(""X"", new JLabel(""X""));
		gle.associate(""Y"", new JLabel(""Y""));
		gle.associate(""Z"", new JLabel(""Z""));
		gle.engineer();
		
		FunctionsOnGroup fog = gle.getGroup(Axis.HORIZONTAL, ""A"", ""Z"");
		assertEquals(fog.getFirstName(), ""A"");
		assertEquals(fog.getLastName(), ""Z"");
		assertEquals(fog.getFirstIndex(), 0);
		assertEquals(fog.getLastIndex(), 25);
		assertEquals(fog.getSize(), 26);
		assertEquals(fog.getNames(), ""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		assertEquals(fog.getIndices(), ""0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"");
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 */
	@Test
	void test5() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.associate(""D"", new JLabel(""D""));
		gle.associate(""E"", new JLabel(""E""));
		gle.associate(""F"", new JLabel(""F""));
		gle.associate(""G"", new JLabel(""G""));
		gle.associate(""H"", new JLabel(""H""));
		gle.associate(""I"", new JLabel(""I""));
		gle.associate(""J"", new JLabel(""J""));
		gle.associate(""K"", new JLabel(""K""));
		gle.associate(""L"", new JLabel(""L""));
		gle.associate(""M"", new JLabel(""M""));
		gle.associate(""N"", new JLabel(""N""));
		gle.associate(""O"", new JLabel(""O""));
		gle.associate(""P"", new JLabel(""P""));
		gle.associate(""Q"", new JLabel(""Q""));
		gle.associate(""R"", new"
5879c6aa-4980-4db9-9312-2ec9488c89ee,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer2.java,-1,"ERROR - HTTP code 502 from API (<html>
<head><title>502 Bad Gateway</title></head>
<body>
<center><h1>502 Bad Gateway</h1></center>
<hr><center>nginx</center>
</body>
</html>
)","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis layout direction
     * @param firstName the name of the first component in the group
     * @param lastName the name of the last component in the group
     * @return an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {
"
cmpl-6wvqTdzsLFst22ntpMXFP3fpLVfxs,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer3.java,136.63584566116333,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis layout direction
     * @param firstName the name of the first component in the group
     * @param lastName the name of the last component in the group
     * @return an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

	/**
	 * Test case 1.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup1() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""A"", ""C"");
		
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""C"");
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup2() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""B"", ""B"");
		
		assertEquals(fosg.getFirstName(), ""B"");
		assertEquals(fosg.getLastName(), ""B"");
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup3() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""C"", ""A"");
		
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""C"");
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup4() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""A"", ""B"");
		
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""B"");
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup5() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""B"", ""C"");
		
		assertEquals(fosg.getFirstName(), ""B"");
		assertEquals(fosg.getLastName(), ""C"");
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup6() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""A"", ""A"");
		
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""A"");
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup7() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""C"", ""C"");
		
		assertEquals(fosg.getFirstName(), ""C"");
		assertEquals(fosg.getLastName(), ""C"");
	}
	
	/**
	 * Test case 8.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup8() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""C"", ""B"");
		
		assertEquals(fosg.getFirstName(), ""B"");
		assertEquals(fosg.getLastName(), ""C"");
	}
	
	/**
	 * Test case 9.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup9() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""B"", ""A"");
		
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""B"");
	}
	
	/**
	 * Test case 10.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup10() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""C"", ""A"");
		
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""C"");
	}
}

// FunctionsOnSequentialGroup.java
package glengineer.agents;

import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code FunctionsOnSequentialGroup} is an interface for adjusting
 * a sequential group and adding gaps into it.
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public interface FunctionsOnSequentialGroup {

    /**
     * Returns the name of the first component in the group.
     *
     * @return the name of the first component in the group
     */
    String getFirstName();

    /**
     * Returns the name of the last component in the group.
     *
     * @return the name of the last component in the group
     */
    String getLastName();

    /**
     * Adds a gap of the specified type and length
     * before the first component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addPrecedingGap(ComponentPlacement type, int length);

    /**
     * Adds a gap of the specified type and length
     * after the last component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addTrailingGap(ComponentPlacement type, int length);

    /**
     * Adds a gap of the specified type and length
     * before the first component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addPrecedingUnrelatedGap(int length, int maxLength);

    /**
     * Adds a gap of the specified type and length
     * after the last component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addTrailingUnrelatedGap(int length, int maxLength);

    /**
     * Adds a gap of the specified type and length
     * before the first component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addPrecedingRelatedGap(int length, int maxLength);

    /**
     * Adds a gap of the specified type and length
     * after the last component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addTrailingRelatedGap(int length, int maxLength);

    /**
     * Adds a gap of the specified type and length
     * before the first component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addPrecedingGap(int length, int maxLength);

    /**
     * Adds a gap of the specified type and length
     * after the last component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addTrailingGap(int length, int maxLength);

    /**
     * Adds a gap of the specified type and length
     * before the first component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addPrecedingGap(int length);

    /**
     * Adds a gap of the specified type and length
     * after the last component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addTrailingGap(int length);

    /**
     * Adds a gap of the specified type and length
     * before the first component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addPrecedingUnrelatedGap(int length);

    /**
     * Adds a gap of the specified type and length
     * after the last component in the group.
     *
     * @param type the type of the gap
     * @param length the length of the gap
     * @return this interface
     */
    FunctionsOnSequentialGroup addTrailingUnrelatedGap(int length);

    /**
     * Adds a gap of the specified type and length
     * before the"
cmpl-6wvuvRHggXhxSUwH24frSfeAfzXiN,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer4.java,287.02713561058044,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis layout direction
     * @return the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {

		/**
		* Test case 1.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						getContentPane(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertEquals(gle.getTopSequentialGroup(Axis.HORIZONTAL).toString(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "");
				assertEquals(gle.getTopSequentialGroup(Axis.VERTICAL).toString(),
						""          --------------+             "" +
						""           CB11   CB12  | CANSELBUTTON"" +
						""                        |             "" +
						""           CB21   CB22  |             "");
		}
		
		/**
		* Test case 2.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						getContentPane(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertEquals(gle.getTopSequentialGroup(Axis.HORIZONTAL).toString(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "");
				assertEquals(gle.getTopSequentialGroup(Axis.VERTICAL).toString(),
						""          --------------+             "" +
						""           CB11   CB12  | CANSELBUTTON"" +
						""                        |             "" +
						""           CB21   CB22  |             "");
		}
		
		/**
		* Test case 3.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						getContentPane(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertEquals(gle.getTopSequentialGroup(Axis.HORIZONTAL).toString(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "");
				assertEquals(gle.getTopSequentialGroup(Axis.VERTICAL).toString(),
						""          --------------+             "" +
						""           CB11   CB12  | CANSELBUTTON"" +
						""                        |             "" +
						""           CB21   CB22  |             "");
		}
		
		/**
		* Test case 4.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase4() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						getContentPane(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertEquals(gle.getTopSequentialGroup(Axis.HORIZONTAL).toString(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "");
				assertEquals(gle.getTopSequentialGroup(Axis.VERTICAL).toString(),
						""          --------------+             "" +
						""           CB11   CB12  | CANSELBUTTON"" +
						""                        |             "" +
						""           CB21   CB22  |             "");
		}
		
		/**
		* Test case 5.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase5() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						getContentPane(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertEquals(gle.getTopSequentialGroup(Axis.HORIZONTAL).toString(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "");
				assertEquals(gle.getTopSequentialGroup(Axis.VERTICAL).toString(),
						""          --------------+             "" +
						""           CB11   CB12  | CANSELBUTTON"" +
						""                        |             "" +
						""           CB21   CB22  |             "");
		}
		
		/**
		* Test case 6.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase6() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						getContentPane(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				"
cmpl-6wvxJt6H6509aGaR5Ky5OHZdF6HeF,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent0.java,172.55671644210815,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly();
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {

	/**
	 * Test case 1.
	 * The parallel group agent contains gaps only.
	 */
	@Test
	void testContainsGapsOnly1() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		assertTrue(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 2.
	 * The parallel group agent contains gaps and elements.
	 */
	@Test
	void testContainsGapsOnly2() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addElement(new ElementAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 3.
	 * The parallel group agent contains gaps and parallel groups.
	 */
	@Test
	void testContainsGapsOnly3() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addParallelGroup(new ParallelGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 4.
	 * The parallel group agent contains gaps and sequential groups.
	 */
	@Test
	void testContainsGapsOnly4() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addSequentialGroup(new SequentialGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 5.
	 * The parallel group agent contains gaps and elements and parallel groups.
	 */
	@Test
	void testContainsGapsOnly5() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addElement(new ElementAgent());
		agent.addParallelGroup(new ParallelGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 6.
	 * The parallel group agent contains gaps and elements and sequential groups.
	 */
	@Test
	void testContainsGapsOnly6() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addElement(new ElementAgent());
		agent.addSequentialGroup(new SequentialGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 7.
	 * The parallel group agent contains gaps and parallel groups and sequential groups.
	 */
	@Test
	void testContainsGapsOnly7() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addParallelGroup(new ParallelGroupAgent());
		agent.addSequentialGroup(new SequentialGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 8.
	 * The parallel group agent contains gaps and elements and parallel groups and sequential groups.
	 */
	@Test
	void testContainsGapsOnly8() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addElement(new ElementAgent());
		agent.addParallelGroup(new ParallelGroupAgent());
		agent.addSequentialGroup(new SequentialGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 9.
	 * The parallel group agent contains elements only.
	 */
	@Test
	void testContainsGapsOnly9() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addElement(new ElementAgent());
		agent.addElement(new ElementAgent());
		agent.addElement(new ElementAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 10.
	 * The parallel group agent contains parallel groups only.
	 */
	@Test
	void testContainsGapsOnly10() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addParallelGroup(new ParallelGroupAgent());
		agent.addParallelGroup(new ParallelGroupAgent());
		agent.addParallelGroup(new ParallelGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
}

// ParallelGroupSettings.java
package glengineer.agents.settings;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupSettings {

    /**
     * The alignment of this parallel group.
     */
    public Alignment alignment;

    /**
     * The resizability of this parallel group.
     */
    public boolean resizable;

    /**
     * The preferred size of this parallel group.
     */
    public int preferredSize;

    /**
     * The minimum size of this parallel group.
     */
    public int minimumSize;

    /**
     * The maximum size of this parallel group.
     */
    public int maximumSize;

    /**
     * The alignment of this parallel group.
     */
    public Alignment getAlignment();

    /**
     * The resizability of this parallel group.
     */
    public boolean isResizable();

    /**
     * The preferred size of this parallel group.
     */
    public int getPreferredSize();

    /**
     * The minimum size of this parallel group.
     */
    public int getMinimumSize();

    /**
     * The maximum size of this parallel group.
     */
    public int getMaximumSize();
}

// SequentialGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class SequentialGroupAgent {

    /**
     * Adds a gap to this sequential group agent.
     */
    public void addGap(int size);

    /**
     * Adds an element to this sequential group agent.
     */
    public void addElement(ElementAgent element);

    /**
     * Adds a parallel group to this sequential group agent.
     */
    public void addParallelGroup(ParallelGroupAgent parallelGroup);

    /**
     * Adds a sequential group to this sequential group agent.
     */
    public void addSequentialGroup(SequentialGroupAgent sequentialGroup);

    /**
     * Adds a gap to this sequential group agent.
     */
    public void addGap(int size, FunctionsOnGroup functions);

    /**
     * Adds an element to this sequential group agent.
     */
    public void addElement(ElementAgent element, FunctionsOnGroup functions);

    /**
     * Adds a parallel group to this sequential group agent.
     */
    public void addParallelGroup(ParallelGroupAgent parallelGroup, FunctionsOnGroup functions);

    /**
     * Adds a sequential group to this sequential group agent.
     */
    public void addSequentialGroup(SequentialGroupAgent sequentialGroup, FunctionsOnGroup functions);

    /**
     * Adds a gap to this sequential group agent.
     */
    public void addGap(int size, FunctionsOnParallelGroup functions);

    /**
     * Adds an element to this sequential group agent.
     */
    public void addElement(ElementAgent element, FunctionsOnParallelGroup functions);

    /**
     * Adds a parallel group to this sequential group agent.
     */
    public void addParallelGroup(ParallelGroupAgent parallelGroup, FunctionsOnParallelGroup functions);

    /**
     * Adds a sequential group to this sequential group agent.
     */
    public void addSequentialGroup(SequentialGroupAgent sequentialGroup, FunctionsOnParallelGroup functions);

    /**
     * Adds a gap to this sequential group agent.
     */
    public void addGap(int size, FunctionsOnParallelGroupAndElement functions);

    /**
     * Adds an element to this sequential group agent.
     */
    public void addElement(ElementAgent element, FunctionsOnParallelGroupAndElement functions);

    /**
     * Adds a parallel group to this sequential group agent.
     */
    public void addParallelGroup(ParallelGroupAgent parallelGroup, FunctionsOnParallelGroupAndElement functions);

    /**
     * Adds a sequential group to this sequential group agent.
     */
    public void addSequentialGroup(SequentialGroupAgent sequentialGroup, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings();

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnParallelGroup functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions);

    /**
     * Returns the settings of this sequential group agent.
     */
    public SequentialGroupSettings getSettings(FunctionsOnGroup functions, FunctionsOnParallelGroup functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAndElement functions, FunctionsOnParallelGroupAnd"
cmpl-6ww05SWE6uFUdob8LFEJ9TETHGIbU,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent1.java,148.63502740859985,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @param creatorAndAdder ��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return ������, ������������ �� ���������������
     * 							�����������.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {

	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code null}.
	 */
	@Test
	void testGroupContent_NullAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return null;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(Alignment.LEADING, group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code Alignment.LEADING}.
	 */
	@Test
	void testGroupContent_LeadingAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return Alignment.LEADING;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(Alignment.LEADING, group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code Alignment.TRAILING}.
	 */
	@Test
	void testGroupContent_TrailingAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return Alignment.TRAILING;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(Alignment.TRAILING, group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code Alignment.CENTER}.
	 */
	@Test
	void testGroupContent_CenterAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return Alignment.CENTER;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(Alignment.CENTER, group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code Alignment.BASELINE}.
	 */
	@Test
	void testGroupContent_BaselineAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return Alignment.BASELINE;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(Alignment.BASELINE, group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getResizable()} method returns {@code true}.
	 */
	@Test
	void testGroupContent_Resizable() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public boolean getResizable() {
				return true;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertTrue(group.isResizable());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getResizable()} method returns {@code false}.
	 */
	@Test
	void testGroupContent_NotResizable() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public boolean getResizable() {
				return false;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertFalse(group.isResizable());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getElements()} method returns {@code null}.
	 */
	@Test
	void testGroupContent_NullElements() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Iterator<Object> getElements() {
				return null;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(0, group.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getElements()} method returns an empty iterator.
	 */
	@Test
	void testGroupContent_EmptyElements() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Iterator<Object> getElements() {
				return new Iterator<Object>() {
					@Override
					public boolean hasNext() {
						return false;
					}
					@Override
					public Object next() {
						return null;
					}
				};
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(0, group.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getElements()} method returns an iterator with one element.
	 */
	@Test
	void testGroupContent_OneElement() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Iterator<Object> getElements() {
				return new Iterator<Object>() {
					private int count = 1;
					@Override
					public boolean hasNext() {
						return count > 0;
					}
					@Override
					public Object next() {
						count--;
						return new Object();
					}
				};
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(1, group.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getElements()} method returns an iterator with two elements.
	 */
	@Test
	void testGroupContent_TwoElements() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Iterator<Object> getElements() {
				return new Iterator<Object>() {
					private int count = 2;
					@Override
					public boolean hasNext() {
						return count > 0;
					}
					@Override
					public Object next() {
						count--;
						return new Object();
					}
				};
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(2, group.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getElements()} method returns an iterator with three elements.
	 */
	@Test
	void testGroupContent_ThreeElements() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Iterator<Object> getElements() {
				return new Iterator<Object>() {
					private int count = 3;
					@Override
					public boolean hasNext() {
						return count > 0;
					}
					@Override
					public Object next() {
						count--;
						return new Object();
					}
				};
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(Alignment alignment) {
				return new ParallelGroup(alignment);
			}
		});
		assertEquals(3, group.getSize());
	}
}

// ParallelGroupSettings.java
package glengineer.agents.settings;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �������������� ������������ ������.
 */
public interface ParallelGroupSettings extends GroupSettings {

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @return �������������� ���������� � ����� ������������ ������
     * 							� ���������� �.
     */
    public Iterator<Object> getElements();

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @return �������������� ���������� � ����� ������������ ������
     * 							� ���������� �.
     */
    public Alignment getAlignment();

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @return �������������� ���������� � ����� ������������ ������
     * 							� ���������� �.
    "
cmpl-6ww2Ujntz0xN6vaJtifJrLXAlgSVD,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java,157.19506001472473,length,"// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * �����, �������������� ���������������� ������.
 */
public class SequentialGroupAgent extends GroupAgent {

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������
     * � ���������� �.
     *
     * @param creatorAndAdder ��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return ������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);
}
","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {

	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called once.
	*/
	@Test
	void testGroupContent_1() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called twice.
	*/
	@Test
	void testGroupContent_2() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called three times.
	*/
	@Test
	void testGroupContent_3() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called four times.
	*/
	@Test
	void testGroupContent_4() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called five times.
	*/
	@Test
	void testGroupContent_5() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called six times.
	*/
	@Test
	void testGroupContent_6() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called seven times.
	*/
	@Test
	void testGroupContent_7() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called eight times.
	*/
	@Test
	void testGroupContent_8() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called nine times.
	*/
	@Test
	void testGroupContent_9() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ComponentGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
"
cmpl-6ww51WBIHIXbqinBeEVSmQIlJVTq1,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java,154.1002311706543,length,"// TopSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * �����, �������������� ���������������� ������ �������� ������.
 * <p>
 * ��������� ��������� {@code FunctionsOnTopSequentialGroup}
 * ���������� �������������� ������������ �����������
 * � ������ � � ����� ���������������� ������ �������� ������.
 */
public class TopSequentialGroupAgent extends SequentialGroupAgent {

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������,
     * ��������, ���� ����, ������������ ���������� � ������ � � �����,
     * � ���������� ���������� ������.
     * <p>
     * ����������� ����� {@code TopSequentialGroupAgent.groupContent()},
     * �������� ������ � ������������� ������������.
     *
     * @param creatorAndAdder ��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return ������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);
}
","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {

	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the first element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the first element.
	 */
	@Test
	void testGroupContent_SequentialGroupAsFirstElement() {
		SequentialGroupAgent agent = new TopSequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public SequentialGroup addGroup(SequentialGroup group) {
				return group.addGroup(new SequentialGroup());
			}
		};
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(1, result.getComponents().length);
		assertTrue(result.getComponents()[0] instanceof SequentialGroup);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the second element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the second element.
	 */
	@Test
	void testGroupContent_SequentialGroupAsSecondElement() {
		SequentialGroupAgent agent = new TopSequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public SequentialGroup addGroup(SequentialGroup group) {
				group.addComponent(new Object());
				return group.addGroup(new SequentialGroup());
			}
		};
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(2, result.getComponents().length);
		assertTrue(result.getComponents()[1] instanceof SequentialGroup);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the third element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the third element.
	 */
	@Test
	void testGroupContent_SequentialGroupAsThirdElement() {
		SequentialGroupAgent agent = new TopSequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public SequentialGroup addGroup(SequentialGroup group) {
				group.addComponent(new Object());
				group.addComponent(new Object());
				return group.addGroup(new SequentialGroup());
			}
		};
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(3, result.getComponents().length);
		assertTrue(result.getComponents()[2] instanceof SequentialGroup);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the fourth element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the fourth element.
	 */
	@Test
	void testGroupContent_SequentialGroupAsFourthElement() {
		SequentialGroupAgent agent = new TopSequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public SequentialGroup addGroup(SequentialGroup group) {
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				return group.addGroup(new SequentialGroup());
			}
		};
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(4, result.getComponents().length);
		assertTrue(result.getComponents()[3] instanceof SequentialGroup);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the fifth element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the fifth element.
	 */
	@Test
	void testGroupContent_SequentialGroupAsFifthElement() {
		SequentialGroupAgent agent = new TopSequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public SequentialGroup addGroup(SequentialGroup group) {
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				return group.addGroup(new SequentialGroup());
			}
		};
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(5, result.getComponents().length);
		assertTrue(result.getComponents()[4] instanceof SequentialGroup);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the sixth element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the sixth element.
	 */
	@Test
	void testGroupContent_SequentialGroupAsSixthElement() {
		SequentialGroupAgent agent = new TopSequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public SequentialGroup addGroup(SequentialGroup group) {
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				return group.addGroup(new SequentialGroup());
			}
		};
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(6, result.getComponents().length);
		assertTrue(result.getComponents()[5] instanceof SequentialGroup);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the seventh element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the seventh element.
	 */
	@Test
	void testGroupContent_SequentialGroupAsSeventhElement() {
		SequentialGroupAgent agent = new TopSequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public SequentialGroup addGroup(SequentialGroup group) {
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				return group.addGroup(new SequentialGroup());
			}
		};
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(7, result.getComponents().length);
		assertTrue(result.getComponents()[6] instanceof SequentialGroup);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the eighth element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the eighth element.
	 */
	@Test
	void testGroupContent_SequentialGroupAsEighthElement() {
		SequentialGroupAgent agent = new TopSequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public SequentialGroup addGroup(SequentialGroup group) {
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				return group.addGroup(new SequentialGroup());
			}
		};
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(8, result.getComponents().length);
		assertTrue(result.getComponents()[7] instanceof SequentialGroup);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the ninth element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the ninth element.
	 */
	@Test
	void testGroupContent_SequentialGroupAsNinthElement() {
		SequentialGroupAgent agent = new TopSequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new SequentialGroup();
			}
			@Override
			public SequentialGroup addGroup(SequentialGroup group) {
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				group.addComponent(new Object());
				return group.addGroup(new SequentialGroup());
			}
		};
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(9, result.getComponents().length);
		assertTrue(result.getComponents()[8] instanceof SequentialGroup);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code TopSequentialGroupAgent}
	 * is created with the {@code GroupCreatorAndElementAdder}
	 * that creates and adds the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the tenth element.
	 * <p>
	 * The {@code TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)}
	 * method should return the {@code SequentialGroup}
	 * with the {@code SequentialGroup} as the tenth element.
	 */"
cmpl-6ww7VV3zytaHXagk5VpQjRBBIfknS,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock0.java,94.35003066062927,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {

	/**
	 * Test case 1.
	 * The block is empty.
	 */
	@Test
	void testExtractSequentialSubblocks1() {
		HorizontalBlock block = new HorizontalBlock();
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 2.
	 * The block contains one position.
	 */
	@Test
	void testExtractSequentialSubblocks2() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(1, subblocks.get(0).size());
	}
	
	/**
	 * Test case 3.
	 * The block contains two positions.
	 */
	@Test
	void testExtractSequentialSubblocks3() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
	}
	
	/**
	 * Test case 4.
	 * The block contains three positions.
	 */
	@Test
	void testExtractSequentialSubblocks4() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(3, subblocks.get(0).size());
	}
	
	/**
	 * Test case 5.
	 * The block contains four positions.
	 */
	@Test
	void testExtractSequentialSubblocks5() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(4, subblocks.get(0).size());
	}
	
	/**
	 * Test case 6.
	 * The block contains five positions.
	 */
	@Test
	void testExtractSequentialSubblocks6() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(5, subblocks.get(0).size());
	}
	
	/**
	 * Test case 7.
	 * The block contains six positions.
	 */
	@Test
	void testExtractSequentialSubblocks7() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		block.add(new Position(5, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(6, subblocks.get(0).size());
	}
	
	/**
	 * Test case 8.
	 * The block contains seven positions.
	 */
	@Test
	void testExtractSequentialSubblocks8() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		block.add(new Position(5, 0));
		block.add(new Position(6, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(7, subblocks.get(0).size());
	}
	
	/**
	 * Test case 9.
	 * The block contains eight positions.
	 */
	@Test
	void testExtractSequentialSubblocks9() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		block.add(new Position(5, 0));
		block.add(new Position(6, 0));
		block.add(new Position(7, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(8, subblocks.get(0).size());
	}
	
	/**
	 * Test case 10.
	 * The block contains nine positions.
	 */
	@Test
	void testExtractSequentialSubblocks10() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		block.add(new Position(5, 0));
		block.add(new Position(6, 0));
		block.add(new Position(7, 0));
		block.add(new Position(8, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(9, subblocks.get(0).size());
	}
}

// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();
}

// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {
		
	/**
	 * Test case 1.
	 * The block is empty.
	 */
	@Test
	void testExtractSequentialSubblocks1() {
		VerticalBlock block = new VerticalBlock();
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 2.
	 * The block contains one position.
	 */
	@Test
	void testExtractSequentialSubblocks2() {
		VerticalBlock block = new VerticalBlock();
		block.add(new Position(0, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(1, subblocks.get(0).size());
	}
	
	/**
	 * Test case 3.
	 * The block contains two positions.
	 */
	@Test
	void testExtractSequentialSubblocks3() {
		VerticalBlock block = new VerticalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(0, 1));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
	}
	
	/**
	 * Test case 4.
	 * The block contains three positions.
	 */
	@Test
	void testExtractSequentialSubblocks4() {
		VerticalBlock block = new VerticalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(0, 1));
		block.add(new Position(0, 2));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(3, subblocks.get(0).size());
	}
	
	/**
	 * Test case 5.
	 * The block contains four positions.
	 */
	@Test
	void testExtractSequentialSubblocks5() {
		VerticalBlock block = new VerticalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(0, 1));
		block.add(new Position(0, 2));
		block.add(new Position(0, 3));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(4, subblocks.get(0).size());
	}
	
	/**
	 * Test case 6.
	 * The block contains five positions.
	 */
	@Test
	void testExtractSequentialSubblocks6() {
		VerticalBlock block = new VerticalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(0, 1));
		block.add(new Position(0, 2));
		block.add(new Position(0, 3));
		block.add(new Position(0, 4));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(5, subblocks.get(0).size());
	}
	
	/**
	 * Test case 7.
	 * The block contains six positions.
	 */
	@Test
	void testExtractSequentialSubblocks7() {
		VerticalBlock block = new VerticalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(0, 1));
		block.add(new Position(0, 2));
		block.add(new Position(0, 3));
		block.add(new Position(0, 4));
		block.add(new Position(0, 5));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(6, subblocks.get(0).size());
	}
	
	/**
	 * Test case 8.
	 * The block contains seven positions.
	 */
	@Test
	void testExtractSequentialSubblocks8() {
		VerticalBlock block = new VerticalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(0, 1));
		block.add(new Position(0, 2));
		block.add(new Position(0, 3));
		block.add(new Position(0, 4));
		block.add(new Position(0, 5));
		block.add(new Position(0, 6));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(7, subblocks.get(0).size());
	}
	
	/**
	 * Test case 9.
	 * The block contains eight positions.
	 */
	@Test
	void testExtractSequentialSubblocks9() {
		VerticalBlock block = new VerticalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(0, 1));
		block.add(new Position(0, 2));
		block.add(new Position(0, 3));
		block.add(new Position(0, 4));
		block.add(new Position(0, 5));
		block.add(new Position(0, 6));
		block.add(new Position(0, 7));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(8, subblocks.get(0).size());
	}
	
	/**
	 * Test case 10.
	 * The block contains nine positions.
	 */
	@Test
	void testExtractSequentialSubblocks10() {
		VerticalBlock block = new VerticalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(0, 1));
		block.add(new Position(0, 2));
		block.add(new Position(0, 3));
		block.add(new Position(0, 4));
		block.add(new Position(0, 5));
		block.add(new Position(0, 6));
		block.add(new Position(0, 7));
		block.add(new Position(0, 8));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(9, subblocks.get(0).size());
	}
}

// Position.java
package glengineer.positions;

/**
 * A class representing a position on the game board.
 */
public class Position {

    /**
     * The x coordinate of the position.
     */
    private int x;

    /**
     * The y coordinate of the position.
     */
    private int y;

    /**
     * Constructs a new position with the given coordinates.
     *
     * @param x the x coordinate of the position.
     * @param y the y coordinate of the position.
     */
    public Position(int x, int y);

    /**
     * Returns the x coordinate of the position.
     *
     * @return the x coordinate of the position.
     */
    public int getX();

    /**
     * Returns the y coordinate of the position.
     *
     * @return the y coordinate of the position.
     */
    public int getY();

    /**
     * Returns the hash code of the position.
     *
     * @return the hash code of the position.
     */
    public int hashCode();

    /**
     * Returns whether the given object is equal to the position.
     *
     * @param obj the object to be compared with the position.
     * @return {@code true} if the given object is equal to the position,
     *         {@code false} otherwise.
     */
    public boolean equals(Object obj);
}

// PositionTest.java
package glengineer.positions;

import org.junit.jupiter.api.Test;
import static org.junit"
cmpl-6ww92G9JFR8M0ndOYvgy0BsQFI80x,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock1.java,104.8962242603302,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks();
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {

	/**
	 * Test case 1.
	 * <p>
	 * The block has no horizontal lines.
	 * <p>
	 * The block is divided into two parallel subblocks.
	 */
	@Test
	void testCase1() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(1).getBottomRight());
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block has one horizontal line.
	 * <p>
	 * The block is divided into two parallel subblocks.
	 */
	@Test
	void testCase2() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(1).getBottomRight());
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block has two horizontal lines.
	 * <p>
	 * The block is divided into three parallel subblocks.
	 */
	@Test
	void testCase3() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(2).getBottomRight());
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block has three horizontal lines.
	 * <p>
	 * The block is divided into four parallel subblocks.
	 */
	@Test
	void testCase4() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		block.addHorizontalLine(9);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(3).getBottomRight());
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block has four horizontal lines.
	 * <p>
	 * The block is divided into five parallel subblocks.
	 */
	@Test
	void testCase5() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		block.addHorizontalLine(9);
		block.addHorizontalLine(11);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 11), subblocks.get(3).getBottomRight());
		assertEquals(new Position(0, 11), subblocks.get(4).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(4).getBottomRight());
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The block has five horizontal lines.
	 * <p>
	 * The block is divided into six parallel subblocks.
	 */
	@Test
	void testCase6() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		block.addHorizontalLine(9);
		block.addHorizontalLine(11);
		block.addHorizontalLine(13);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(6, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 11), subblocks.get(3).getBottomRight());
		assertEquals(new Position(0, 11), subblocks.get(4).getTopLeft());
		assertEquals(new Position(10, 13), subblocks.get(4).getBottomRight());
		assertEquals(new Position(0, 13), subblocks.get(5).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(5).getBottomRight());
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The block has six horizontal lines.
	 * <p>
	 * The block is divided into seven parallel subblocks.
	 */
	@Test
	void testCase7() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		block.addHorizontalLine(9);
		block.addHorizontalLine(11);
		block.addHorizontalLine(13);
		block.addHorizontalLine(15);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(7, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 11), subblocks.get(3).getBottomRight());
		assertEquals(new Position(0, 11), subblocks.get(4).getTopLeft());
		assertEquals(new Position(10, 13), subblocks.get(4).getBottomRight());
		assertEquals(new Position(0, 13), subblocks.get(5).getTopLeft());
		assertEquals(new Position(10, 15), subblocks.get(5).getBottomRight());
		assertEquals(new Position(0, 15), subblocks.get(6).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(6).getBottomRight());
	}
	
	/**
	 * Test case 8.
	 * <p>
	 * The block has seven horizontal lines.
	 * <p>
	 * The block is divided into eight parallel subblocks.
	 */
	@Test
	void testCase8() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		block.addHorizontalLine(9);
		block.addHorizontalLine(11);
		block.addHorizontalLine(13);
		block.addHorizontalLine(15);
		block.addHorizontalLine(17);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(8, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 11), subblocks.get(3).getBottomRight());
		assertEquals(new Position(0, 11), subblocks.get(4).getTopLeft());
		assertEquals(new Position(10, 13), subblocks.get(4).getBottomRight());
		assertEquals(new Position(0, 13), subblocks.get(5).getTopLeft());
		assertEquals(new Position(10, 15), subblocks.get(5).getBottomRight());
		assertEquals(new Position(0, 15), subblocks.get(6).getTopLeft());
		assertEquals(new Position(10, 17), subblocks.get(6).getBottomRight());
		assertEquals(new Position(0, 17), subblocks.get(7).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(7).getBottomRight());
	}
	
	/**
	 * Test case 9.
	 * <p>
	 * The block has eight horizontal lines.
	 * <p>
	 * The block is divided into nine parallel subblocks.
	 */
	@Test
	void testCase9() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		block.addHorizontalLine(9);
		block.addHorizontalLine(11);
		block.addHorizontalLine(13);
		block.addHorizontalLine(15);
		block.addHorizontalLine(17);
		block.addHorizontalLine(19);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(9, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 11), subblocks.get(3).getBottomRight());
		assertEquals(new Position(0, 11), subblocks.get(4).getTopLeft());
		assertEquals(new Position(10, 13), subblocks.get(4).getBottomRight());
		assertEquals(new Position(0, 13), subblocks.get(5).getTopLeft());
		assertEquals(new Position(10, 15), subblocks.get(5).getBottomRight());
		assertEquals(new Position(0, 15), subblocks.get(6).getTopLeft());
		assertEquals(new Position(10, 17), subblocks.get(6).getBottomRight());
		assertEquals(new Position(0, 17), subblocks.get(7).getTopLeft());
		assertEquals(new Position(10, 19), subblocks.get(7).getBottomRight());
		assertEquals(new Position(0, 19), subblocks.get(8).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(8).getBottomRight());
	}
	
	/**
	 * Test case 10.
	 * <p>
	 * The block has nine horizontal lines.
	 * <p>
	 * The block is divided into ten parallel subblocks.
	 */
	@Test
"
cmpl-6wwAjBGMYutM78GfKdC7HhukKn8nB,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock0.java,152.37336468696594,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {

	/**
	 * Test case 1.
	 * The block contains only one position.
	 */
	@Test
	void testCase1() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(1, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
	}
	
	/**
	 * Test case 2.
	 * The block contains two positions.
	 */
	@Test
	void testCase2() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(2, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
	}
	
	/**
	 * Test case 3.
	 * The block contains three positions.
	 */
	@Test
	void testCase3() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(3, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
	}
	
	/**
	 * Test case 4.
	 * The block contains four positions.
	 */
	@Test
	void testCase4() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(4, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
	}
	
	/**
	 * Test case 5.
	 * The block contains five positions.
	 */
	@Test
	void testCase5() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		block.addPosition(new Position(0, 4));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(5, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
		assertEquals(new Position(0, 4), subblocks.get(0).getPositions().get(4));
	}
	
	/**
	 * Test case 6.
	 * The block contains six positions.
	 */
	@Test
	void testCase6() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		block.addPosition(new Position(0, 4));
		block.addPosition(new Position(0, 5));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(6, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
		assertEquals(new Position(0, 4), subblocks.get(0).getPositions().get(4));
		assertEquals(new Position(0, 5), subblocks.get(0).getPositions().get(5));
	}
	
	/**
	 * Test case 7.
	 * The block contains seven positions.
	 */
	@Test
	void testCase7() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		block.addPosition(new Position(0, 4));
		block.addPosition(new Position(0, 5));
		block.addPosition(new Position(0, 6));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(7, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
		assertEquals(new Position(0, 4), subblocks.get(0).getPositions().get(4));
		assertEquals(new Position(0, 5), subblocks.get(0).getPositions().get(5));
		assertEquals(new Position(0, 6), subblocks.get(0).getPositions().get(6));
	}
	
	/**
	 * Test case 8.
	 * The block contains eight positions.
	 */
	@Test
	void testCase8() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		block.addPosition(new Position(0, 4));
		block.addPosition(new Position(0, 5));
		block.addPosition(new Position(0, 6));
		block.addPosition(new Position(0, 7));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(8, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
		assertEquals(new Position(0, 4), subblocks.get(0).getPositions().get(4));
		assertEquals(new Position(0, 5), subblocks.get(0).getPositions().get(5));
		assertEquals(new Position(0, 6), subblocks.get(0).getPositions().get(6));
		assertEquals(new Position(0, 7), subblocks.get(0).getPositions().get(7));
	}
	
	/**
	 * Test case 9.
	 * The block contains nine positions.
	 */
	@Test
	void testCase9() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		block.addPosition(new Position(0, 4));
		block.addPosition(new Position(0, 5));
		block.addPosition(new Position(0, 6));
		block.addPosition(new Position(0, 7));
		block.addPosition(new Position(0, 8));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(9, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
		assertEquals(new Position(0, 4), subblocks.get(0).getPositions().get(4));
		assertEquals(new Position(0, 5), subblocks.get(0).getPositions().get(5));
		assertEquals(new Position(0, 6), subblocks.get(0).getPositions().get(6));
		assertEquals(new Position(0, 7), subblocks.get(0).getPositions().get(7));
		assertEquals(new Position(0, 8), subblocks.get(0).getPositions().get(8));
	}
	
	/**
	 * Test case 10.
	 * The block contains ten positions.
	 */
	@Test
	void testCase10() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		block.addPosition(new Position(0, 4));
		block.addPosition(new Position(0, 5));
		block.addPosition(new Position(0, 6));
		block.addPosition(new Position(0, 7));
		block.addPosition(new Position(0, 8));
		block.addPosition(new Position(0, 9));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(10, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
		assertEquals(new Position(0, 4), subblocks.get(0).getPositions().get(4));
		assertEquals(new Position(0, 5), subblocks.get(0).getPositions().get(5));
		assertEquals(new Position(0, 6), subblocks.get(0).getPositions().get(6));
		assertEquals(new Position(0, 7), subblocks.get(0).getPositions().get(7));
		assertEquals(new Position(0, 8), subblocks.get(0).getPositions().get(8));
		assertEquals(new Position(0, 9), subblocks.get(0).getPositions().get(9));
	}
}

// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();
}

// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {
		
	/**
	 * Test case 1.
	 * The block contains only one position.
	 */
	@Test
	void testCase1() {
		HorizontalBlock block = new HorizontalBlock();
		block.addPosition(new Position(0, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(1, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
	}
	
	/**
	 * Test case 2.
	 * The block contains two positions.
	 */
	@Test
	void testCase2() {
		HorizontalBlock block = new HorizontalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(1, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks."
cmpl-6wwDByB885UncirmGS6YNdAXCiJ2b,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock1.java,121.95609211921692,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks();
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {

	/**
	 * Test case 1.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into two parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks1() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(10, 0));
		block.addLine(new Position(0, 10), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(0, 10));
		block.addLine(new Position(10, 0), new Position(10, 10));
		block.addLine(new Position(0, 5), new Position(10, 5));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getLeftBottom());
		assertEquals(new Position(10, 5), subblocks.get(0).getRightTop());
		assertEquals(new Position(0, 5), subblocks.get(1).getLeftBottom());
		assertEquals(new Position(10, 10), subblocks.get(1).getRightTop());
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into three parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks2() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(10, 0));
		block.addLine(new Position(0, 10), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(0, 10));
		block.addLine(new Position(10, 0), new Position(10, 10));
		block.addLine(new Position(0, 5), new Position(10, 5));
		block.addLine(new Position(0, 7), new Position(10, 7));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getLeftBottom());
		assertEquals(new Position(10, 5), subblocks.get(0).getRightTop());
		assertEquals(new Position(0, 5), subblocks.get(1).getLeftBottom());
		assertEquals(new Position(10, 7), subblocks.get(1).getRightTop());
		assertEquals(new Position(0, 7), subblocks.get(2).getLeftBottom());
		assertEquals(new Position(10, 10), subblocks.get(2).getRightTop());
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into four parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks3() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(10, 0));
		block.addLine(new Position(0, 10), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(0, 10));
		block.addLine(new Position(10, 0), new Position(10, 10));
		block.addLine(new Position(0, 5), new Position(10, 5));
		block.addLine(new Position(0, 7), new Position(10, 7));
		block.addLine(new Position(0, 9), new Position(10, 9));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getLeftBottom());
		assertEquals(new Position(10, 5), subblocks.get(0).getRightTop());
		assertEquals(new Position(0, 5), subblocks.get(1).getLeftBottom());
		assertEquals(new Position(10, 7), subblocks.get(1).getRightTop());
		assertEquals(new Position(0, 7), subblocks.get(2).getLeftBottom());
		assertEquals(new Position(10, 9), subblocks.get(2).getRightTop());
		assertEquals(new Position(0, 9), subblocks.get(3).getLeftBottom());
		assertEquals(new Position(10, 10), subblocks.get(3).getRightTop());
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into five parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks4() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(10, 0));
		block.addLine(new Position(0, 10), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(0, 10));
		block.addLine(new Position(10, 0), new Position(10, 10));
		block.addLine(new Position(0, 5), new Position(10, 5));
		block.addLine(new Position(0, 7), new Position(10, 7));
		block.addLine(new Position(0, 9), new Position(10, 9));
		block.addLine(new Position(0, 2), new Position(10, 2));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getLeftBottom());
		assertEquals(new Position(10, 2), subblocks.get(0).getRightTop());
		assertEquals(new Position(0, 2), subblocks.get(1).getLeftBottom());
		assertEquals(new Position(10, 5), subblocks.get(1).getRightTop());
		assertEquals(new Position(0, 5), subblocks.get(2).getLeftBottom());
		assertEquals(new Position(10, 7), subblocks.get(2).getRightTop());
		assertEquals(new Position(0, 7), subblocks.get(3).getLeftBottom());
		assertEquals(new Position(10, 9), subblocks.get(3).getRightTop());
		assertEquals(new Position(0, 9), subblocks.get(4).getLeftBottom());
		assertEquals(new Position(10, 10), subblocks.get(4).getRightTop());
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into six parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks5() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(10, 0));
		block.addLine(new Position(0, 10), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(0, 10));
		block.addLine(new Position(10, 0), new Position(10, 10));
		block.addLine(new Position(0, 5), new Position(10, 5));
		block.addLine(new Position(0, 7), new Position(10, 7));
		block.addLine(new Position(0, 9), new Position(10, 9));
		block.addLine(new Position(0, 2), new Position(10, 2));
		block.addLine(new Position(0, 4), new Position(10, 4));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(6, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getLeftBottom());
		assertEquals(new Position(10, 2), subblocks.get(0).getRightTop());
		assertEquals(new Position(0, 2), subblocks.get(1).getLeftBottom());
		assertEquals(new Position(10, 4), subblocks.get(1).getRightTop());
		assertEquals(new Position(0, 4), subblocks.get(2).getLeftBottom());
		assertEquals(new Position(10, 5), subblocks.get(2).getRightTop());
		assertEquals(new Position(0, 5), subblocks.get(3).getLeftBottom());
		assertEquals(new Position(10, 7), subblocks.get(3).getRightTop());
		assertEquals(new Position(0, 7), subblocks.get(4).getLeftBottom());
		assertEquals(new Position(10, 9), subblocks.get(4).getRightTop());
		assertEquals(new Position(0, 9), subblocks.get(5).getLeftBottom());
		assertEquals(new Position(10, 10), subblocks.get(5).getRightTop());
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into seven parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks6() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(10, 0));
		block.addLine(new Position(0, 10), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(0, 10));
		block.addLine(new Position(10, 0), new Position(10, 10));
		block.addLine(new Position(0, 5), new Position(10, 5));
		block.addLine(new Position(0, 7), new Position(10, 7));
		block.addLine(new Position(0, 9), new Position(10, 9));
		block.addLine(new Position(0, 2), new Position(10, 2));
		block.addLine(new Position(0, 4), new Position(10, 4));
		block.addLine(new Position(0, 6), new Position(10, 6));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(7, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getLeftBottom());
		assertEquals(new Position(10, 2), subblocks.get(0).getRightTop());
		assertEquals(new Position(0, 2), subblocks.get(1).getLeftBottom());
		assertEquals(new Position(10, 4), subblocks.get(1).getRightTop());
		assertEquals(new Position(0, 4), subblocks.get(2).getLeftBottom());
		assertEquals(new Position(10, 5), subblocks.get(2).getRightTop());
		assertEquals(new Position(0, 5), subblocks.get(3).getLeftBottom());
		assertEquals(new Position(10, 6), subblocks.get(3).getRightTop());
		assertEquals(new Position(0, 6), subblocks.get(4).getLeftBottom());
		assertEquals(new Position(10, 7), subblocks.get(4).getRightTop());
		assertEquals(new Position(0, 7), subblocks.get(5).getLeftBottom());
		assertEquals(new Position(10, 9), subblocks.get(5).getRightTop());
		assertEquals(new Position(0, 9), subblocks.get(6).getLeftBottom());
		assertEquals(new Position(10, 10), subblocks.get(6).getRightTop());
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into eight parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks7() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(10, 0));
		block.addLine(new Position(0, 10), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(0, 10));
		block.addLine(new Position(10, 0), new Position(10, 10));
		block.addLine(new Position(0, 5), new Position(10, 5));
		block.addLine(new Position(0, 7), new Position(10, 7));
		block.addLine(new Position(0, 9), new Position(10, 9));
		block.addLine(new Position(0, 2), new Position(10, 2));
		block.addLine(new Position(0, 4), new Position(10, 4));
		block.addLine(new Position(0, 6), new Position(10, 6));
		block.addLine(new Position(0, 8), new Position(10, 8));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(8, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getLeftBottom());
		assertEquals(new Position(10, 2), subblocks.get(0).getRightTop());
		assertEquals(new Position(0, 2), subblocks.get(1).getLeftBottom());
		assertEquals(new Position(10, 4), subblocks.get(1).getRightTop());
		assertEquals(new Position(0, 4), subblocks.get(2).getLeftBottom());
		assertEquals(new Position(10, 5), subblocks.get(2).getRightTop());
		assertEquals(new Position(0, 5), subblocks.get(3).getLeftBottom());
		assertEquals(new Position(10, 6), subblocks.get(3).getRightTop());
		assertEquals(new Position(0, 6), subblocks.get(4).getLeftBottom());
		assertEquals(new Position(10, 7), subblocks.get(4).getRightTop());
		assertEquals(new Position(0, 7), subblocks.get(5).getLeftBottom());
		assertEquals(new Position(10, 8), subblocks.get(5).getRightTop());
		assertEquals(new Position(0, 8), subblocks.get(6).getLeftBottom());
		assertEquals(new Position(10, 9), subblocks.get(6).getRightTop());
		assertEquals(new Position(0, 9), subblocks.get(7).getLeftBottom());
		assertEquals(new Position(10, 10), subblocks.get(7).getRightTop());
	}
	
	/**
	 * Test case 8.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into nine parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks8() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Position(0, 0), new Position(10, 0));
		block.addLine(new Position(0, 10), new Position("
cmpl-6wwF9ssO6GvKdI0ygcSQTosc8wDQd,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/positions/HWordPosition.java,54.16918611526489,stop,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public String textAt(CharTable ct);
}
","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {

	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		HWordPosition wp = new HWordPosition(0, 0, 5);
		ct.setBlock(0, 0, new Block('A'));
		ct.setBlock(1, 0, new Block('B'));
		ct.setBlock(2, 0, new Block('C'));
		ct.setBlock(3, 0, new Block('D'));
		ct.setBlock(4, 0, new Block('E'));
		assertEquals(""ABCDE"", wp.textAt(ct));
	}
}

// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public String textAt(CharTable ct);
}

// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		VWordPosition wp = new VWordPosition(0, 0, 5);
		ct.setBlock(0, 0, new Block('A'));
		ct.setBlock(0, 1, new Block('B'));
		ct.setBlock(0, 2, new Block('C'));
		ct.setBlock(0, 3, new Block('D'));
		ct.setBlock(0, 4, new Block('E'));
		assertEquals(""ABCDE"", wp.textAt(ct));
	}
}

// CharTable.java
package glengineer.blocks;

import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;

/**
 * Represents a table of characters.
 *
 * The table is represented as a two-dimensional array of blocks.
 * Each block contains a character.
 */
public class CharTable {

    /**
     * Returns the text at the specified position on this char table.
     *
     * The call is dispatched to the specified word position
     * informing it about the concrete char table type.
     *
     * @param wp the word position at which the text must be read.
     * @return the text at the specified position on this char table.
     */
    public String textAt(WordPosition wp);
}

// CharTableTest.java
package glengineer.blocks;

import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CharTable}.
* It contains ten unit test cases for the {@link CharTable#textAt(WordPosition)} method.
*/
class CharTableTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		HWordPosition wp = new HWordPosition(0, 0, 5);
		ct.setBlock(0, 0, new Block('A'));
		ct.setBlock(1, 0, new Block('B'));
		ct.setBlock(2, 0, new Block('C'));
		ct.setBlock(3, 0, new Block('D'));
		ct.setBlock(4, 0, new Block('E'));
		assertEquals(""ABCDE"", ct.textAt(wp));
		VWordPosition wp2 = new VWordPosition(0, 0, 5);
		ct.setBlock(0, 0, new Block('A'));
		ct.setBlock(0, 1, new Block('B'));
		ct.setBlock(0, 2, new Block('C'));
		ct.setBlock(0, 3, new Block('D'));
		ct.setBlock(0, 4, new Block('E'));
		assertEquals(""ABCDE"", ct.textAt(wp2));
	}
}

// WordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying on the scheme.
 */
public abstract class WordPosition {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public abstract String textAt(CharTable ct);
}

// WordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPosition}.
* It contains ten unit test cases for the {@link WordPosition#textAt(CharTable)} method.
*/
class WordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		HWordPosition wp = new HWordPosition(0, 0, 5);
		ct.setBlock(0, 0, new Block('A'));
		ct.setBlock(1, 0, new Block('B'));
		ct.setBlock(2, 0, new Block('C'));
		ct.setBlock(3, 0, new Block('D'));
		ct.setBlock(4, 0, new Block('E'));
		assertEquals(""ABCDE"", wp.textAt(ct));
		VWordPosition wp2 = new VWordPosition(0, 0, 5);
		ct.setBlock(0, 0, new Block('A'));
		ct.setBlock(0, 1, new Block('B'));
		ct.setBlock(0, 2, new Block('C'));
		ct.setBlock(0, 3, new Block('D'));
		ct.setBlock(0, 4, new Block('E'));
		assertEquals(""ABCDE"", wp2.textAt(ct));
	}
}"
cmpl-6wwGCapTrIfqJp5ZKofUCjuGP24Qe,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/positions/VWordPosition.java,143.04219698905945,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public String textAt(CharTable ct);
}
","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {

	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(0, 1, 'b');
		ct.setCharAt(0, 2, 'c');
		ct.setCharAt(0, 3, 'd');
		ct.setCharAt(0, 4, 'e');
		ct.setCharAt(0, 5, 'f');
		ct.setCharAt(0, 6, 'g');
		ct.setCharAt(0, 7, 'h');
		ct.setCharAt(0, 8, 'i');
		ct.setCharAt(0, 9, 'j');
		ct.setCharAt(1, 0, 'k');
		ct.setCharAt(1, 1, 'l');
		ct.setCharAt(1, 2, 'm');
		ct.setCharAt(1, 3, 'n');
		ct.setCharAt(1, 4, 'o');
		ct.setCharAt(1, 5, 'p');
		ct.setCharAt(1, 6, 'q');
		ct.setCharAt(1, 7, 'r');
		ct.setCharAt(1, 8, 's');
		ct.setCharAt(1, 9, 't');
		ct.setCharAt(2, 0, 'u');
		ct.setCharAt(2, 1, 'v');
		ct.setCharAt(2, 2, 'w');
		ct.setCharAt(2, 3, 'x');
		ct.setCharAt(2, 4, 'y');
		ct.setCharAt(2, 5, 'z');
		ct.setCharAt(2, 6, 'a');
		ct.setCharAt(2, 7, 'b');
		ct.setCharAt(2, 8, 'c');
		ct.setCharAt(2, 9, 'd');
		ct.setCharAt(3, 0, 'e');
		ct.setCharAt(3, 1, 'f');
		ct.setCharAt(3, 2, 'g');
		ct.setCharAt(3, 3, 'h');
		ct.setCharAt(3, 4, 'i');
		ct.setCharAt(3, 5, 'j');
		ct.setCharAt(3, 6, 'k');
		ct.setCharAt(3, 7, 'l');
		ct.setCharAt(3, 8, 'm');
		ct.setCharAt(3, 9, 'n');
		ct.setCharAt(4, 0, 'o');
		ct.setCharAt(4, 1, 'p');
		ct.setCharAt(4, 2, 'q');
		ct.setCharAt(4, 3, 'r');
		ct.setCharAt(4, 4, 's');
		ct.setCharAt(4, 5, 't');
		ct.setCharAt(4, 6, 'u');
		ct.setCharAt(4, 7, 'v');
		ct.setCharAt(4, 8, 'w');
		ct.setCharAt(4, 9, 'x');
		ct.setCharAt(5, 0, 'y');
		ct.setCharAt(5, 1, 'z');
		ct.setCharAt(5, 2, 'a');
		ct.setCharAt(5, 3, 'b');
		ct.setCharAt(5, 4, 'c');
		ct.setCharAt(5, 5, 'd');
		ct.setCharAt(5, 6, 'e');
		ct.setCharAt(5, 7, 'f');
		ct.setCharAt(5, 8, 'g');
		ct.setCharAt(5, 9, 'h');
		ct.setCharAt(6, 0, 'i');
		ct.setCharAt(6, 1, 'j');
		ct.setCharAt(6, 2, 'k');
		ct.setCharAt(6, 3, 'l');
		ct.setCharAt(6, 4, 'm');
		ct.setCharAt(6, 5, 'n');
		ct.setCharAt(6, 6, 'o');
		ct.setCharAt(6, 7, 'p');
		ct.setCharAt(6, 8, 'q');
		ct.setCharAt(6, 9, 'r');
		ct.setCharAt(7, 0, 's');
		ct.setCharAt(7, 1, 't');
		ct.setCharAt(7, 2, 'u');
		ct.setCharAt(7, 3, 'v');
		ct.setCharAt(7, 4, 'w');
		ct.setCharAt(7, 5, 'x');
		ct.setCharAt(7, 6, 'y');
		ct.setCharAt(7, 7, 'z');
		ct.setCharAt(7, 8, 'a');
		ct.setCharAt(7, 9, 'b');
		ct.setCharAt(8, 0, 'c');
		ct.setCharAt(8, 1, 'd');
		ct.setCharAt(8, 2, 'e');
		ct.setCharAt(8, 3, 'f');
		ct.setCharAt(8, 4, 'g');
		ct.setCharAt(8, 5, 'h');
		ct.setCharAt(8, 6, 'i');
		ct.setCharAt(8, 7, 'j');
		ct.setCharAt(8, 8, 'k');
		ct.setCharAt(8, 9, 'l');
		ct.setCharAt(9, 0, 'm');
		ct.setCharAt(9, 1, 'n');
		ct.setCharAt(9, 2, 'o');
		ct.setCharAt(9, 3, 'p');
		ct.setCharAt(9, 4, 'q');
		ct.setCharAt(9, 5, 'r');
		ct.setCharAt(9, 6, 's');
		ct.setCharAt(9, 7, 't');
		ct.setCharAt(9, 8, 'u');
		ct.setCharAt(9, 9, 'v');
		
		VWordPosition wp = new VWordPosition(0, 0, 0, 9);
		assertEquals(""abcdefghij"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 1, 0, 9);
		assertEquals(""klmnopqrst"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 2, 0, 9);
		assertEquals(""uvwxyzabcd"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 3, 0, 9);
		assertEquals(""efghijklmn"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 4, 0, 9);
		assertEquals(""opqrstuvwx"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 5, 0, 9);
		assertEquals(""yzabcdefgh"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 6, 0, 9);
		assertEquals(""ijklmnopqr"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 7, 0, 9);
		assertEquals(""stuvwxyzab"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 8, 0, 9);
		assertEquals(""cdefghijkl"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 9, 0, 9);
		assertEquals(""mnopqrstuv"", wp.textAt(ct));
	}
}

// WordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying on the scheme.
 */
public abstract class WordPosition {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public abstract String textAt(CharTable ct);
}

// WordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPosition}.
* It contains ten unit test cases for the {@link WordPosition#textAt(CharTable)} method.
*/
class WordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(0, 1, 'b');
		ct.setCharAt(0, 2, 'c');
		ct.setCharAt(0, 3, 'd');
		ct.setCharAt(0, 4, 'e');
		ct.setCharAt(0, 5, 'f');
		ct.setCharAt(0, 6, 'g');
		ct.setCharAt(0, 7, 'h');
		ct.setCharAt(0, 8, 'i');
		ct.setCharAt(0, 9, 'j');
		ct.setCharAt(1, 0, 'k');
		ct.setCharAt(1, 1, 'l');
		ct.setCharAt(1, 2, 'm');
		ct.setCharAt(1, 3, 'n');
		ct.setCharAt(1, 4, 'o');
		ct.setCharAt(1, 5, 'p');
		ct.setCharAt(1, 6, 'q');
		ct.setCharAt(1, 7, 'r');
		ct.setCharAt(1, 8, 's');
		ct.setCharAt(1, 9, 't');
		ct.setCharAt(2, 0, 'u');
		ct.setCharAt(2, 1, 'v');
		ct.setCharAt(2, 2, 'w');
		ct.setCharAt(2, 3, 'x');
		ct.setCharAt(2, 4, 'y');
		ct.setCharAt(2, 5, 'z');
		ct.setCharAt(2, 6, 'a');
		ct.setCharAt(2, 7, 'b');
		ct.setCharAt(2, 8, 'c');
		ct.setCharAt(2, 9, 'd');
		ct.setCharAt(3, 0, 'e');
		ct.setCharAt(3, 1, 'f');
		ct.setCharAt(3, 2, 'g');
		ct.setCharAt(3, 3, 'h');
		ct.setCharAt(3, 4, 'i');
		ct.setCharAt(3, 5, 'j');
		ct.setCharAt(3, 6, 'k');
		ct.setCharAt(3, 7, 'l');
		ct.setCharAt(3, 8, 'm');
		ct.setCharAt(3, 9, 'n');
		ct.setCharAt(4, 0, 'o');
		ct.setCharAt(4, 1, 'p');
		ct.setCharAt(4, 2, 'q');
		ct.setCharAt(4, 3, 'r');
		ct.setCharAt(4, 4, 's');
		ct.setCharAt(4, 5, 't');
		ct.setCharAt(4, 6, 'u');
		ct.setCharAt(4, 7, 'v');
		ct.setCharAt(4, 8, 'w');
		ct.setCharAt(4, 9, 'x');
		ct.setCharAt(5, 0, 'y');
		ct.setCharAt(5, 1, 'z');
		ct.setCharAt(5, 2, 'a');
		ct.setCharAt(5, 3, 'b');
		ct.setCharAt(5, 4, 'c');
		ct.setCharAt(5, 5, 'd');
		ct.setCharAt(5, 6, 'e');
		ct.setCharAt(5, 7, 'f');
		ct.setCharAt(5, 8, 'g');
		ct.setCharAt(5, 9, 'h');
		ct.setCharAt(6, 0, 'i');
		ct.setCharAt(6, 1, 'j');
		ct.setCharAt(6, 2, 'k');
		ct.setCharAt(6, 3, 'l');
		ct.setCharAt(6, 4, 'm');
		ct.setCharAt(6, 5, 'n');
		ct.setCharAt(6, 6, 'o');
		ct.setCharAt(6, 7, 'p');
		ct.setCharAt(6, 8, 'q');
		ct.setCharAt(6, 9, 'r');
		ct.setCharAt(7, 0, 's');
		ct.setCharAt(7, 1, 't');
		ct.setCharAt(7, 2, 'u');
		ct.setCharAt(7, 3, 'v');
		ct.setCharAt(7, 4, 'w');
		ct.setCharAt(7, 5, 'x');
		ct.setCharAt(7, 6, 'y');
		ct.setCharAt(7, 7, 'z');
		ct.setCharAt(7, 8, 'a');
		ct.setCharAt(7, 9, 'b');
		ct.setCharAt(8, 0, 'c');
		ct.setCharAt(8, 1, 'd');
		ct.setCharAt(8, 2, 'e');
		ct.setCharAt(8, 3, 'f');
		ct.setCharAt(8, 4, 'g');
		ct.setCharAt(8, 5, 'h');
		ct.setCharAt(8, 6, 'i');
		ct.setCharAt(8, 7, 'j');
		ct.setCharAt(8, 8, 'k');
		ct.setCharAt(8, 9, 'l');
		ct.setCharAt(9, 0, 'm');
		ct.setCharAt(9, 1, 'n');
		ct.setCharAt(9, 2, 'o');
		ct.setCharAt(9, 3, 'p');
		ct.setCharAt(9, 4, 'q');
		ct.setCharAt(9, 5, 'r');
		ct.setCharAt(9, 6, 's');
		ct.setCharAt(9, 7, 't');
		ct.setCharAt(9, 8, 'u');
		ct.setCharAt(9, 9, 'v');
		
		WordPosition wp = new HWordPosition(0"
