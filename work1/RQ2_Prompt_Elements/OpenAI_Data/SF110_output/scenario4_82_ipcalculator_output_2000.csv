ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6x8MWIwKuBu3fHz1yupC3TwJKlgvl,/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_0Test.java,88.88088774681091,length,"// BinaryCalculate.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;

public class BinaryCalculate {

    boolean isIPv4 = false;

    boolean isIPv6 = false;

    String currentIP = """";

    String fullReassembler = """";

    String DELIMITER = """";

    int lengthOfToken = 0;

    String IPRangeAddress = """";

    String usableRange = """";

    int semiCol = 0;

    String prefix = """";

    BigInteger totalIPAddresses;

    int MAXPREFIX = 0;

    /**
     *  Calculates the sum of two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be added to the starting binary
     *  @return      The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2);

    /**
     *  Subtracts two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be subtracted from the
     *                       starting binary
     *  @return      The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored into an <code>string</code> to be
     *  returned to the method that called it.
     *
     *  @param      IP          The starting IP address (subnet) in binary
     *  @param      IPPrefix    Number of IP addresses in binary
     *  @return     Results string
     */
    public String IPCalculate(String IP, String IPPrefix);

    /**
     *  Adds delimiters back into a given IP address
     *
     *  @param      binaryIP     binary IP address with no delimiters
     *  @return     binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP);

    /**
     *  Gets the netmask from a binary representation of number of IP addresses
     *
     *  @param      binaryIP     binary representation of number of IP addresses
     *  @return     netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored as declared global variables for many
     *  other methods to manipulate or use.
     *  <br>This method also detects if the provided of number of IP addresses
     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and
     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds
     *  the IP addressing bounds.
     *  <br>This method also calculates the prefix size needed to accomodate all
     *  the IP Addresses to be listed and stores it as a global variable for use
     *  in other methods.
     *
     *  @param       subnet              The starting IP address (subnet)
     *  @param       noOfIPAddresses     Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses from the smaller prefix. The results are stored into an array
     *  to be printed using <code><b>Output.java</b></code>.
     *
     *  @param       IP          The starting IP address (subnet)
     *  @param       IPPrefix    Number of IP addresses for smaller prefix
     *  @param       noPrefix    Number of smaller prefixes within the total
     *                           prefix
     *  @param       endPrefix   Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);

    /**
     *  Determines whether an IP Address provided in binary form is an IPv4 or
     *  an IPv6 by the length of the binary string.
     *
     *  @param       size1    Length of binary string
     */
    private void checkIPType(int size1);

    /**
     *  Reconstructs the dotted-decimal or hexidecimal IP address with
     *  seperators from an given binary IP Address. The reconstructed IP address
     *  is stored as a global declared variable, <code>currentIP</code>.
     *
     *  @param   IP  An binary IP Address to be converted back into
     *               dotted-decimal or hexidecimal format
     */
    private String convert(String binaryIP);

    /**
     *  Converts an given IPv4 or IPv6 address into binary format.
     *
     *  @param   IP  An IP Address to be converted back into binary format
     *  @return  Binary representation of given IP Address.
     */
    private String convertToBinary(String IP);

    /**
     *  Gets the starting IP of an IP range.
     *
     *  @return     Starting IP of IP range
     */
    private String getStartIP();
}
","// BinaryCalculate_0Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.
*/
class BinaryCalculate_0Test {","// BinaryCalculate_0Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.
*/
class BinaryCalculate_0Test {

	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_0() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_1() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""1101"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_2() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_3() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""1101"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_4() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_5() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""1101"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_6() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_7() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""1101"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testAddBinary_8() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#addBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testAddBinary_9() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""1101"";
		String expected = ""101000"";
		String actual = binaryCalculate.addBinary(num1, num2);
		assertEquals(expected, actual);
	}
}

// BinaryCalculate_1Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.
*/
class BinaryCalculate_1Test {
		
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testSubBinary_0() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""11011"";
		String expected = ""101000"";
		String actual = binaryCalculate.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal in length.
	*/
	@Test
	void testSubBinary_1() {
		BinaryCalculate binaryCalculate = new BinaryCalculate();
		String num1 = ""10101"";
		String num2 = ""1101"";
		String expected = ""101000"";
		String actual = binaryCalculate.subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal in length.
	*/
	@Test
	void testSubBinary_2() {
	"
cmpl-6x8NxP4ENhy87OBukAe2XYIQK5Eu4,/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_1Test.java,83.24481725692749,length,"// BinaryCalculate.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;

public class BinaryCalculate {

    boolean isIPv4 = false;

    boolean isIPv6 = false;

    String currentIP = """";

    String fullReassembler = """";

    String DELIMITER = """";

    int lengthOfToken = 0;

    String IPRangeAddress = """";

    String usableRange = """";

    int semiCol = 0;

    String prefix = """";

    BigInteger totalIPAddresses;

    int MAXPREFIX = 0;

    /**
     *  Calculates the sum of two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be added to the starting binary
     *  @return      The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2);

    /**
     *  Subtracts two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be subtracted from the
     *                       starting binary
     *  @return      The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored into an <code>string</code> to be
     *  returned to the method that called it.
     *
     *  @param      IP          The starting IP address (subnet) in binary
     *  @param      IPPrefix    Number of IP addresses in binary
     *  @return     Results string
     */
    public String IPCalculate(String IP, String IPPrefix);

    /**
     *  Adds delimiters back into a given IP address
     *
     *  @param      binaryIP     binary IP address with no delimiters
     *  @return     binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP);

    /**
     *  Gets the netmask from a binary representation of number of IP addresses
     *
     *  @param      binaryIP     binary representation of number of IP addresses
     *  @return     netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored as declared global variables for many
     *  other methods to manipulate or use.
     *  <br>This method also detects if the provided of number of IP addresses
     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and
     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds
     *  the IP addressing bounds.
     *  <br>This method also calculates the prefix size needed to accomodate all
     *  the IP Addresses to be listed and stores it as a global variable for use
     *  in other methods.
     *
     *  @param       subnet              The starting IP address (subnet)
     *  @param       noOfIPAddresses     Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses from the smaller prefix. The results are stored into an array
     *  to be printed using <code><b>Output.java</b></code>.
     *
     *  @param       IP          The starting IP address (subnet)
     *  @param       IPPrefix    Number of IP addresses for smaller prefix
     *  @param       noPrefix    Number of smaller prefixes within the total
     *                           prefix
     *  @param       endPrefix   Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);

    /**
     *  Determines whether an IP Address provided in binary form is an IPv4 or
     *  an IPv6 by the length of the binary string.
     *
     *  @param       size1    Length of binary string
     */
    private void checkIPType(int size1);

    /**
     *  Reconstructs the dotted-decimal or hexidecimal IP address with
     *  seperators from an given binary IP Address. The reconstructed IP address
     *  is stored as a global declared variable, <code>currentIP</code>.
     *
     *  @param   IP  An binary IP Address to be converted back into
     *               dotted-decimal or hexidecimal format
     */
    private String convert(String binaryIP);

    /**
     *  Converts an given IPv4 or IPv6 address into binary format.
     *
     *  @param   IP  An IP Address to be converted back into binary format
     *  @return  Binary representation of given IP Address.
     */
    private String convertToBinary(String IP);

    /**
     *  Gets the starting IP of an IP range.
     *
     *  @return     Starting IP of IP range
     */
    private String getStartIP();
}
","// BinaryCalculate_1Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.
*/
class BinaryCalculate_1Test {","// BinaryCalculate_1Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.
*/
class BinaryCalculate_1Test {

	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are equal.
	*/
	@Test
	void testSubBinary_1() {
		String num1 = ""10101"";
		String num2 = ""10101"";
		String expected = ""0"";
		String actual = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal.
	*/
	@Test
	void testSubBinary_2() {
		String num1 = ""10101"";
		String num2 = ""10100"";
		String expected = ""1"";
		String actual = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal.
	*/
	@Test
	void testSubBinary_3() {
		String num1 = ""10101"";
		String num2 = ""10110"";
		String expected = ""1111"";
		String actual = new BinaryCalculate().subBinary(num1, num2);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#subBinary(String, String)} method.
	* It tests the method with two binary numbers that are not equal.
	*/
	@Test
	void testSubBinary_4() {
		String num1 = ""10101"";
		String num2 = ""11111"";
		String expected = ""111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
cmpl-6x8PIQZ7ofCPK0KGeZI2T26uSD9Sn,/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_2Test.java,70.49733829498291,length,"// BinaryCalculate.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;

public class BinaryCalculate {

    boolean isIPv4 = false;

    boolean isIPv6 = false;

    String currentIP = """";

    String fullReassembler = """";

    String DELIMITER = """";

    int lengthOfToken = 0;

    String IPRangeAddress = """";

    String usableRange = """";

    int semiCol = 0;

    String prefix = """";

    BigInteger totalIPAddresses;

    int MAXPREFIX = 0;

    /**
     *  Calculates the sum of two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be added to the starting binary
     *  @return      The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2);

    /**
     *  Subtracts two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be subtracted from the
     *                       starting binary
     *  @return      The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored into an <code>string</code> to be
     *  returned to the method that called it.
     *
     *  @param      IP          The starting IP address (subnet) in binary
     *  @param      IPPrefix    Number of IP addresses in binary
     *  @return     Results string
     */
    public String IPCalculate(String IP, String IPPrefix);

    /**
     *  Adds delimiters back into a given IP address
     *
     *  @param      binaryIP     binary IP address with no delimiters
     *  @return     binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP);

    /**
     *  Gets the netmask from a binary representation of number of IP addresses
     *
     *  @param      binaryIP     binary representation of number of IP addresses
     *  @return     netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored as declared global variables for many
     *  other methods to manipulate or use.
     *  <br>This method also detects if the provided of number of IP addresses
     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and
     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds
     *  the IP addressing bounds.
     *  <br>This method also calculates the prefix size needed to accomodate all
     *  the IP Addresses to be listed and stores it as a global variable for use
     *  in other methods.
     *
     *  @param       subnet              The starting IP address (subnet)
     *  @param       noOfIPAddresses     Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses from the smaller prefix. The results are stored into an array
     *  to be printed using <code><b>Output.java</b></code>.
     *
     *  @param       IP          The starting IP address (subnet)
     *  @param       IPPrefix    Number of IP addresses for smaller prefix
     *  @param       noPrefix    Number of smaller prefixes within the total
     *                           prefix
     *  @param       endPrefix   Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);

    /**
     *  Determines whether an IP Address provided in binary form is an IPv4 or
     *  an IPv6 by the length of the binary string.
     *
     *  @param       size1    Length of binary string
     */
    private void checkIPType(int size1);

    /**
     *  Reconstructs the dotted-decimal or hexidecimal IP address with
     *  seperators from an given binary IP Address. The reconstructed IP address
     *  is stored as a global declared variable, <code>currentIP</code>.
     *
     *  @param   IP  An binary IP Address to be converted back into
     *               dotted-decimal or hexidecimal format
     */
    private String convert(String binaryIP);

    /**
     *  Converts an given IPv4 or IPv6 address into binary format.
     *
     *  @param   IP  An IP Address to be converted back into binary format
     *  @return  Binary representation of given IP Address.
     */
    private String convertToBinary(String IP);

    /**
     *  Gets the starting IP of an IP range.
     *
     *  @return     Starting IP of IP range
     */
    private String getStartIP();
}
","// BinaryCalculate_2Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.
*/
class BinaryCalculate_2Test {","// BinaryCalculate_2Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.
*/
class BinaryCalculate_2Test {

	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11111111""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.1""</li>
	* <li>Usable Range: ""192.168.1.2 - 192.168.1.254""</li>
	* <li>Broadcast Address: ""192.168.1.255""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_1() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11111111"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.1\nUsable Range: 192.168.1.2 - 192.168.1.254\nBroadcast Address: 192.168.1.255\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11111110""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.2""</li>
	* <li>Usable Range: ""192.168.1.3 - 192.168.1.254""</li>
	* <li>Broadcast Address: ""192.168.1.255""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_2() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11111110"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.2\nUsable Range: 192.168.1.3 - 192.168.1.254\nBroadcast Address: 192.168.1.255\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11111100""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.4""</li>
	* <li>Usable Range: ""192.168.1.5 - 192.168.1.254""</li>
	* <li>Broadcast Address: ""192.168.1.255""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_3() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11111100"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.4\nUsable Range: 192.168.1.5 - 192.168.1.254\nBroadcast Address: 192.168.1.255\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11111000""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.8""</li>
	* <li>Usable Range: ""192.168.1.9 - 192.168.1.254""</li>
	* <li>Broadcast Address: ""192.168.1.255""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_4() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11111000"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.8\nUsable Range: 192.168.1.9 - 192.168.1.254\nBroadcast Address: 192.168.1.255\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP: ""11000000.10101000.00000001.00000001""</li>
	* <li>IPPrefix: ""11111111.11111111.11111111.11110000""</li>
	* </ul>
	* It expects the following results:
	* <ul>
	* <li>IP Range: ""192.168.1.1 - 192.168.1.16""</li>
	* <li>Usable Range: ""192.168.1.17 - 192.168.1.254""</li>
	* <li>Broadcast Address: ""192.168.1.255""</li>
	* <li>Total IP Addresses: ""254""</li>
	* </ul>
	*/
	@Test
	void testIPCalculate_5() {
		String IP = ""11000000.10101000.00000001.00000001"";
		String IPPrefix = ""11111111.11111111.11111111.11110000"";
		String expected = ""IP Range: 192.168.1.1 - 192.168.1.16\nUsable Range: 192.168.1.17 - 192.168.1.254\nBroadcast Address: 192.168.1.255\nTotal IP Addresses: 254"";
		String actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.
	* It tests the method with the following parameters:
	* <ul>
	* <li>IP"
