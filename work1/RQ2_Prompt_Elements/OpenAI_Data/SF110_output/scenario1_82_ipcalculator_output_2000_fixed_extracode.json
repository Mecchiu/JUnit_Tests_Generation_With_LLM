[
    {
        "id": "cmpl-6wrfvgVbZ07fXrtDRcjXTRkGhytum",
        "object": "text_completion",
        "created": 1679487371,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// BinaryCalculateTest.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.\n*/\nclass BinaryCalculateTest {\n\t\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the first number is null.\n\t*/\n\t@Test\n\tvoid testAddBinary_1() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = null;\n\t\tString num2 = \"101\";\n\t\tString expected = \"101\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the second number is null.\n\t*/\n\t@Test\n\tvoid testAddBinary_2() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"101\";\n\t\tString num2 = null;\n\t\tString expected = \"101\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when both numbers are null.\n\t*/\n\t@Test\n\tvoid testAddBinary_3() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = null;\n\t\tString num2 = null;\n\t\tString expected = \"\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when both numbers are empty.\n\t*/\n\t@Test\n\tvoid testAddBinary_4() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"\";\n\t\tString num2 = \"\";\n\t\tString expected = \"\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the first number is empty.\n\t*/\n\t@Test\n\tvoid testAddBinary_5() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"\";\n\t\tString num2 = \"101\";\n\t\tString expected = \"101\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the second number is empty.\n\t*/\n\t@Test\n\tvoid testAddBinary_6() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"101\";\n\t\tString num2 = \"\";\n\t\tString expected = \"101\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the first number is longer than the second number.\n\t*/\n\t@Test\n\tvoid testAddBinary_7() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"101\";\n\t\tString expected = \"10110\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the second number is longer than the first number.\n\t*/\n\t@Test\n\tvoid testAddBinary_8() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"101\";\n\t\tString num2 = \"10101\";\n\t\tString expected = \"10110\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the two numbers are the same length.\n\t*/\n\t@Test\n\tvoid testAddBinary_9() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10101\";\n\t\tString expected = \"101010\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the two numbers are the same length and the sum is longer than the two numbers.\n\t*/\n\t@Test\n\tvoid testAddBinary_10() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10111\";\n\t\tString expected = \"101010\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": null
            }
        ],
        "usage": {
            "prompt_tokens": 754,
            "completion_tokens": 1399,
            "total_tokens": 2153
        },
        "time_taken": 56.2587788105011,
        "prompt_id": "/EvoSuiteBenchmark/scenario1/82_ipcalculator/src/main/java/ipac/BinaryCalculate0.java",
        "original_code": "// BinaryCalculate.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class BinaryCalculate {\n\n    public String addBinary(String num1, String num2) {\n        boolean carry = false;\n        int size1 = num1.length() - 1;\n        int size2 = num2.length() - 1;\n        String sum = \"\";\n        if (size2 > size1) {\n            String s = num1;\n            num1 = num2;\n            num2 = s;\n            int n = size1;\n            size1 = size2;\n            size2 = n;\n        }\n        for (; size2 >= 0; size1--, size2--) {\n            if (num1.charAt(size1) == '0' && num2.charAt(size2) == '0') {\n                if (!carry)\n                    sum = \"0\" + sum;\n                else\n                    sum = \"1\" + sum;\n                carry = false;\n            } else if (num1.charAt(size1) == '1' && num2.charAt(size2) == '0') {\n                if (!carry)\n                    sum = \"1\" + sum;\n                else {\n                    sum = \"0\" + sum;\n                    carry = true;\n                }\n            } else if (num1.charAt(size1) == '0' && num2.charAt(size2) == '1') {\n                if (!carry)\n                    sum = \"1\" + sum;\n                else {\n                    sum = \"0\" + sum;\n                    carry = true;\n                }\n            } else if (num1.charAt(size1) == '1' && num2.charAt(size2) == '1') {\n                if (!carry)\n                    sum = \"0\" + sum;\n                else\n                    sum = \"1\" + sum;\n                carry = true;\n            }\n        }\n        for (; size1 >= 0; size1--) {\n            if (num1.charAt(size1) == '0') {\n                if (!carry)\n                    sum = \"0\" + sum;\n                else\n                    sum = \"1\" + sum;\n                carry = false;\n            } else if (num1.charAt(size1) == '1') {\n                if (!carry)\n                    sum = \"1\" + sum;\n                else {\n                    sum = \"0\" + sum;\n                    carry = true;\n                }\n            }\n        }\n        if (carry)\n            sum = \"1\" + sum;\n        return sum;\n    }\n}\n",
        "test_prompt": "// BinaryCalculateTest.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.\n*/\nclass BinaryCalculateTest {",
        "original_generated_code": "\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the first number is null.\n\t*/\n\t@Test\n\tvoid testAddBinary_1() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = null;\n\t\tString num2 = \"101\";\n\t\tString expected = \"101\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the second number is null.\n\t*/\n\t@Test\n\tvoid testAddBinary_2() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"101\";\n\t\tString num2 = null;\n\t\tString expected = \"101\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when both numbers are null.\n\t*/\n\t@Test\n\tvoid testAddBinary_3() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = null;\n\t\tString num2 = null;\n\t\tString expected = \"\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when both numbers are empty.\n\t*/\n\t@Test\n\tvoid testAddBinary_4() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"\";\n\t\tString num2 = \"\";\n\t\tString expected = \"\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the first number is empty.\n\t*/\n\t@Test\n\tvoid testAddBinary_5() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"\";\n\t\tString num2 = \"101\";\n\t\tString expected = \"101\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the second number is empty.\n\t*/\n\t@Test\n\tvoid testAddBinary_6() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"101\";\n\t\tString num2 = \"\";\n\t\tString expected = \"101\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the first number is longer than the second number.\n\t*/\n\t@Test\n\tvoid testAddBinary_7() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"101\";\n\t\tString expected = \"10110\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the second number is longer than the first number.\n\t*/\n\t@Test\n\tvoid testAddBinary_8() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"101\";\n\t\tString num2 = \"10101\";\n\t\tString expected = \"10110\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the two numbers are the same length.\n\t*/\n\t@Test\n\tvoid testAddBinary_9() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10101\";\n\t\tString expected = \"101010\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the case when the two numbers are the same length and the sum is longer than the two numbers.\n\t*/\n\t@Test\n\tvoid testAddBinary_10() {\n\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10111\";\n\t\tString expected = \"101010\";\n\t\tString actual = bc.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n}",
        "applied_heuristics": ""
    },
    {
        "id": "cmpl-6wrgyC32lZx7T0B6V819FyEt9SQJa",
        "object": "text_completion",
        "created": 1679487436,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// BinaryCalculateTest.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.\n*/\nclass BinaryCalculateTest {\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two positive numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositive() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two negative numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegative() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one positive and one negative number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositiveNegative() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one negative and one positive number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegativePositive() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two positive numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositive2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two negative numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegative2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one positive and one negative number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositiveNegative2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one negative and one positive number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegativePositive2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two positive numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositive3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two negative numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegative3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one positive and one negative number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositiveNegative3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one negative and one positive number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegativePositive3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "stop"
            }
        ],
        "usage": {
            "prompt_tokens": 339,
            "completion_tokens": 1921,
            "total_tokens": 2260
        },
        "time_taken": 67.34730291366577,
        "prompt_id": "/EvoSuiteBenchmark/scenario1/82_ipcalculator/src/main/java/ipac/BinaryCalculate1.java",
        "original_code": "// BinaryCalculate.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class BinaryCalculate {\n\n    public String subBinary(String num1, String num2) {\n        String diff = \"\";\n        String twosComp = \"\";\n        int size = num1.length() - 1;\n        for (; size >= 0; size--) {\n            if (num1.charAt(size) == '0')\n                twosComp = \"1\" + twosComp;\n            else\n                twosComp = \"0\" + twosComp;\n        }\n        twosComp = \"0\" + twosComp;\n        twosComp = addBinary(twosComp, \"1\");\n        diff = addBinary(twosComp, num2);\n        return diff.substring(1);\n    }\n}\n",
        "test_prompt": "// BinaryCalculateTest.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.\n*/\nclass BinaryCalculateTest {",
        "original_generated_code": "\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two positive numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositive() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two negative numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegative() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one positive and one negative number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositiveNegative() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one negative and one positive number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegativePositive() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two positive numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositive2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two negative numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegative2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one positive and one negative number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositiveNegative2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one negative and one positive number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegativePositive2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two positive numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositive3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with two negative numbers.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegative3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one positive and one negative number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryPositiveNegative3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t\t* It tests the method with one negative and one positive number.\n\t\t*/\n\t\t@Test\n\t\tvoid testSubBinaryNegativePositive3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString num1 = \"101\";\n\t\t\t\tString num2 = \"11\";\n\t\t\t\tString expected = \"1010\";\n\t\t\t\tString actual = bc.subBinary(num1, num2);\n\t\t\t\tassertEquals(expected, actual);\n\t\t}\n}",
        "applied_heuristics": ""
    },
    {
        "id": "cmpl-6wri3yQtTDSxX6ivOi3OFr6P7COJv",
        "object": "text_completion",
        "created": 1679487503,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// BinaryCalculateTest.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.\n*/\nclass BinaryCalculateTest {\n\t\t\n\t\t/**\n\t\t* Test case 1.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"24\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.255\\nUsable Range: 192.168.1.1 - 192.168.1.254\\n\\nTotal usable IP Addresses : 254\\nSubnet: 192.168.1.1\\nBinary Subnet: 11000000.10101000.00000001.00000001\\nBroadcast Address: 192.168.1.255\\nPrefix: 24\\nNetmask: 255.255.255.0\\nBinary Netmask: 11111111.11111111.11111111.00000000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate1() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"24\");\n\t\t\t\tassertEquals(\"Total Range: 192.168.1.0 - 192.168.1.255\\nUsable Range: 192.168.1.1 - 192.168.1.254\\n\\nTotal usable IP Addresses : 254\\nSubnet: 192.168.1.1\\nBinary Subnet: 11000000.10101000.00000001.00000001\\nBroadcast Address: 192.168.1.255\\nPrefix: 24\\nNetmask: 255.255.255.0\\nBinary Netmask: 11111111.11111111.11111111.00000000\", output);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 2.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"25\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.127\\nUsable Range: 192.168.1.1 - 192.168.1.126\\n\\nTotal usable IP Addresses : 126\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.127\\nPrefix: 25\\nNetmask: 255.255.255.128\\nBinary Netmask: 11111111.11111111.11111111.10000000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"25\");\n\t\t\t\tassertEquals(\"Total Range: 192.168.1.0 - 192.168.1.127\\nUsable Range: 192.168.1.1 - 192.168.1.126\\n\\nTotal usable IP Addresses : 126\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.127\\nPrefix: 25\\nNetmask: 255.255.255.128\\nBinary Netmask: 11111111.11111111.11111111.10000000\", output);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 3.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"26\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.63\\nUsable Range: 192.168.1.1 - 192.168.1.62\\n\\nTotal usable IP Addresses : 62\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.63\\nPrefix: 26\\nNetmask: 255.255.255.192\\nBinary Netmask: 11111111.11111111.11111111.11000000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"26\");\n\t\t\t\tassertEquals(\"Total Range: 192.168.1.0 - 192.168.1.63\\nUsable Range: 192.168.1.1 - 192.168.1.62\\n\\nTotal usable IP Addresses : 62\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.63\\nPrefix: 26\\nNetmask: 255.255.255.192\\nBinary Netmask: 11111111.11111111.11111111.11000000\", output);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 4.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"27\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.31\\nUsable Range: 192.168.1.1 - 192.168.1.30\\n\\nTotal usable IP Addresses : 30\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.31\\nPrefix: 27\\nNetmask: 255.255.255.224\\nBinary Netmask: 11111111.11111111.11111111.11100000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate4() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"27\");\n\t\t\t\tassertEquals(\"Total Range: 192.168.1.0 - 192.168.1.31\\nUsable Range: 192.168.1.1 - 192.168.1.30\\n\\nTotal usable IP Addresses : 30\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.31\\nPrefix: 27\\nNetmask: 255.255.255.224\\nBinary Netmask: 11111111.11111111.11111111.11100000\", output);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 5.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"28\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.15\\nUsable Range: 192.168.1.1 - 192.168.1.14\\n\\nTotal usable IP Addresses : 14\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.15\\nPrefix: 28\\nNetmask: 255.255.255.240\\nBinary Netmask: 11111111.11111111.11111111.11110000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate5() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"28\");\n}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 517,
            "completion_tokens": 2000,
            "total_tokens": 2517
        },
        "time_taken": 66.62093567848206,
        "prompt_id": "/EvoSuiteBenchmark/scenario1/82_ipcalculator/src/main/java/ipac/BinaryCalculate2.java",
        "original_code": "// BinaryCalculate.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class BinaryCalculate {\n\n    public String IPCalculate(String IP, String IPPrefix) {\n        String outputText = \"\";\n        checkIPType(IP.length() - 1);\n        String subnet = convert(IP);\n        String netmask = getNetmask(IPPrefix);\n        calculate(IP, IPPrefix);\n        outputText += \"Total Range: \" + IPRangeAddress + \"\\n\";\n        outputText += \"Usable Range: \" + usableRange + \"\\n\";\n        NumberFormat formatter = new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\n        outputText += \"\\n\";\n        outputText += \"Total usable IP Addresses : \" + formatter.format(totalIPAddresses) + \"\\n\";\n        outputText += \"Subnet: \" + subnet + \"\\n\";\n        outputText += \"Binary Subnet: \" + getBinaryIP(IP) + \"\\n\";\n        outputText += \"Broadcast Address: \" + currentIP + \"\\n\";\n        outputText += \"Prefix: \" + prefix + \"\\n\";\n        checkIPType(netmask.length() - 1);\n        String outputNetmask = convert(netmask);\n        outputText += \"Netmask: \" + outputNetmask + \"\\n\";\n        String binaryNetmask = getBinaryIP(netmask);\n        outputText += \"Binary Netmask: \" + binaryNetmask;\n        return outputText;\n    }\n}\n",
        "test_prompt": "// BinaryCalculateTest.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.\n*/\nclass BinaryCalculateTest {",
        "original_generated_code": "\n\t\t/**\n\t\t* Test case 1.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"24\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.255\\nUsable Range: 192.168.1.1 - 192.168.1.254\\n\\nTotal usable IP Addresses : 254\\nSubnet: 192.168.1.1\\nBinary Subnet: 11000000.10101000.00000001.00000001\\nBroadcast Address: 192.168.1.255\\nPrefix: 24\\nNetmask: 255.255.255.0\\nBinary Netmask: 11111111.11111111.11111111.00000000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate1() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"24\");\n\t\t\t\tassertEquals(\"Total Range: 192.168.1.0 - 192.168.1.255\\nUsable Range: 192.168.1.1 - 192.168.1.254\\n\\nTotal usable IP Addresses : 254\\nSubnet: 192.168.1.1\\nBinary Subnet: 11000000.10101000.00000001.00000001\\nBroadcast Address: 192.168.1.255\\nPrefix: 24\\nNetmask: 255.255.255.0\\nBinary Netmask: 11111111.11111111.11111111.00000000\", output);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 2.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"25\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.127\\nUsable Range: 192.168.1.1 - 192.168.1.126\\n\\nTotal usable IP Addresses : 126\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.127\\nPrefix: 25\\nNetmask: 255.255.255.128\\nBinary Netmask: 11111111.11111111.11111111.10000000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate2() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"25\");\n\t\t\t\tassertEquals(\"Total Range: 192.168.1.0 - 192.168.1.127\\nUsable Range: 192.168.1.1 - 192.168.1.126\\n\\nTotal usable IP Addresses : 126\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.127\\nPrefix: 25\\nNetmask: 255.255.255.128\\nBinary Netmask: 11111111.11111111.11111111.10000000\", output);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 3.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"26\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.63\\nUsable Range: 192.168.1.1 - 192.168.1.62\\n\\nTotal usable IP Addresses : 62\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.63\\nPrefix: 26\\nNetmask: 255.255.255.192\\nBinary Netmask: 11111111.11111111.11111111.11000000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate3() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"26\");\n\t\t\t\tassertEquals(\"Total Range: 192.168.1.0 - 192.168.1.63\\nUsable Range: 192.168.1.1 - 192.168.1.62\\n\\nTotal usable IP Addresses : 62\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.63\\nPrefix: 26\\nNetmask: 255.255.255.192\\nBinary Netmask: 11111111.11111111.11111111.11000000\", output);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 4.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"27\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.31\\nUsable Range: 192.168.1.1 - 192.168.1.30\\n\\nTotal usable IP Addresses : 30\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.31\\nPrefix: 27\\nNetmask: 255.255.255.224\\nBinary Netmask: 11111111.11111111.11111111.11100000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate4() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"27\");\n\t\t\t\tassertEquals(\"Total Range: 192.168.1.0 - 192.168.1.31\\nUsable Range: 192.168.1.1 - 192.168.1.30\\n\\nTotal usable IP Addresses : 30\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.31\\nPrefix: 27\\nNetmask: 255.255.255.224\\nBinary Netmask: 11111111.11111111.11111111.11100000\", output);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 5.\n\t\t* Test the {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t\t* Input: IP = \"192.168.1.1\", IPPrefix = \"28\"\n\t\t* Expected output: \"Total Range: 192.168.1.0 - 192.168.1.15\\nUsable Range: 192.168.1.1 - 192.168.1.14\\n\\nTotal usable IP Addresses : 14\\nSubnet: 192.168.1.0\\nBinary Subnet: 11000000.10101000.00000001.00000000\\nBroadcast Address: 192.168.1.15\\nPrefix: 28\\nNetmask: 255.255.255.240\\nBinary Netmask: 11111111.11111111.11111111.11110000\"\n\t\t*/\n\t\t@Test\n\t\tvoid testIPCalculate5() {\n\t\t\t\tBinaryCalculate bc = new BinaryCalculate();\n\t\t\t\tString output = bc.IPCalculate(\"192.168.1.1\", \"28\");\n\t\t\t\tassertEquals(\"Total Range: 192.168.1.0 - 192.168.1.15\\nUsable Range: 192.168.1.1 - 192.168.1.14\\n\\nTotal usable IP Addresses : 14\\nSubnet: 192.168.1.0\\",
        "applied_heuristics": "H7"
    }
]