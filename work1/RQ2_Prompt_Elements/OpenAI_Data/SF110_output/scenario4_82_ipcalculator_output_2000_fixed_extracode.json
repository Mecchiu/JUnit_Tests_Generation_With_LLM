[
    {
        "id": "cmpl-6x8MWIwKuBu3fHz1yupC3TwJKlgvl",
        "object": "text_completion",
        "created": 1679551516,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// BinaryCalculate_0Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.\n*/\nclass BinaryCalculate_0Test {\n\t\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_0() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_1() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_2() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_3() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_4() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_5() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_6() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_7() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_8() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_9() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 1423,
            "completion_tokens": 2000,
            "total_tokens": 3423
        },
        "time_taken": 88.88088774681091,
        "prompt_id": "/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_0Test.java",
        "original_code": "// BinaryCalculate.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class BinaryCalculate {\n\n    boolean isIPv4 = false;\n\n    boolean isIPv6 = false;\n\n    String currentIP = \"\";\n\n    String fullReassembler = \"\";\n\n    String DELIMITER = \"\";\n\n    int lengthOfToken = 0;\n\n    String IPRangeAddress = \"\";\n\n    String usableRange = \"\";\n\n    int semiCol = 0;\n\n    String prefix = \"\";\n\n    BigInteger totalIPAddresses;\n\n    int MAXPREFIX = 0;\n\n    /**\n     *  Calculates the sum of two binary numbers.\n     *\n     *  @param       num1    The starting binary number\n     *  @param       num2    The binary number to be added to the starting binary\n     *  @return      The sum of two binary numbers.\n     */\n    public String addBinary(String num1, String num2);\n\n    /**\n     *  Subtracts two binary numbers.\n     *\n     *  @param       num1    The starting binary number\n     *  @param       num2    The binary number to be subtracted from the\n     *                       starting binary\n     *  @return      The difference of two binary numbers.\n     */\n    public String subBinary(String num1, String num2);\n\n    /**\n     *  Calculates the IP Range from the provided IP address and number of IP\n     *  addresses. The results are stored into an <code>string</code> to be\n     *  returned to the method that called it.\n     *\n     *  @param      IP          The starting IP address (subnet) in binary\n     *  @param      IPPrefix    Number of IP addresses in binary\n     *  @return     Results string\n     */\n    public String IPCalculate(String IP, String IPPrefix);\n\n    /**\n     *  Adds delimiters back into a given IP address\n     *\n     *  @param      binaryIP     binary IP address with no delimiters\n     *  @return     binary IP address with delimiters\n     */\n    private String getBinaryIP(String binaryIP);\n\n    /**\n     *  Gets the netmask from a binary representation of number of IP addresses\n     *\n     *  @param      binaryIP     binary representation of number of IP addresses\n     *  @return     netmask of <code>binaryIP</code>\n     */\n    private String getNetmask(String binaryIP);\n\n    /**\n     *  Calculates the IP Range from the provided IP address and number of IP\n     *  addresses. The results are stored as declared global variables for many\n     *  other methods to manipulate or use.\n     *  <br>This method also detects if the provided of number of IP addresses\n     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and\n     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds\n     *  the IP addressing bounds.\n     *  <br>This method also calculates the prefix size needed to accomodate all\n     *  the IP Addresses to be listed and stores it as a global variable for use\n     *  in other methods.\n     *\n     *  @param       subnet              The starting IP address (subnet)\n     *  @param       noOfIPAddresses     Number of IP addresses\n     */\n    private void calculate(String subnet, String noOfIPAddresses);\n\n    /**\n     *  Calculates the IP Range from the provided IP address and number of IP\n     *  addresses from the smaller prefix. The results are stored into an array\n     *  to be printed using <code><b>Output.java</b></code>.\n     *\n     *  @param       IP          The starting IP address (subnet)\n     *  @param       IPPrefix    Number of IP addresses for smaller prefix\n     *  @param       noPrefix    Number of smaller prefixes within the total\n     *                           prefix\n     *  @param       endPrefix   Prefix of total number of IP Addresses\n     */\n    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);\n\n    /**\n     *  Determines whether an IP Address provided in binary form is an IPv4 or\n     *  an IPv6 by the length of the binary string.\n     *\n     *  @param       size1    Length of binary string\n     */\n    private void checkIPType(int size1);\n\n    /**\n     *  Reconstructs the dotted-decimal or hexidecimal IP address with\n     *  seperators from an given binary IP Address. The reconstructed IP address\n     *  is stored as a global declared variable, <code>currentIP</code>.\n     *\n     *  @param   IP  An binary IP Address to be converted back into\n     *               dotted-decimal or hexidecimal format\n     */\n    private String convert(String binaryIP);\n\n    /**\n     *  Converts an given IPv4 or IPv6 address into binary format.\n     *\n     *  @param   IP  An IP Address to be converted back into binary format\n     *  @return  Binary representation of given IP Address.\n     */\n    private String convertToBinary(String IP);\n\n    /**\n     *  Gets the starting IP of an IP range.\n     *\n     *  @return     Starting IP of IP range\n     */\n    private String getStartIP();\n}\n",
        "test_prompt": "// BinaryCalculate_0Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.\n*/\nclass BinaryCalculate_0Test {",
        "original_generated_code": "\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_0() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_1() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_2() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_3() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_4() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_5() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_6() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_7() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_8() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#addBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testAddBinary_9() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.addBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n}\n\n// BinaryCalculate_1Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.\n*/\nclass BinaryCalculate_1Test {\n\t\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testSubBinary_0() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11011\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.subBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal in length.\n\t*/\n\t@Test\n\tvoid testSubBinary_1() {\n\t\tBinaryCalculate binaryCalculate = new BinaryCalculate();\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"1101\";\n\t\tString expected = \"101000\";\n\t\tString actual = binaryCalculate.subBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal in length.\n\t*/\n\t@Test\n\tvoid testSubBinary_2() {\n\t",
        "applied_heuristics": "H1"
    },
    {
        "id": "cmpl-6x8NxP4ENhy87OBukAe2XYIQK5Eu4",
        "object": "text_completion",
        "created": 1679551605,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// BinaryCalculate_1Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.\n*/\nclass BinaryCalculate_1Test {\n\t\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal.\n\t*/\n\t@Test\n\tvoid testSubBinary_1() {\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10101\";\n\t\tString expected = \"0\";\n\t\tString actual = new BinaryCalculate().subBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal.\n\t*/\n\t@Test\n\tvoid testSubBinary_2() {\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10100\";\n\t\tString expected = \"1\";\n\t\tString actual = new BinaryCalculate().subBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal.\n\t*/\n\t@Test\n\tvoid testSubBinary_3() {\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10110\";\n\t\tString expected = \"1111\";\n\t\tString actual = new BinaryCalculate().subBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal.\n\t*/\n\t@Test\n\tvoid testSubBinary_4() {\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11111\";\n}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 1423,
            "completion_tokens": 2000,
            "total_tokens": 3423
        },
        "time_taken": 83.24481725692749,
        "prompt_id": "/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_1Test.java",
        "original_code": "// BinaryCalculate.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class BinaryCalculate {\n\n    boolean isIPv4 = false;\n\n    boolean isIPv6 = false;\n\n    String currentIP = \"\";\n\n    String fullReassembler = \"\";\n\n    String DELIMITER = \"\";\n\n    int lengthOfToken = 0;\n\n    String IPRangeAddress = \"\";\n\n    String usableRange = \"\";\n\n    int semiCol = 0;\n\n    String prefix = \"\";\n\n    BigInteger totalIPAddresses;\n\n    int MAXPREFIX = 0;\n\n    /**\n     *  Calculates the sum of two binary numbers.\n     *\n     *  @param       num1    The starting binary number\n     *  @param       num2    The binary number to be added to the starting binary\n     *  @return      The sum of two binary numbers.\n     */\n    public String addBinary(String num1, String num2);\n\n    /**\n     *  Subtracts two binary numbers.\n     *\n     *  @param       num1    The starting binary number\n     *  @param       num2    The binary number to be subtracted from the\n     *                       starting binary\n     *  @return      The difference of two binary numbers.\n     */\n    public String subBinary(String num1, String num2);\n\n    /**\n     *  Calculates the IP Range from the provided IP address and number of IP\n     *  addresses. The results are stored into an <code>string</code> to be\n     *  returned to the method that called it.\n     *\n     *  @param      IP          The starting IP address (subnet) in binary\n     *  @param      IPPrefix    Number of IP addresses in binary\n     *  @return     Results string\n     */\n    public String IPCalculate(String IP, String IPPrefix);\n\n    /**\n     *  Adds delimiters back into a given IP address\n     *\n     *  @param      binaryIP     binary IP address with no delimiters\n     *  @return     binary IP address with delimiters\n     */\n    private String getBinaryIP(String binaryIP);\n\n    /**\n     *  Gets the netmask from a binary representation of number of IP addresses\n     *\n     *  @param      binaryIP     binary representation of number of IP addresses\n     *  @return     netmask of <code>binaryIP</code>\n     */\n    private String getNetmask(String binaryIP);\n\n    /**\n     *  Calculates the IP Range from the provided IP address and number of IP\n     *  addresses. The results are stored as declared global variables for many\n     *  other methods to manipulate or use.\n     *  <br>This method also detects if the provided of number of IP addresses\n     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and\n     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds\n     *  the IP addressing bounds.\n     *  <br>This method also calculates the prefix size needed to accomodate all\n     *  the IP Addresses to be listed and stores it as a global variable for use\n     *  in other methods.\n     *\n     *  @param       subnet              The starting IP address (subnet)\n     *  @param       noOfIPAddresses     Number of IP addresses\n     */\n    private void calculate(String subnet, String noOfIPAddresses);\n\n    /**\n     *  Calculates the IP Range from the provided IP address and number of IP\n     *  addresses from the smaller prefix. The results are stored into an array\n     *  to be printed using <code><b>Output.java</b></code>.\n     *\n     *  @param       IP          The starting IP address (subnet)\n     *  @param       IPPrefix    Number of IP addresses for smaller prefix\n     *  @param       noPrefix    Number of smaller prefixes within the total\n     *                           prefix\n     *  @param       endPrefix   Prefix of total number of IP Addresses\n     */\n    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);\n\n    /**\n     *  Determines whether an IP Address provided in binary form is an IPv4 or\n     *  an IPv6 by the length of the binary string.\n     *\n     *  @param       size1    Length of binary string\n     */\n    private void checkIPType(int size1);\n\n    /**\n     *  Reconstructs the dotted-decimal or hexidecimal IP address with\n     *  seperators from an given binary IP Address. The reconstructed IP address\n     *  is stored as a global declared variable, <code>currentIP</code>.\n     *\n     *  @param   IP  An binary IP Address to be converted back into\n     *               dotted-decimal or hexidecimal format\n     */\n    private String convert(String binaryIP);\n\n    /**\n     *  Converts an given IPv4 or IPv6 address into binary format.\n     *\n     *  @param   IP  An IP Address to be converted back into binary format\n     *  @return  Binary representation of given IP Address.\n     */\n    private String convertToBinary(String IP);\n\n    /**\n     *  Gets the starting IP of an IP range.\n     *\n     *  @return     Starting IP of IP range\n     */\n    private String getStartIP();\n}\n",
        "test_prompt": "// BinaryCalculate_1Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.\n*/\nclass BinaryCalculate_1Test {",
        "original_generated_code": "\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are equal.\n\t*/\n\t@Test\n\tvoid testSubBinary_1() {\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10101\";\n\t\tString expected = \"0\";\n\t\tString actual = new BinaryCalculate().subBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal.\n\t*/\n\t@Test\n\tvoid testSubBinary_2() {\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10100\";\n\t\tString expected = \"1\";\n\t\tString actual = new BinaryCalculate().subBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal.\n\t*/\n\t@Test\n\tvoid testSubBinary_3() {\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"10110\";\n\t\tString expected = \"1111\";\n\t\tString actual = new BinaryCalculate().subBinary(num1, num2);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#subBinary(String, String)} method.\n\t* It tests the method with two binary numbers that are not equal.\n\t*/\n\t@Test\n\tvoid testSubBinary_4() {\n\t\tString num1 = \"10101\";\n\t\tString num2 = \"11111\";\n\t\tString expected = \"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
        "applied_heuristics": "H7"
    },
    {
        "id": "cmpl-6x8PIQZ7ofCPK0KGeZI2T26uSD9Sn",
        "object": "text_completion",
        "created": 1679551688,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// BinaryCalculate_2Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.\n*/\nclass BinaryCalculate_2Test {\n\t\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11111111\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.1\"</li>\n\t* <li>Usable Range: \"192.168.1.2 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_1() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11111111\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.1\\nUsable Range: 192.168.1.2 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11111110\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.2\"</li>\n\t* <li>Usable Range: \"192.168.1.3 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_2() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11111110\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.2\\nUsable Range: 192.168.1.3 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11111100\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.4\"</li>\n\t* <li>Usable Range: \"192.168.1.5 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_3() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11111100\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.4\\nUsable Range: 192.168.1.5 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11111000\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.8\"</li>\n\t* <li>Usable Range: \"192.168.1.9 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_4() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11111000\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.8\\nUsable Range: 192.168.1.9 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11110000\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.16\"</li>\n\t* <li>Usable Range: \"192.168.1.17 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_5() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11110000\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.16\\nUsable Range: 192.168.1.17 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 1424,
            "completion_tokens": 2000,
            "total_tokens": 3424
        },
        "time_taken": 70.49733829498291,
        "prompt_id": "/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_2Test.java",
        "original_code": "// BinaryCalculate.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class BinaryCalculate {\n\n    boolean isIPv4 = false;\n\n    boolean isIPv6 = false;\n\n    String currentIP = \"\";\n\n    String fullReassembler = \"\";\n\n    String DELIMITER = \"\";\n\n    int lengthOfToken = 0;\n\n    String IPRangeAddress = \"\";\n\n    String usableRange = \"\";\n\n    int semiCol = 0;\n\n    String prefix = \"\";\n\n    BigInteger totalIPAddresses;\n\n    int MAXPREFIX = 0;\n\n    /**\n     *  Calculates the sum of two binary numbers.\n     *\n     *  @param       num1    The starting binary number\n     *  @param       num2    The binary number to be added to the starting binary\n     *  @return      The sum of two binary numbers.\n     */\n    public String addBinary(String num1, String num2);\n\n    /**\n     *  Subtracts two binary numbers.\n     *\n     *  @param       num1    The starting binary number\n     *  @param       num2    The binary number to be subtracted from the\n     *                       starting binary\n     *  @return      The difference of two binary numbers.\n     */\n    public String subBinary(String num1, String num2);\n\n    /**\n     *  Calculates the IP Range from the provided IP address and number of IP\n     *  addresses. The results are stored into an <code>string</code> to be\n     *  returned to the method that called it.\n     *\n     *  @param      IP          The starting IP address (subnet) in binary\n     *  @param      IPPrefix    Number of IP addresses in binary\n     *  @return     Results string\n     */\n    public String IPCalculate(String IP, String IPPrefix);\n\n    /**\n     *  Adds delimiters back into a given IP address\n     *\n     *  @param      binaryIP     binary IP address with no delimiters\n     *  @return     binary IP address with delimiters\n     */\n    private String getBinaryIP(String binaryIP);\n\n    /**\n     *  Gets the netmask from a binary representation of number of IP addresses\n     *\n     *  @param      binaryIP     binary representation of number of IP addresses\n     *  @return     netmask of <code>binaryIP</code>\n     */\n    private String getNetmask(String binaryIP);\n\n    /**\n     *  Calculates the IP Range from the provided IP address and number of IP\n     *  addresses. The results are stored as declared global variables for many\n     *  other methods to manipulate or use.\n     *  <br>This method also detects if the provided of number of IP addresses\n     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and\n     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds\n     *  the IP addressing bounds.\n     *  <br>This method also calculates the prefix size needed to accomodate all\n     *  the IP Addresses to be listed and stores it as a global variable for use\n     *  in other methods.\n     *\n     *  @param       subnet              The starting IP address (subnet)\n     *  @param       noOfIPAddresses     Number of IP addresses\n     */\n    private void calculate(String subnet, String noOfIPAddresses);\n\n    /**\n     *  Calculates the IP Range from the provided IP address and number of IP\n     *  addresses from the smaller prefix. The results are stored into an array\n     *  to be printed using <code><b>Output.java</b></code>.\n     *\n     *  @param       IP          The starting IP address (subnet)\n     *  @param       IPPrefix    Number of IP addresses for smaller prefix\n     *  @param       noPrefix    Number of smaller prefixes within the total\n     *                           prefix\n     *  @param       endPrefix   Prefix of total number of IP Addresses\n     */\n    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);\n\n    /**\n     *  Determines whether an IP Address provided in binary form is an IPv4 or\n     *  an IPv6 by the length of the binary string.\n     *\n     *  @param       size1    Length of binary string\n     */\n    private void checkIPType(int size1);\n\n    /**\n     *  Reconstructs the dotted-decimal or hexidecimal IP address with\n     *  seperators from an given binary IP Address. The reconstructed IP address\n     *  is stored as a global declared variable, <code>currentIP</code>.\n     *\n     *  @param   IP  An binary IP Address to be converted back into\n     *               dotted-decimal or hexidecimal format\n     */\n    private String convert(String binaryIP);\n\n    /**\n     *  Converts an given IPv4 or IPv6 address into binary format.\n     *\n     *  @param   IP  An IP Address to be converted back into binary format\n     *  @return  Binary representation of given IP Address.\n     */\n    private String convertToBinary(String IP);\n\n    /**\n     *  Gets the starting IP of an IP range.\n     *\n     *  @return     Starting IP of IP range\n     */\n    private String getStartIP();\n}\n",
        "test_prompt": "// BinaryCalculate_2Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.\n*/\nclass BinaryCalculate_2Test {",
        "original_generated_code": "\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11111111\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.1\"</li>\n\t* <li>Usable Range: \"192.168.1.2 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_1() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11111111\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.1\\nUsable Range: 192.168.1.2 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11111110\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.2\"</li>\n\t* <li>Usable Range: \"192.168.1.3 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_2() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11111110\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.2\\nUsable Range: 192.168.1.3 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11111100\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.4\"</li>\n\t* <li>Usable Range: \"192.168.1.5 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_3() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11111100\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.4\\nUsable Range: 192.168.1.5 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11111000\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.8\"</li>\n\t* <li>Usable Range: \"192.168.1.9 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_4() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11111000\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.8\\nUsable Range: 192.168.1.9 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP: \"11000000.10101000.00000001.00000001\"</li>\n\t* <li>IPPrefix: \"11111111.11111111.11111111.11110000\"</li>\n\t* </ul>\n\t* It expects the following results:\n\t* <ul>\n\t* <li>IP Range: \"192.168.1.1 - 192.168.1.16\"</li>\n\t* <li>Usable Range: \"192.168.1.17 - 192.168.1.254\"</li>\n\t* <li>Broadcast Address: \"192.168.1.255\"</li>\n\t* <li>Total IP Addresses: \"254\"</li>\n\t* </ul>\n\t*/\n\t@Test\n\tvoid testIPCalculate_5() {\n\t\tString IP = \"11000000.10101000.00000001.00000001\";\n\t\tString IPPrefix = \"11111111.11111111.11111111.11110000\";\n\t\tString expected = \"IP Range: 192.168.1.1 - 192.168.1.16\\nUsable Range: 192.168.1.17 - 192.168.1.254\\nBroadcast Address: 192.168.1.255\\nTotal IP Addresses: 254\";\n\t\tString actual = new BinaryCalculate().IPCalculate(IP, IPPrefix);\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t* Test case for {@link BinaryCalculate#IPCalculate(String, String)} method.\n\t* It tests the method with the following parameters:\n\t* <ul>\n\t* <li>IP",
        "applied_heuristics": "H7"
    }
]