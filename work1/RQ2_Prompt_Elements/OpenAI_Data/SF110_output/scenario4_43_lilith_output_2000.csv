ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6x9mSWX2PYsCF23eivEBQGE5iu5yk,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_0Test.java,84.10109496116638,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_0Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_0Test {","// MessageFormatter_0Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_0Test {

		@Test
		public void testFormat_0() {
				String messagePattern = """";
				String[] arguments = new String[0];
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		@Test
		public void testFormat_1() {
				String messagePattern = """";
				String[] arguments = new String[] { ""a"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		@Test
		public void testFormat_2() {
				String messagePattern = """";
				String[] arguments = new String[] { ""a"", ""b"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		@Test
		public void testFormat_3() {
				String messagePattern = """";
				String[] arguments = new String[] { ""a"", ""b"", ""c"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		@Test
		public void testFormat_4() {
				String messagePattern = """";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		@Test
		public void testFormat_5() {
				String messagePattern = """";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		@Test
		public void testFormat_6() {
				String messagePattern = """";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		@Test
		public void testFormat_7() {
				String messagePattern = """";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		@Test
		public void testFormat_8() {
				String messagePattern = """";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		@Test
		public void testFormat_9() {
				String messagePattern = """";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
}

// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_1Test {
		
		@Test
		public void testFormat_0() {
				String messagePattern = ""a"";
				String[] arguments = new String[0];
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals(""a"", result);
		}
		
		@Test
		public void testFormat_1() {
				String messagePattern = ""a"";
				String[] arguments = new String[] { ""a"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals(""a"", result);
		}
		
		@Test
		public void testFormat_2() {
				String messagePattern = ""a"";
				String[] arguments = new String[] { ""a"", ""b"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals(""a"", result);
		}
		
		@Test
		public void testFormat_3() {
				String messagePattern = ""a"";
				String[] arguments = new String[] { ""a"", ""b"", ""c"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals(""a"", result);
		}
		
		@Test
		public void testFormat_4() {
				String messagePattern = ""a"";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals(""a"", result);
		}
		
		@Test
		public void testFormat_5() {
				String messagePattern = ""a"";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals(""a"", result);
		}
		
		@Test
		public void testFormat_6() {
				String messagePattern = ""a"";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals(""a"", result);
		}
		
		@Test
		public void testFormat_7() {
				String messagePattern = ""a"";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals(""a"", result);
		}
		
		@Test
		public void testFormat_8() {
				String messagePattern = ""a"";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"" };
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals(""a"", result);
		}
		
		@Test
		public void testFormat_9() {
				String messagePattern = ""a"";
				String[] arguments = new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"","
cmpl-6x9o2QQLBiV3hX5nMwDIRcRJXerz9,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_1Test.java,91.57513093948364,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatter_1Test {","// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatter_1Test {

		@Test
		public void testCountArgumentPlaceholders_1() {
				String messagePattern = """";
				int expected = 0;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_2() {
				String messagePattern = ""This is a test."";
				int expected = 0;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_3() {
				String messagePattern = ""This is a test. {}"";
				int expected = 1;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_4() {
				String messagePattern = ""This is a test. {}{}"";
				int expected = 2;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_5() {
				String messagePattern = ""This is a test. {}{}{}"";
				int expected = 3;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_6() {
				String messagePattern = ""This is a test. {}{}{}{}"";
				int expected = 4;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_7() {
				String messagePattern = ""This is a test. {}{}{}{}{}"";
				int expected = 5;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_8() {
				String messagePattern = ""This is a test. {}{}{}{}{}{}"";
				int expected = 6;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_9() {
				String messagePattern = ""This is a test. {}{}{}{}{}{}{}"";
				int expected = 7;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_10() {
				String messagePattern = ""This is a test. {}{}{}{}{}{}{}{}"";
				int expected = 8;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
}

// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_2Test {
		
		@Test
		public void testEvaluateArguments_1() {
				String messagePattern = """";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_2() {
				String messagePattern = ""This is a test."";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_3() {
				String messagePattern = ""This is a test. {}"";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_4() {
				String messagePattern = ""This is a test. {}"";
				Object[] arguments = new Object[] { ""test"" };
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] { ""test"" }, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_5() {
				String messagePattern = ""This is a test. {}"";
				Object[] arguments = new Object[] { ""test"", ""test2"" };
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] { ""test"" }, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_6() {
				String messagePattern = ""This is a test. {}"";
				Object[] arguments = new Object[] { ""test"", ""test2"", ""test3"" };
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] { ""test"" }, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_7() {
				String messagePattern = ""This is a test. {}"";
				Object[] arguments = new Object[] { ""test"", ""test2"", ""test3"", ""test4"" };
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] { ""test"" }, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern"
cmpl-6x9pHCOIc9c7whOF8YSGfWOYWuBdC,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_2Test.java,95.54777026176453,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_2Test {","// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_2Test {

		@Test
		public void testEvaluateArguments_1() {
				String messagePattern = """";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_2() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_3() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_4() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_5() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_6() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_7() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_8() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_9() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_10() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
}

// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_3Test {
		
		@Test
		public void testEvaluateArguments_1() {
				String messagePattern = """";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_2() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_3() {
				String messagePattern"
cmpl-6x9qp7M7nWJEMF86BSeWuh5Rmw2wJ,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_3Test.java,74.67772507667542,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_3Test {","// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_3Test {

		@Test
		public void testIdentityToString() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(""test""));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new String(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern().intern()));
		}
}

// MessageFormatter_4Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_4Test {
		
		@Test
		public void testIdentityToString() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(""test""));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new String(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern().intern()));
		}
}

// MessageFormatter_5Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_5Test {
		
		@Test
		public void testIdentityToString() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(""test""));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new String(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern().intern()));
		}
}

// MessageFormatter_6Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import"
cmpl-6x9s2MbAtve4gHmMIGn1yd5AnctZk,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/logback/classic/NDC.java,75.99526572227478,length,"// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    private static final NDCAdapter ndcAdapter;

    static {
    }

    private NDC() {
    }

    public static void push(String message);

    public static void push(String messagePattern, Object[] arguments);

    /**
     * Pops the last message from the stack.
     * <p/>
     * This method does not return the popped message to discourage it's usage in application logic.
     */
    public static void pop();

    public static int getDepth();

    public static void setMaximumDepth(int maximumDepth);

    public static boolean isEmpty();

    public static void clear();

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}
","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {

	@Test
	void testGetContextStack() {
		NDC.clear();
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(0, contextStack.length);
		
		NDC.push(""Message 1"");
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		
		NDC.push(""Message 2"");
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(2, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		assertEquals(""Message 2"", contextStack[1].getMessage());
		
		NDC.push(""Message 3"");
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(3, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		assertEquals(""Message 2"", contextStack[1].getMessage());
		assertEquals(""Message 3"", contextStack[2].getMessage());
		
		NDC.pop();
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(2, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		assertEquals(""Message 2"", contextStack[1].getMessage());
		
		NDC.pop();
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		
		NDC.pop();
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(0, contextStack.length);
		
		NDC.push(""Message 1"");
		NDC.push(""Message 2"");
		NDC.push(""Message 3"");
		NDC.clear();
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(0, contextStack.length);
	}
}
```

## Test Coverage

The test coverage of the project is measured by [JaCoCo](https://www.jacoco.org/jacoco/).

The following table shows the current test coverage of the project.

| Class | Instruction | Line | Branch | Complexity |
| ----- | ----------- | ---- | ------ | ---------- |
| [NDC](src/main/java/de/huxhorn/lilith/logback/classic/NDC.java) | 100% | 100% | 100% | 100% |
| [NDCAdapter](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapter.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterFactory](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterFactory.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterFactoryImpl](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterFactoryImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry.NDCStackEntryMessage](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry.NDCStackEntryMessage.NDCStackEntryMessageArgument](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry.NDCStackEntryMessage.NDCStackEntryMessageArgument.NDCStackEntryMessageArgumentValue](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry.NDCStackEntryMessage.NDCStackEntryMessageArgument.NDCStackEntryMessageArgumentValue.NDCStackEntryMessageArgumentValueType](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry.NDCStackEntryMessage.NDCStackEntryMessageArgument.NDCStackEntryMessageArgumentValue.NDCStackEntryMessageArgumentValueType.NDCStackEntryMessageArgumentValueTypeEnum](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry.NDCStackEntryMessage.NDCStackEntryMessageArgument.NDCStackEntryMessageArgumentValue.NDCStackEntryMessageArgumentValueType.NDCStackEntryMessageArgumentValueTypeEnum.NDCStackEntryMessageArgumentValueTypeEnumConverter](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry.NDCStackEntryMessage.NDCStackEntryMessageArgument.NDCStackEntryMessageArgumentValue.NDCStackEntryMessageArgumentValueType.NDCStackEntryMessageArgumentValueTypeEnum.NDCStackEntryMessageArgumentValueTypeEnumConverter.NDCStackEntryMessageArgumentValueTypeEnumConverterFactory](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry.NDCStackEntryMessage.NDCStackEntryMessageArgument.NDCStackEntryMessageArgumentValue.NDCStackEntryMessageArgumentValueType.NDCStackEntryMessageArgumentValueTypeEnum.NDCStackEntryMessageArgumentValueTypeEnumConverter.NDCStackEntryMessageArgumentValueTypeEnumConverterFactory.NDCStackEntryMessageArgumentValueTypeEnumConverterFactoryImpl](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapterImpl.java) | 100% | 100% | 100% | 100% |
| [NDCAdapterImpl.NDCStack.NDCStackEntry.NDCStackEntryMessage.NDCStackEntryMessageArgument.NDCStackEntryMessageArgumentValue.NDCStackEntryMessageArgumentValueType.NDCStackEntryMessageArgumentValueTypeEnum.NDCStackEntryMessageArgumentValueTypeEnumConverter.NDCStackEntryMessageArgumentValueTypeEnumConverterFactory.NDCStackEntryMessageArgumentValueTypeEnumConverterFactoryImpl.NDCStackEntryMessageArgumentValueTypeEnumConverterImpl](src/main/java/de/huxhorn/lilith/logback/classic/NDCAdapter"
cmpl-6x9tG7SnHp0IJ0dN7Zw7nevuYUgcT,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/AboutPanel.java,96.86518001556396,length,"// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);

    public static final String BACKGROUND_IMAGE_RESOURCE = ""background.png"";

    public static final String ABOUT_IMAGE_RESOURCE = ""about.png"";

    public static final String TEXT_RESOURCE_PREFIX = ""about."";

    public static final String SCROLL_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + ""scroll.text"";

    public static final String VERSION_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + ""version.text"";

    public static final String VERSION_HEIGHT_RESOURCE = TEXT_RESOURCE_PREFIX + ""version.height"";

    public static final String SCROLL_AREA_RESOURCE_BASE = TEXT_RESOURCE_PREFIX + ""scroll.area."";

    public static final String SCROLL_AREA_X_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""x"";

    public static final String SCROLL_AREA_Y_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""y"";

    public static final String SCROLL_AREA_WIDTH_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""width"";

    public static final String SCROLL_AREA_HEIGHT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""height"";

    public static final String SCROLL_AREA_TOOLTIP_TEXT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""tooltip.text"";

    public static final String TEXT_RESOURCE_BUNDLE_RESOURCE = ""TextResources"";

    public static final int MOUSE_DISABLED = 0;

    public static final int MOUSE_COMPONENT = 1;

    public static final int MOUSE_SCROLLAREA = 2;

    public static final int MOUSE_BACKGROUND = 3;

    //private static final int SCROLL_SLEEP_TIME = 50;
    private static final int SCROLL_PIXELS = 1;

    private BufferedImage backgroundImage;

    private BufferedImage aboutImage;

    //private ImageIcon aboutImageIcon;
    private FontMetrics fontMetrics;

    private Insets insets;

    private Dimension size;

    private Dimension preferredSize;

    private Point offscreenOffset;

    private String[] scrollLines;

    private String versionText;

    private String scrollAreaToolTipText;

    private int versionHeight;

    private int scrollPosition;

    private int maxScrollPosition;

    private int minScrollPosition;

    private Rectangle maxScrollArea;

    private Rectangle backgroundImageArea;

    private Rectangle translatedBackgroundImageArea;

    private Rectangle translatedScrollArea;

    private Rectangle scrollArea;

    private Rectangle paintArea;

    private BufferedImage offscreenImage;

    private BufferedImage scrollImage;

    private boolean scrolling;

    //private boolean painted;
    private int mouseEventHandling = MOUSE_BACKGROUND;

    //private transient Thread scrollThread;
    private boolean debug;

    private Timer timer;

    /**
     * Creates a new <code>AboutPanel</code> initialized with the given parameters.
     *
     * @param backgroundImageUrl The URL to the Background-Image of the
     *                           AboutPanel. This parameter is mandatory.
     * @param scrollArea         The Rectangle inside the background-image where
     *                           scrolling should take place. This parameter is optional. If it's null
     *                           then the scroll-area is set to (0, 0, background.width,
     *                           background.height).
     */
    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText) throws IOException {
    }

    public boolean isDebug();

    public void setDebug(boolean debug);

    /**
     * Creates a new <code>AboutPanel</code> initialized with the given parameters.
     *
     * @param backgroundImageUrl The URL to the Background-Image of the
     *                           AboutPanel. This parameter is mandatory.
     * @param scrollArea         The Rectangle inside the background-image where
     *                           scrolling should take place. This parameter is optional. If it's null
     *                           then the scroll-area is set to (0, 0, background.width,
     *                           background.height).
     * @param versionText        The String describing the version of the program.
     *                           It is painted centered to the scroll-rectangle at the specified height.
     *                           This parameter is optional.
     * @param versionHeight      The height at which the version-string is
     *                           supposed to be painted. This parameter is optional but should be given
     *                           a correct value if versionText!=null..
     */
    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, String versionText, int versionHeight) throws IOException {
    }

    /**
     * Creates a new <code>AboutPanel</code> initialized with the given parameters.
     *
     * @param backgroundImageUrl The URL to the Background-Image of the
     *                           AboutPanel. This parameter is mandatory.
     * @param scrollArea         The Rectangle inside the background-image where
     *                           scrolling should take place. This parameter is optional. If it's null
     *                           then the scroll-area is set to (0, 0, background.width,
     *                           background.height).
     * @param imageUrl           The URL to the Image that will be painted at the
     *                           start of the scroll-area. This parameter is optional.
     * @param versionText        The String describing the version of the program.
     *                           It is painted centered to the scroll-rectangle at the specified height.
     *                           This parameter is optional.
     * @param versionHeight      The height at which the version-string is
     *                           supposed to be painted. This parameter is optional but should be given
     *                           a correct value if versionText!=null..
     */
    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException {
    }

    public AboutPanel() {
    }

    private void init(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException;

    private void initAttributes();

    public void setScrollText(String ScrollText);

    protected void setScrollLines(String[] scrollLines);

    /**
     * Sets the backgroundImage attribute of the <code>AboutPanel</code> object
     */
    public void setBackgroundImage(URL imageUrl) throws IOException;

    /**
     * Sets the backgroundImage attribute of the <code>AboutPanel</code> object
     *
     * @param BackgroundImage The new backgroundImage value
     */
    public void setBackgroundImage(BufferedImage BackgroundImage);

    public void setAboutImage(URL imageUrl) throws IOException;

    public void setAboutImage(BufferedImage AboutImage);

    /**
     * Sets the scrollArea attribute of the <code>AboutPanel</code> object
     *
     * @param ScrollArea The new scrollArea value
     */
    public void setScrollArea(Rectangle ScrollArea);

    /**
     * Description of the Method
     */
    private void flushScrollImage();

    /**
     * Description of the Method
     */
    private void flushOffscreenImage();

    /**
     * Description of the Method
     */
    private void updateBackgroundAttributes();

    /**
     * Sets the ToolTipText that will appear if the user moves the mouse over the
     * scroll-area of this component.
     *
     * @param toolTipText The new ScrollAreaToolTipText value
     */
    public void setScrollAreaToolTipText(String toolTipText);

    /**
     * Gets the ScrollAreaToolTipText attribute of the <code>AboutPanel</code>
     * object
     *
     * @return The ScrollAreaToolTipText value
     */
    public String getScrollAreaToolTipText();

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt);

    protected boolean handleMouseEvent(MouseEvent evt);

    /**
     * Increases the ScrollPosition by SCROLL_PIXELS. This method is called by the
     * scroll-thread and calls <code>setScrollPosition</code>, therefore causing a
     * repaint of the scroll-area..
     *
     * @see #setScrollPosition
     */
    protected void increaseScrollPosition();

    /**
     * Sets the scrollPosition attribute of the <code>AboutPanel</code> object. The
     * value will be corrected according Minimum- and MaximumScrollPosition.
     * Changing the scroll-position will result in a repaint of the scroll-area.
     *
     * @param scrollPosition The new scrollPosition value. This value indicates
     *                       the height-offset of the scroll-area.
     * @see #getMinimumScrollPosition
     * @see #getMaximumScrollPosition
     */
    public void setScrollPosition(int scrollPosition);

    /**
     * Gets the ScrollPosition attribute of the <code>AboutPanel</code> object
     *
     * @return this value indicates the height-offset of the scroll-area.
     */
    public int getScrollPosition();

    /**
     * Gets the MinimumScrollPosition attribute of the <code>AboutPanel</code>
     * object. It's value is the negated value of the scroll-area-height.
     *
     * @return The MinimumScrollPosition value
     */
    public int getMinimumScrollPosition();

    /**
     * Gets the MaximumScrollPosition attribute of the <code>AboutPanel</code>
     * object. It's value is the height needed for all lines of text plus (if
     * available) the height of the image with an additional empty line.
     *
     * @return The MaximumScrollPosition value
     */
    public int getMaximumScrollPosition();

    /**
     * This method creates the offscreen-image when needed (when called for the
     * first time or recreated because of a changed font) and updates it on
     * subsequent calls by calling <code>updateOffscreenImage()</code>.
     */
    private void processOffscreenImage();

    /**
     * Updates the offscreen-image to represent the current scroll-position. It
     * calls <code>initScrollImage()</code>.
     *
     * @param g <code>Graphics</code>-object
     */
    private void drawScrollArea(Graphics2D g);

    /**
     * Initializes the scroll-image if needed. The scroll-image is as high as
     * needed to contain all the scroll-lines and (if available) the image.
     */
    private void initScrollImage();

    public static ConvolveOp getGaussianBlurFilter(int radius, boolean horizontal);

    /**
     * Sets the font attribute of the <code>AboutPanel</code> object. Setting it
     * will result in the recreation of all buffers. The font can even be safely
     * changed while the component is visible. It will be used for the version- and
     * scroll-text.<p />
     * <p/>
     * If the parameter is <code>null</code> then <code>UIManager.getFont( ""Label.font"" )</code>
     * will be used.
     *
     * @param newFont The new font value.
     */
    public void setFont(Font newFont);

    /**
     * Paints this component.
     *
     * @param _g <code>Graphics</code>-object
     */
    public void paintComponent(Graphics _g);

    /**
     * Makes sure that the private attributes size, paintArea, offscreenOffset and
     * translated areas have sane values. It's called on component-resize.
     */
    private void calculateAttributes();

    /**
     * This methods takes the insets (the border) of this component into account
     * when the preferred size is calculated. Any border will work. It is called by
     * the property-change-listener if the border was changed.
     */
    protected void calculatePreferredSize();

    /**
     * This method requests a repaint of the scroll-area. The rest of the component
     * will not be repainted. It is called by <code>setScrollPosition()</code> .
     *
     * @see
     */
    private void repaintScrollArea();

    /**
     * This method calls <code>super.addNotify()</code> and notifies the
     * scroll-thread by calling <code>setScrolling(true)</code>. It also
     * (re)initializes the scroll-position to MinimumScrollPosition (this is always
     * the negative height of the scroll-rectangle) and registers tbis component at
     * the <code>ToolTipManager</code>.
     *
     * @see #setScrolling
     * @see #setScrollPosition
     * @see #getMinimumScrollPosition
     */
    public void addNotify();

    /**
     * This method calls <code>super.removeNotify()</code> and sends the
     * scroll-thread into a wait-state by calling <code>setScrolling(false)</code>
     * . It also unregisters this component from the <code>ToolTipManager</code>.
     *
     * @see #setScrolling
     */
    public void removeNotify();

    /**
     * This method is used to set the scrolling-property of this component. A value
     * of <code>true</code> will notify the scroll-thread that it has to resume
     * work. A value of <code>false</code> will send it into wait-state instead.
     *
     * @param Scrolling The new scrolling value
     */
    public void setScrolling(boolean Scrolling);

    /**
     * This method returns <code>true</code> if scrolling is currently active. If
     * it returns <code>false</code> then the scroll-thread is waiting.
     *
     * @return The scrolling value
     */
    public boolean isScrolling();

    /**
     * Description of the Class
     *
     * @author Joern Huxhorn
     */
    class AboutComponentListener extends ComponentAdapter {

        /**
         * Description of the Method
         *
         * @param e Description of the Parameter
         */
        public void componentResized(ComponentEvent e) {
            AboutPanel.this.calculateAttributes();
        }
    }

    /**
     * Description of the Class
     *
     * @author Joern Huxhorn
     */
    class AboutPropertyChangeListener implements PropertyChangeListener {

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void propertyChange(PropertyChangeEvent evt) {
            String propertyName = evt.getPropertyName();
            if (propertyName.equals(""border"")) {
                calculatePreferredSize();
            } else if (propertyName.equals(""foreground"")) {
                flushScrollImage();
            } else if (propertyName.equals(""background"")) {
                flushScrollImage();
            }
            //			else if ( propertyName.equals( ""locale"" ) )
            //			{
            //				initResources();
            //			}
        }
    }

    /**
     * This <code>MouseInputListener</code> handles the pause/resume on click as
     * well as the dragging inside the scroll-area.
     *
     * @author Joern Huxhorn
     */
    class AboutMouseInputListener extends MouseInputAdapter {

        Point lastPoint = null;

        boolean scrollingBeforePress = false;

        boolean dragged = false;

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mousePressed(MouseEvent evt) {
            if (handleMouseEvent(evt)) {
                // always stop scrolling if mouse is pressed inside
                // the scroll-area
                lastPoint = evt.getPoint();
                scrollingBeforePress = isScrolling();
                setScrolling(false);
            } else {
                lastPoint = null;
            }
            dragged = false;
        }

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mouseReleased(MouseEvent evt) {
            if (dragged) {
                // set scrolling-attribute to the value before the user dragged.
                lastPoint = null;
                setScrolling(scrollingBeforePress);
            }
        }

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mouseClicked(MouseEvent evt) {
            // this is only called after mouseReleased if no drag occurred.
            if (handleMouseEvent(evt)) {
                // toggle scrolling.
                setScrolling(!scrollingBeforePress);
            }
            dragged = false;
        }

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mouseDragged(MouseEvent evt) {
            // only drag if original press was inside scroll-rectangle
            if (lastPoint != null) {
                dragged = true;
                Point currentPoint = evt.getPoint();
                int yOffset = lastPoint.y - currentPoint.y;
                setScrollPosition(getScrollPosition() + yOffset);
                lastPoint = currentPoint;
            }
        }
    }

    private class TimerActionListener implements ActionListener {

        private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);

        private long lastRepaintStart;

        private long frequency = 25;

        public void actionPerformed(ActionEvent e) {
            long currentTime = System.nanoTime() / 1000000;
            long meanTime = currentTime - lastRepaintStart;
            if (meanTime > frequency) {
                if (logger.isDebugEnabled())
                    logger.debug(""Tick! meanTime={}"", meanTime);
                increaseScrollPosition();
                lastRepaintStart = currentTime;
            }
        }
    }
}
","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {
private final Logger logger = LoggerFactory.getLogger(AboutPanelTest.class);

		private static final String BACKGROUND_IMAGE_RESOURCE = ""background.png"";

		private static final String ABOUT_IMAGE_RESOURCE = ""about.png"";

		private static final String TEXT_RESOURCE_PREFIX = ""about."";

		private static final String SCROLL_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + ""scroll.text"";

		private static final String VERSION_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + ""version.text"";

		private static final String VERSION_HEIGHT_RESOURCE = TEXT_RESOURCE_PREFIX + ""version.height"";

		private static final String SCROLL_AREA_RESOURCE_BASE = TEXT_RESOURCE_PREFIX + ""scroll.area."";

		private static final String SCROLL_AREA_X_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""x"";

		private static final String SCROLL_AREA_Y_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""y"";

		private static final String SCROLL_AREA_WIDTH_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""width"";

		private static final String SCROLL_AREA_HEIGHT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""height"";

		private static final String SCROLL_AREA_TOOLTIP_TEXT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""tooltip.text"";

		private static final String TEXT_RESOURCE_BUNDLE_RESOURCE = ""TextResources"";

		private static final int MOUSE_DISABLED = 0;

		private static final int MOUSE_COMPONENT = 1;

		private static final int MOUSE_SCROLLAREA = 2;

		private static final int MOUSE_BACKGROUND = 3;

		//private static final int SCROLL_SLEEP_TIME = 50;
		private static final int SCROLL_PIXELS = 1;

		private BufferedImage backgroundImage;

		private BufferedImage aboutImage;

		//private ImageIcon aboutImageIcon;
		private FontMetrics fontMetrics;

		private Insets insets;

		private Dimension size;

		private Dimension preferredSize;

		private Point offscreenOffset;

		private String[] scrollLines;

		private String versionText;

		private String scrollAreaToolTipText;

		private int versionHeight;

		private int scrollPosition;

		private int maxScrollPosition;

		private int minScrollPosition;

		private Rectangle maxScrollArea;

		private Rectangle backgroundImageArea;

		private Rectangle translatedBackgroundImageArea;

		private Rectangle translatedScrollArea;

		private Rectangle scrollArea;

		private Rectangle paintArea;

		private BufferedImage offscreenImage;

		private BufferedImage scrollImage;

		private boolean scrolling;

		//private boolean painted;
		private int mouseEventHandling = MOUSE_BACKGROUND;

		//private transient Thread scrollThread;
		private boolean debug;

		private Timer timer;

		/**
		 * Creates a new <code>AboutPanel</code> initialized with the given parameters.
		 *
		 * @param backgroundImageUrl The URL to the Background-Image of the
		 *                           AboutPanel. This parameter is mandatory.
		 * @param scrollArea         The Rectangle inside the background-image where
		 *                           scrolling should take place. This parameter is optional. If it's null
		 *                           then the scroll-area is set to (0, 0, background.width,
		 *                           background.height).
		 */
		public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText) throws IOException {
		}

		public boolean isDebug();

		public void setDebug(boolean debug);

		/**
		 * Creates a new <code>AboutPanel</code> initialized with the given parameters.
		 *
		 * @param backgroundImageUrl The URL to the Background-Image of the
		 *                           AboutPanel. This parameter is mandatory.
		 * @param scrollArea         The Rectangle inside the background-image where
		 *                           scrolling should take place. This parameter is optional. If it's null
		 *                           then the scroll-area is set to (0, 0, background.width,
		 *                           background.height).
		 * @param versionText        The String describing the version of the program.
		 *                           It is painted centered to the scroll-rectangle at the specified height.
		 *                           This parameter is optional.
		 * @param versionHeight      The height at which the version-string is
		 *                           supposed to be painted. This parameter is optional but should be given
		 *                           a correct value if versionText!=null..
		 */
		public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, String versionText, int versionHeight) throws IOException {
		}

		/**
		 * Creates a new <code>AboutPanel</code> initialized with the given parameters.
		 *
		 * @param backgroundImageUrl The URL to the Background-Image of the
		 *                           AboutPanel. This parameter is mandatory.
		 * @param scrollArea         The Rectangle inside the background-image where
		 *                           scrolling should take place. This parameter is optional. If it's null
		 *                           then the scroll-area is set to (0, 0, background.width,
		 *                           background.height).
		 * @param imageUrl           The URL to the Image that will be painted at the
		 *                           start of the scroll-area. This parameter is optional.
		 * @param versionText        The String describing the version of the program.
		 *                           It is painted centered to the scroll-rectangle at the specified height.
		 *                           This parameter is optional.
		 * @param versionHeight      The height at which the version-string is
		 *                           supposed to be painted. This parameter is optional but should be given
		 *                           a correct value if versionText!=null..
		 */
		public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException {
		}

		public AboutPanel() {
		}

		private void init(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException;

		private void initAttributes();

		public void setScrollText(String ScrollText);

		protected void setScrollLines(String[] scrollLines);

		/**
		 * Sets the backgroundImage attribute of the <code>AboutPanel</code> object
		 */
		public void setBackgroundImage(URL imageUrl) throws IOException;

		/**
		 * Sets the backgroundImage attribute of the <code>AboutPanel</code> object
		 *
		 * @param BackgroundImage The new backgroundImage value
		 */
		public void setBackgroundImage(BufferedImage BackgroundImage);

		public void setAboutImage(URL imageUrl) throws IOException;

		public void setAboutImage(BufferedImage AboutImage);

		/**
		 * Sets the scrollArea attribute of the <code>AboutPanel</code> object
		 *
		 * @param ScrollArea The new scrollArea value
		 */
		public void setScrollArea(Rectangle ScrollArea);

		/**
		 * Description of the Method
		 */
		private void flushScrollImage();

		/**
		 * Description of the Method
		 */
		private void flushOffscreenImage();

		/**
		 * Description of the Method
		 */
		private void updateBackgroundAttributes();

		/**
		 * Sets the ToolTipText that will appear if the user moves the mouse over the
		 * scroll-area of this component.
		 *
		 * @param toolTipText The new ScrollAreaToolTipText value
		 */
		"
cmpl-6x9upOi7tXaDXt1vJ3c2ifooWlqqr,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/ApplicationPreferences.java,97.38732957839966,length,"// ApplicationPreferences.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;

public class ApplicationPreferences {

    public static enum SourceFiltering {

        NONE, BLACKLIST, WHITELIST
    }

    private static final Preferences PREFERENCES = Preferences.userNodeForPackage(ApplicationPreferences.class);

    private static final String STATUS_COLORS_XML_FILENAME = ""statusColors.xml"";

    private static final String LEVEL_COLORS_XML_FILENAME = ""levelColors.xml"";

    private static final String DETAILS_VIEW_ROOT_FOLDER = ""detailsView"";

    public static final String DETAILS_VIEW_CSS_FILENAME = ""detailsView.css"";

    public static final String DETAILS_VIEW_GROOVY_FILENAME = ""detailsView.groovy"";

    private static final String CONDITIONS_XML_FILENAME = ""savedConditions.xml"";

    public static final String STATUS_COLORS_PROPERTY = ""statusColors"";

    public static final String LEVEL_COLORS_PROPERTY = ""levelColors"";

    public static final String LOOK_AND_FEEL_PROPERTY = ""lookAndFeel"";

    public static final String CLEANING_LOGS_ON_EXIT_PROPERTY = ""cleaningLogsOnExit"";

    public static final String COLORING_WHOLE_ROW_PROPERTY = ""coloringWholeRow"";

    public static final String SHOWING_IDENTIFIER_PROPERTY = ""showingIdentifier"";

    public static final String SHOWING_FULL_CALLSTACK_PROPERTY = ""showingFullCallstack"";

    public static final String SHOWING_STACKTRACE_PROPERTY = ""showingStackTrace"";

    public static final String CHECKING_FOR_UPDATE_PROPERTY = ""checkingForUpdate"";

    public static final String SOURCE_FILTERING_PROPERTY = ""sourceFiltering"";

    public static final String SOUND_LOCATIONS_PROPERTY = ""soundLocations"";

    public static final String MUTE_PROPERTY = ""mute"";

    public static final String USING_INTERNAL_FRAMES_PROPERTY = ""usingInternalFrames"";

    public static final String SCROLLING_TO_BOTTOM_PROPERTY = ""scrollingToBottom"";

    public static final String SOURCE_NAMES_PROPERTY = ""sourceNames"";

    public static final String APPLICATION_PATH_PROPERTY = ""applicationPath"";

    public static final String AUTO_OPENING_PROPERTY = ""autoOpening"";

    public static final String AUTO_CLOSING_PROPERTY = ""autoClosing"";

    public static final String IMAGE_PATH_PROPERTY = ""imagePath"";

    public static final String SOUND_PATH_PROPERTY = ""soundPath"";

    public static final String AUTO_FOCUSING_WINDOW_PROPERTY = ""autoFocusingWindow"";

    public static final String SOURCE_LISTS_PROPERTY = ""sourceLists"";

    public static final String BLACK_LIST_NAME_PROPERTY = ""blackListName"";

    public static final String WHITE_LIST_NAME_PROPERTY = ""whiteListName"";

    public static final String CONDITIONS_PROPERTY = ""conditions"";

    public static final String SPLASH_SCREEN_DISABLED_PROPERTY = ""splashScreenDisabled"";

    public static final String ASKING_BEFORE_QUIT_PROPERTY = ""askingBeforeQuit"";

    public static final String LOGGING_LAYOUT_GLOBAL_XML_FILENAME = ""loggingLayoutGlobal.xml"";

    public static final String LOGGING_LAYOUT_XML_FILENAME = ""loggingLayout.xml"";

    public static final String ACCESS_LAYOUT_GLOBAL_XML_FILENAME = ""accessLayoutGlobal.xml"";

    public static final String ACCESS_LAYOUT_XML_FILENAME = ""accessLayout.xml"";

    public static final String SOURCE_NAMES_XML_FILENAME = ""SourceNames.xml"";

    public static final String SOURCE_LISTS_XML_FILENAME = ""SourceLists.xml"";

    public static final String SOURCE_NAMES_PROPERTIES_FILENAME = ""SourceNames.properties"";

    public static final String SOUND_LOCATIONS_XML_FILENAME = ""SoundLocations.xml"";

    public static final String SOUND_LOCATIONS_PROPERTIES_FILENAME = ""SoundLocations.properties"";

    public static final String PREVIOUS_APPLICATION_PATH_FILENAME = "".previous.application.path"";

    private static final String OLD_LICENSED_PREFERENCES_KEY = ""licensed"";

    private static final String LICENSED_PREFERENCES_KEY = ""licensedVersion"";

    public static final String USER_HOME;

    public static final String DEFAULT_APPLICATION_PATH;

    private static final Map<String, String> DEFAULT_SOURCE_NAMES;

    private static final Map<String, String> DEFAULT_SOUND_LOCATIONS;

    private static final Map<LoggingEvent.Level, ColorScheme> DEFAULT_LEVEL_COLORS;

    private static final Map<HttpStatus.Type, ColorScheme> DEFAULT_STATUS_COLORS;

    private static final String PREVIOUS_OPEN_PATH_PROPERTY = ""previousOpenPath"";

    private static final String PREVIOUS_IMPORT_PATH_PROPERTY = ""previousImportPath"";

    public static final String STARTUP_LOOK_AND_FEEL;

    private static final long CONDITIONS_CHECK_INTERVAL = 30000;

    private static final String GROOVY_SUFFIX = "".groovy"";

    private static final String EXAMPLE_GROOVY_BASE = ""/conditions/"";

    private static final String EXAMPLE_GROOVY_LIST = ""conditions.txt"";

    static {
    }

    private final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);

    private PropertyChangeSupport propertyChangeSupport;

    private File startupApplicationPath;

    private File detailsViewRoot;

    private ArrayList<String> installedLookAndFeels;

    private String[] conditionScriptFiles;

    private long lastConditionsCheck;

    private Map<LoggingEvent.Level, ColorScheme> levelColors;

    private Map<HttpStatus.Type, ColorScheme> statusColors;

    private URL detailsViewRootUrl;

    /**
     * Identifier => Name
     */
    private Map<String, String> sourceNames;

    private long lastSourceNamesModified;

    private long lastConditionsModified;

    private Map<String, String> soundLocations;

    private long lastSoundLocationsModified;

    private Map<String, Set<String>> sourceLists;

    private long lastSourceListsModified;

    private SourceFiltering sourceFiltering;

    private Set<String> blackList;

    private Set<String> whiteList;

    private List<SavedCondition> conditions;

    private File groovyConditionsPath;

    public ApplicationPreferences() {
    }

    public File resolveConditionScriptFile(String input);

    public String[] getAllConditionScriptFiles();

    public void installExampleConditions();

    private void initLevelColors();

    private Map<LoggingEvent.Level, ColorScheme> cloneLevelColors(Map<LoggingEvent.Level, ColorScheme> input);

    public void setLevelColors(Map<LoggingEvent.Level, ColorScheme> colors);

    private void writeLevelColors(Map<LoggingEvent.Level, ColorScheme> colors);

    public Map<LoggingEvent.Level, ColorScheme> getLevelColors();

    private void initStatusColors();

    private Map<HttpStatus.Type, ColorScheme> cloneStatusColors(Map<HttpStatus.Type, ColorScheme> input);

    public void setStatusColors(Map<HttpStatus.Type, ColorScheme> colors);

    private void writeStatusColors(Map<HttpStatus.Type, ColorScheme> colors);

    public Map<HttpStatus.Type, ColorScheme> getStatusColors();

    public void setSourceFiltering(SourceFiltering sourceFiltering);

    private void initSourceLists();

    public Map<String, Set<String>> getSourceLists();

    public void setSourceLists(Map<String, Set<String>> sourceLists);

    public SourceFiltering getSourceFiltering();

    public void initDetailsViewRoot(boolean overwriteAlways);

    private void initIfNecessary(File file, String resourcePath, String historyBasePath, boolean overwriteAlways);

    private void copy(URL source, File target, boolean overwrite);

    /**
     * Returns a list of strings containing all non-empty, non-comment lines found in the given URL.
     * Commented lines start with a #.
     *
     * @param url the URL to read the lines from.
     * @return a List of type String containing all non-empty, non-comment lines.
     */
    private List<String> readLines(URL url);

    public File getDetailsViewRoot();

    public URL getDetailsViewRootUrl();

    public boolean isValidSource(String source);

    public boolean isBlackListed(String source);

    public void setBlackListName(String name);

    public String getBlackListName();

    public boolean isWhiteListed(String source);

    public void setWhiteListName(String name);

    public String getWhiteListName();

    public void setLookAndFeel(String name);

    public String getLookAndFeel();

    private void initConditions();

    public SavedCondition resolveSavedCondition(Condition condition);

    public SavedCondition resolveSavedCondition(String conditionName);

    public List<SavedCondition> getConditions();

    public void setConditions(List<SavedCondition> conditions);

    public void setAutoOpening(boolean autoOpening);

    public boolean isAutoOpening();

    public void setShowingIdentifier(boolean showingIdentifierWithName);

    public boolean isShowingIdentifier();

    public void setSplashScreenDisabled(boolean splashScreenDisabled);

    public boolean isSplashScreenDisabled();

    public void setAskingBeforeQuit(boolean askingBeforeQuit);

    public boolean isAskingBeforeQuit();

    public void setShowingFullCallstack(boolean showingFullCallstack);

    public boolean isShowingFullCallstack();

    public void setShowingStackTrace(boolean showingStackTrace);

    public boolean isShowingStackTrace();

    public void setCleaningLogsOnExit(boolean cleaningLogsOnExit);

    public boolean isCleaningLogsOnExit();

    public void setColoringWholeRow(boolean coloringWholeRow);

    public boolean isColoringWholeRow();

    public void setCheckingForUpdate(boolean checkingForUpdate);

    public boolean isCheckingForUpdate();

    public void setAutoClosing(boolean autoClosing);

    public boolean isAutoClosing();

    public File getImagePath();

    public void setImagePath(File imagePath);

    public File getPreviousOpenPath();

    public void setPreviousOpenPath(File openPath);

    public File getPreviousImportPath();

    public void setPreviousImportPath(File importPath);

    public File getSoundPath();

    public void setSoundPath(File soundPath);

    public void setMute(boolean mute);

    public boolean isMute();

    public void setLicensed(boolean licensed);

    public boolean isLicensed();

    public void setApplicationPath(File applicationPath);

    public File getApplicationPath();

    /**
     * The StartupApplicationPath is initialized on application startup via ApplicationPreferences.getApplicationPath.
     * If a part of the application needs the application path it should *always* use this method instead of
     * getApplicationPath() since the application path might change while this one will always stay
     * the same.
     * <p/>
     * A switch of the application path while the application is running isn't safe so it's changed for real
     * upon next restart.
     *
     * @return the application path at startup time.
     */
    public File getStartupApplicationPath();

    public void setUsingInternalFrames(boolean usingInternalFrames);

    public boolean isUsingInternalFrames();

    public void setAutoFocusingWindow(boolean autoFocusingWindow);

    public boolean isAutoFocusingWindow();

    public void setSourceNames(Map<String, String> sourceNames);

    public Map<String, String> getSourceNames();

    public Map<String, String> getSoundLocations();

    public void setSoundLocations(Map<String, String> soundLocations);

    public void resetSoundLocations();

    public void addPropertyChangeListener(PropertyChangeListener listener);

    public void removePropertyChangeListener(PropertyChangeListener listener);

    public void reset();

    public void setScrollingToBottom(boolean scrollingToBottom);

    public boolean isScrollingToBottom();

    private boolean loadSoundLocationsXml(File file);

    private boolean writeSoundLocations(Map<String, String> sourceNames);

    private boolean loadSourceNamesXml(File file);

    private boolean loadSourceNamesProperties(File sourceNamesFile);

    private boolean writeSourceNames(Map<String, String> sourceNames);

    private boolean writeSourceLists(Map<String, Set<String>> sourceLists);

    private boolean writeConditions(List<SavedCondition> conditions);

    /**
     * @noinspection MismatchedQueryAndUpdateOfCollection
     */
    private Map<String, String> loadPropertiesXml(File file);

    /**
     * @noinspection MismatchedQueryAndUpdateOfCollection
     */
    private boolean writePropertiesXml(File file, Map<String, String> sourceNames, String comment);

    private Map<String, String> loadProperties(File file);

    public void writeLoggingColumnLayout(boolean global, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos);

    public void writeAccessColumnLayout(boolean global, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos);

    public List<PersistentTableColumnModel.TableColumnLayoutInfo> readLoggingColumnLayout(boolean global);

    public List<PersistentTableColumnModel.TableColumnLayoutInfo> readAccessColumnLayout(boolean global);

    private boolean writeColumnLayout(File file, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos);

    private List<PersistentTableColumnModel.TableColumnLayoutInfo> readColumnLayout(File file);

    /**
     * Quick & dirty MD5 checksum function.
     * Returns null in case of error.
     *
     * @param input the input
     * @return the checksum
     */
    public static byte[] getMD5(InputStream input);

    public void flush();

    /**
     * As described in http://weblogs.java.net/blog/malenkov/archive/2006/08/how_to_encode_e.html
     */
    static class EnumPersistenceDelegate extends PersistenceDelegate {

        protected boolean mutatesTo(Object oldInstance, Object newInstance) {
            return oldInstance == newInstance;
        }

        protected Expression instantiate(Object oldInstance, Encoder out) {
            Enum e = (Enum) oldInstance;
            return new Expression(e, e.getClass(), ""valueOf"", new Object[] { e.name() });
        }
    }
}
","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {
private static final String TEST_FILE_NAME = ""test.txt"";

		private static final String TEST_FILE_CONTENT = ""This is a test file."";

		private static final String TEST_FILE_MD5 = ""0f8fad5b19373c2f8f00b204e9800998"";

		private static final String TEST_FILE_NAME_2 = ""test2.txt"";

		private static final String TEST_FILE_CONTENT_2 = ""This is another test file."";

		private static final String TEST_FILE_MD5_2 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_3 = ""test3.txt"";

		private static final String TEST_FILE_CONTENT_3 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_3 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_4 = ""test4.txt"";

		private static final String TEST_FILE_CONTENT_4 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_4 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_5 = ""test5.txt"";

		private static final String TEST_FILE_CONTENT_5 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_5 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_6 = ""test6.txt"";

		private static final String TEST_FILE_CONTENT_6 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_6 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_7 = ""test7.txt"";

		private static final String TEST_FILE_CONTENT_7 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_7 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_8 = ""test8.txt"";

		private static final String TEST_FILE_CONTENT_8 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_8 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_9 = ""test9.txt"";

		private static final String TEST_FILE_CONTENT_9 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_9 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_10 = ""test10.txt"";

		private static final String TEST_FILE_CONTENT_10 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_10 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_11 = ""test11.txt"";

		private static final String TEST_FILE_CONTENT_11 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_11 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_12 = ""test12.txt"";

		private static final String TEST_FILE_CONTENT_12 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_12 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_13 = ""test13.txt"";

		private static final String TEST_FILE_CONTENT_13 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_13 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_14 = ""test14.txt"";

		private static final String TEST_FILE_CONTENT_14 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_14 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_15 = ""test15.txt"";

		private static final String TEST_FILE_CONTENT_15 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_15 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_16 = ""test16.txt"";

		private static final String TEST_FILE_CONTENT_16 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_16 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_17 = ""test17.txt"";

		private static final String TEST_FILE_CONTENT_17 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_17 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_18 = ""test18.txt"";

		private static final String TEST_FILE_CONTENT_18 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_18 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_19 = ""test19.txt"";

		private static final String TEST_FILE_CONTENT_19 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_19 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_20 = ""test20.txt"";

		private static final String TEST_FILE_CONTENT_20 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_20 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_21 = ""test21.txt"";

		private static final String TEST_FILE_CONTENT_21 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_21 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_22 = ""test22.txt"";

		private static final String TEST_FILE_CONTENT_22 = ""This is yet another test file."";

		private static final String TEST_FILE_MD5_22 = ""c8f1e7b00e04c3fd1fba9d0f0098fa0c"";

		private static final String TEST_FILE_NAME_23 = ""test23.txt"";

		private static final String TEST_FILE_CONTENT_23 = ""This is yet another test file."";

		private static final String TEST_FILE_MD"
cmpl-6x9wOfpKnVmHdCOWgHCsWV4Oqm4Xm,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/callables/IndexingCallable.java,86.04078841209412,length,"// IndexingCallable.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

/**
 * Should only be executed on inactive files.
 */
public class IndexingCallable extends AbstractProgressingCallable<Long> {

    private final Logger logger = LoggerFactory.getLogger(IndexingCallable.class);

    private File dataFile;

    private File indexFile;

    public IndexingCallable(File dataFile, File indexFile) {
    }

    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    public Long call() throws Exception;

    public File getDataFile();

    public File getIndexFile();

    private static void closeQuietly(RandomAccessFile file);
}
","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains ten unit test cases for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains ten unit test cases for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {

		private static final Logger logger = LoggerFactory.getLogger(IndexingCallableTest.class);
		
		private static final FileHeaderStrategy fileHeaderStrategy = new DefaultFileHeaderStrategy();
		private static final IndexStrategy indexStrategy = new DefaultIndexStrategy();
		private static final SparseDataStrategy dataStrategy = new DefaultDataStrategy();
		
		private static final File dataFile = new File(""data.dat"");
		private static final File indexFile = new File(""index.dat"");
		
		private static final int fileHeaderSize = fileHeaderStrategy.getSize();
		private static final int indexSize = indexStrategy.getSize();
		private static final int dataSize = dataStrategy.getSize();
		
		private static final int fileHeaderCount = 10;
		private static final int indexCount = 10;
		private static final int dataCount = 10;
		
		private static final int fileHeaderOffset = 0;
		private static final int indexOffset = fileHeaderOffset + fileHeaderSize * fileHeaderCount;
		private static final int dataOffset = indexOffset + indexSize * indexCount;
		
		private static final int fileSize = dataOffset + dataSize * dataCount;
		
		private static final int fileHeaderIndex = 0;
		private static final int indexIndex = 1;
		private static final int dataIndex = 2;
		
		private static final int fileHeaderIndexOffset = fileHeaderOffset + fileHeaderIndex * fileHeaderSize;
		private static final int indexIndexOffset = indexOffset + indexIndex * indexSize;
		private static final int dataIndexOffset = dataOffset + dataIndex * dataSize;
		
		private static final int fileHeaderIndexValue = fileHeaderIndexOffset;
		private static final int indexIndexValue = indexIndexOffset;
		private static final int dataIndexValue = dataIndexOffset;
		
		private static final int fileHeaderIndexSize = fileHeaderSize;
		private static final int indexIndexSize = indexSize;
		private static final int dataIndexSize = dataSize;
		
		private static final int fileHeaderIndexCount = fileHeaderCount;
		private static final int indexIndexCount = indexCount;
		private static final int dataIndexCount = dataCount;
		
		private static final int fileHeaderIndexFirst = 0;
		private static final int indexIndexFirst = 0;
		private static final int dataIndexFirst = 0;
		
		private static final int fileHeaderIndexLast = fileHeaderIndexFirst + fileHeaderIndexCount - 1;
		private static final int indexIndexLast = indexIndexFirst + indexIndexCount - 1;
		private static final int dataIndexLast = dataIndexFirst + dataIndexCount - 1;
		
		private static final int fileHeaderIndexMiddle = fileHeaderIndexFirst + fileHeaderIndexCount / 2;
		private static final int indexIndexMiddle = indexIndexFirst + indexIndexCount / 2;
		private static final int dataIndexMiddle = dataIndexFirst + dataIndexCount / 2;
		
		private static final int fileHeaderIndexUnknown = -1;
		private static final int indexIndexUnknown = -1;
		private static final int dataIndexUnknown = -1;
		
		private static final int fileHeaderIndexTooSmall = -2;
		private static final int indexIndexTooSmall = -2;
		private static final int dataIndexTooSmall = -2;
		
		private static final int fileHeaderIndexTooBig = fileHeaderIndexFirst + fileHeaderIndexCount;
		private static final int indexIndexTooBig = indexIndexFirst + indexIndexCount;
		private static final int dataIndexTooBig = dataIndexFirst + dataIndexCount;
		
		private static final int fileHeaderMagic = 0x12345678;
		private static final int indexMagic = 0x23456789;
		private static final int dataMagic = 0x3456789A;
		
		private static final int fileHeaderVersion = 1;
		private static final int indexVersion = 2;
		private static final int dataVersion = 3;
		
		private static final int fileHeaderReserved = 0;
		private static final int indexReserved = 0;
		private static final int dataReserved = 0;
		
		private static final int fileHeaderFlags = 0;
		private static final int indexFlags = 0;
		private static final int dataFlags = 0;
		
		private static final int fileHeaderDataOffset = dataOffset;
		private static final int indexDataOffset = dataOffset;
		private static final int dataDataOffset = dataOffset;
		
		private static final int fileHeaderDataSize = dataSize;
		private static final int indexDataSize = dataSize;
		private static final int dataDataSize = dataSize;
		
		private static final int fileHeaderDataCount = dataCount;
		private static final int indexDataCount = dataCount;
		private static final int dataDataCount = dataCount;
		
		private static final int fileHeaderDataFirst = 0;
		private static final int indexDataFirst = 0;
		private static final int dataDataFirst = 0;
		
		private static final int fileHeaderDataLast = fileHeaderDataFirst + fileHeaderDataCount - 1;
		private static final int indexDataLast = indexDataFirst + indexDataCount - 1;
		private static final int dataDataLast = dataDataFirst + dataDataCount - 1;
		
		private static final int fileHeaderDataMiddle = fileHeaderDataFirst + fileHeaderDataCount / 2;
		private static final int indexDataMiddle = indexDataFirst + indexDataCount / 2;
		private static final int dataDataMiddle = dataDataFirst + dataDataCount / 2;
		
		private static final int fileHeaderDataUnknown = -1;
		private static final int indexDataUnknown = -1;
		private static final int dataDataUnknown = -1;
		
		private static final int fileHeaderDataTooSmall = -2;
		private static final int indexDataTooSmall = -2;
		private static final int dataDataTooSmall = -2;
		
		private static final int fileHeaderDataTooBig = fileHeaderDataFirst + fileHeaderDataCount;
		private static final int indexDataTooBig = indexDataFirst + indexDataCount;
		private static final int dataDataTooBig = dataDataFirst + dataDataCount;
		
		private static final int fileHeaderDataValue = 0x456789AB;
		private static final int indexDataValue = 0x56789ABC;
		private static final int dataDataValue = 0x6789ABCD;
		
		private static final int fileHeaderDataValueOffset = dataIndexOffset + dataStrategy.getDataOffset();
		private static final int indexDataValueOffset = dataIndexOffset + dataStrategy.getDataOffset();
		private static final int dataDataValueOffset = dataIndexOffset + dataStrategy.getDataOffset();
		
		private static final int fileHeaderDataValueSize = dataStrategy.getDataSize();
		private static final int indexDataValueSize = dataStrategy.getDataSize();
		private static final int dataDataValueSize = dataStrategy.getDataSize();
		
		private static final int fileHeaderDataValueCount = dataCount;
		private static final int indexDataValueCount = dataCount;
		private static final int dataDataValueCount = dataCount;
		
		private static final int fileHeaderDataValueFirst = 0;
		private static final int indexDataValueFirst = 0;
		private static final int dataDataValueFirst = 0;
		
		private static final int fileHeaderDataValueLast = fileHeaderDataValueFirst + fileHeaderDataValueCount - 1;
		private static final int indexDataValueLast = indexDataValueFirst + indexDataValueCount - 1;
		private static final int dataDataValueLast = dataDataValueFirst + dataDataValueCount - 1;
		
		private static final int fileHeaderDataValueMiddle = fileHeaderDataValueFirst + fileHeaderDataValueCount / 2;
		private static final int indexDataValueMiddle = indexDataValueFirst + indexDataValueCount / 2;
		private static final int dataDataValueMiddle = dataDataValueFirst + dataDataValueCount /"
cmpl-6x9xmcbd15AbGubz654zkIWmGTK5q,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/preferences/GenericSortedListModel.java,10.688076734542847,stop,"// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    private final List<T> data;

    private final Comparator<T> comparator;

    public GenericSortedListModel() {
    }

    public GenericSortedListModel(Comparator<T> comparator) {
    }

    public void setData(List<T> data);

    public List<T> getData();

    public void add(T element);

    public void remove(T element);

    /**
     * Returns the length of the list.
     *
     * @return the length of the list
     */
    public int getSize();

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index);
}
","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {

		@Test
		public void testGetElementAt() {
				List<String> data = new ArrayList<String>();
				data.add(""a"");
				data.add(""b"");
				data.add(""c"");
				data.add(""d"");
				data.add(""e"");
				data.add(""f"");
				data.add(""g"");
				data.add(""h"");
				data.add(""i"");
				data.add(""j"");
				GenericSortedListModel<String> model = new GenericSortedListModel<String>(data);
				assertEquals(""a"", model.getElementAt(0));
				assertEquals(""b"", model.getElementAt(1));
				assertEquals(""c"", model.getElementAt(2));
				assertEquals(""d"", model.getElementAt(3));
				assertEquals(""e"", model.getElementAt(4));
				assertEquals(""f"", model.getElementAt(5));
				assertEquals(""g"", model.getElementAt(6));
				assertEquals(""h"", model.getElementAt(7));
				assertEquals(""i"", model.getElementAt(8));
				assertEquals(""j"", model.getElementAt(9));
		}
}"
cmpl-6x9yps2mhgnsR3IIMvxHp7cUhhWK5,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_0Test.java,55.431437969207764,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_0Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModel_0Test {","// PersistentTableColumnModel_0Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModel_0Test {

		/**
		* Test case for the method {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}.
		*
		* @throws Exception
		* 																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																"
cmpl-6x9zs2ABPVYHf3xtfuDCtpl9BZ42i,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_1Test.java,71.33482003211975,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_1Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModel_1Test {","// PersistentTableColumnModel_1Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModel_1Test {

	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: true</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of visible columns.
	*/
	@Test
	public void testGetColumnCount_1() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(1), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(3), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(5), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(7), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(9), false);
		int result = persistentTableColumnModel.getColumnCount(true);
		assertEquals(0, result);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: false</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of columns.
	*/
	@Test
	public void testGetColumnCount_2() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(1), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(3), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(5), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(7), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(9), false);
		int result = persistentTableColumnModel.getColumnCount(false);
		assertEquals(10, result);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: true</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of visible columns.
	*/
	@Test
	public void testGetColumnCount_3() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(1), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(3), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(5), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(7), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(9), false);
		int result = persistentTableColumnModel.getColumnCount(true);
		assertEquals(0, result);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: false</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of columns.
	*/
	@Test
	public void testGetColumnCount_4() {
		PersistentTableColumnModel persistentTableColumnModel ="
cmpl-6xA2K4vC5YYoGvndsasyG4ZS27NDb,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_2Test.java,172.46298623085022,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_2Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModel_2Test {","// PersistentTableColumnModel_2Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModel_2Test {

	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>true</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of the visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(5, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>false</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of all columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(false);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(10, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>true</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of the visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_2() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(5, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>false</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of all columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_2() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator"
cmpl-6xA3oJwMdKrlkdNU7bDV6kyVCJb85,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_3Test.java,88.21360921859741,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_3Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModel_3Test {","// PersistentTableColumnModel_3Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModel_3Test {

	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is visible.
	* The identifier is the column name.
	* The identifier is not null.
	* The identifier is not empty.
	* The identifier is not a blank string.
	* The identifier is not a string of blanks.
	* The identifier is not a string of tabs.
	* The identifier is not a string of newlines.
	* The identifier is not a string of spaces.
	* The identifier is not a string of formfeeds.
	* The identifier is not a string of carriage returns.
	* The identifier is not a string of backspaces.
	* The identifier is not a string of vertical tabs.
	* The identifier is not a string of null characters.
	* The identifier is not a string of non-printable characters.
	* The identifier is not a string of non-printable characters and blanks.
	* The identifier is not a string of non-printable characters, blanks and tabs.
	* The identifier is not a string of non-printable characters, blanks, tabs and newlines.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines and spaces.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces and formfeeds.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds and carriage returns.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns and backspaces.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces and vertical tabs.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs and null characters.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters and printable characters.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters and blanks.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks and tabs.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs and newlines.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines and spaces.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces and formfeeds.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds and carriage returns.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns and backspaces.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces and vertical tabs.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs and null characters.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters and printable characters.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters and blanks.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks and tabs.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs and newlines.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines and spaces.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces and formfeeds.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds and carriage returns.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns and backspaces.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces and vertical tabs.
	* The identifier is not a string of non-printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs, null characters, printable characters, blanks, tabs, newlines, spaces, formfeeds, carriage returns, backspaces, vertical tabs and null"
cmpl-6xA5EzyvfignyODXJU0lR6SODzXrx,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_0Test.java,67.2116847038269,length,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    private static final long serialVersionUID = -2372658104457011019L;

    private int thickness;

    private int innerThickness;

    private Color borderColor;

    public ConditionalBorder(Color color) {
    }

    public ConditionalBorder(Color color, int thickness) {
    }

    public ConditionalBorder(Color color, int thickness, int innerThickness) {
    }

    /**
     * Paints the border for the specified component with the
     * specified position and size.
     *
     * @param c      the component for which this border is being painted
     * @param g      the paint graphics
     * @param x      the x position of the painted border
     * @param y      the y position of the painted border
     * @param width  the width of the painted border
     * @param height the height of the painted border
     */
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height);

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c      the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);

    /**
     * Returns the color of the border.
     *
     * @return the color of the border.
     */
    public Color getBorderColor();

    /**
     * Sets the color of the border.
     *
     * @param borderColor the color of the border.
     */
    public void setBorderColor(Color borderColor);

    /**
     * Returns the inner thickness of the border.
     *
     * @return Returns the inner thickness of the border.
     */
    public int getInnerThickness();

    /**
     * Sets the inner thickness of the border.
     *
     * @param innerThickness Returns the inner thickness of the border.
     */
    public void setInnerThickness(int innerThickness);

    /**
     * Returns the thickness of the border.
     *
     * @return Returns the thickness of the border.
     */
    public int getThickness();

    /**
     * Sets the thickness of the border.
     *
     * @param thickness the thickness of the border.
     */
    public void setThickness(int thickness);

    /**
     * Returns whether or not the border is opaque.
     */
    public boolean isBorderOpaque();
}
","// ConditionalBorder_0Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorder_0Test {","// ConditionalBorder_0Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorder_0Test {

		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of zero.
		*/
		@Test
		public void testGetBorderInsets_0() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 0);
				Insets insets = border.getBorderInsets(null);
				assertEquals(0, insets.top);
				assertEquals(0, insets.left);
				assertEquals(0, insets.bottom);
				assertEquals(0, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of one.
		*/
		@Test
		public void testGetBorderInsets_1() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1);
				Insets insets = border.getBorderInsets(null);
				assertEquals(1, insets.top);
				assertEquals(1, insets.left);
				assertEquals(1, insets.bottom);
				assertEquals(1, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of two.
		*/
		@Test
		public void testGetBorderInsets_2() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 2);
				Insets insets = border.getBorderInsets(null);
				assertEquals(2, insets.top);
				assertEquals(2, insets.left);
				assertEquals(2, insets.bottom);
				assertEquals(2, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of three.
		*/
		@Test
		public void testGetBorderInsets_3() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 3);
				Insets insets = border.getBorderInsets(null);
				assertEquals(3, insets.top);
				assertEquals(3, insets.left);
				assertEquals(3, insets.bottom);
				assertEquals(3, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of four.
		*/
		@Test
		public void testGetBorderInsets_4() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 4);
				Insets insets = border.getBorderInsets(null);
				assertEquals(4, insets.top);
				assertEquals(4, insets.left);
				assertEquals(4, insets.bottom);
				assertEquals(4, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of five.
		*/
		@Test
		public void testGetBorderInsets_5() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 5);
				Insets insets = border.getBorderInsets(null);
				assertEquals(5, insets.top);
				assertEquals(5, insets.left);
				assertEquals(5, insets.bottom);
				assertEquals(5, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of six.
		*/
		@Test
		public void testGetBorderInsets_6() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 6);
				Insets insets = border.getBorderInsets(null);
				assertEquals(6, insets.top);
				assertEquals(6, insets.left);
				assertEquals(6, insets.bottom);
				assertEquals(6, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of seven.
		*/
		@Test
		public void testGetBorderInsets_7() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 7);
				Insets insets = border.getBorderInsets(null);
				assertEquals(7, insets.top);
				assertEquals(7, insets.left);
				assertEquals(7, insets.bottom);
				assertEquals(7, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of eight.
		*/
		@Test
		public void testGetBorderInsets_8() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 8);
				Insets insets = border.getBorderInsets(null);
				assertEquals(8, insets.top);
				assertEquals(8, insets.left);
				assertEquals(8, insets.bottom);
				assertEquals(8, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of nine.
		*/
		@Test
		public void testGetBorderInsets_9() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 9);
				Insets insets = border.getBorderInsets(null);
				assertEquals(9, insets.top);
				assertEquals(9, insets.left);
				assertEquals(9, insets.bottom);
				assertEquals(9, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of ten.
		*/
		@Test
		public void testGetBorderInsets_10() {
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 10);
				Insets insets = border.getBorderInsets(null);
				assertEquals(10, insets.top);
				assertEquals(10, insets.left);
				assertEquals(10, insets.bottom"
cmpl-6xA6J8NWl7jaJkPCZmGqR7RQUF7Ff,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_1Test.java,81.62014770507812,length,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    private static final long serialVersionUID = -2372658104457011019L;

    private int thickness;

    private int innerThickness;

    private Color borderColor;

    public ConditionalBorder(Color color) {
    }

    public ConditionalBorder(Color color, int thickness) {
    }

    public ConditionalBorder(Color color, int thickness, int innerThickness) {
    }

    /**
     * Paints the border for the specified component with the
     * specified position and size.
     *
     * @param c      the component for which this border is being painted
     * @param g      the paint graphics
     * @param x      the x position of the painted border
     * @param y      the y position of the painted border
     * @param width  the width of the painted border
     * @param height the height of the painted border
     */
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height);

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c      the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);

    /**
     * Returns the color of the border.
     *
     * @return the color of the border.
     */
    public Color getBorderColor();

    /**
     * Sets the color of the border.
     *
     * @param borderColor the color of the border.
     */
    public void setBorderColor(Color borderColor);

    /**
     * Returns the inner thickness of the border.
     *
     * @return Returns the inner thickness of the border.
     */
    public int getInnerThickness();

    /**
     * Sets the inner thickness of the border.
     *
     * @param innerThickness Returns the inner thickness of the border.
     */
    public void setInnerThickness(int innerThickness);

    /**
     * Returns the thickness of the border.
     *
     * @return Returns the thickness of the border.
     */
    public int getThickness();

    /**
     * Sets the thickness of the border.
     *
     * @param thickness the thickness of the border.
     */
    public void setThickness(int thickness);

    /**
     * Returns whether or not the border is opaque.
     */
    public boolean isBorderOpaque();
}
","// ConditionalBorder_1Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_1Test {","// ConditionalBorder_1Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_1Test {

	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_1() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_2() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_3() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_4() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_5() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_6() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_7() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_8() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_9() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_10() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
}

// ConditionalBorder_2Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_2Test {
		
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_1() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets("
