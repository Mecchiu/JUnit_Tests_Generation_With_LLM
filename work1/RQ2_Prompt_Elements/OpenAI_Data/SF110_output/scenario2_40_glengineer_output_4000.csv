ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wznVe1e6YolCLebddNmOabLYybWi,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer0.java,153.19711303710938,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis layout direction
     * @param componentName the name of the component to be found
     * @return an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {

		/**
		* Test case 1.
		* <p>
		* The method {@link GroupLayoutEngineer#getComponent(Axis, String)}
		* is tested for the case when the specified component name
		* is not associated with any component.
		* <p>
		* The expected result is an exception of the type
		* {@link IllegalArgumentException}.
		*/
		@Test
		void testGetComponent1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertThrows(IllegalArgumentException.class, () -> {
						gle.getComponent(Axis.HORIZONTAL, ""FINDLABEL1"");
				});
		}
		
		/**
		* Test case 2.
		* <p>
		* The method {@link GroupLayoutEngineer#getComponent(Axis, String)}
		* is tested for the case when the specified component name
		* is associated with a component, but the specified layout direction
		* is not the same as the layout direction of that component.
		* <p>
		* The expected result is an exception of the type
		* {@link IllegalArgumentException}.
		*/
		@Test
		void testGetComponent2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertThrows(IllegalArgumentException.class, () -> {
						gle.getComponent(Axis.VERTICAL, ""FINDLABEL"");
				});
		}
		
		/**
		* Test case 3.
		* <p>
		* The method {@link GroupLayoutEngineer#getComponent(Axis, String)}
		* is tested for the case when the specified component name
		* is associated with a component, and the specified layout direction
		* is the same as the layout direction of that component.
		* <p>
		* The expected result is an interface {@link FunctionsOnComponent}
		* for adjusting the component.
		*/
		@Test
		void testGetComponent3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertTrue(gle.getComponent(Axis.HORIZONTAL, ""FINDLABEL"") instanceof FunctionsOnComponent);
		}
		
		/**
		* Test case 4.
		* <p>
		* The method {@link GroupLayoutEngineer#getComponent(Axis, String)}
		* is tested for the case when the specified component name
		* is associated with a component, and the specified layout direction
		* is the same as the layout direction of that component.
		* <p>
		* The expected result is an interface {@link FunctionsOnComponent}
		* for adjusting the component.
		*/
		@Test
		void testGetComponent4() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertTrue(gle.getComponent(Axis.HORIZONTAL, ""TEXTFIELD"") instanceof FunctionsOnComponent);
		}
		
		/**
		* Test case 5.
		* <p>
		* The method {@link GroupLayoutEngineer#getComponent(Axis, String)}
		* is tested for the case when the specified component name
		* is associated with a component, and the specified layout direction
		* is the same as the layout direction of that component.
		* <p>
		* The expected result is an interface {@link FunctionsOnComponent}
		* for adjusting the component.
		*/
		@Test
		void testGetComponent5() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertTrue(gle.getComponent(Axis.HORIZONTAL, ""FINDBUTTON"") instanceof FunctionsOnComponent);
		}
		
		/**
		* Test case 6.
		* <p>
		* The method {@link GroupLayoutEngineer#getComponent(Axis, String)}
		* is tested for the case when the specified component name
		* is associated with a component, and the specified layout direction
		* is the same as the layout direction of that component.
		* <p>
		* The expected result is an interface {@link FunctionsOnComponent}
		* for adjusting the component.
		*/
		@Test
		void testGetComponent6() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertTrue(gle.getComponent(Axis.HORIZONTAL, ""CB11"") instanceof FunctionsOnComponent);
		}
		
		/**
		* Test case 7.
		* <p>
		* The method {@link GroupLayoutEngineer#getComponent(Axis, String)}
		* is tested for the case when the specified component name
		* is associated with a component, and the specified layout direction
		* is the same as the layout direction of that component.
		* <p>
		* The expected result is an interface {@link FunctionsOnComponent}
		* for adjusting the component.
		*/
		@Test
		void testGetComponent7() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertTrue(gle.getComponent(Axis.HORIZONTAL, ""CB12"") instanceof FunctionsOnComponent);
		}
		
		/**
		* Test case 8.
		* <p>
		* The method {@link GroupLayoutEngineer#getComponent(Axis, String)}
		* is tested for the case when the specified component name
		* is associated with a component, and the specified layout direction
		* is the same as the layout direction of that component.
		* <p>
		* The expected result is an interface {@link FunctionsOnComponent}
		* for adjusting the component.
		*/
		@Test
		void testGetComponent8() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				assertTrue(gle.getComponent(Axis.HORIZONTAL, ""CB21"") instanceof FunctionsOnComponent);
		}
		
		/**
	"
cmpl-6wzpyr9Zv7T5as8k1XkoiW74AwTH1,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer1.java,114.23777151107788,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis layout direction
     * @param firstName the name of the first component in the group
     * @param lastName the name of the last component in the group
     * @return an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

		/**
		* Test case 1.
		* <p>
		* The scheme:
		* <pre>
		* ""A1  A2  A3  A4  A5  A6  A7  A8  A9  A10 A11 A12 A13 A14 A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28 A29 A30 A31 A32 A33 A34 A35 A36 A37 A38 A39 A40 A41 A42 A43 A44 A45 A46 A47 A48 A49 A50 A51 A52 A53 A54 A55 A56 A57 A58 A59 A60 A61 A62 A63 A64 A65 A66 A67 A68 A69 A70 A71 A72 A73 A74 A75 A76 A77 A78 A79 A80 A81 A82 A83 A84 A85 A86 A87 A88 A89 A90 A91 A92 A93 A94 A95 A96 A97 A98 A99 A100 A101 A102 A103 A104 A105 A106 A107 A108 A109 A110 A111 A112 A113 A114 A115 A116 A117 A118 A119 A120 A121 A122 A123 A124 A125 A126 A127 A128 A129 A130 A131 A132 A133 A134 A135 A136 A137 A138 A139 A140 A141 A142 A143 A144 A145 A146 A147 A148 A149 A150 A151 A152 A153 A154 A155 A156 A157 A158 A159 A160 A161 A162 A163 A164 A165 A166 A167 A168 A169 A170 A171 A172 A173 A174 A175 A176 A177 A178 A179 A180 A181 A182 A183 A184 A185 A186 A187 A188 A189 A190 A191 A192 A193 A194 A195 A196 A197 A198 A199 A200 A201 A202 A203 A204 A205 A206 A207 A208 A209 A210 A211 A212 A213 A214 A215 A216 A217 A218 A219 A220 A221 A222 A223 A224 A225 A226 A227 A228 A229 A230 A231 A232 A233 A234 A235 A236 A237 A238 A239 A240 A241 A242 A243 A244 A245 A246 A247 A248 A249 A250 A251 A252 A253 A254 A255 A256 A257 A258 A259 A260 A261 A262 A263 A264 A265 A266 A267 A268 A269 A270 A271 A272 A273 A274 A275 A276 A277 A278 A279 A280 A281 A282 A283 A284 A285 A286 A287 A288 A289 A290 A291 A292 A293 A294 A295 A296 A297 A298 A299 A300 A301 A302 A303 A304 A305 A306 A307 A308 A309 A310 A311 A312 A313 A314 A315 A316 A317 A318 A319 A320 A321 A322 A323 A324 A325 A326 A327 A328 A329 A330 A331 A332 A333 A334 A335 A336 A337 A338 A339 A340 A341 A342 A343 A344 A345 A346 A347 A348 A349 A350 A351 A352 A353 A354 A355 A356 A357 A358 A359 A360 A361 A362 A363 A364 A365 A366 A367 A368 A369 A370 A371 A372 A373 A374 A375 A376 A377 A378 A379 A380 A381 A382 A383 A384 A385 A386 A387 A388 A389 A390 A391 A392 A393 A394 A395 A396 A397 A398 A399 A400 A401 A402 A403 A404 A405 A406 A407 A408 A409 A410 A411 A412 A413 A414 A415 A416 A417 A418 A419 A420 A421 A422 A423 A424 A425 A426 A427 A428 A429 A430 A431 A432 A433 A434 A435 A436 A437 A438 A439 A440 A441 A442 A443 A444 A445 A446 A447 A448 A449 A450 A451 A452 A453 A454 A455 A456 A457 A458 A459 A460 A461 A462 A463 A464 A465 A466 A467 A468 A469 A470 A471 A472 A473 A474 A475 A476 A477 A478 A479 A480 A481 A482 A483 A484 A485 A486 A487 A488 A489 A490 A491 A492 A493 A494 A495 A496 A497 A498 A499 A500 A501 A502 A503 A504 A505 A506 A507 A508 A509 A510 A511 A512 A513 A514 A515 A516 A517 A518 A519 A520 A521 A522 A523 A524 A525 A526 A527 A528 A529 A530 A531 A532 A533 A534 A535 A536 A537 A538 A539 A540 A541 A542 A543 A544 A545 A546 A547 A548 A549 A550 A551 A552 A553 A554 A555 A556 A557 A558 A559 A560 A561 A562 A563 A564 A565 A566 A567 A568 A569 A570 A571 A572 A573 A574 A575 A576 A577 A578 A579 A580 A581 A582 A583 A584 A585 A586 A587 A588 A589 A590 A591 A592 A593 A594 A595 A596 A597 A598 A599 A600 A601 A602 A603 A604 A605 A606 A607 A608 A609 A610 A611 A612 A613 A614 A615 A616 A617 A618 A619 A620 A621 A622 A623 A624 A625 A626 A627 A628 A629 A630 A631 A632 A633 A634 A635 A636 A637 A638 A639 A640 A641 A642 A643 A644 A645 A646 A647 A648 A649 A650 A651 A652 A653 A654 A655 A656 A657 A658 A659 A660 A661 A662 A663 A664 A665 A666 A667 A668 A669 A670 A671 A672 A673 A674 A675 A676 A677 A678 A679 A680 A681 A682 A683 A684 A685 A686 A687 A688 A689 A690 A691 A692 A693 A694 A695 A696 A697 A698 A699 A700 A701 A702 A703 A704 A705 A706 A707 A708 A709 A710 A711 A712 A713 A714 A715 A716 A717 A718 A719 A720 A721 A722 A723 A724 A725 A726 A727 A728 A729 A730 A731 A732 A733 A734 A735 A736 A737 A738 A739 A740 A741 A742 A743 A744 A745 A746 A747 A748 A749 A750 A751 A752 A753 A754 A755 A756 A757 A758 A759 A760 A761 A762 A763 A764 A765 A766 A767 A768 A769 A770 A771 A772 A773 A774 A775 A776 A777 A778 A779 A780 A781 A782 A783 A784 A785 A786 A787 A788 A789 A790 A791 A792 A793 A794 A795 A796 A797 A798 A799 A800 A801 A802 A803 A804 A805 A806 A807 A808 A809 A810 A811 A812 A813 A814 A815 A816 A817 A818 A819 A820 A821 A822 A823 A824 A825 A826 A827 A828 A829 A830 A831 A832 A833 A834 A835 A836 A837 A838 A839 A840 A841 A842 A843 A844 A845 A846 A847 A848 A849 A850 A851 A852 A853 A854 A855 A856 A857 A858 A859 A860 A861 A862 A863 A864 A865 A866 A867 A868 A869 A870 A871 A872 A873 A874 A875 A876 A877 A878 A879 A880 A881 A882 A883 A884 A885 A886 A887 A888 A889 A890 A891 A892 A893 A894 A895 A896 A897 A898 A899 A900 A901 A902 A903 A904 A905 A906 A907 A908 A909 A910 A911 A912 A913 A914 A915 A916 A917 A918 A919 A920 A921 A922 A923 A924 A925 A926 A927 A928 A929 A930 A931 A932 A933 A934 A935 A936 A937 A938 A939 A940 A941 A942 A943 A944 A945 A946 A947 A948 A949 A950 A951 A952 A953 A954 A955 A956 A957 A958 A959 A960 A961 A962 A963 A964 A965 A966 A967 A968 A969 A970 A971 A972 A973 A974 A975 A976 A977 A978 A979 A980 A981 A982 A983 A984 A985 A986 A987 A988 A989 A990 A991 A992 A993 A994 A995 A996 A997 A998 A999 A1000 A1001 A1002 A1003 A1004 A1005 A1006 A1007 A1008 A1009 A1010 A1011 A1012 A1013 A1014 A1015 A1016 A1017 A1018 A1019 A1020 A1021 A1022 A1023 A1024 A1025 A1026 A1027 A1028 A1029 A1030 A1031 A1032 A1033 A1034 A1035 A1036 A1037 A1038 A1039 A1040 A1041 A1042 A1043 A1044 A1045 A1046 A1047 A1048 A1049 A1050 A1051 A1052 A1053 A1054 A1055 A1056 A1057 A1058 A1059 A1060 A1061 A1062 A1063 A1064 A1065 A1066 A1067 A1068 A1069 A1070 A1071 A1072 A1073 A1074 A1075 A1076 A1077 A1078 A1079 A1080 A1081 A1082 A1083 A1084 A1085 A1086 A1087 A1088 A1089 A1090 A1091 A1092 A1093 A1094 A1095 A1096 A1097 A1098 A1099 A1100 A1101 A1102 A1103 A1104 A1105 A1106 A1107 A1108 A1109 A1110 A1111 A1112 A1113 A1114 A1115 A1116 A1117 A1118 A1119 A1120 A1121 A1122 A1123 A1124 A1125 A1126 A1127 A1128 A1129 A1130 A1131 A1132 A1133 A1134 A1135 A1136 A1137 A1138 A1139 A1140 A1141 A1142 A1143 A1144 A1145 A1146 A1147 A1148 A1149 A1150 A1151 A1152 A1153 A1154 A1155 A1156 A1157 A1158 A1159 A1160 A1161 A1162 A1163 A1164 A1165 A1166 A1167 A1168 A1169 A1170 A1171 A1172 A1173 A1174 A1175 A1176 A1177 A1178 A1179 A1180 A1181 A1182 A1183 A1184 A1185 A1186 A1187 A1188 A1189 A1190 A1191 A1192 A1193 A1194 A1195 A1196 A1197 A1198 A1199 A1200 A1201 A1202 A1203 A1204 A1205 A1206 A1207 A1208 A1209 A1210 A1211 A1212 A1213 A1214 A1215 A1216 A1217 A1218 A1219 A1220 A1221 A1222 A1223 A1224 A1225 A1226 A1227 A1228 A1229 A1230 A1231 A1232 A1233 A1234 A1235 A1236 A1237 A1238 A1239 A1240 A1241 A1242 A1243 A1244 A1245 A1246 A1247 A1248 A1249 A1250 A1251 A1252 A1253 A1254 A1255 A1256 A1257 A1258 A1259 A1260 A1261 A1262 A1263 A1264 A1265 A1266 A1267 A1268 A1269 A1270 A1271 A1272 A1273 A1274 A1275 A1276 A1277 A1278 A1279 A1280 A1281 A1282 A1283 A1284 A1285 A1286 A1287 A1288 A1289 A1290 A1291 A1292 A1293 A1294 A1295 A1296 A1297 A1298 A1299 A1300 A1301 A1302 A1303 A1304 A1305 A1306 A1307 A1308 A1309 A1310 A1311 A1312 A1313 A1314 A1315 A1316 A1317 A1318 A1319 A1320 A1321 A1322 A1323 A1324 A1325 A1326 A1327 A1328 A1329 A1330 A1331 A1332 A1333 A1334 A1335 A1336 A1337 A1338 A1339 A1340 A1341 A1342 A1343 A1344 A1345 A1346 A1347 A1348 A1349 A1350 A1351 A1352 A1353 A1354 A1355 A1356 A1357 A1358 A1359 A1360 A1361 A1362 A1363 A1364 A1365 A1366 A1367 A1368 A1369 A1370 A1371 A1372 A1373 A1374 A1375 A1376 A1377 A1378 A1379 A1380 A1381 A1382 A1383 A1384 A1385 A1386 A1387 A1388 A1389 A1390 A1391 A1392 A1393 A1394 A1395 A1396 A1397 A1398 A1399 A1400 A1401 A1402 A1403 A1404 A1405 A1406 A1407 A1408 A1409 A1410 A1411 A1412 A1413 A1414 A1415 A1416 A1417 A1418 A1419 A1420 A1421 A1422 A1423 A1424 A1425 A1426 A1427 A1428 A1429 A1430 A1431 A1432 A1433 A1434 A1435 A1436 A1437 A1438 A1439 A1440 A1441 A1442 A1443 A1444 A1445 A1446 A1447 A1448 A1449 A1450 A1451 A1452 A1453 A1454 A1455 A1456 A1457 A1458 A1459 A1460 A1461 A1462 A1463 A1464 A1465 A1466 A1467 A1468 A1469 A1470 A1471 A1472 A1473 A1474 A1475 A1476 A1477 A1478 A1479 A1480 A1481 A1482 A1483 A1484 A1485 A1486 A1487 A1488 A1489 A1490 A1491 A1492 A1493 A1494 A1495 A1496 A1497 A1498 A1499 A1500 A1501 A1502 A1503 A1504 A1505 A1506 A1507 A1508 A1509 A1510 A1511 A1512 A1513 A1514 A1515 A1516 A1517 A1518 A1519 A1520 A1521 A1522 A1523 A1524 A1525 A1526 A1527 A1528 A1529 A1530 A1531 A1532 A1533 A1534 A1535 A1536 A1537 A1538 A1539 A1540 A1541 A1542 A1543 A1544 A1545 A1546 A1547 A1548 A1549 A1550 A1551 A1552 A1553 A1554 A1555 A1556 A1557 A1558 A1559 A1560 A1561 A1562 A1563 A1564 A1565 A1566 A1567 A1568 A1569 A1570 A1571 A1572 A1573 A1574 A1575 A1576 A1577 A1578 A1579 A1580 A1581 A1582 A1583 A1584 A1585 A1586 A1587 A1588 A1589 A1590 A1591 A1592 A1593 A1594"
cmpl-6wzrolqRT0vdph0MHoeCaSAlxAsSQ,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer2.java,136.84495997428894,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis layout direction
     * @param firstName the name of the first component in the group
     * @param lastName the name of the last component in the group
     * @return an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

		/**
		* Test case 1.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapResizeBehavior(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapContentAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapGap(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapGapType(), ComponentPlacement.RELATED);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapGapSize(), GroupLayout.DEFAULT_SIZE);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapGapAlignment(), Alignment.LEADING);
				assertEquals(fopg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getGapGapGapGapGapGapGapGapGapGapGapRes"
cmpl-6wzvxzbNlZIbVuczz5J4N4zhkZ8h0,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer3.java,276.8147521018982,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis layout direction
     * @param firstName the name of the first component in the group
     * @param lastName the name of the last component in the group
     * @return an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

		/**
		* Test case 1.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.getComponent(""FINDBUTTON""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(0), gle.getComponent(""FINDLABEL""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(1), gle.getComponent(""TEXTFIELD""));
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponent(2), gle.get"
cmpl-6wzyUomv9bO8DwgyyZAPPw1PZjfG4,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer4.java,118.61041307449341,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis layout direction
     * @return the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {

		/**
		 * Test case 1.
		 * <p>
		 * The scheme is:
		 * <pre>
		 * ""A""
		 * </pre>
		 * <p>
		 * The expected result is:
		 * <pre>
		 * ""A""
		 * </pre>
		 */
		@Test
		void test1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A"");
				gle.associate(""A"", new JLabel(""A""));
				gle.engineer();
				
				FunctionsOnTopSequentialGroup fotg = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(1, fotg.getSize());
				assertEquals(""A"", fotg.getElement(0).getName());
		}
		
		/**
		 * Test case 2.
		 * <p>
		 * The scheme is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * </pre>
		 * <p>
		 * The expected result is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * </pre>
		 */
		@Test
		void test2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A"",
						""B"");
				gle.associate(""A"", new JLabel(""A""));
				gle.associate(""B"", new JLabel(""B""));
				gle.engineer();
				
				FunctionsOnTopSequentialGroup fotg = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(2, fotg.getSize());
				assertEquals(""A"", fotg.getElement(0).getName());
				assertEquals(""B"", fotg.getElement(1).getName());
		}
		
		/**
		 * Test case 3.
		 * <p>
		 * The scheme is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * </pre>
		 * <p>
		 * The expected result is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * </pre>
		 */
		@Test
		void test3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A"",
						""B"",
						""C"");
				gle.associate(""A"", new JLabel(""A""));
				gle.associate(""B"", new JLabel(""B""));
				gle.associate(""C"", new JLabel(""C""));
				gle.engineer();
				
				FunctionsOnTopSequentialGroup fotg = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(3, fotg.getSize());
				assertEquals(""A"", fotg.getElement(0).getName());
				assertEquals(""B"", fotg.getElement(1).getName());
				assertEquals(""C"", fotg.getElement(2).getName());
		}
		
		/**
		 * Test case 4.
		 * <p>
		 * The scheme is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * </pre>
		 * <p>
		 * The expected result is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * </pre>
		 */
		@Test
		void test4() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A"",
						""B"",
						""C"",
						""D"");
				gle.associate(""A"", new JLabel(""A""));
				gle.associate(""B"", new JLabel(""B""));
				gle.associate(""C"", new JLabel(""C""));
				gle.associate(""D"", new JLabel(""D""));
				gle.engineer();
				
				FunctionsOnTopSequentialGroup fotg = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(4, fotg.getSize());
				assertEquals(""A"", fotg.getElement(0).getName());
				assertEquals(""B"", fotg.getElement(1).getName());
				assertEquals(""C"", fotg.getElement(2).getName());
				assertEquals(""D"", fotg.getElement(3).getName());
		}
		
		/**
		 * Test case 5.
		 * <p>
		 * The scheme is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * ""E""
		 * </pre>
		 * <p>
		 * The expected result is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * ""E""
		 * </pre>
		 */
		@Test
		void test5() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A"",
						""B"",
						""C"",
						""D"",
						""E"");
				gle.associate(""A"", new JLabel(""A""));
				gle.associate(""B"", new JLabel(""B""));
				gle.associate(""C"", new JLabel(""C""));
				gle.associate(""D"", new JLabel(""D""));
				gle.associate(""E"", new JLabel(""E""));
				gle.engineer();
				
				FunctionsOnTopSequentialGroup fotg = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(5, fotg.getSize());
				assertEquals(""A"", fotg.getElement(0).getName());
				assertEquals(""B"", fotg.getElement(1).getName());
				assertEquals(""C"", fotg.getElement(2).getName());
				assertEquals(""D"", fotg.getElement(3).getName());
				assertEquals(""E"", fotg.getElement(4).getName());
		}
		
		/**
		 * Test case 6.
		 * <p>
		 * The scheme is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * ""E""
		 * ""F""
		 * </pre>
		 * <p>
		 * The expected result is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * ""E""
		 * ""F""
		 * </pre>
		 */
		@Test
		void test6() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A"",
						""B"",
						""C"",
						""D"",
						""E"",
						""F"");
				gle.associate(""A"", new JLabel(""A""));
				gle.associate(""B"", new JLabel(""B""));
				gle.associate(""C"", new JLabel(""C""));
				gle.associate(""D"", new JLabel(""D""));
				gle.associate(""E"", new JLabel(""E""));
				gle.associate(""F"", new JLabel(""F""));
				gle.engineer();
				
				FunctionsOnTopSequentialGroup fotg = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(6, fotg.getSize());
				assertEquals(""A"", fotg.getElement(0).getName());
				assertEquals(""B"", fotg.getElement(1).getName());
				assertEquals(""C"", fotg.getElement(2).getName());
				assertEquals(""D"", fotg.getElement(3).getName());
				assertEquals(""E"", fotg.getElement(4).getName());
				assertEquals(""F"", fotg.getElement(5).getName());
		}
		
		/**
		 * Test case 7.
		 * <p>
		 * The scheme is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * ""E""
		 * ""F""
		 * ""G""
		 * </pre>
		 * <p>
		 * The expected result is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * ""E""
		 * ""F""
		 * ""G""
		 * </pre>
		 */
		@Test
		void test7() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A"",
						""B"",
						""C"",
						""D"",
						""E"",
						""F"",
						""G"");
				gle.associate(""A"", new JLabel(""A""));
				gle.associate(""B"", new JLabel(""B""));
				gle.associate(""C"", new JLabel(""C""));
				gle.associate(""D"", new JLabel(""D""));
				gle.associate(""E"", new JLabel(""E""));
				gle.associate(""F"", new JLabel(""F""));
				gle.associate(""G"", new JLabel(""G""));
				gle.engineer();
				
				FunctionsOnTopSequentialGroup fotg = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(7, fotg.getSize());
				assertEquals(""A"", fotg.getElement(0).getName());
				assertEquals(""B"", fotg.getElement(1).getName());
				assertEquals(""C"", fotg.getElement(2).getName());
				assertEquals(""D"", fotg.getElement(3).getName());
				assertEquals(""E"", fotg.getElement(4).getName());
				assertEquals(""F"", fotg.getElement(5).getName());
				assertEquals(""G"", fotg.getElement(6).getName());
		}
		
		/**
		 * Test case 8.
		 * <p>
		 * The scheme is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * ""E""
		 * ""F""
		 * ""G""
		 * ""H""
		 * </pre>
		 * <p>
		 * The expected result is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * ""E""
		 * ""F""
		 * ""G""
		 * ""H""
		 * </pre>
		 */
		@Test
		void test8() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A"",
						""B"",
						""C"",
						""D"",
						""E"",
						""F"",
						""G"",
						""H"");
				gle.associate(""A"", new JLabel(""A""));
				gle.associate(""B"", new JLabel(""B""));
				gle.associate(""C"", new JLabel(""C""));
				gle.associate(""D"", new JLabel(""D""));
				gle.associate(""E"", new JLabel(""E""));
				gle.associate(""F"", new JLabel(""F""));
				gle.associate(""G"", new JLabel(""G""));
				gle.associate(""H"", new JLabel(""H""));
				gle.engineer();
				
				FunctionsOnTopSequentialGroup fotg = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(8, fotg.getSize());
				assertEquals(""A"", fotg.getElement(0).getName());
				assertEquals(""B"", fotg.getElement(1).getName());
				assertEquals(""C"", fotg.getElement(2).getName());
				assertEquals(""D"", fotg.getElement(3).getName());
				assertEquals(""E"", fotg.getElement(4).getName());
				assertEquals(""F"", fotg.getElement(5).getName());
				assertEquals(""G"", fotg.getElement(6).getName());
				assertEquals(""H"", fotg.getElement(7).getName());
		}
		
		/**
		 * Test case 9.
		 * <p>
		 * The scheme is:
		 * <pre>
		 * ""A""
		 * ""B""
		 * ""C""
		 * ""D""
		 * ""E"
cmpl-6x00OTZfDFBMDKkbp1Z9PVHHNOmSg,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent0.java,164.64601159095764,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {

	/**
	 * Test case 1.
	 * Verifies that the method returns true if the parallel group agent contains gaps only.
	 */
	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertTrue(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 2.
	 * Verifies that the method returns false if the parallel group agent contains gaps and components.
	 */
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 3.
	 * Verifies that the method returns false if the parallel group agent contains gaps and sequential groups.
	 */
	@Test
	void testContainsGapsOnly_3() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new SequentialGroupAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 4.
	 * Verifies that the method returns false if the parallel group agent contains gaps and parallel groups.
	 */
	@Test
	void testContainsGapsOnly_4() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 5.
	 * Verifies that the method returns false if the parallel group agent contains gaps and components in sequential groups.
	 */
	@Test
	void testContainsGapsOnly_5() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		SequentialGroupAgent sequentialGroupAgent = new SequentialGroupAgent();
		sequentialGroupAgent.addChild(new ComponentAgent());
		agent.addChild(sequentialGroupAgent);
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 6.
	 * Verifies that the method returns false if the parallel group agent contains gaps and components in parallel groups.
	 */
	@Test
	void testContainsGapsOnly_6() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addChild(new ComponentAgent());
		agent.addChild(parallelGroupAgent);
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 7.
	 * Verifies that the method returns false if the parallel group agent contains gaps and sequential groups in sequential groups.
	 */
	@Test
	void testContainsGapsOnly_7() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		SequentialGroupAgent sequentialGroupAgent = new SequentialGroupAgent();
		sequentialGroupAgent.addChild(new SequentialGroupAgent());
		agent.addChild(sequentialGroupAgent);
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 8.
	 * Verifies that the method returns false if the parallel group agent contains gaps and sequential groups in parallel groups.
	 */
	@Test
	void testContainsGapsOnly_8() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addChild(new SequentialGroupAgent());
		agent.addChild(parallelGroupAgent);
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 9.
	 * Verifies that the method returns false if the parallel group agent contains gaps and parallel groups in sequential groups.
	 */
	@Test
	void testContainsGapsOnly_9() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		SequentialGroupAgent sequentialGroupAgent = new SequentialGroupAgent();
		sequentialGroupAgent.addChild(new ParallelGroupAgent());
		agent.addChild(sequentialGroupAgent);
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 10.
	 * Verifies that the method returns false if the parallel group agent contains gaps and parallel groups in parallel groups.
	 */
	@Test
	void testContainsGapsOnly_10() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addChild(new ParallelGroupAgent());
		agent.addChild(parallelGroupAgent);
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
}

// ParallelGroupSettings.java
package glengineer.agents.settings;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupSettings {

    /**
     * The alignment of the parallel group.
     */
    private Alignment alignment;

    /**
     * The resizable property of the parallel group.
     */
    private boolean resizable;

    /**
     * The preferred size of the parallel group.
     */
    private int preferredSize;

    /**
     * The maximum size of the parallel group.
     */
    private int maximumSize;

    /**
     * The minimum size of the parallel group.
     */
    private int minimumSize;

    /**
     * Creates a new instance of {@link ParallelGroupSettings}.
     */
    public ParallelGroupSettings() {
        this.alignment = Alignment.LEADING;
        this.resizable = true;
        this.preferredSize = GroupLayoutSettings.DEFAULT_SIZE;
        this.maximumSize = GroupLayoutSettings.DEFAULT_SIZE;
        this.minimumSize = GroupLayoutSettings.DEFAULT_SIZE;
    }

    /**
     * Creates a new instance of {@link ParallelGroupSettings} with the specified alignment.
     *
     * @param alignment the alignment of the parallel group
     */
    public ParallelGroupSettings(Alignment alignment) {
        this.alignment = alignment;
        this.resizable = true;
        this.preferredSize = GroupLayoutSettings.DEFAULT_SIZE;
        this.maximumSize = GroupLayoutSettings.DEFAULT_SIZE;
        this.minimumSize = GroupLayoutSettings.DEFAULT_SIZE;
    }

    /**
     * Creates a new instance of {@link ParallelGroupSettings} with the specified alignment and resizable property.
     *
     * @param alignment the alignment of the parallel group
     * @param resizable the resizable property of the parallel group
     */
    public ParallelGroupSettings(Alignment alignment, boolean resizable) {
        this.alignment = alignment;
        this.resizable = resizable;
        this.preferredSize = GroupLayoutSettings.DEFAULT_SIZE;
        this.maximumSize = GroupLayoutSettings.DEFAULT_SIZE;
        this.minimumSize = GroupLayoutSettings.DEFAULT_SIZE;
    }

    /**
     * Creates a new instance of {@link ParallelGroupSettings} with the specified alignment, resizable property, and preferred size.
     *
     * @param alignment the alignment of the parallel group
     * @param resizable the resizable property of the parallel group
     * @param preferredSize the preferred size of the parallel group
     */
    public ParallelGroupSettings(Alignment alignment, boolean resizable, int preferredSize) {
        this.alignment = alignment;
        this.resizable = resizable;
        this.preferredSize = preferredSize;
        this.maximumSize = GroupLayoutSettings.DEFAULT_SIZE;
        this.minimumSize = GroupLayoutSettings.DEFAULT_SIZE;
    }

    /**
     * Creates a new instance of {@link ParallelGroupSettings} with the specified alignment, resizable property, preferred size, and maximum size.
     *
     * @param alignment the alignment of the parallel group
     * @param resizable the resizable property of the parallel group
     * @param preferredSize the preferred size of the parallel group
     * @param maximumSize the maximum size of the parallel group
     */
    public ParallelGroupSettings(Alignment alignment, boolean resizable, int preferredSize, int maximumSize) {
        this.alignment = alignment;
        this.resizable = resizable;
        this.preferredSize = preferredSize;
        this.maximumSize = maximumSize;
        this.minimumSize = GroupLayoutSettings.DEFAULT_SIZE;
    }

    /**
     * Creates a new instance of {@link ParallelGroupSettings} with the specified alignment, resizable property, preferred size, maximum size, and minimum size.
     *
     * @param alignment the alignment of the parallel group
     * @param resizable the resizable property of the parallel group
     * @param preferredSize the preferred size of the parallel group
     * @param maximumSize the maximum size of the parallel group
     * @param minimumSize the minimum size of the parallel group
     */
    public ParallelGroupSettings(Alignment alignment, boolean resizable, int preferredSize, int maximumSize, int minimumSize) {
        this.alignment = alignment;
        this.resizable = resizable;
        this.preferredSize = preferredSize;
        this.maximumSize = maximumSize;
        this.minimumSize = minimumSize;
    }

    /**
     * Returns the alignment of the parallel group.
     *
     * @return the alignment of the parallel group
     */
    public Alignment getAlignment() {
        return alignment;
    }

    /**
     * Sets the alignment of the parallel group.
     *
     * @param alignment the alignment of the parallel group
     */
    public void setAlignment(Alignment alignment) {
        this.alignment = alignment;
    }

    /**
     * Returns the resizable property of the parallel group.
     *
     * @return the resizable property of the parallel group
     */
    public boolean isResizable() {
        return resizable;
    }

    /**
     * Sets the resizable property of the parallel group.
     *
     * @param resizable the resizable property of the parallel group
     */
    public void setResizable(boolean resizable) {
        this.resizable = resizable;
    }

    /**
     * Returns the preferred size of the parallel group.
     *
     * @return the preferred size of the parallel group
     */
    public int getPreferredSize() {
        return preferredSize;
    }

    /**
     * Sets the preferred size of the parallel group.
     *
     * @param preferredSize the preferred size of the parallel group
     */
    public void setPreferredSize(int preferredSize) {
        this.preferredSize = preferredSize;
    }

    /**
     * Returns the maximum size of the parallel group.
     *
     * @return the maximum size of the parallel group
     */
    public int getMaximumSize() {
        return maximumSize;
    }

    /**
     * Sets the maximum size of the parallel group.
     *
     * @param maximumSize the maximum size of the parallel group
     */
    public void setMaximumSize(int maximumSize) {
        this.maximumSize = maximumSize;
    }

    /**
     * Returns the minimum size of the parallel group.
     *
     * @return the minimum size of the parallel group
     */
    public int getMinimumSize() {
        return minimumSize;
    }

    /**
     * Sets the minimum size of the parallel group.
     *
     * @param minimumSize the minimum size of the parallel group
     */
    public void setMinimumSize(int minimumSize) {
        this.minimumSize = minimumSize;
    }

    /**
     * Applies the settings to the specified parallel group.
     *
     * @param parallelGroup the parallel group to which the settings are applied
     */
    public void applyTo(ParallelGroup parallelGroup) {
        FunctionsOnParallelGroup.setAlignment(parallelGroup, alignment);
        FunctionsOnParallelGroup.setResizable(parallelGroup, resizable);
        FunctionsOnParallelGroup.setPreferredSize(parallelGroup, preferredSize);
        FunctionsOnParallelGroup.setMaximumSize(parallelGroup, maximumSize);
        FunctionsOnParallelGroup.setMinimumSize(parallelGroup, minimumSize);
    }

    /**
     * Applies the settings to the specified parallel group and element.
     *
     * @param parallelGroup the parallel group to which the settings are applied
     * @param element the element to which the settings are applied
     */
    public void applyTo(ParallelGroup parallelGroup, Object element) {
        FunctionsOnParallelGroupAndElement.setAlignment(parallelGroup, element, alignment);
        FunctionsOnParallelGroupAndElement.setResizable(parallelGroup, element, resizable);
        FunctionsOnParallelGroupAndElement.setPreferredSize(parallelGroup, element, preferredSize);
        FunctionsOnParallelGroupAndElement.setMaximumSize(parallelGroup, element, maximumSize);
        FunctionsOnParallelGroupAndElement.setMinimumSize(parallelGroup, element, minimumSize);
    }
}

// ParallelGroupSettingsTest.java
package glengineer.agents.settings;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupSettings}.
* It contains ten unit test cases for the {@link ParallelGroupSettings#applyTo(ParallelGroup)} method.
*/
class ParallelGroupSettingsTest {
		
	/**
	 * Test case 1.
	 * Verifies that the method applies the settings to the parallel group.
	 */
	@Test
	void testApplyTo_1() {
		ParallelGroup parallelGroup = FunctionsOnGroup.createParallelGroup();
		ParallelGroupSettings settings = new ParallelGroupSettings(Alignment.TRAILING, false, 10, 20, 30);
		settings.applyTo(parallelGroup);
		assertEquals(Alignment.TRAILING, FunctionsOnParallelGroup.getAlignment(parallelGroup));
		assertFalse(FunctionsOnParallelGroup.isResizable(parallelGroup));
		assertEquals(10, FunctionsOnParallelGroup.getPreferredSize(parallelGroup));
		assertEquals(20, FunctionsOnParallelGroup.getMaximumSize(parallelGroup));
		assertEquals(30, FunctionsOnParallelGroup.getMinimumSize(parallelGroup));
	}
	
	/**
	 * Test case 2.
	 * Verifies that the method applies the settings to the parallel group and element.
	 */
	@Test
	void testApplyTo_2() {
		ParallelGroup parallelGroup = FunctionsOnGroup.createParallelGroup();
		Object element = new Object();
		ParallelGroupSettings settings = new ParallelGroupSettings(Alignment.TRAILING, false, 10, 20, 30);
"
cmpl-6x044Q7vT0z9USCeh4abJA8y3E9gE,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent1.java,187.327073097229,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    /**
     *       
     *   .
     *
     * @param creatorAndAdder    
     * 							    
     * @return ,   
     * 							.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {

	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It checks the case when the agent has no children.
	 */
	@Test
	void testGroupContent_noChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addElementToGroup(ParallelGroup group, Agent agent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(0, result.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It checks the case when the agent has one child.
	 */
	@Test
	void testGroupContent_oneChild() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.TRAILING));
			}
		});
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addElementToGroup(ParallelGroup group, Agent agent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(1, result.getSize());
		Iterator<ParallelGroup> iterator = result.iterator();
		assertTrue(iterator.hasNext());
		ParallelGroup child = iterator.next();
		assertEquals(Alignment.TRAILING, child.getAlignment());
		assertEquals(0, child.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It checks the case when the agent has two children.
	 */
	@Test
	void testGroupContent_twoChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.TRAILING));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.CENTER));
			}
		});
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addElementToGroup(ParallelGroup group, Agent agent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(2, result.getSize());
		Iterator<ParallelGroup> iterator = result.iterator();
		assertTrue(iterator.hasNext());
		ParallelGroup child = iterator.next();
		assertEquals(Alignment.TRAILING, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.CENTER, child.getAlignment());
		assertEquals(0, child.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It checks the case when the agent has three children.
	 */
	@Test
	void testGroupContent_threeChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.TRAILING));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.CENTER));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.BASELINE));
			}
		});
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addElementToGroup(ParallelGroup group, Agent agent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(3, result.getSize());
		Iterator<ParallelGroup> iterator = result.iterator();
		assertTrue(iterator.hasNext());
		ParallelGroup child = iterator.next();
		assertEquals(Alignment.TRAILING, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.CENTER, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.BASELINE, child.getAlignment());
		assertEquals(0, child.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It checks the case when the agent has four children.
	 */
	@Test
	void testGroupContent_fourChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.TRAILING));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.CENTER));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.BASELINE));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.LEADING));
			}
		});
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addElementToGroup(ParallelGroup group, Agent agent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(4, result.getSize());
		Iterator<ParallelGroup> iterator = result.iterator();
		assertTrue(iterator.hasNext());
		ParallelGroup child = iterator.next();
		assertEquals(Alignment.TRAILING, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.CENTER, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.BASELINE, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.LEADING, child.getAlignment());
		assertEquals(0, child.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It checks the case when the agent has five children.
	 */
	@Test
	void testGroupContent_fiveChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.TRAILING));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.CENTER));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.BASELINE));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.LEADING));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.TRAILING));
			}
		});
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addElementToGroup(ParallelGroup group, Agent agent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(5, result.getSize());
		Iterator<ParallelGroup> iterator = result.iterator();
		assertTrue(iterator.hasNext());
		ParallelGroup child = iterator.next();
		assertEquals(Alignment.TRAILING, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.CENTER, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.BASELINE, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.LEADING, child.getAlignment());
		assertEquals(0, child.getSize());
		assertTrue(iterator.hasNext());
		child = iterator.next();
		assertEquals(Alignment.TRAILING, child.getAlignment());
		assertEquals(0, child.getSize());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It checks the case when the agent has six children.
	 */
	@Test
	void testGroupContent_sixChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.TRAILING));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.CENTER));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				group.addGroup(new ParallelGroup(Alignment.BASELINE));
			}
		});
		agent.addChild(new GroupAgent() {
			@Override
			public void addContentToGroup(ParallelGroup group, GroupCreatorAndElementAdder creatorAndAdder) {
				"
cmpl-6x064HlksA40CefEL5nMVNivxOB7H,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java,128.19573616981506,length,"// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * ,   .
 */
public class SequentialGroupAgent extends GroupAgent {

    /**
     *       
     *   .
     *
     * @param creatorAndAdder    
     * 							    
     * @return ,   
     * 							.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }
}
","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {

	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has no children.
	*/
	@Test
	void testGroupContent_NoChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(0, result.getComponents().length);
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has one child.
	*/
	@Test
	void testGroupContent_OneChild() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(1, result.getComponents().length);
		assertEquals(""component"", result.getComponents()[0].getName());
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has two children.
	*/
	@Test
	void testGroupContent_TwoChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(2, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has three children.
	*/
	@Test
	void testGroupContent_ThreeChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(3, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has four children.
	*/
	@Test
	void testGroupContent_FourChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		agent.addChild(new ComponentAgent(""component4""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(4, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
		assertEquals(""component4"", result.getComponents()[3].getName());
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has five children.
	*/
	@Test
	void testGroupContent_FiveChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		agent.addChild(new ComponentAgent(""component4""));
		agent.addChild(new ComponentAgent(""component5""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(5, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
		assertEquals(""component4"", result.getComponents()[3].getName());
		assertEquals(""component5"", result.getComponents()[4].getName());
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has six children.
	*/
	@Test
	void testGroupContent_SixChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		agent.addChild(new ComponentAgent(""component4""));
		agent.addChild(new ComponentAgent(""component5""));
		agent.addChild(new ComponentAgent(""component6""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(6, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
		assertEquals(""component4"", result.getComponents()[3].getName());
		assertEquals(""component5"", result.getComponents()[4].getName());
		assertEquals(""component6"", result.getComponents()[5].getName());
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has seven children.
	*/
	@Test
	void testGroupContent_SevenChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		agent.addChild(new ComponentAgent(""component4""));
		agent.addChild(new ComponentAgent(""component5""));
		agent.addChild(new ComponentAgent(""component6""));
		agent.addChild(new ComponentAgent(""component7""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(7, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
		assertEquals(""component4"", result.getComponents()[3].getName());
		assertEquals(""component5"", result.getComponents()[4].getName());
		assertEquals(""component6"", result.getComponents()[5].getName());
		assertEquals(""component7"", result.getComponents()[6].getName());
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has eight children.
	*/
	@Test
	void testGroupContent_EightChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		agent.addChild(new ComponentAgent(""component4""));
		agent.addChild(new ComponentAgent(""component5""));
		agent.addChild(new ComponentAgent(""component6""));
		agent.addChild(new ComponentAgent(""component7""));
		agent.addChild(new ComponentAgent(""component8""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(8, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
		assertEquals(""component4"", result.getComponents()[3].getName());
		assertEquals(""component5"", result.getComponents()[4].getName());
		assertEquals(""component6"", result.getComponents()[5].getName());
		assertEquals(""component7"", result.getComponents()[6].getName());
		assertEquals(""component8"", result.getComponents()[7].getName());
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has nine children.
	*/
	@Test
	void testGroupContent_NineChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		agent.addChild(new ComponentAgent(""component4""));
		agent.addChild(new ComponentAgent(""component5""));
		agent.addChild(new ComponentAgent(""component6""));
		agent.addChild(new ComponentAgent(""component7""));
		agent.addChild(new ComponentAgent(""component8""));
		agent.addChild(new ComponentAgent(""component9""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(9, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
		assertEquals(""component4"", result.getComponents()[3].getName());
		assertEquals(""component5"", result.getComponents()[4].getName());
		assertEquals(""component6"", result.getComponents()[5].getName());
		assertEquals(""component7"", result.getComponents()[6].getName());
		assertEquals(""component8"", result.getComponents()[7].getName());
		assertEquals(""component9"", result.getComponents()[8].getName());
	}
	
	/**
	* Test case for {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has ten children.
	*/
	@Test
	void testGroupContent_TenChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		agent.addChild(new ComponentAgent(""component4""));
		agent.addChild(new ComponentAgent(""component5""));
		agent.addChild(new ComponentAgent(""component6""));
		agent.addChild(new ComponentAgent(""component7""));
		agent.addChild(new ComponentAgent(""component8""));
		agent.addChild(new ComponentAgent(""component9""));
		agent.addChild(new ComponentAgent(""component10""));
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(10, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
		assertEquals(""component4"", result.getComponents()[3].getName());
		assertEquals(""component5"", result.getComponents()[4].getName());
		assertEquals(""component6"", result.getComponents()[5].getName());
		assertEquals(""component7"", result.getComponents()[6].getName());
		assertEquals(""component8"", result.getComponents()[7].getName());
		assertEquals(""component9"", result.getComponents()[8].getName());
		assertEquals(""component10"", result.getComponents()[9].getName());
	}
}

// GroupCreatorAndElementAdder.java
package glengineer.agents.setters;

import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * ,      .
 */
public class GroupCreatorAndElementAdder {

    /**
     *       
     *   .
     *
     * @return ,   
     * 							.
     */
    public SequentialGroup createSequentialGroup() {
        return new SequentialGroup();
    }

    /**
     *       
     *   .
     *
     * @return ,   
     * 							.
     */
    public ParallelGroup createParallelGroup() {
        return new ParallelGroup();
    }

    /**
     *       
     *   .
     *
     * @return ,   
     * 							.
     */
    public ParallelGroup createParallelGroup(Alignment alignment) {
        return new ParallelGroup(alignment);
    }

   "
cmpl-6x088ZjJpPG9liSiefET16M3NlLWq,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java,152.9809274673462,length,"// TopSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * ,     .
 * <p>
 *   {@code FunctionsOnTopSequentialGroup}
 *    
 *         .
 */
public class TopSequentialGroupAgent extends SequentialGroupAgent {

    /**
     *       ,
     * ,  ,       ,
     *    .
     * <p>
     *   {@code TopSequentialGroupAgent.groupContent()},
     *     .
     *
     * @param creatorAndAdder    
     * 							    
     * @return ,   
     * 							.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        if (precedingContainerGap != null)
            precedingContainerGap.addOneselfToGroup(result);
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        if (followingContainerGap != null)
            followingContainerGap.addOneselfToGroup(result);
        return result;
    }
}
","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {

	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup}
	 * with the same elements as the {@link TopSequentialGroupAgent} has.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has two children:
	 * <ul>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (100, 100)}</li>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (200, 200)}</li>
	 * </ul>
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no gaps.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no alignment.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no resize behavior.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no baseline resize behavior.
	 */
	@Test
	void testGroupContent_twoChildren_noGaps_noAlignment_noResizeBehavior_noBaselineResizeBehavior() {
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.addChild(new ComponentAgent(100, 100));
		agent.addChild(new ComponentAgent(200, 200));
		SequentialGroup result = agent.groupContent(new GroupCreatorAndElementAdder());
		assertEquals(2, result.getComponents().length);
		assertEquals(100, result.getComponents()[0].getPreferredSize().width);
		assertEquals(100, result.getComponents()[0].getPreferredSize().height);
		assertEquals(200, result.getComponents()[1].getPreferredSize().width);
		assertEquals(200, result.getComponents()[1].getPreferredSize().height);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup}
	 * with the same elements as the {@link TopSequentialGroupAgent} has.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has two children:
	 * <ul>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (100, 100)}</li>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (200, 200)}</li>
	 * </ul>
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no gaps.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no alignment.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no resize behavior.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no baseline resize behavior.
	 */
	@Test
	void testGroupContent_twoChildren_noGaps_noAlignment_noResizeBehavior_noBaselineResizeBehavior_withAlignment() {
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.addChild(new ComponentAgent(100, 100));
		agent.addChild(new ComponentAgent(200, 200));
		SequentialGroup result = agent.groupContent(new GroupCreatorAndElementAdder());
		assertEquals(2, result.getComponents().length);
		assertEquals(100, result.getComponents()[0].getPreferredSize().width);
		assertEquals(100, result.getComponents()[0].getPreferredSize().height);
		assertEquals(200, result.getComponents()[1].getPreferredSize().width);
		assertEquals(200, result.getComponents()[1].getPreferredSize().height);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup}
	 * with the same elements as the {@link TopSequentialGroupAgent} has.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has two children:
	 * <ul>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (100, 100)}</li>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (200, 200)}</li>
	 * </ul>
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no gaps.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no alignment.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no resize behavior.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no baseline resize behavior.
	 */
	@Test
	void testGroupContent_twoChildren_noGaps_noAlignment_noResizeBehavior_noBaselineResizeBehavior_withAlignment_withResizeBehavior() {
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.addChild(new ComponentAgent(100, 100));
		agent.addChild(new ComponentAgent(200, 200));
		SequentialGroup result = agent.groupContent(new GroupCreatorAndElementAdder());
		assertEquals(2, result.getComponents().length);
		assertEquals(100, result.getComponents()[0].getPreferredSize().width);
		assertEquals(100, result.getComponents()[0].getPreferredSize().height);
		assertEquals(200, result.getComponents()[1].getPreferredSize().width);
		assertEquals(200, result.getComponents()[1].getPreferredSize().height);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup}
	 * with the same elements as the {@link TopSequentialGroupAgent} has.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has two children:
	 * <ul>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (100, 100)}</li>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (200, 200)}</li>
	 * </ul>
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no gaps.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no alignment.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no resize behavior.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no baseline resize behavior.
	 */
	@Test
	void testGroupContent_twoChildren_noGaps_noAlignment_noResizeBehavior_noBaselineResizeBehavior_withAlignment_withResizeBehavior_withBaselineResizeBehavior() {
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.addChild(new ComponentAgent(100, 100));
		agent.addChild(new ComponentAgent(200, 200));
		SequentialGroup result = agent.groupContent(new GroupCreatorAndElementAdder());
		assertEquals(2, result.getComponents().length);
		assertEquals(100, result.getComponents()[0].getPreferredSize().width);
		assertEquals(100, result.getComponents()[0].getPreferredSize().height);
		assertEquals(200, result.getComponents()[1].getPreferredSize().width);
		assertEquals(200, result.getComponents()[1].getPreferredSize().height);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup}
	 * with the same elements as the {@link TopSequentialGroupAgent} has.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has two children:
	 * <ul>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (100, 100)}</li>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (200, 200)}</li>
	 * </ul>
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no gaps.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no alignment.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no resize behavior.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no baseline resize behavior.
	 */
	@Test
	void testGroupContent_twoChildren_noGaps_noAlignment_noResizeBehavior_noBaselineResizeBehavior_withAlignment_withResizeBehavior_withBaselineResizeBehavior_withGaps() {
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.addChild(new ComponentAgent(100, 100));
		agent.addChild(new ComponentAgent(200, 200));
		SequentialGroup result = agent.groupContent(new GroupCreatorAndElementAdder());
		assertEquals(2, result.getComponents().length);
		assertEquals(100, result.getComponents()[0].getPreferredSize().width);
		assertEquals(100, result.getComponents()[0].getPreferredSize().height);
		assertEquals(200, result.getComponents()[1].getPreferredSize().width);
		assertEquals(200, result.getComponents()[1].getPreferredSize().height);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup}
	 * with the same elements as the {@link TopSequentialGroupAgent} has.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has two children:
	 * <ul>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (100, 100)}</li>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (200, 200)}</li>
	 * </ul>
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no gaps.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no alignment.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no resize behavior.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no baseline resize behavior.
	 */
	@Test
	void testGroupContent_twoChildren_noGaps_noAlignment_noResizeBehavior_noBaselineResizeBehavior_withAlignment_withResizeBehavior_withBaselineResizeBehavior_withGaps_withAlignment() {
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.addChild(new ComponentAgent(100, 100));
		agent.addChild(new ComponentAgent(200, 200));
		SequentialGroup result = agent.groupContent(new GroupCreatorAndElementAdder());
		assertEquals(2, result.getComponents().length);
		assertEquals(100, result.getComponents()[0].getPreferredSize().width);
		assertEquals(100, result.getComponents()[0].getPreferredSize().height);
		assertEquals(200, result.getComponents()[1].getPreferredSize().width);
		assertEquals(200, result.getComponents()[1].getPreferredSize().height);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup}
	 * with the same elements as the {@link TopSequentialGroupAgent} has.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has two children:
	 * <ul>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (100, 100)}</li>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (200, 200)}</li>
	 * </ul>
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no gaps.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no alignment.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no resize behavior.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no baseline resize behavior.
	 */
	@Test
	void testGroupContent_twoChildren_noGaps_noAlignment_noResizeBehavior_noBaselineResizeBehavior_withAlignment_withResizeBehavior_withBaselineResizeBehavior_withGaps_withAlignment_withResizeBehavior() {
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.addChild(new ComponentAgent(100, 100));
		agent.addChild(new ComponentAgent(200, 200));
		SequentialGroup result = agent.groupContent(new GroupCreatorAndElementAdder());
		assertEquals(2, result.getComponents().length);
		assertEquals(100, result.getComponents()[0].getPreferredSize().width);
		assertEquals(100, result.getComponents()[0].getPreferredSize().height);
		assertEquals(200, result.getComponents()[1].getPreferredSize().width);
		assertEquals(200, result.getComponents()[1].getPreferredSize().height);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup}
	 * with the same elements as the {@link TopSequentialGroupAgent} has.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has two children:
	 * <ul>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (100, 100)}</li>
	 * <li>{@link ComponentAgent} with the {@link ComponentAgent#preferredSize}
	 * equal to {@code (200, 200)}</li>
	 * </ul>
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no gaps.
	 * <p>
	 * The {@link TopSequentialGroupAgent} has no alignment.
	 * <p>
	 * The {@link TopSequentialGroupAgent"
cmpl-6x0AbOMtN07CKAl5sdrJqEIwUDMzK,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock0.java,128.5897297859192,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        HorizontalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {

	/**
	 * Test case 1.
	 * The block is empty.
	 */
	@Test
	void test1() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(0, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(0, result.size());
	}
	
	/**
	 * Test case 2.
	 * The block contains only one character.
	 */
	@Test
	void test2() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(1, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).x1);
		assertEquals(new CharPosition1(1, 0), result.get(0).x2);
	}
	
	/**
	 * Test case 3.
	 * The block contains two sequential characters.
	 */
	@Test
	void test3() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(2, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).x1);
		assertEquals(new CharPosition1(2, 0), result.get(0).x2);
	}
	
	/**
	 * Test case 4.
	 * The block contains two non-sequential characters.
	 */
	@Test
	void test4() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(2, 0));
		block.add(new CharPosition1(1, 1));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).x1);
		assertEquals(new CharPosition1(1, 0), result.get(0).x2);
		assertEquals(new CharPosition1(1, 1), result.get(1).x1);
		assertEquals(new CharPosition1(2, 0), result.get(1).x2);
	}
	
	/**
	 * Test case 5.
	 * The block contains three sequential characters.
	 */
	@Test
	void test5() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(3, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).x1);
		assertEquals(new CharPosition1(3, 0), result.get(0).x2);
	}
	
	/**
	 * Test case 6.
	 * The block contains three non-sequential characters.
	 */
	@Test
	void test6() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(3, 0));
		block.add(new CharPosition1(1, 1));
		block.add(new CharPosition1(2, 2));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).x1);
		assertEquals(new CharPosition1(1, 0), result.get(0).x2);
		assertEquals(new CharPosition1(1, 1), result.get(1).x1);
		assertEquals(new CharPosition1(2, 0), result.get(1).x2);
		assertEquals(new CharPosition1(2, 2), result.get(2).x1);
		assertEquals(new CharPosition1(3, 0), result.get(2).x2);
	}
	
	/**
	 * Test case 7.
	 * The block contains four sequential characters.
	 */
	@Test
	void test7() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(4, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).x1);
		assertEquals(new CharPosition1(4, 0), result.get(0).x2);
	}
	
	/**
	 * Test case 8.
	 * The block contains four non-sequential characters.
	 */
	@Test
	void test8() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(4, 0));
		block.add(new CharPosition1(1, 1));
		block.add(new CharPosition1(2, 2));
		block.add(new CharPosition1(3, 3));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(4, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).x1);
		assertEquals(new CharPosition1(1, 0), result.get(0).x2);
		assertEquals(new CharPosition1(1, 1), result.get(1).x1);
		assertEquals(new CharPosition1(2, 0), result.get(1).x2);
		assertEquals(new CharPosition1(2, 2), result.get(2).x1);
		assertEquals(new CharPosition1(3, 0), result.get(2).x2);
		assertEquals(new CharPosition1(3, 3), result.get(3).x1);
		assertEquals(new CharPosition1(4, 0), result.get(3).x2);
	}
	
	/**
	 * Test case 9.
	 * The block contains five sequential characters.
	 */
	@Test
	void test9() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(5, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).x1);
		assertEquals(new CharPosition1(5, 0), result.get(0).x2);
	}
	
	/**
	 * Test case 10.
	 * The block contains five non-sequential characters.
	 */
	@Test
	void test10() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(5, 0));
		block.add(new CharPosition1(1, 1));
		block.add(new CharPosition1(2, 2));
		block.add(new CharPosition1(3, 3));
		block.add(new CharPosition1(4, 4));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(5, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).x1);
		assertEquals(new CharPosition1(1, 0), result.get(0).x2);
		assertEquals(new CharPosition1(1, 1), result.get(1).x1);
		assertEquals(new CharPosition1(2, 0), result.get(1).x2);
		assertEquals(new CharPosition1(2, 2), result.get(2).x1);
		assertEquals(new CharPosition1(3, 0), result.get(2).x2);
		assertEquals(new CharPosition1(3, 3), result.get(3).x1);
		assertEquals(new CharPosition1(4, 0), result.get(3).x2);
		assertEquals(new CharPosition1(4, 4), result.get(4).x1);
		assertEquals(new CharPosition1(5, 0), result.get(4).x2);
	}
}

// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}

// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {
		
	/**
	 * Test case 1.
	 * The block is empty.
	 */
	@Test
	void test1() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(0, result.size());
	}
	
	/**
	 * Test case 2.
	 * The block contains only one character.
	 */
	@Test
	void test2() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 1));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).y1);
		assertEquals(new CharPosition1(0, 1), result.get(0).y2);
	}
	
	/**
	 * Test case 3.
	 * The block contains two sequential characters.
	 */
	@Test
	void test3() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 2));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).y1);
		assertEquals(new CharPosition1(0, 2), result.get(0).y2);
	}
	
	/**
	 * Test case 4.
	 * The block contains two non-sequential characters.
	 */
	@Test
	void test4() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 2));
		block.add(new CharPosition1(1, 1));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).y1);
		assertEquals(new CharPosition1(0, 1), result.get(0).y2);
		assertEquals(new CharPosition1(1, 1), result.get(1).y1);
		assertEquals(new CharPosition1(0, 2), result.get(1).y2);
	}
	
	/**
	 * Test case 5.
	 * The block contains three sequential characters.
	 */
	@Test
	void test5() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 3));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).y1);
		assertEquals(new CharPosition1(0, 3), result.get(0).y2);
	}
	
	/**
	 * Test case 6.
	 * The block contains three non-sequential characters.
	 */
	@Test
	void test6() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 3));
		block.add(new CharPosition1(1, 1));
		block.add(new CharPosition1(2, 2));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).y1);
		assertEquals(new CharPosition1(0, 1), result.get(0).y2);
		assertEquals(new CharPosition1(1, 1), result.get(1).y1);
		assertEquals(new CharPosition1(0, 2), result.get(1).y2);
		assertEquals(new CharPosition1(2, 2), result.get(2).y1);
		assertEquals(new CharPosition1(0, 3), result.get(2).y2);
	}
	
	/**
	 * Test case 7.
	 * The block contains four sequential characters.
	 */
	@Test
	void test7() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 4));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).y1);
		assertEquals(new CharPosition1(0, 4), result.get(0).y2);
	}
	
	/**
	 * Test case 8.
	 * The block contains four non-sequential characters.
	 */
	@Test
	void test8() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 4));
		block.add(new CharPosition1(1, 1));
		block.add(new CharPosition1(2, 2));
		block.add(new CharPosition1(3, 3));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(4, result.size());
		assertEquals(new CharPosition1(0, 0), result.get(0).y1);
		assertEquals(new CharPosition1(0, 1), result.get(0).y2);
		assertEquals(new CharPosition1(1, 1), result.get(1).y1);
		assertEquals(new CharPosition1(0, 2), result.get(1).y2);
		assertEqu"
cmpl-6x0Cg1pASspN9D1alLTy8jIbIbXn1,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock1.java,129.42362189292908,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<HWordPosition> hLines = getIntersectingHLines();
        if (hLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(hLines);
        else
            return extractParallelSubblocksWithoutLines();
    }
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {

	/**
	 * Test case 1.
	 * <p>
	 * The block is empty.
	 * <p>
	 * The expected result is an empty list.
	 */
	@Test
	void testExtractParallelSubblocks1() {
		HorizontalBlock block = new HorizontalBlock();
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block contains one word.
	 * <p>
	 * The expected result is an empty list.
	 */
	@Test
	void testExtractParallelSubblocks2() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, ""word""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block contains two words.
	 * <p>
	 * The expected result is an empty list.
	 */
	@Test
	void testExtractParallelSubblocks3() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, ""word1""));
		block.add(new HWordPosition(0, 0, ""word2""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block contains three words.
	 * <p>
	 * The expected result is a list of two blocks.
	 */
	@Test
	void testExtractParallelSubblocks4() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, ""word1""));
		block.add(new HWordPosition(0, 0, ""word2""));
		block.add(new HWordPosition(0, 0, ""word3""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(1, subblocks.get(1).size());
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block contains four words.
	 * <p>
	 * The expected result is a list of three blocks.
	 */
	@Test
	void testExtractParallelSubblocks5() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, ""word1""));
		block.add(new HWordPosition(0, 0, ""word2""));
		block.add(new HWordPosition(0, 0, ""word3""));
		block.add(new HWordPosition(0, 0, ""word4""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(1, subblocks.get(1).size());
		assertEquals(1, subblocks.get(2).size());
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The block contains five words.
	 * <p>
	 * The expected result is a list of three blocks.
	 */
	@Test
	void testExtractParallelSubblocks6() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, ""word1""));
		block.add(new HWordPosition(0, 0, ""word2""));
		block.add(new HWordPosition(0, 0, ""word3""));
		block.add(new HWordPosition(0, 0, ""word4""));
		block.add(new HWordPosition(0, 0, ""word5""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(2, subblocks.get(1).size());
		assertEquals(1, subblocks.get(2).size());
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The block contains six words.
	 * <p>
	 * The expected result is a list of four blocks.
	 */
	@Test
	void testExtractParallelSubblocks7() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, ""word1""));
		block.add(new HWordPosition(0, 0, ""word2""));
		block.add(new HWordPosition(0, 0, ""word3""));
		block.add(new HWordPosition(0, 0, ""word4""));
		block.add(new HWordPosition(0, 0, ""word5""));
		block.add(new HWordPosition(0, 0, ""word6""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(2, subblocks.get(1).size());
		assertEquals(1, subblocks.get(2).size());
		assertEquals(1, subblocks.get(3).size());
	}
	
	/**
	 * Test case 8.
	 * <p>
	 * The block contains seven words.
	 * <p>
	 * The expected result is a list of four blocks.
	 */
	@Test
	void testExtractParallelSubblocks8() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, ""word1""));
		block.add(new HWordPosition(0, 0, ""word2""));
		block.add(new HWordPosition(0, 0, ""word3""));
		block.add(new HWordPosition(0, 0, ""word4""));
		block.add(new HWordPosition(0, 0, ""word5""));
		block.add(new HWordPosition(0, 0, ""word6""));
		block.add(new HWordPosition(0, 0, ""word7""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(2, subblocks.get(1).size());
		assertEquals(2, subblocks.get(2).size());
		assertEquals(1, subblocks.get(3).size());
	}
	
	/**
	 * Test case 9.
	 * <p>
	 * The block contains eight words.
	 * <p>
	 * The expected result is a list of five blocks.
	 */
	@Test
	void testExtractParallelSubblocks9() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, ""word1""));
		block.add(new HWordPosition(0, 0, ""word2""));
		block.add(new HWordPosition(0, 0, ""word3""));
		block.add(new HWordPosition(0, 0, ""word4""));
		block.add(new HWordPosition(0, 0, ""word5""));
		block.add(new HWordPosition(0, 0, ""word6""));
		block.add(new HWordPosition(0, 0, ""word7""));
		block.add(new HWordPosition(0, 0, ""word8""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(2, subblocks.get(1).size());
		assertEquals(2, subblocks.get(2).size());
		assertEquals(1, subblocks.get(3).size());
		assertEquals(1, subblocks.get(4).size());
	}
	
	/**
	 * Test case 10.
	 * <p>
	 * The block contains nine words.
	 * <p>
	 * The expected result is a list of five blocks.
	 */
	@Test
	void testExtractParallelSubblocks10() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, ""word1""));
		block.add(new HWordPosition(0, 0, ""word2""));
		block.add(new HWordPosition(0, 0, ""word3""));
		block.add(new HWordPosition(0, 0, ""word4""));
		block.add(new HWordPosition(0, 0, ""word5""));
		block.add(new HWordPosition(0, 0, ""word6""));
		block.add(new HWordPosition(0, 0, ""word7""));
		block.add(new HWordPosition(0, 0, ""word8""));
		block.add(new HWordPosition(0, 0, ""word9""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(2, subblocks.get(1).size());
		assertEquals(2, subblocks.get(2).size());
		assertEquals(2, subblocks.get(3).size());
		assertEquals(1, subblocks.get(4).size());
	}
}

// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }
}

// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {
		
	/**
	 * Test case 1.
	 * <p>
	 * The block is empty.
	 * <p>
	 * The expected result is an empty list.
	 */
	@Test
	void testExtractParallelSubblocks1() {
		VerticalBlock block = new VerticalBlock();
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block contains one word.
	 * <p>
	 * The expected result is an empty list.
	 */
	@Test
	void testExtractParallelSubblocks2() {
		VerticalBlock block = new VerticalBlock();
		block.add(new VWordPosition(0, 0, ""word""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block contains two words.
	 * <p>
	 * The expected result is an empty list.
	 */
	@Test
	void testExtractParallelSubblocks3() {
		VerticalBlock block = new VerticalBlock();
		block.add(new VWordPosition(0, 0, ""word1""));
		block.add(new VWordPosition(0, 0, ""word2""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block contains three words.
	 * <p>
	 * The expected result is a list of two blocks.
	 */
	@Test
	void testExtractParallelSubblocks4() {
		VerticalBlock block = new VerticalBlock();
		block.add(new VWordPosition(0, 0, ""word1""));
		block.add(new VWordPosition(0, 0, ""word2""));
		block.add(new VWordPosition(0, 0, ""word3""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(1, subblocks.get(1).size());
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block contains four words.
	 * <p>
	 * The expected result is a list of three blocks.
	 */
	@Test
	void testExtractParallelSubblocks5() {
		VerticalBlock block = new VerticalBlock();
		block.add(new VWordPosition(0, 0, ""word1""));
		block.add(new VWordPosition(0, 0, ""word2""));
		block.add(new VWordPosition(0, 0, ""word3""));
		block.add(new VWordPosition(0, 0, ""word4""));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(1, subblocks.get(1).size());
		assertEquals(1, subblocks.get(2).size());
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The block contains five words.
	 * <p>
	 * The expected result is a list of three blocks.
	 */
	@Test
	void testExtractParallelSubblocks6() {
		VerticalBlock block = new VerticalBlock();
		block.add(new VWordPosition(0, 0, ""word1""));
		block.add(new VWordPosition(0, 0, ""word2""));
		block.add(new VWordPosition(0, 0, ""word3""));
		block.add(new VWordPosition(0, 0, ""word4""));
		block.add(new VWordPosition(0, 0, ""word5""));
		List<Block> sub"
cmpl-6x0EltGNxO2I9VUAHznnP9fclaMM8,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock0.java,124.47128105163574,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        VerticalBlock firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {

	/**
	 * Test case 1.
	 * The block is empty.
	 */
	@Test
	void testExtractSequentialSubblocks1() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(0, result.size());
	}
	
	/**
	 * Test case 2.
	 * The block contains only one character.
	 */
	@Test
	void testExtractSequentialSubblocks2() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 1));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 1)), result.get(0));
	}
	
	/**
	 * Test case 3.
	 * The block contains two sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks3() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 2));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 2)), result.get(0));
	}
	
	/**
	 * Test case 4.
	 * The block contains two non-sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks4() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 2));
		block.add(new CharPosition1(0, 4));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(0, 4), new CharPosition1(0, 4)), result.get(1));
	}
	
	/**
	 * Test case 5.
	 * The block contains three sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks5() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 3));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 3)), result.get(0));
	}
	
	/**
	 * Test case 6.
	 * The block contains three non-sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks6() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 3));
		block.add(new CharPosition1(0, 5));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 3)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(0, 5), new CharPosition1(0, 5)), result.get(1));
	}
	
	/**
	 * Test case 7.
	 * The block contains four sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks7() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 4));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 4)), result.get(0));
	}
	
	/**
	 * Test case 8.
	 * The block contains four non-sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks8() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 4));
		block.add(new CharPosition1(0, 6));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 4)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(0, 6), new CharPosition1(0, 6)), result.get(1));
	}
	
	/**
	 * Test case 9.
	 * The block contains five sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks9() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 5));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 5)), result.get(0));
	}
	
	/**
	 * Test case 10.
	 * The block contains five non-sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks10() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 5));
		block.add(new CharPosition1(0, 7));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 5)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(0, 7), new CharPosition1(0, 7)), result.get(1));
	}
}

// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        HorizontalBlock firstBlock;
        HorizontalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}

// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {
		
	/**
	 * Test case 1.
	 * The block is empty.
	 */
	@Test
	void testExtractSequentialSubblocks1() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(0, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(0, result.size());
	}
	
	/**
	 * Test case 2.
	 * The block contains only one character.
	 */
	@Test
	void testExtractSequentialSubblocks2() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(1, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(1, 0)), result.get(0));
	}
	
	/**
	 * Test case 3.
	 * The block contains two sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks3() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(2, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(2, 0)), result.get(0));
	}
	
	/**
	 * Test case 4.
	 * The block contains two non-sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks4() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(2, 0));
		block.add(new CharPosition1(4, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(2, 0)), result.get(0));
		assertEquals(new HorizontalBlock(new CharPosition1(4, 0), new CharPosition1(4, 0)), result.get(1));
	}
	
	/**
	 * Test case 5.
	 * The block contains three sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks5() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(3, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(3, 0)), result.get(0));
	}
	
	/**
	 * Test case 6.
	 * The block contains three non-sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks6() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(3, 0));
		block.add(new CharPosition1(5, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(3, 0)), result.get(0));
		assertEquals(new HorizontalBlock(new CharPosition1(5, 0), new CharPosition1(5, 0)), result.get(1));
	}
	
	/**
	 * Test case 7.
	 * The block contains four sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks7() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(4, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(4, 0)), result.get(0));
	}
	
	/**
	 * Test case 8.
	 * The block contains four non-sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks8() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(4, 0));
		block.add(new CharPosition1(6, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(4, 0)), result.get(0));
		assertEquals(new HorizontalBlock(new CharPosition1(6, 0), new CharPosition1(6, 0)), result.get(1));
	}
	
	/**
	 * Test case 9.
	 * The block contains five sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks9() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(5, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(5, 0)), result.get(0));
	}
	
	/**
	 * Test case 10.
	 * The block contains five non-sequential characters.
	 */
	@Test
	void testExtractSequentialSubblocks10() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(5, 0));
		block.add(new CharPosition1(7, 0));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(5, 0)), result.get(0));
		assertEquals(new HorizontalBlock(new CharPosition1(7, 0), new CharPosition1(7, 0)), result.get(1));
	}
}

// Block.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An abstract class representing a block of characters.
 * A block is a set of characters with the same x-coordinate
 * or the same y-coordinate.
 */
public abstract class Block {

    /**
     * The first character of the block.
     */
    protected CharPosition1 first;

    /**
     * The last character of the block.
     */
    protected CharPosition1 last;

    /**
     * The x-coordinate of the first character of the block.
     */
    protected int x1;

    /**
     * The x-coordinate of the last character of the block.
     */
    protected int x2;

    /**
     * The y-coordinate of the first character of the block.
     */
    protected int y1;

    /**
     * The y-coordinate of the last character of the block.
     */
    protected int y2;

    /**
     * The set of characters of the block.
     */
    protected Set<CharPosition1> chars;

    /**
     * Constructs a block with the given first and last characters.
     *
     * @param first the first character of the block.
     * @param last the last character of the block.
     */
    public Block(CharPosition1 first, CharPosition1 last) {
        this.first = first;
        this.last = last;
        this.x1 = first.getX();
        this.x2 ="
cmpl-6x0Gm2MaIoAC2NwBqCtIuYs0ynwOT,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock1.java,171.76995658874512,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {

	/**
	 * Test case 1.
	 * <p>
	 * The block contains no words.
	 * <p>
	 * The block is trivial.
	 * <p>
	 * The block is not divided.
	 */
	@Test
	void testExtractParallelSubblocks1() {
		VerticalBlock block = new VerticalBlock();
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block contains one word.
	 * <p>
	 * The block is trivial.
	 * <p>
	 * The block is not divided.
	 */
	@Test
	void testExtractParallelSubblocks2() {
		VerticalBlock block = new VerticalBlock();
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block contains two words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into two subblocks.
	 */
	@Test
	void testExtractParallelSubblocks3() {
		VerticalBlock block = new VerticalBlock();
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block contains three words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks4() {
		VerticalBlock block = new VerticalBlock();
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block contains four words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into four subblocks.
	 */
	@Test
	void testExtractParallelSubblocks5() {
		VerticalBlock block = new VerticalBlock();
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The block contains five words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into five subblocks.
	 */
	@Test
	void testExtractParallelSubblocks6() {
		VerticalBlock block = new VerticalBlock();
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(5, subblocks.size());
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The block contains six words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into six subblocks.
	 */
	@Test
	void testExtractParallelSubblocks7() {
		VerticalBlock block = new VerticalBlock();
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(6, subblocks.size());
	}
	
	/**
	 * Test case 8.
	 * <p>
	 * The block contains seven words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into seven subblocks.
	 */
	@Test
	void testExtractParallelSubblocks8() {
		VerticalBlock block = new VerticalBlock();
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(7, subblocks.size());
	}
	
	/**
	 * Test case 9.
	 * <p>
	 * The block contains eight words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into eight subblocks.
	 */
	@Test
	void testExtractParallelSubblocks9() {
		VerticalBlock block = new VerticalBlock();
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(8, subblocks.size());
	}
	
	/**
	 * Test case 10.
	 * <p>
	 * The block contains nine words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into nine subblocks.
	 */
	@Test
	void testExtractParallelSubblocks10() {
		VerticalBlock block = new VerticalBlock();
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(9, subblocks.size());
	}
}

// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<HWordPosition> hLines = getIntersectingHLines();
        if (hLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(hLines);
        else
            return extractParallelSubblocksWithoutLines();
    }
}

// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {
		
	/**
	 * Test case 1.
	 * <p>
	 * The block contains no words.
	 * <p>
	 * The block is trivial.
	 * <p>
	 * The block is not divided.
	 */
	@Test
	void testExtractParallelSubblocks1() {
		HorizontalBlock block = new HorizontalBlock();
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block contains one word.
	 * <p>
	 * The block is trivial.
	 * <p>
	 * The block is not divided.
	 */
	@Test
	void testExtractParallelSubblocks2() {
		HorizontalBlock block = new HorizontalBlock();
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block contains two words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into two subblocks.
	 */
	@Test
	void testExtractParallelSubblocks3() {
		HorizontalBlock block = new HorizontalBlock();
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block contains three words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks4() {
		HorizontalBlock block = new HorizontalBlock();
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block contains four words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into four subblocks.
	 */
	@Test
	void testExtractParallelSubblocks5() {
		HorizontalBlock block = new HorizontalBlock();
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		block.addWord(new HWordPosition(0, 0, 0, 0, 0, 0, 0, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The block contains five words.
	 * <p>
	 * The block is not trivial.
	 * <p>
	 * The block is divided into five subblocks.
	 */
	@Test
	void testExtractParallelSubblocks6() {
		HorizontalBlock block = new HorizontalBlock();
		block."
cmpl-6x0JYKVhp8LCI26uJTZ5GBFdUf7BF,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/positions/HWordPosition.java,115.53224015235901,length,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {

	/**
	 * Test case 1.
	 * The text at the position is empty.
	 */
	@Test
	void testTextAt1() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(0, 0, 0);
		assertEquals("""", pos.textAt(ct));
	}

	/**
	 * Test case 2.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt2() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(0, 0, 2);
		assertEquals(""AB"", pos.textAt(ct));
	}

	/**
	 * Test case 3.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt3() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(1, 0, 2);
		assertEquals(""DE"", pos.textAt(ct));
	}

	/**
	 * Test case 4.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt4() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(2, 0, 2);
		assertEquals(""GH"", pos.textAt(ct));
	}

	/**
	 * Test case 5.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt5() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(0, 1, 2);
		assertEquals(""BC"", pos.textAt(ct));
	}

	/**
	 * Test case 6.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt6() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(1, 1, 2);
		assertEquals(""EF"", pos.textAt(ct));
	}

	/**
	 * Test case 7.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt7() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(2, 1, 2);
		assertEquals(""HI"", pos.textAt(ct));
	}

	/**
	 * Test case 8.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt8() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(0, 2, 2);
		assertEquals(""CD"", pos.textAt(ct));
	}

	/**
	 * Test case 9.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt9() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(1, 2, 2);
		assertEquals(""FG"", pos.textAt(ct));
	}

	/**
	 * Test case 10.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt10() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		HWordPosition pos = new HWordPosition(2, 2, 2);
		assertEquals(""IJ"", pos.textAt(ct));
	}
}

// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}

// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {
		
	/**
	 * Test case 1.
	 * The text at the position is empty.
	 */
	@Test
	void testTextAt1() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(0, 0, 0);
		assertEquals("""", pos.textAt(ct));
	}

	/**
	 * Test case 2.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt2() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(0, 0, 2);
		assertEquals(""AD"", pos.textAt(ct));
	}

	/**
	 * Test case 3.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt3() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(1, 0, 2);
		assertEquals(""AE"", pos.textAt(ct));
	}

	/**
	 * Test case 4.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt4() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(2, 0, 2);
		assertEquals(""AF"", pos.textAt(ct));
	}

	/**
	 * Test case 5.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt5() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(0, 1, 2);
		assertEquals(""BD"", pos.textAt(ct));
	}

	/**
	 * Test case 6.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt6() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(1, 1, 2);
		assertEquals(""BE"", pos.textAt(ct));
	}

	/**
	 * Test case 7.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt7() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(2, 1, 2);
		assertEquals(""BF"", pos.textAt(ct));
	}

	/**
	 * Test case 8.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt8() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(0, 2, 2);
		assertEquals(""CD"", pos.textAt(ct));
	}

	/**
	 * Test case 9.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt9() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(1, 2, 2);
		assertEquals(""CE"", pos.textAt(ct));
	}

	/**
	 * Test case 10.
	 * The text at the position is not empty.
	 */
	@Test
	void testTextAt10() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(2, 2, 2);
		assertEquals(""CF"", pos.textAt(ct));
	}
}

// CharTable.java
package glengineer.blocks;

import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;

/**
 * Represents a table of characters.
 *
 * The table is represented as a two-dimensional array of blocks.
 * Each block contains a character.
 */
public class CharTable {

    /**
     * The two-dimensional array of blocks.
     */
    private Block[][] blocks;

    /**
     * Constructs a char table from the specified two-dimensional array of blocks.
     *
     * @param blocks the two-dimensional array of blocks.
     */
    public CharTable(Block[][] blocks) {
        this.blocks = blocks;
    }

    /**
     * Returns the text at the specified position on this char table.
     *
     * The call is dispatched to the specified word position
     * informing it about the concrete char table type.
     *
     * @param pos the position at which the text must be read.
     * @return the text at the specified position on this char table.
     */
    public String textAt(WordPosition pos) {
        return pos.textAt(this);
    }

    /**
     * Returns the text at the specified horizontal position on this char table.
     *
     * @param pos the horizontal position at which the text must be read.
     * @return the text at the specified horizontal position on this char table.
     */
    public String textAt(HWordPosition pos) {
        StringBuilder sb = new StringBuilder();
        for (int i = pos.getStart(); i <= pos.getEnd(); i++) {
            sb.append(blocks[pos.getRow()][i].getChar());
        }
        return sb.toString();
    }

    /**
     * Returns the text at the specified vertical position on this char table.
     *
     *"
cmpl-6x0LPEr54oL2ZdIOnY4W3v9yybVeT,/EvoSuiteBenchmark/scenario2/40_glengineer/src/main/java/glengineer/positions/VWordPosition.java,139.4473705291748,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {

	/**
	 * Test case 1.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt1() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(0, 0, 2);
		assertEquals(""ADG"", pos.textAt(ct));
	}
	
	/**
	 * Test case 2.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt2() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(1, 0, 2);
		assertEquals(""BEH"", pos.textAt(ct));
	}
	
	/**
	 * Test case 3.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt3() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(2, 0, 2);
		assertEquals(""CFI"", pos.textAt(ct));
	}
	
	/**
	 * Test case 4.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt4() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(0, 1, 2);
		assertEquals(""AEH"", pos.textAt(ct));
	}
	
	/**
	 * Test case 5.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt5() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(1, 1, 2);
		assertEquals(""BF"", pos.textAt(ct));
	}
	
	/**
	 * Test case 6.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt6() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(2, 1, 2);
		assertEquals(""CG"", pos.textAt(ct));
	}
	
	/**
	 * Test case 7.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt7() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(0, 2, 2);
		assertEquals(""AFI"", pos.textAt(ct));
	}
	
	/**
	 * Test case 8.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt8() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(1, 2, 2);
		assertEquals(""BGI"", pos.textAt(ct));
	}
	
	/**
	 * Test case 9.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt9() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(2, 2, 2);
		assertEquals(""CH"", pos.textAt(ct));
	}
	
	/**
	 * Test case 10.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt10() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		VWordPosition pos = new VWordPosition(0, 0, 1);
		assertEquals(""A"", pos.textAt(ct));
	}
}

// WordPosition.java
package glengineer.positions;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying on the scheme.
 */
public abstract class WordPosition {

    /**
     * The start column of the word.
     */
    public final int startCol;

    /**
     * The start row of the word.
     */
    public final int startRow;

    /**
     * The end column of the word.
     */
    public final int endCol;

    /**
     * The end row of the word.
     */
    public final int endRow;

    /**
     * Constructs a new word position.
     *
     * @param startCol the start column of the word.
     * @param startRow the start row of the word.
     * @param endCol the end column of the word.
     * @param endRow the end row of the word.
     */
    public WordPosition(int startCol, int startRow, int endCol, int endRow) {
        this.startCol = startCol;
        this.startRow = startRow;
        this.endCol = endCol;
        this.endRow = endRow;
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public abstract String textAt(CharTable ct);
}

// WordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPosition}.
* It contains ten unit test cases for the {@link WordPosition#textAt(CharTable)} method.
*/
class WordPositionTest {
		
	/**
	 * Test case 1.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt1() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(0, 0, 2);
		assertEquals(""ABC"", pos.textAt(ct));
	}
	
	/**
	 * Test case 2.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt2() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(1, 0, 2);
		assertEquals(""DEF"", pos.textAt(ct));
	}
	
	/**
	 * Test case 3.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt3() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(2, 0, 2);
		assertEquals(""GHI"", pos.textAt(ct));
	}
	
	/**
	 * Test case 4.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt4() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(0, 1, 2);
		assertEquals(""ADG"", pos.textAt(ct));
	}
	
	/**
	 * Test case 5.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt5() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(1, 1, 2);
		assertEquals(""BEH"", pos.textAt(ct));
	}
	
	/**
	 * Test case 6.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt6() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(2, 1, 2);
		assertEquals(""CFI"", pos.textAt(ct));
	}
	
	/**
	 * Test case 7.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt7() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(0, 2, 2);
		assertEquals(""AEI"", pos.textAt(ct));
	}
	
	/**
	 * Test case 8.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt8() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(1, 2, 2);
		assertEquals(""BFI"", pos.textAt(ct));
	}
	
	/**
	 * Test case 9.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt9() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(2, 2, 2);
		assertEquals(""CHI"", pos.textAt(ct));
	}
	
	/**
	 * Test case 10.
	 * The text at the position is read from the char table.
	 */
	@Test
	void testTextAt10() {
		CharTable ct = new CharTable(new Block[][] {
			{ new Block('A'), new Block('B'), new Block('C') },
			{ new Block('D'), new Block('E'), new Block('F') },
			{ new Block('G'), new Block('H'), new Block('I') }
		});
		WordPosition pos = new HWordPosition(0, 0, 1);
		assertEquals(""A"", pos.textAt(ct));
	}
}

// WordSearch.java
package glengineer;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Encapsulates the word search scheme.
 */
public class WordSearch {

    /**
     * The char table of the word search scheme.
     */
    private final CharTable charTable;

    /**
     * The list of words to be found on the scheme.
     */
"
