ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6xFBIbC1QJVz4ZQOfah3iIbnacae2,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/io/DefaultHomeInputStream.java,89.800283908844,length,"// DefaultHomeInputStream.java
package com.eteks.sweethome3d.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.ObjectInputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.URLContent;

/**
 * An <code>InputStream</code> filter that reads a home from a stream
 * at .sh3d file format.
 *
 * @see DefaultHomeOutputStream
 */
public class DefaultHomeInputStream extends FilterInputStream {

    private final ContentRecording contentRecording;

    private File tempFile;

    /**
     * Creates a home input stream filter able to read a home and its content
     * from <code>in</code>.
     */
    public DefaultHomeInputStream(InputStream in) throws IOException {
    }

    /**
     * Creates a home input stream filter able to read a home and its content
     * from <code>in</code>.
     */
    public DefaultHomeInputStream(InputStream in, ContentRecording contentRecording) throws IOException {
    }

    /**
     * Throws an <code>InterruptedRecorderException</code> exception
     * if current thread is interrupted. The interrupted status of the current thread
     * is cleared when an exception is thrown.
     */
    private static void checkCurrentThreadIsntInterrupted() throws InterruptedIOException;

    /**
     * Reads home from a zipped stream.
     */
    public Home readHome() throws IOException, ClassNotFoundException;

    /**
     * <code>ObjectInputStream</code> that replaces temporary <code>URLContent</code>
     * objects by <code>URLContent</code> objects that points to file.
     */
    private class HomeObjectInputStream extends ObjectInputStream {

        public HomeObjectInputStream(InputStream in) throws IOException {
            super(in);
            if (contentRecording != ContentRecording.INCLUDE_NO_CONTENT) {
                enableResolveObject(true);
            }
        }

        @Override
        protected Object resolveObject(Object obj) throws IOException {
            if (obj instanceof URLContent) {
                URL tmpURL = ((URLContent) obj).getURL();
                String url = tmpURL.toString();
                if (url.startsWith(""jar:file:temp!/"")) {
                    // Replace ""temp"" in URL by current temporary file
                    String entryName = url.substring(url.indexOf('!') + 2);
                    URL fileURL = new URL(""jar:file:"" + tempFile.toString() + ""!/"" + entryName);
                    try {
                        // Check entry exists
                        fileURL.openStream().close();
                    } catch (IOException ex) {
                        throw new IOException(""Missing entry \"""" + entryName + ""\"""");
                    }
                    return new HomeURLContent(fileURL);
                } else {
                    return obj;
                }
            } else {
                return obj;
            }
        }
    }
}
","// DefaultHomeInputStreamTest.java
package com.eteks.sweethome3d.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.ObjectInputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultHomeInputStream}.
* It contains ten unit test cases for the {@link DefaultHomeInputStream#readHome()} method.
*/
class DefaultHomeInputStreamTest {","// DefaultHomeInputStreamTest.java
package com.eteks.sweethome3d.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.ObjectInputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultHomeInputStream}.
* It contains ten unit test cases for the {@link DefaultHomeInputStream#readHome()} method.
*/
class DefaultHomeInputStreamTest {

		@Test
		public void testReadHome() throws IOException, ClassNotFoundException {
				// Create a home with a wall and a piece of furniture
				Home home = new Home();
				home.addWall(new Wall(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"
06133156-a237-4db5-95a9-d29151661a24,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/io/FileUserPreferences_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9540 tokens (5540 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// FileUserPreferences.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;

/**
 * User preferences initialized from
 * {@link com.eteks.sweethome3d.io.DefaultUserPreferences default user preferences}
 * and stored in user preferences on local file system.
 *
 * @author Emmanuel Puybaret
 */
public class FileUserPreferences extends UserPreferences {

    private static final String LANGUAGE = ""language"";

    private static final String UNIT = ""unit"";

    private static final String FURNITURE_CATALOG_VIEWED_IN_TREE = ""furnitureCatalogViewedInTree"";

    private static final String NAVIGATION_PANEL_VISIBLE = ""navigationPanelVisible"";

    private static final String MAGNETISM_ENABLED = ""magnetismEnabled"";

    private static final String RULERS_VISIBLE = ""rulersVisible"";

    private static final String GRID_VISIBLE = ""gridVisible"";

    private static final String FURNITURE_VIEWED_FROM_TOP = ""furnitureViewedFromTop"";

    private static final String ROOM_FLOOR_COLORED_OR_TEXTURED = ""roomFloorColoredOrTextured"";

    private static final String WALL_PATTERN = ""wallPattern"";

    private static final String NEW_WALL_HEIGHT = ""newHomeWallHeight"";

    private static final String NEW_WALL_THICKNESS = ""newWallThickness"";

    private static final String NEW_FLOOR_THICKNESS = ""newFloorThickness"";

    private static final String AUTO_SAVE_DELAY_FOR_RECOVERY = ""autoSaveDelayForRecovery"";

    private static final String AUTO_COMPLETION_PROPERTY = ""autoCompletionProperty#"";

    private static final String AUTO_COMPLETION_STRINGS = ""autoCompletionStrings#"";

    private static final String RECENT_HOMES = ""recentHomes#"";

    private static final String IGNORED_ACTION_TIP = ""ignoredActionTip#"";

    private static final String FURNITURE_NAME = ""furnitureName#"";

    private static final String FURNITURE_CATEGORY = ""furnitureCategory#"";

    private static final String FURNITURE_ICON = ""furnitureIcon#"";

    private static final String FURNITURE_MODEL = ""furnitureModel#"";

    private static final String FURNITURE_WIDTH = ""furnitureWidth#"";

    private static final String FURNITURE_DEPTH = ""furnitureDepth#"";

    private static final String FURNITURE_HEIGHT = ""furnitureHeight#"";

    private static final String FURNITURE_MOVABLE = ""furnitureMovable#"";

    private static final String FURNITURE_DOOR_OR_WINDOW = ""furnitureDoorOrWindow#"";

    private static final String FURNITURE_ELEVATION = ""furnitureElevation#"";

    private static final String FURNITURE_COLOR = ""furnitureColor#"";

    private static final String FURNITURE_MODEL_ROTATION = ""furnitureModelRotation#"";

    private static final String FURNITURE_STAIRCASE_CUT_OUT_SHAPE = ""furnitureStaircaseCutOutShape#"";

    private static final String FURNITURE_BACK_FACE_SHOWN = ""furnitureBackFaceShown#"";

    private static final String FURNITURE_ICON_YAW = ""furnitureIconYaw#"";

    private static final String FURNITURE_PROPORTIONAL = ""furnitureProportional#"";

    private static final String TEXTURE_NAME = ""textureName#"";

    private static final String TEXTURE_CATEGORY = ""textureCategory#"";

    private static final String TEXTURE_IMAGE = ""textureImage#"";

    private static final String TEXTURE_WIDTH = ""textureWidth#"";

    private static final String TEXTURE_HEIGHT = ""textureHeight#"";

    private static final String FURNITURE_CONTENT_PREFIX = ""Furniture-3-"";

    private static final String TEXTURE_CONTENT_PREFIX = ""Texture-3-"";

    private static final String LANGUAGE_LIBRARIES_PLUGIN_SUB_FOLDER = ""languages"";

    private static final String FURNITURE_LIBRARIES_PLUGIN_SUB_FOLDER = ""furniture"";

    private static final String TEXTURES_LIBRARIES_PLUGIN_SUB_FOLDER = ""textures"";

    private static final Content DUMMY_CONTENT;

    private final Map<String, Boolean> ignoredActionTips = new HashMap<String, Boolean>();

    private List<ClassLoader> resourceClassLoaders;

    private final File preferencesFolder;

    private final File[] applicationFolders;

    private Preferences preferences;

    private Executor catalogsLoader;

    private Executor updater;

    static {
    }

    /**
     * Creates user preferences read from user preferences in file system,
     * and from resource files.
     */
    public FileUserPreferences() {
    }

    /**
     * Creates user preferences stored in the folders given in parameter.
     * @param preferencesFolder the folder where preferences files are stored
     *    or <code>null</code> if this folder is the default one.
     * @param applicationFolders the folders where application private files are stored
     *    or <code>null</code> if it's the default one. As the first application folder
     *    is used as the folder where plug-ins files are imported by the user, it should
     *    have write access otherwise the user won't be able to import them.
     */
    public FileUserPreferences(File preferencesFolder, File[] applicationFolders) {
    }

    /**
     * Creates user preferences stored in the folders given in parameter.
     * @param preferencesFolder the folder where preferences files are stored
     *    or <code>null</code> if this folder is the default one.
     * @param applicationFolders  the folders where application private files are stored
     *    or <code>null</code> if it's the default one. As the first application folder
     *    is used as the folder where plug-ins files are imported by the user, it should
     *    have write access otherwise the user won't be able to import them.
     * @param updater  an executor that will be used to update user preferences for lengthy
     *    operations. If <code>null</code>, then these operations and
     *    updates will be executed in the current thread.
     */
    public FileUserPreferences(File preferencesFolder, File[] applicationFolders, Executor updater) {
    }

    /**
     * Updates the default supported languages with languages available in plugin folder.
     */
    private void updateSupportedLanguages();

    /**
     * Returns the languages included in the given language library file.
     */
    private Set<String> getLanguages(File languageLibraryFile) throws IOException;

    /**
     * Returns the default class loader of user preferences and the class loaders that
     * give access to resources in language libraries plugin folder.
     */
    @Override
    public List<ClassLoader> getResourceClassLoaders();

    /**
     * Reloads furniture default catalogs.
     */
    private void updateFurnitureDefaultCatalog(Executor furnitureCatalogLoader, final Executor updater);

    /**
     * Reloads textures default catalog.
     */
    private void updateTexturesDefaultCatalog(Executor texturesCatalogLoader, final Executor updater);

    /**
     * Adds to auto completion strings the default strings of the new chosen language.
     */
    private void updateAutoCompletionStrings();

    /**
     * Read modifiable furniture catalog from preferences.
     */
    private void readModifiableFurnitureCatalog(Preferences preferences);

    /**
     * Returns model rotation parsed from key value.
     */
    private float[][] getModelRotation(Preferences preferences, String key);

    /**
     * Returns a content instance from the resource file value of key.
     */
    private Content getContent(Preferences preferences, String key);

    /**
     * Read modifiable textures catalog from preferences.
     */
    private void readModifiableTexturesCatalog(Preferences preferences);

    /**
     * Writes user preferences in current user preferences in system.
     */
    @Override
    public void write() throws RecorderException;

    /**
     * Writes modifiable furniture in <code>preferences</code>.
     */
    private void writeModifiableFurnitureCatalog(Preferences preferences) throws RecorderException;

    /**
     * Returns the string value of the given float, except for -1.0, 1.0 or 0.0 where -1, 1 and 0 is returned.
     */
    private String floatToString(float f);

    /**
     * Writes modifiable textures catalog in <code>preferences</code>.
     */
    private void writeModifiableTexturesCatalog(Preferences preferences) throws RecorderException;

    /**
     * Writes <code>key</code> <code>content</code> in <code>preferences</code>.
     */
    private void putContent(Preferences preferences, String key, Content content, String contentPrefix, Set<URL> furnitureContentURLs) throws RecorderException;

    /**
     * Returns a content object that references a copy of <code>content</code> in
     * user preferences folder.
     */
    private URLContent copyToPreferencesURLContent(Content content, String contentPrefix) throws RecorderException;

    /**
     * Returns the folder where language libraries files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getLanguageLibrariesPluginFolders();

    /**
     * Returns the folder where furniture catalog files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getFurnitureLibrariesPluginFolders();

    /**
     * Returns the folder where texture catalog files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getTexturesLibrariesPluginFolders();

    /**
     * Returns the first Sweet Home 3D application folder.
     */
    public File getApplicationFolder() throws IOException;

    /**
     * Returns Sweet Home 3D application folders.
     */
    public File[] getApplicationFolders() throws IOException;

    /**
     * Returns subfolders of Sweet Home 3D application folders of a given name.
     */
    public File[] getApplicationSubfolders(String subfolder) throws IOException;

    /**
     * Returns a new file in user preferences folder.
     */
    private File createPreferencesFile(String filePrefix) throws IOException;

    /**
     * Creates preferences folder and its sub folders if it doesn't exist.
     */
    private void checkPreferencesFolder() throws IOException;

    /**
     * Creates the first folder in the given folders.
     */
    private void checkPreferencesSubFolder(File[] librariesPluginFolders);

    /**
     * Deletes from application folder the content files starting by <code>contentPrefix</code>
     * that don't belong to <code>contentURLs</code>.
     */
    private void deleteObsoleteContent(final Set<URL> contentURLs, final String contentPrefix) throws RecorderException;

    /**
     * Returns the folder where files depending on preferences are stored.
     */
    private File getPreferencesFolder() throws IOException;

    /**
     * Returns default Java preferences for current system user.
     * Caution : This method is called once in constructor so overriding implementations
     * shouldn't be based on the state of their fields.
     */
    protected Preferences getPreferences();

    /**
     * Sets which action tip should be ignored.
     */
    @Override
    public void setActionTipIgnored(String actionKey);

    /**
     * Returns whether an action tip should be ignored or not.
     */
    @Override
    public boolean isActionTipIgnored(String actionKey);

    /**
     * Resets the display flag of action tips.
     */
    @Override
    public void resetIgnoredActionTips();

    /**
     * Returns <code>true</code> if the given language library exists in the first
     * language libraries folder.
     */
    public boolean languageLibraryExists(String name) throws RecorderException;

    /**
     * Adds <code>languageLibraryName</code> to the first language libraries folder
     * to make the language library it contains available to supported languages.
     */
    public void addLanguageLibrary(String languageLibraryName) throws RecorderException;

    /**
     * Returns <code>true</code> if the given furniture library file exists in the first
     * furniture libraries folder.
     * @param name the name of the resource to check
     */
    @Override
    public boolean furnitureLibraryExists(String name) throws RecorderException;

    /**
     * Adds the file <code>furnitureLibraryName</code> to the first furniture libraries folder
     * to make the furniture library available to catalog.
     */
    @Override
    public void addFurnitureLibrary(String furnitureLibraryName) throws RecorderException;

    /**
     * Returns <code>true</code> if the given textures library file exists in the first textures libraries folder.
     * @param name the name of the resource to check
     */
    @Override
    public boolean texturesLibraryExists(String name) throws RecorderException;

    /**
     * Adds the file <code>texturesLibraryName</code> to the first textures libraries folder
     * to make the textures library available to catalog.
     */
    @Override
    public void addTexturesLibrary(String texturesLibraryName) throws RecorderException;

    /**
     * Copies a library file to a folder.
     */
    private void copyToLibraryFolder(File libraryFile, File folder) throws IOException;

    /**
     * Preferences based on the <code>preferences.xml</code> file
     * stored in a preferences folder.
     * @author Emmanuel Puybaret
     */
    private class PortablePreferences extends AbstractPreferences {

        private static final String PREFERENCES_FILE = ""preferences.xml"";

        private Properties preferencesProperties;

        private boolean exist;

        private PortablePreferences() {
            super(null, """");
            this.preferencesProperties = new Properties();
            this.exist = readPreferences();
        }

        public boolean exist() {
            return this.exist;
        }

        @Override
        protected void syncSpi() throws BackingStoreException {
            this.preferencesProperties.clear();
            this.exist = readPreferences();
        }

        @Override
        protected void removeSpi(String key) {
            this.preferencesProperties.remove(key);
        }

        @Override
        protected void putSpi(String key, String value) {
            this.preferencesProperties.put(key, value);
        }

        @Override
        protected String[] keysSpi() throws BackingStoreException {
            return this.preferencesProperties.keySet().toArray(new String[0]);
        }

        @Override
        protected String getSpi(String key) {
            return (String) this.preferencesProperties.get(key);
        }

        @Override
        protected void flushSpi() throws BackingStoreException {
            try {
                writePreferences();
            } catch (IOException ex) {
                throw new BackingStoreException(ex);
            }
        }

        @Override
        protected void removeNodeSpi() throws BackingStoreException {
            throw new UnsupportedOperationException();
        }

        @Override
        protected String[] childrenNamesSpi() throws BackingStoreException {
            throw new UnsupportedOperationException();
        }

        @Override
        protected AbstractPreferences childSpi(String name) {
            throw new UnsupportedOperationException();
        }

        /**
         * Reads user preferences.
         */
        private boolean readPreferences() {
            InputStream in = null;
            try {
                in = new FileInputStream(new File(getPreferencesFolder(), PREFERENCES_FILE));
                this.preferencesProperties.loadFromXML(in);
                return true;
            } catch (IOException ex) {
                // Preferences don't exist
                return false;
            } finally {
                try {
                    if (in != null) {
                        in.close();
                    }
                } catch (IOException ex) {
                    // Let default preferences unchanged
                }
            }
        }

        /**
         * Writes user preferences.
         */
        private void writePreferences() throws IOException {
            OutputStream out = null;
            try {
                checkPreferencesFolder();
                out = new FileOutputStream(new File(getPreferencesFolder(), PREFERENCES_FILE));
                this.preferencesProperties.storeToXML(out, ""Portable user preferences 3.0"");
            } finally {
                if (out != null) {
                    out.close();
                    this.exist = true;
                }
            }
        }
    }
}
","// FileUserPreferences_0Test.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileUserPreferences}.
* It contains ten unit test cases for the {@link FileUserPreferences#furnitureLibraryExists(String)} method.
*/
class FileUserPreferences_0Test {","// FileUserPreferences_0Test.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileUserPreferences}.
* It contains ten unit test cases for the {@link FileUserPreferences#furnitureLibraryExists(String)} method.
*/
class FileUserPreferences_0Test {
"
a04af66c-aabf-42da-aeeb-798236b443e7,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/io/FileUserPreferences_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9539 tokens (5539 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// FileUserPreferences.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;

/**
 * User preferences initialized from
 * {@link com.eteks.sweethome3d.io.DefaultUserPreferences default user preferences}
 * and stored in user preferences on local file system.
 *
 * @author Emmanuel Puybaret
 */
public class FileUserPreferences extends UserPreferences {

    private static final String LANGUAGE = ""language"";

    private static final String UNIT = ""unit"";

    private static final String FURNITURE_CATALOG_VIEWED_IN_TREE = ""furnitureCatalogViewedInTree"";

    private static final String NAVIGATION_PANEL_VISIBLE = ""navigationPanelVisible"";

    private static final String MAGNETISM_ENABLED = ""magnetismEnabled"";

    private static final String RULERS_VISIBLE = ""rulersVisible"";

    private static final String GRID_VISIBLE = ""gridVisible"";

    private static final String FURNITURE_VIEWED_FROM_TOP = ""furnitureViewedFromTop"";

    private static final String ROOM_FLOOR_COLORED_OR_TEXTURED = ""roomFloorColoredOrTextured"";

    private static final String WALL_PATTERN = ""wallPattern"";

    private static final String NEW_WALL_HEIGHT = ""newHomeWallHeight"";

    private static final String NEW_WALL_THICKNESS = ""newWallThickness"";

    private static final String NEW_FLOOR_THICKNESS = ""newFloorThickness"";

    private static final String AUTO_SAVE_DELAY_FOR_RECOVERY = ""autoSaveDelayForRecovery"";

    private static final String AUTO_COMPLETION_PROPERTY = ""autoCompletionProperty#"";

    private static final String AUTO_COMPLETION_STRINGS = ""autoCompletionStrings#"";

    private static final String RECENT_HOMES = ""recentHomes#"";

    private static final String IGNORED_ACTION_TIP = ""ignoredActionTip#"";

    private static final String FURNITURE_NAME = ""furnitureName#"";

    private static final String FURNITURE_CATEGORY = ""furnitureCategory#"";

    private static final String FURNITURE_ICON = ""furnitureIcon#"";

    private static final String FURNITURE_MODEL = ""furnitureModel#"";

    private static final String FURNITURE_WIDTH = ""furnitureWidth#"";

    private static final String FURNITURE_DEPTH = ""furnitureDepth#"";

    private static final String FURNITURE_HEIGHT = ""furnitureHeight#"";

    private static final String FURNITURE_MOVABLE = ""furnitureMovable#"";

    private static final String FURNITURE_DOOR_OR_WINDOW = ""furnitureDoorOrWindow#"";

    private static final String FURNITURE_ELEVATION = ""furnitureElevation#"";

    private static final String FURNITURE_COLOR = ""furnitureColor#"";

    private static final String FURNITURE_MODEL_ROTATION = ""furnitureModelRotation#"";

    private static final String FURNITURE_STAIRCASE_CUT_OUT_SHAPE = ""furnitureStaircaseCutOutShape#"";

    private static final String FURNITURE_BACK_FACE_SHOWN = ""furnitureBackFaceShown#"";

    private static final String FURNITURE_ICON_YAW = ""furnitureIconYaw#"";

    private static final String FURNITURE_PROPORTIONAL = ""furnitureProportional#"";

    private static final String TEXTURE_NAME = ""textureName#"";

    private static final String TEXTURE_CATEGORY = ""textureCategory#"";

    private static final String TEXTURE_IMAGE = ""textureImage#"";

    private static final String TEXTURE_WIDTH = ""textureWidth#"";

    private static final String TEXTURE_HEIGHT = ""textureHeight#"";

    private static final String FURNITURE_CONTENT_PREFIX = ""Furniture-3-"";

    private static final String TEXTURE_CONTENT_PREFIX = ""Texture-3-"";

    private static final String LANGUAGE_LIBRARIES_PLUGIN_SUB_FOLDER = ""languages"";

    private static final String FURNITURE_LIBRARIES_PLUGIN_SUB_FOLDER = ""furniture"";

    private static final String TEXTURES_LIBRARIES_PLUGIN_SUB_FOLDER = ""textures"";

    private static final Content DUMMY_CONTENT;

    private final Map<String, Boolean> ignoredActionTips = new HashMap<String, Boolean>();

    private List<ClassLoader> resourceClassLoaders;

    private final File preferencesFolder;

    private final File[] applicationFolders;

    private Preferences preferences;

    private Executor catalogsLoader;

    private Executor updater;

    static {
    }

    /**
     * Creates user preferences read from user preferences in file system,
     * and from resource files.
     */
    public FileUserPreferences() {
    }

    /**
     * Creates user preferences stored in the folders given in parameter.
     * @param preferencesFolder the folder where preferences files are stored
     *    or <code>null</code> if this folder is the default one.
     * @param applicationFolders the folders where application private files are stored
     *    or <code>null</code> if it's the default one. As the first application folder
     *    is used as the folder where plug-ins files are imported by the user, it should
     *    have write access otherwise the user won't be able to import them.
     */
    public FileUserPreferences(File preferencesFolder, File[] applicationFolders) {
    }

    /**
     * Creates user preferences stored in the folders given in parameter.
     * @param preferencesFolder the folder where preferences files are stored
     *    or <code>null</code> if this folder is the default one.
     * @param applicationFolders  the folders where application private files are stored
     *    or <code>null</code> if it's the default one. As the first application folder
     *    is used as the folder where plug-ins files are imported by the user, it should
     *    have write access otherwise the user won't be able to import them.
     * @param updater  an executor that will be used to update user preferences for lengthy
     *    operations. If <code>null</code>, then these operations and
     *    updates will be executed in the current thread.
     */
    public FileUserPreferences(File preferencesFolder, File[] applicationFolders, Executor updater) {
    }

    /**
     * Updates the default supported languages with languages available in plugin folder.
     */
    private void updateSupportedLanguages();

    /**
     * Returns the languages included in the given language library file.
     */
    private Set<String> getLanguages(File languageLibraryFile) throws IOException;

    /**
     * Returns the default class loader of user preferences and the class loaders that
     * give access to resources in language libraries plugin folder.
     */
    @Override
    public List<ClassLoader> getResourceClassLoaders();

    /**
     * Reloads furniture default catalogs.
     */
    private void updateFurnitureDefaultCatalog(Executor furnitureCatalogLoader, final Executor updater);

    /**
     * Reloads textures default catalog.
     */
    private void updateTexturesDefaultCatalog(Executor texturesCatalogLoader, final Executor updater);

    /**
     * Adds to auto completion strings the default strings of the new chosen language.
     */
    private void updateAutoCompletionStrings();

    /**
     * Read modifiable furniture catalog from preferences.
     */
    private void readModifiableFurnitureCatalog(Preferences preferences);

    /**
     * Returns model rotation parsed from key value.
     */
    private float[][] getModelRotation(Preferences preferences, String key);

    /**
     * Returns a content instance from the resource file value of key.
     */
    private Content getContent(Preferences preferences, String key);

    /**
     * Read modifiable textures catalog from preferences.
     */
    private void readModifiableTexturesCatalog(Preferences preferences);

    /**
     * Writes user preferences in current user preferences in system.
     */
    @Override
    public void write() throws RecorderException;

    /**
     * Writes modifiable furniture in <code>preferences</code>.
     */
    private void writeModifiableFurnitureCatalog(Preferences preferences) throws RecorderException;

    /**
     * Returns the string value of the given float, except for -1.0, 1.0 or 0.0 where -1, 1 and 0 is returned.
     */
    private String floatToString(float f);

    /**
     * Writes modifiable textures catalog in <code>preferences</code>.
     */
    private void writeModifiableTexturesCatalog(Preferences preferences) throws RecorderException;

    /**
     * Writes <code>key</code> <code>content</code> in <code>preferences</code>.
     */
    private void putContent(Preferences preferences, String key, Content content, String contentPrefix, Set<URL> furnitureContentURLs) throws RecorderException;

    /**
     * Returns a content object that references a copy of <code>content</code> in
     * user preferences folder.
     */
    private URLContent copyToPreferencesURLContent(Content content, String contentPrefix) throws RecorderException;

    /**
     * Returns the folder where language libraries files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getLanguageLibrariesPluginFolders();

    /**
     * Returns the folder where furniture catalog files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getFurnitureLibrariesPluginFolders();

    /**
     * Returns the folder where texture catalog files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getTexturesLibrariesPluginFolders();

    /**
     * Returns the first Sweet Home 3D application folder.
     */
    public File getApplicationFolder() throws IOException;

    /**
     * Returns Sweet Home 3D application folders.
     */
    public File[] getApplicationFolders() throws IOException;

    /**
     * Returns subfolders of Sweet Home 3D application folders of a given name.
     */
    public File[] getApplicationSubfolders(String subfolder) throws IOException;

    /**
     * Returns a new file in user preferences folder.
     */
    private File createPreferencesFile(String filePrefix) throws IOException;

    /**
     * Creates preferences folder and its sub folders if it doesn't exist.
     */
    private void checkPreferencesFolder() throws IOException;

    /**
     * Creates the first folder in the given folders.
     */
    private void checkPreferencesSubFolder(File[] librariesPluginFolders);

    /**
     * Deletes from application folder the content files starting by <code>contentPrefix</code>
     * that don't belong to <code>contentURLs</code>.
     */
    private void deleteObsoleteContent(final Set<URL> contentURLs, final String contentPrefix) throws RecorderException;

    /**
     * Returns the folder where files depending on preferences are stored.
     */
    private File getPreferencesFolder() throws IOException;

    /**
     * Returns default Java preferences for current system user.
     * Caution : This method is called once in constructor so overriding implementations
     * shouldn't be based on the state of their fields.
     */
    protected Preferences getPreferences();

    /**
     * Sets which action tip should be ignored.
     */
    @Override
    public void setActionTipIgnored(String actionKey);

    /**
     * Returns whether an action tip should be ignored or not.
     */
    @Override
    public boolean isActionTipIgnored(String actionKey);

    /**
     * Resets the display flag of action tips.
     */
    @Override
    public void resetIgnoredActionTips();

    /**
     * Returns <code>true</code> if the given language library exists in the first
     * language libraries folder.
     */
    public boolean languageLibraryExists(String name) throws RecorderException;

    /**
     * Adds <code>languageLibraryName</code> to the first language libraries folder
     * to make the language library it contains available to supported languages.
     */
    public void addLanguageLibrary(String languageLibraryName) throws RecorderException;

    /**
     * Returns <code>true</code> if the given furniture library file exists in the first
     * furniture libraries folder.
     * @param name the name of the resource to check
     */
    @Override
    public boolean furnitureLibraryExists(String name) throws RecorderException;

    /**
     * Adds the file <code>furnitureLibraryName</code> to the first furniture libraries folder
     * to make the furniture library available to catalog.
     */
    @Override
    public void addFurnitureLibrary(String furnitureLibraryName) throws RecorderException;

    /**
     * Returns <code>true</code> if the given textures library file exists in the first textures libraries folder.
     * @param name the name of the resource to check
     */
    @Override
    public boolean texturesLibraryExists(String name) throws RecorderException;

    /**
     * Adds the file <code>texturesLibraryName</code> to the first textures libraries folder
     * to make the textures library available to catalog.
     */
    @Override
    public void addTexturesLibrary(String texturesLibraryName) throws RecorderException;

    /**
     * Copies a library file to a folder.
     */
    private void copyToLibraryFolder(File libraryFile, File folder) throws IOException;

    /**
     * Preferences based on the <code>preferences.xml</code> file
     * stored in a preferences folder.
     * @author Emmanuel Puybaret
     */
    private class PortablePreferences extends AbstractPreferences {

        private static final String PREFERENCES_FILE = ""preferences.xml"";

        private Properties preferencesProperties;

        private boolean exist;

        private PortablePreferences() {
            super(null, """");
            this.preferencesProperties = new Properties();
            this.exist = readPreferences();
        }

        public boolean exist() {
            return this.exist;
        }

        @Override
        protected void syncSpi() throws BackingStoreException {
            this.preferencesProperties.clear();
            this.exist = readPreferences();
        }

        @Override
        protected void removeSpi(String key) {
            this.preferencesProperties.remove(key);
        }

        @Override
        protected void putSpi(String key, String value) {
            this.preferencesProperties.put(key, value);
        }

        @Override
        protected String[] keysSpi() throws BackingStoreException {
            return this.preferencesProperties.keySet().toArray(new String[0]);
        }

        @Override
        protected String getSpi(String key) {
            return (String) this.preferencesProperties.get(key);
        }

        @Override
        protected void flushSpi() throws BackingStoreException {
            try {
                writePreferences();
            } catch (IOException ex) {
                throw new BackingStoreException(ex);
            }
        }

        @Override
        protected void removeNodeSpi() throws BackingStoreException {
            throw new UnsupportedOperationException();
        }

        @Override
        protected String[] childrenNamesSpi() throws BackingStoreException {
            throw new UnsupportedOperationException();
        }

        @Override
        protected AbstractPreferences childSpi(String name) {
            throw new UnsupportedOperationException();
        }

        /**
         * Reads user preferences.
         */
        private boolean readPreferences() {
            InputStream in = null;
            try {
                in = new FileInputStream(new File(getPreferencesFolder(), PREFERENCES_FILE));
                this.preferencesProperties.loadFromXML(in);
                return true;
            } catch (IOException ex) {
                // Preferences don't exist
                return false;
            } finally {
                try {
                    if (in != null) {
                        in.close();
                    }
                } catch (IOException ex) {
                    // Let default preferences unchanged
                }
            }
        }

        /**
         * Writes user preferences.
         */
        private void writePreferences() throws IOException {
            OutputStream out = null;
            try {
                checkPreferencesFolder();
                out = new FileOutputStream(new File(getPreferencesFolder(), PREFERENCES_FILE));
                this.preferencesProperties.storeToXML(out, ""Portable user preferences 3.0"");
            } finally {
                if (out != null) {
                    out.close();
                    this.exist = true;
                }
            }
        }
    }
}
","// FileUserPreferences_1Test.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileUserPreferences}.
* It contains ten unit test cases for the {@link FileUserPreferences#texturesLibraryExists(String)} method.
*/
class FileUserPreferences_1Test {","// FileUserPreferences_1Test.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileUserPreferences}.
* It contains ten unit test cases for the {@link FileUserPreferences#texturesLibraryExists(String)} method.
*/
class FileUserPreferences_1Test {
"
cmpl-6xFEgJR5JZzZH0JSvKuARHFEPPpcU,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/Component3DManager_0Test.java,109.85635590553284,length,"// Component3DManager.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;

/**
 * Manager of <code>Canvas3D</code> instantiations and Java 3D error listeners.
 * Note: this class is compatible with Java 3D 1.3 at runtime but requires Java 3D 1.5 to compile.
 *
 * @author Emmanuel Puybaret
 */
public class Component3DManager {

    private static final String CHECK_OFF_SCREEN_IMAGE_SUPPORT = ""com.eteks.sweethome3d.j3d.checkOffScreenSupport"";

    private static Component3DManager instance;

    private RenderingErrorObserver renderingErrorObserver;

    // (use Object class to ensure Component3DManager class can run with Java 3D 1.3.1)
    private Object renderingErrorListener;

    private Boolean offScreenImageSupported;

    private GraphicsConfiguration defaultScreenConfiguration;

    private Component3DManager() {
    }

    /**
     * Returns the template to configure the graphics of canvas 3D.
     */
    private GraphicsConfigTemplate3D createGraphicsConfigurationTemplate3D();

    /**
     * Returns an instance of this singleton.
     */
    public static Component3DManager getInstance();

    /**
     * Sets the current rendering error listener bound to <code>VirtualUniverse</code>.
     */
    public void setRenderingErrorObserver(RenderingErrorObserver observer);

    /**
     * Returns the current rendering error listener bound to <code>VirtualUniverse</code>.
     */
    public RenderingErrorObserver getRenderingErrorObserver();

    /**
     * Returns <code>true</code> if offscreen is supported in Java 3D on user system.
     * Will always return <code>false</code> if <code>com.eteks.sweethome3d.j3d.checkOffScreenSupport</code>
     * system is equal to <code>false</code>. By default, <code>com.eteks.sweethome3d.j3d.checkOffScreenSupport</code>
     * is equal to <code>true</code>.
     */
    public boolean isOffScreenImageSupported();

    /**
     * Returns a new <code>canva3D</code> instance that will call <code>renderingObserver</code>
     * methods during the rendering loop.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    private Canvas3D getCanvas3D(GraphicsConfiguration deviceConfiguration, boolean offscreen, final RenderingObserver renderingObserver);

    /**
     * Returns a new on screen <code>canva3D</code> instance. The returned canvas 3D will be associated
     * with the graphics configuration of the default screen device.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D();

    /**
     * Returns a new on screen <code>canva3D</code> instance which rendering will be observed
     * with the given rendering observer. The returned canvas 3D will be associated with the
     * graphics configuration of the default screen device.
     * @param renderingObserver an observer of the 3D rendering process of the returned canvas.
     *            Caution: The methods of the observer will be called in 3D rendering loop thread.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D(RenderingObserver renderingObserver);

    /**
     * Returns a new on screen <code>canva3D</code> instance which rendering will be observed
     * with the given rendering observer.
     * @param renderingObserver an observer of the 3D rendering process of the returned canvas.
     *            Caution: The methods of the observer will be called in 3D rendering loop thread.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D(GraphicsConfiguration deviceConfiguration, RenderingObserver renderingObserver);

    /**
     * Returns a new off screen <code>canva3D</code> at the given size.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     *    To avoid this exception, call {@link #isOffScreenImageSupported() isOffScreenImageSupported()} first.
     */
    public Canvas3D getOffScreenCanvas3D(int width, int height);

    /**
     * Returns an image at the given size of the 3D <code>view</code>.
     * This image is created with an off screen canvas.
     * @throws IllegalRenderingStateException  if the image couldn't be created.
     */
    public BufferedImage getOffScreenImage(View view, int width, int height);

    /**
     * An observer that receives error notifications in Java 3D.
     */
    public static interface RenderingErrorObserver {

        void errorOccured(int errorCode, String errorMessage);
    }

    /**
     * Manages Java 3D 1.5 <code>RenderingErrorListener</code> change matching the given
     * rendering error observer.
     */
    private static class RenderingErrorListenerManager {

        public static Object setRenderingErrorObserver(final RenderingErrorObserver observer, Object previousRenderingErrorListener) {
            if (previousRenderingErrorListener != null) {
                VirtualUniverse.removeRenderingErrorListener((RenderingErrorListener) previousRenderingErrorListener);
            }
            RenderingErrorListener renderingErrorListener = new RenderingErrorListener() {

                public void errorOccurred(RenderingError error) {
                    observer.errorOccured(error.getErrorCode(), error.getErrorMessage());
                }
            };
            VirtualUniverse.addRenderingErrorListener(renderingErrorListener);
            return renderingErrorListener;
        }
    }

    /**
     * An observer that receives notifications during the different steps
     * of the loop rendering a canvas 3D.
     */
    public static interface RenderingObserver {

        /**
         * Called before <code>canvas3D</code> is rendered.
         */
        public void canvas3DPreRendered(Canvas3D canvas3D);

        /**
         * Called after <code>canvas3D</code> is rendered.
         */
        public void canvas3DPostRendered(Canvas3D canvas3D);

        /**
         * Called after <code>canvas3D</code> buffer is swapped.
         */
        public void canvas3DSwapped(Canvas3D canvas3D);
    }
}
","// Component3DManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains ten unit test cases for the {@link Component3DManager#getInstance()} method.
*/
class Component3DManager_0Test {","// Component3DManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains ten unit test cases for the {@link Component3DManager#getInstance()} method.
*/
class Component3DManager_0Test {

	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_0() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_1() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_2() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_3() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_4() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_5() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_6() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_7() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_8() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_9() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
}

// Component3DManager_1Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains ten unit test cases for the {@link Component3DManager#getInstance()} method.
*/
class Component3DManager_1Test {
		
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_0() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_1() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_2() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_3() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_4() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_5() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_6() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_7() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_8() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_9() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
}

// Component3DManager_2Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains ten unit test cases for the {@link Component3DManager#getInstance()} method.
*/
class Component3DManager_2Test {
		
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_0() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_1() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_2() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_3() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_4() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_5() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_6() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_7() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_8() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link Component3DManager#getInstance()} method.
	 * Test method for {@link Component3DManager#getInstance()}.
	 */
	@Test
	void testGetInstance_9() {
		Component3DManager result = Component3DManager.getInstance();
		assertNotNull(result);
	}
	
}

// Component3DManager_3Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import jav"
cmpl-6xFGSHQRn3MLqYxa3rNsTRsjtg7c9,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/Component3DManager_1Test.java,101.27104997634888,length,"// Component3DManager.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;

/**
 * Manager of <code>Canvas3D</code> instantiations and Java 3D error listeners.
 * Note: this class is compatible with Java 3D 1.3 at runtime but requires Java 3D 1.5 to compile.
 *
 * @author Emmanuel Puybaret
 */
public class Component3DManager {

    private static final String CHECK_OFF_SCREEN_IMAGE_SUPPORT = ""com.eteks.sweethome3d.j3d.checkOffScreenSupport"";

    private static Component3DManager instance;

    private RenderingErrorObserver renderingErrorObserver;

    // (use Object class to ensure Component3DManager class can run with Java 3D 1.3.1)
    private Object renderingErrorListener;

    private Boolean offScreenImageSupported;

    private GraphicsConfiguration defaultScreenConfiguration;

    private Component3DManager() {
    }

    /**
     * Returns the template to configure the graphics of canvas 3D.
     */
    private GraphicsConfigTemplate3D createGraphicsConfigurationTemplate3D();

    /**
     * Returns an instance of this singleton.
     */
    public static Component3DManager getInstance();

    /**
     * Sets the current rendering error listener bound to <code>VirtualUniverse</code>.
     */
    public void setRenderingErrorObserver(RenderingErrorObserver observer);

    /**
     * Returns the current rendering error listener bound to <code>VirtualUniverse</code>.
     */
    public RenderingErrorObserver getRenderingErrorObserver();

    /**
     * Returns <code>true</code> if offscreen is supported in Java 3D on user system.
     * Will always return <code>false</code> if <code>com.eteks.sweethome3d.j3d.checkOffScreenSupport</code>
     * system is equal to <code>false</code>. By default, <code>com.eteks.sweethome3d.j3d.checkOffScreenSupport</code>
     * is equal to <code>true</code>.
     */
    public boolean isOffScreenImageSupported();

    /**
     * Returns a new <code>canva3D</code> instance that will call <code>renderingObserver</code>
     * methods during the rendering loop.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    private Canvas3D getCanvas3D(GraphicsConfiguration deviceConfiguration, boolean offscreen, final RenderingObserver renderingObserver);

    /**
     * Returns a new on screen <code>canva3D</code> instance. The returned canvas 3D will be associated
     * with the graphics configuration of the default screen device.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D();

    /**
     * Returns a new on screen <code>canva3D</code> instance which rendering will be observed
     * with the given rendering observer. The returned canvas 3D will be associated with the
     * graphics configuration of the default screen device.
     * @param renderingObserver an observer of the 3D rendering process of the returned canvas.
     *            Caution: The methods of the observer will be called in 3D rendering loop thread.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D(RenderingObserver renderingObserver);

    /**
     * Returns a new on screen <code>canva3D</code> instance which rendering will be observed
     * with the given rendering observer.
     * @param renderingObserver an observer of the 3D rendering process of the returned canvas.
     *            Caution: The methods of the observer will be called in 3D rendering loop thread.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D(GraphicsConfiguration deviceConfiguration, RenderingObserver renderingObserver);

    /**
     * Returns a new off screen <code>canva3D</code> at the given size.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     *    To avoid this exception, call {@link #isOffScreenImageSupported() isOffScreenImageSupported()} first.
     */
    public Canvas3D getOffScreenCanvas3D(int width, int height);

    /**
     * Returns an image at the given size of the 3D <code>view</code>.
     * This image is created with an off screen canvas.
     * @throws IllegalRenderingStateException  if the image couldn't be created.
     */
    public BufferedImage getOffScreenImage(View view, int width, int height);

    /**
     * An observer that receives error notifications in Java 3D.
     */
    public static interface RenderingErrorObserver {

        void errorOccured(int errorCode, String errorMessage);
    }

    /**
     * Manages Java 3D 1.5 <code>RenderingErrorListener</code> change matching the given
     * rendering error observer.
     */
    private static class RenderingErrorListenerManager {

        public static Object setRenderingErrorObserver(final RenderingErrorObserver observer, Object previousRenderingErrorListener) {
            if (previousRenderingErrorListener != null) {
                VirtualUniverse.removeRenderingErrorListener((RenderingErrorListener) previousRenderingErrorListener);
            }
            RenderingErrorListener renderingErrorListener = new RenderingErrorListener() {

                public void errorOccurred(RenderingError error) {
                    observer.errorOccured(error.getErrorCode(), error.getErrorMessage());
                }
            };
            VirtualUniverse.addRenderingErrorListener(renderingErrorListener);
            return renderingErrorListener;
        }
    }

    /**
     * An observer that receives notifications during the different steps
     * of the loop rendering a canvas 3D.
     */
    public static interface RenderingObserver {

        /**
         * Called before <code>canvas3D</code> is rendered.
         */
        public void canvas3DPreRendered(Canvas3D canvas3D);

        /**
         * Called after <code>canvas3D</code> is rendered.
         */
        public void canvas3DPostRendered(Canvas3D canvas3D);

        /**
         * Called after <code>canvas3D</code> buffer is swapped.
         */
        public void canvas3DSwapped(Canvas3D canvas3D);
    }
}
","// Component3DManager_1Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains ten unit test cases for the {@link Component3DManager#getOnscreenCanvas3D(RenderingObserver)} method.
*/
class Component3DManager_1Test {","// Component3DManager_1Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains ten unit test cases for the {@link Component3DManager#getOnscreenCanvas3D(RenderingObserver)} method.
*/
class Component3DManager_1Test {

	@Test
	void testGetOnscreenCanvas3D_1() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOnscreenCanvas3D_2() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOnscreenCanvas3D_3() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOnscreenCanvas3D_4() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOnscreenCanvas3D_5() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOnscreenCanvas3D_6() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOnscreenCanvas3D_7() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOnscreenCanvas3D_8() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOnscreenCanvas3D_9() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOnscreenCanvas3D_10() {
		// Test the creation of a canvas 3D with a rendering observer
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D(new RenderingObserver() {
			public void canvas3DPreRendered(Canvas3D canvas3D) {
			}
			public void canvas3DPostRendered(Canvas3D canvas3D) {
			}
			public void canvas3DSwapped(Canvas3D canvas3D) {
			}
		});
		assertNotNull(canvas3D);
	}
}

// Component3DManager_2Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains ten unit test cases for the {@link Component3DManager#getOffScreenCanvas3D(int, int)} method.
*/
class Component3DManager_2Test {
		
	@Test
	void testGetOffScreenCanvas3D_1() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOffScreenCanvas3D_2() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOffScreenCanvas3D_3() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOffScreenCanvas3D_4() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOffScreenCanvas3D_5() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOffScreenCanvas3D_6() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOffScreenCanvas3D_7() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOffScreenCanvas3D_8() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOffScreenCanvas3D_9() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
	
	@Test
	void testGetOffScreenCanvas3D_10() {
		// Test the creation of an off screen canvas 3D
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOffScreenCanvas3D(100, 100);
		assertNotNull(canvas3D);
	}
}

// Component3DManager_3Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains ten unit test cases for the {@link Component3DManager#getOffScreenImage(View, int, int)} method.
*/
class Component3DManager_3Test {
		
	@Test
	void testGetOffScreenImage_1() {
		// Test the creation of an off screen image
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D();
		View view = new View();
		view.addCanvas3D(canvas3D);
		BufferedImage image = manager.getOffScreenImage(view, 100, 100);
		assertNotNull(image);
	}
	
	@Test
	void testGetOffScreenImage_2() {
		// Test the creation of an off screen image
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D();
		View view = new View();
		view.addCanvas3D(canvas3D);
		BufferedImage image = manager.getOffScreenImage(view, 100, 100);
		assertNotNull(image);
	}
	
	@Test
	void testGetOffScreenImage_3() {
		// Test the creation of an off screen image
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D();
		View view = new View();
		view.addCanvas3D(canvas3D);
		BufferedImage image = manager.getOffScreenImage(view, 100, 100);
		assertNotNull(image);
	}
	
	@Test
	void testGetOffScreenImage_4() {
		// Test the creation of an off screen image
		Component3DManager manager = Component3DManager.getInstance();
		Canvas3D canvas3D = manager.getOnscreenCanvas3D"
9ec3f153-154e-41fa-be69-eed0db06a83a,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/ModelManager_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9507 tokens (5507 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModelManager.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;

/**
 * Singleton managing 3D models cache.
 * This manager supports 3D models with an OBJ, DAE, 3DS or LWS format by default.
 * Additional classes implementing Java 3D <code>Loader</code> interface may be
 * specified in the <code>com.eteks.sweethome3d.j3d.additionalLoaderClasses</code>
 * (separated by a space or a colon :) to enable the support of other formats.<br>
 * Note: this class is compatible with Java 3D 1.3.
 *
 * @author Emmanuel Puybaret
 */
public class ModelManager {

    /**
     * <code>Shape3D</code> user data prefix for window pane shapes.
     */
    public static final String WINDOW_PANE_SHAPE_PREFIX = ""sweethome3d_window_pane"";

    /**
     * <code>Shape3D</code> user data prefix for mirror shapes.
     */
    public static final String MIRROR_SHAPE_PREFIX = ""sweethome3d_window_mirror"";

    /**
     * <code>Shape3D</code> user data prefix for lights.
     */
    public static final String LIGHT_SHAPE_PREFIX = ""sweethome3d_light"";

    private static final TransparencyAttributes WINDOW_PANE_TRANSPARENCY_ATTRIBUTES = new TransparencyAttributes(TransparencyAttributes.NICEST, 0.5f);

    private static final Material DEFAULT_MATERIAL = new Material();

    private static final float MINIMUM_SIZE = 0.001f;

    private static final String ADDITIONAL_LOADER_CLASSES = ""com.eteks.sweethome3d.j3d.additionalLoaderClasses"";

    private static ModelManager instance;

    // Map storing loaded model nodes
    private Map<Content, BranchGroup> loadedModelNodes;

    // Map storing model nodes being loaded
    private Map<Content, List<ModelObserver>> loadingModelObservers;

    // Executor used to load models
    private ExecutorService modelsLoader;

    // List of additional loader classes
    private Class<Loader>[] additionalLoaderClasses;

    // SVG path Shapes
    private final Map<String, Shape> parsedShapes;

    private ModelManager() {
    }

    /**
     * Returns the class of name <code>loaderClassName</code>.
     */
    @SuppressWarnings(""unchecked"")
    private Class<Loader> getLoaderClass(String loaderClassName);

    /**
     * Returns an instance of this singleton.
     */
    public static ModelManager getInstance();

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear();

    /**
     * Returns the minimum size of a model.
     */
    float getMinimumSize();

    /**
     * Returns the size of 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node);

    /**
     * Returns the size of 3D shapes of <code>node</code> after an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node, Transform3D transformation);

    /**
     * Returns the bounds of the 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public BoundingBox getBounds(Node node);

    /**
     * Returns the bounds of the 3D shapes of <code>node</code> with an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes, contrary to <code>node.getBounds()</code>
     * that returns a bounding sphere for a scene.
     */
    public BoundingBox getBounds(Node node, Transform3D transformation);

    /**
     * Returns <code>true</code> if the rotation matrix matches only rotations of
     * a multiple of 90� degrees around x, y or z axis.
     */
    private boolean isOrthogonalRotation(Transform3D transformation);

    private void computeBounds(Node node, BoundingBox bounds, Transform3D parentTransformations, boolean transformShapeGeometry);

    private Bounds computeTransformedGeometryBounds(Shape3D shape, Transform3D transformation);

    private void updateBounds(Point3f vertex, Transform3D transformation, Point3d lower, Point3d upper);

    /**
     * Returns a transform group that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public TransformGroup getNormalizedTransformGroup(Node node, float[][] modelRotation, float width);

    /**
     * Returns a transform that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public Transform3D getNormalizedTransform(Node node, float[][] modelRotation, float width);

    /**
     * Reads asynchronously a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens
     * @throws IllegalStateException if the current thread isn't the Event Dispatch Thread.
     */
    public void loadModel(Content content, ModelObserver modelObserver);

    /**
     * Reads a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param synchronous if <code>true</code>, this method will return only once model content is loaded
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens. When the model is loaded synchronously, the observer will be notified
     *    in the same thread as the caller, otherwise the observer will be notified in the Event
     *    Dispatch Thread and this method must be called in Event Dispatch Thread too.
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadModel(final Content content, boolean synchronous, ModelObserver modelObserver);

    /**
     * Returns a clone of the given <code>node</code>.
     * All the children and the attributes of the given node are duplicated except the geometries
     * and the texture images of shapes.
     */
    public Node cloneNode(Node node);

    private Node cloneNode(Node node, Map<SharedGroup, SharedGroup> clonedSharedGroups);

    /**
     * Returns the node loaded synchronously from <code>content</code> with supported loaders.
     * This method is threadsafe and may be called from any thread.
     * @param content an object containing a model
     */
    public BranchGroup loadModel(Content content) throws IOException;

    /**
     * Updates the name of scene shapes and transparency window panes shapes.
     */
    @SuppressWarnings(""unchecked"")
    private void updateShapeNamesAndWindowPanesTransparency(Scene scene);

    /**
     * Turns off light nodes of <code>node</code> children,
     * and modulates textures if needed.
     */
    private void turnOffLightsShareAndModulateTextures(Node node);

    /**
     * Returns the 2D area of the 3D shapes children of the given <code>node</code>
     * projected on the floor (plan y = 0).
     */
    public Area getAreaOnFloor(Node node);

    /**
     * Returns the total count of vertices in all geometries.
     */
    private int getVertexCount(Node node);

    /**
     * Computes the vertices coordinates projected on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeVerticesOnFloor(Node node, List<float[]> vertices, Transform3D parentTransformations);

    /**
     * Computes the 2D area on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeAreaOnFloor(Node node, Area nodeArea, Transform3D parentTransformations);

    /**
     * Computes the area on floor of a 3D geometry.
     */
    private void computeGeometryAreaOnFloor(Geometry geometry, Transform3D parentTransformations, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices.
     */
    private void addIndexedTriangleToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices.
     */
    private void addIndexedQuadrilateralToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices,
     * only if the triangle has a positive orientation.
     */
    private void addTriangleToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices,
     * only if the quadrilateral has a positive orientation.
     */
    private void addQuadrilateralToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea);

    /**
     * Returns the convex polygon that surrounds the given <code>vertices</code>.
     * From Andrew's monotone chain 2D convex hull algorithm described at
     * http://softsurfer.com/Archive/algorithm%5F0109/algorithm%5F0109.htm
     */
    private float[][] getSurroundingPolygon(float[][] vertices);

    private float isLeft(float[] vertex0, float[] vertex1, float[] vertex2);

    /**
     * Returns the area on the floor of the given staircase.
     */
    public Area getAreaOnFloor(HomePieceOfFurniture staircase);

    /**
     * Returns the mirror area of the given <code>area</code>.
     */
    private Area getMirroredArea(Area area);

    /**
     * Returns the AWT shape matching the given <a href=""http://www.w3.org/TR/SVG/paths.html"">SVG path shape</a>.
     */
    private Shape parseShape(String svgPathShape);

    /**
     * Separated static class to be able to exclude Batik library from classpath.
     */
    private static class SVGPathSupport {

        public static Shape parsePathShape(String svgPathShape) {
            try {
                AWTPathProducer pathProducer = new AWTPathProducer();
                PathParser pathParser = new PathParser();
                pathParser.setPathHandler(pathProducer);
                pathParser.parse(svgPathShape);
                return pathProducer.getShape();
            } catch (ParseException ex) {
                // Fallback to default square shape if shape is incorrect
                return new Rectangle2D.Float(0, 0, 1, 1);
            }
        }
    }

    /**
     * An observer that receives model loading notifications.
     */
    public static interface ModelObserver {

        public void modelUpdated(BranchGroup modelRoot);

        public void modelError(Exception ex);
    }
}
","// ModelManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains ten unit test cases for the {@link ModelManager#getInstance()} method.
*/
class ModelManager_0Test {","// ModelManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains ten unit test cases for the {@link ModelManager#getInstance()} method.
*/
class ModelManager_0Test {
"
4b711ebe-15b6-4712-bda5-c3a26a2f956b,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/ModelManager_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9517 tokens (5517 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModelManager.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;

/**
 * Singleton managing 3D models cache.
 * This manager supports 3D models with an OBJ, DAE, 3DS or LWS format by default.
 * Additional classes implementing Java 3D <code>Loader</code> interface may be
 * specified in the <code>com.eteks.sweethome3d.j3d.additionalLoaderClasses</code>
 * (separated by a space or a colon :) to enable the support of other formats.<br>
 * Note: this class is compatible with Java 3D 1.3.
 *
 * @author Emmanuel Puybaret
 */
public class ModelManager {

    /**
     * <code>Shape3D</code> user data prefix for window pane shapes.
     */
    public static final String WINDOW_PANE_SHAPE_PREFIX = ""sweethome3d_window_pane"";

    /**
     * <code>Shape3D</code> user data prefix for mirror shapes.
     */
    public static final String MIRROR_SHAPE_PREFIX = ""sweethome3d_window_mirror"";

    /**
     * <code>Shape3D</code> user data prefix for lights.
     */
    public static final String LIGHT_SHAPE_PREFIX = ""sweethome3d_light"";

    private static final TransparencyAttributes WINDOW_PANE_TRANSPARENCY_ATTRIBUTES = new TransparencyAttributes(TransparencyAttributes.NICEST, 0.5f);

    private static final Material DEFAULT_MATERIAL = new Material();

    private static final float MINIMUM_SIZE = 0.001f;

    private static final String ADDITIONAL_LOADER_CLASSES = ""com.eteks.sweethome3d.j3d.additionalLoaderClasses"";

    private static ModelManager instance;

    // Map storing loaded model nodes
    private Map<Content, BranchGroup> loadedModelNodes;

    // Map storing model nodes being loaded
    private Map<Content, List<ModelObserver>> loadingModelObservers;

    // Executor used to load models
    private ExecutorService modelsLoader;

    // List of additional loader classes
    private Class<Loader>[] additionalLoaderClasses;

    // SVG path Shapes
    private final Map<String, Shape> parsedShapes;

    private ModelManager() {
    }

    /**
     * Returns the class of name <code>loaderClassName</code>.
     */
    @SuppressWarnings(""unchecked"")
    private Class<Loader> getLoaderClass(String loaderClassName);

    /**
     * Returns an instance of this singleton.
     */
    public static ModelManager getInstance();

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear();

    /**
     * Returns the minimum size of a model.
     */
    float getMinimumSize();

    /**
     * Returns the size of 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node);

    /**
     * Returns the size of 3D shapes of <code>node</code> after an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node, Transform3D transformation);

    /**
     * Returns the bounds of the 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public BoundingBox getBounds(Node node);

    /**
     * Returns the bounds of the 3D shapes of <code>node</code> with an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes, contrary to <code>node.getBounds()</code>
     * that returns a bounding sphere for a scene.
     */
    public BoundingBox getBounds(Node node, Transform3D transformation);

    /**
     * Returns <code>true</code> if the rotation matrix matches only rotations of
     * a multiple of 90� degrees around x, y or z axis.
     */
    private boolean isOrthogonalRotation(Transform3D transformation);

    private void computeBounds(Node node, BoundingBox bounds, Transform3D parentTransformations, boolean transformShapeGeometry);

    private Bounds computeTransformedGeometryBounds(Shape3D shape, Transform3D transformation);

    private void updateBounds(Point3f vertex, Transform3D transformation, Point3d lower, Point3d upper);

    /**
     * Returns a transform group that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public TransformGroup getNormalizedTransformGroup(Node node, float[][] modelRotation, float width);

    /**
     * Returns a transform that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public Transform3D getNormalizedTransform(Node node, float[][] modelRotation, float width);

    /**
     * Reads asynchronously a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens
     * @throws IllegalStateException if the current thread isn't the Event Dispatch Thread.
     */
    public void loadModel(Content content, ModelObserver modelObserver);

    /**
     * Reads a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param synchronous if <code>true</code>, this method will return only once model content is loaded
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens. When the model is loaded synchronously, the observer will be notified
     *    in the same thread as the caller, otherwise the observer will be notified in the Event
     *    Dispatch Thread and this method must be called in Event Dispatch Thread too.
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadModel(final Content content, boolean synchronous, ModelObserver modelObserver);

    /**
     * Returns a clone of the given <code>node</code>.
     * All the children and the attributes of the given node are duplicated except the geometries
     * and the texture images of shapes.
     */
    public Node cloneNode(Node node);

    private Node cloneNode(Node node, Map<SharedGroup, SharedGroup> clonedSharedGroups);

    /**
     * Returns the node loaded synchronously from <code>content</code> with supported loaders.
     * This method is threadsafe and may be called from any thread.
     * @param content an object containing a model
     */
    public BranchGroup loadModel(Content content) throws IOException;

    /**
     * Updates the name of scene shapes and transparency window panes shapes.
     */
    @SuppressWarnings(""unchecked"")
    private void updateShapeNamesAndWindowPanesTransparency(Scene scene);

    /**
     * Turns off light nodes of <code>node</code> children,
     * and modulates textures if needed.
     */
    private void turnOffLightsShareAndModulateTextures(Node node);

    /**
     * Returns the 2D area of the 3D shapes children of the given <code>node</code>
     * projected on the floor (plan y = 0).
     */
    public Area getAreaOnFloor(Node node);

    /**
     * Returns the total count of vertices in all geometries.
     */
    private int getVertexCount(Node node);

    /**
     * Computes the vertices coordinates projected on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeVerticesOnFloor(Node node, List<float[]> vertices, Transform3D parentTransformations);

    /**
     * Computes the 2D area on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeAreaOnFloor(Node node, Area nodeArea, Transform3D parentTransformations);

    /**
     * Computes the area on floor of a 3D geometry.
     */
    private void computeGeometryAreaOnFloor(Geometry geometry, Transform3D parentTransformations, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices.
     */
    private void addIndexedTriangleToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices.
     */
    private void addIndexedQuadrilateralToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices,
     * only if the triangle has a positive orientation.
     */
    private void addTriangleToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices,
     * only if the quadrilateral has a positive orientation.
     */
    private void addQuadrilateralToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea);

    /**
     * Returns the convex polygon that surrounds the given <code>vertices</code>.
     * From Andrew's monotone chain 2D convex hull algorithm described at
     * http://softsurfer.com/Archive/algorithm%5F0109/algorithm%5F0109.htm
     */
    private float[][] getSurroundingPolygon(float[][] vertices);

    private float isLeft(float[] vertex0, float[] vertex1, float[] vertex2);

    /**
     * Returns the area on the floor of the given staircase.
     */
    public Area getAreaOnFloor(HomePieceOfFurniture staircase);

    /**
     * Returns the mirror area of the given <code>area</code>.
     */
    private Area getMirroredArea(Area area);

    /**
     * Returns the AWT shape matching the given <a href=""http://www.w3.org/TR/SVG/paths.html"">SVG path shape</a>.
     */
    private Shape parseShape(String svgPathShape);

    /**
     * Separated static class to be able to exclude Batik library from classpath.
     */
    private static class SVGPathSupport {

        public static Shape parsePathShape(String svgPathShape) {
            try {
                AWTPathProducer pathProducer = new AWTPathProducer();
                PathParser pathParser = new PathParser();
                pathParser.setPathHandler(pathProducer);
                pathParser.parse(svgPathShape);
                return pathProducer.getShape();
            } catch (ParseException ex) {
                // Fallback to default square shape if shape is incorrect
                return new Rectangle2D.Float(0, 0, 1, 1);
            }
        }
    }

    /**
     * An observer that receives model loading notifications.
     */
    public static interface ModelObserver {

        public void modelUpdated(BranchGroup modelRoot);

        public void modelError(Exception ex);
    }
}
","// ModelManager_1Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains ten unit test cases for the {@link ModelManager#getNormalizedTransformGroup(Node, float[][], float)} method.
*/
class ModelManager_1Test {","// ModelManager_1Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains ten unit test cases for the {@link ModelManager#getNormalizedTransformGroup(Node, float[][], float)} method.
*/
class ModelManager_1Test {
"
d2e68f01-600d-4c6e-bdaf-9279f5484ced,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/ModelManager_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9516 tokens (5516 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModelManager.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;

/**
 * Singleton managing 3D models cache.
 * This manager supports 3D models with an OBJ, DAE, 3DS or LWS format by default.
 * Additional classes implementing Java 3D <code>Loader</code> interface may be
 * specified in the <code>com.eteks.sweethome3d.j3d.additionalLoaderClasses</code>
 * (separated by a space or a colon :) to enable the support of other formats.<br>
 * Note: this class is compatible with Java 3D 1.3.
 *
 * @author Emmanuel Puybaret
 */
public class ModelManager {

    /**
     * <code>Shape3D</code> user data prefix for window pane shapes.
     */
    public static final String WINDOW_PANE_SHAPE_PREFIX = ""sweethome3d_window_pane"";

    /**
     * <code>Shape3D</code> user data prefix for mirror shapes.
     */
    public static final String MIRROR_SHAPE_PREFIX = ""sweethome3d_window_mirror"";

    /**
     * <code>Shape3D</code> user data prefix for lights.
     */
    public static final String LIGHT_SHAPE_PREFIX = ""sweethome3d_light"";

    private static final TransparencyAttributes WINDOW_PANE_TRANSPARENCY_ATTRIBUTES = new TransparencyAttributes(TransparencyAttributes.NICEST, 0.5f);

    private static final Material DEFAULT_MATERIAL = new Material();

    private static final float MINIMUM_SIZE = 0.001f;

    private static final String ADDITIONAL_LOADER_CLASSES = ""com.eteks.sweethome3d.j3d.additionalLoaderClasses"";

    private static ModelManager instance;

    // Map storing loaded model nodes
    private Map<Content, BranchGroup> loadedModelNodes;

    // Map storing model nodes being loaded
    private Map<Content, List<ModelObserver>> loadingModelObservers;

    // Executor used to load models
    private ExecutorService modelsLoader;

    // List of additional loader classes
    private Class<Loader>[] additionalLoaderClasses;

    // SVG path Shapes
    private final Map<String, Shape> parsedShapes;

    private ModelManager() {
    }

    /**
     * Returns the class of name <code>loaderClassName</code>.
     */
    @SuppressWarnings(""unchecked"")
    private Class<Loader> getLoaderClass(String loaderClassName);

    /**
     * Returns an instance of this singleton.
     */
    public static ModelManager getInstance();

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear();

    /**
     * Returns the minimum size of a model.
     */
    float getMinimumSize();

    /**
     * Returns the size of 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node);

    /**
     * Returns the size of 3D shapes of <code>node</code> after an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node, Transform3D transformation);

    /**
     * Returns the bounds of the 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public BoundingBox getBounds(Node node);

    /**
     * Returns the bounds of the 3D shapes of <code>node</code> with an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes, contrary to <code>node.getBounds()</code>
     * that returns a bounding sphere for a scene.
     */
    public BoundingBox getBounds(Node node, Transform3D transformation);

    /**
     * Returns <code>true</code> if the rotation matrix matches only rotations of
     * a multiple of 90� degrees around x, y or z axis.
     */
    private boolean isOrthogonalRotation(Transform3D transformation);

    private void computeBounds(Node node, BoundingBox bounds, Transform3D parentTransformations, boolean transformShapeGeometry);

    private Bounds computeTransformedGeometryBounds(Shape3D shape, Transform3D transformation);

    private void updateBounds(Point3f vertex, Transform3D transformation, Point3d lower, Point3d upper);

    /**
     * Returns a transform group that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public TransformGroup getNormalizedTransformGroup(Node node, float[][] modelRotation, float width);

    /**
     * Returns a transform that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public Transform3D getNormalizedTransform(Node node, float[][] modelRotation, float width);

    /**
     * Reads asynchronously a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens
     * @throws IllegalStateException if the current thread isn't the Event Dispatch Thread.
     */
    public void loadModel(Content content, ModelObserver modelObserver);

    /**
     * Reads a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param synchronous if <code>true</code>, this method will return only once model content is loaded
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens. When the model is loaded synchronously, the observer will be notified
     *    in the same thread as the caller, otherwise the observer will be notified in the Event
     *    Dispatch Thread and this method must be called in Event Dispatch Thread too.
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadModel(final Content content, boolean synchronous, ModelObserver modelObserver);

    /**
     * Returns a clone of the given <code>node</code>.
     * All the children and the attributes of the given node are duplicated except the geometries
     * and the texture images of shapes.
     */
    public Node cloneNode(Node node);

    private Node cloneNode(Node node, Map<SharedGroup, SharedGroup> clonedSharedGroups);

    /**
     * Returns the node loaded synchronously from <code>content</code> with supported loaders.
     * This method is threadsafe and may be called from any thread.
     * @param content an object containing a model
     */
    public BranchGroup loadModel(Content content) throws IOException;

    /**
     * Updates the name of scene shapes and transparency window panes shapes.
     */
    @SuppressWarnings(""unchecked"")
    private void updateShapeNamesAndWindowPanesTransparency(Scene scene);

    /**
     * Turns off light nodes of <code>node</code> children,
     * and modulates textures if needed.
     */
    private void turnOffLightsShareAndModulateTextures(Node node);

    /**
     * Returns the 2D area of the 3D shapes children of the given <code>node</code>
     * projected on the floor (plan y = 0).
     */
    public Area getAreaOnFloor(Node node);

    /**
     * Returns the total count of vertices in all geometries.
     */
    private int getVertexCount(Node node);

    /**
     * Computes the vertices coordinates projected on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeVerticesOnFloor(Node node, List<float[]> vertices, Transform3D parentTransformations);

    /**
     * Computes the 2D area on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeAreaOnFloor(Node node, Area nodeArea, Transform3D parentTransformations);

    /**
     * Computes the area on floor of a 3D geometry.
     */
    private void computeGeometryAreaOnFloor(Geometry geometry, Transform3D parentTransformations, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices.
     */
    private void addIndexedTriangleToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices.
     */
    private void addIndexedQuadrilateralToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices,
     * only if the triangle has a positive orientation.
     */
    private void addTriangleToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices,
     * only if the quadrilateral has a positive orientation.
     */
    private void addQuadrilateralToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea);

    /**
     * Returns the convex polygon that surrounds the given <code>vertices</code>.
     * From Andrew's monotone chain 2D convex hull algorithm described at
     * http://softsurfer.com/Archive/algorithm%5F0109/algorithm%5F0109.htm
     */
    private float[][] getSurroundingPolygon(float[][] vertices);

    private float isLeft(float[] vertex0, float[] vertex1, float[] vertex2);

    /**
     * Returns the area on the floor of the given staircase.
     */
    public Area getAreaOnFloor(HomePieceOfFurniture staircase);

    /**
     * Returns the mirror area of the given <code>area</code>.
     */
    private Area getMirroredArea(Area area);

    /**
     * Returns the AWT shape matching the given <a href=""http://www.w3.org/TR/SVG/paths.html"">SVG path shape</a>.
     */
    private Shape parseShape(String svgPathShape);

    /**
     * Separated static class to be able to exclude Batik library from classpath.
     */
    private static class SVGPathSupport {

        public static Shape parsePathShape(String svgPathShape) {
            try {
                AWTPathProducer pathProducer = new AWTPathProducer();
                PathParser pathParser = new PathParser();
                pathParser.setPathHandler(pathProducer);
                pathParser.parse(svgPathShape);
                return pathProducer.getShape();
            } catch (ParseException ex) {
                // Fallback to default square shape if shape is incorrect
                return new Rectangle2D.Float(0, 0, 1, 1);
            }
        }
    }

    /**
     * An observer that receives model loading notifications.
     */
    public static interface ModelObserver {

        public void modelUpdated(BranchGroup modelRoot);

        public void modelError(Exception ex);
    }
}
","// ModelManager_2Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains ten unit test cases for the {@link ModelManager#getNormalizedTransform(Node, float[][], float)} method.
*/
class ModelManager_2Test {","// ModelManager_2Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains ten unit test cases for the {@link ModelManager#getNormalizedTransform(Node, float[][], float)} method.
*/
class ModelManager_2Test {
"
4ae4919b-ef97-40c4-8d16-9c50cfc2b59e,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/ModelManager_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9508 tokens (5508 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModelManager.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;

/**
 * Singleton managing 3D models cache.
 * This manager supports 3D models with an OBJ, DAE, 3DS or LWS format by default.
 * Additional classes implementing Java 3D <code>Loader</code> interface may be
 * specified in the <code>com.eteks.sweethome3d.j3d.additionalLoaderClasses</code>
 * (separated by a space or a colon :) to enable the support of other formats.<br>
 * Note: this class is compatible with Java 3D 1.3.
 *
 * @author Emmanuel Puybaret
 */
public class ModelManager {

    /**
     * <code>Shape3D</code> user data prefix for window pane shapes.
     */
    public static final String WINDOW_PANE_SHAPE_PREFIX = ""sweethome3d_window_pane"";

    /**
     * <code>Shape3D</code> user data prefix for mirror shapes.
     */
    public static final String MIRROR_SHAPE_PREFIX = ""sweethome3d_window_mirror"";

    /**
     * <code>Shape3D</code> user data prefix for lights.
     */
    public static final String LIGHT_SHAPE_PREFIX = ""sweethome3d_light"";

    private static final TransparencyAttributes WINDOW_PANE_TRANSPARENCY_ATTRIBUTES = new TransparencyAttributes(TransparencyAttributes.NICEST, 0.5f);

    private static final Material DEFAULT_MATERIAL = new Material();

    private static final float MINIMUM_SIZE = 0.001f;

    private static final String ADDITIONAL_LOADER_CLASSES = ""com.eteks.sweethome3d.j3d.additionalLoaderClasses"";

    private static ModelManager instance;

    // Map storing loaded model nodes
    private Map<Content, BranchGroup> loadedModelNodes;

    // Map storing model nodes being loaded
    private Map<Content, List<ModelObserver>> loadingModelObservers;

    // Executor used to load models
    private ExecutorService modelsLoader;

    // List of additional loader classes
    private Class<Loader>[] additionalLoaderClasses;

    // SVG path Shapes
    private final Map<String, Shape> parsedShapes;

    private ModelManager() {
    }

    /**
     * Returns the class of name <code>loaderClassName</code>.
     */
    @SuppressWarnings(""unchecked"")
    private Class<Loader> getLoaderClass(String loaderClassName);

    /**
     * Returns an instance of this singleton.
     */
    public static ModelManager getInstance();

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear();

    /**
     * Returns the minimum size of a model.
     */
    float getMinimumSize();

    /**
     * Returns the size of 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node);

    /**
     * Returns the size of 3D shapes of <code>node</code> after an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node, Transform3D transformation);

    /**
     * Returns the bounds of the 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public BoundingBox getBounds(Node node);

    /**
     * Returns the bounds of the 3D shapes of <code>node</code> with an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes, contrary to <code>node.getBounds()</code>
     * that returns a bounding sphere for a scene.
     */
    public BoundingBox getBounds(Node node, Transform3D transformation);

    /**
     * Returns <code>true</code> if the rotation matrix matches only rotations of
     * a multiple of 90� degrees around x, y or z axis.
     */
    private boolean isOrthogonalRotation(Transform3D transformation);

    private void computeBounds(Node node, BoundingBox bounds, Transform3D parentTransformations, boolean transformShapeGeometry);

    private Bounds computeTransformedGeometryBounds(Shape3D shape, Transform3D transformation);

    private void updateBounds(Point3f vertex, Transform3D transformation, Point3d lower, Point3d upper);

    /**
     * Returns a transform group that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public TransformGroup getNormalizedTransformGroup(Node node, float[][] modelRotation, float width);

    /**
     * Returns a transform that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public Transform3D getNormalizedTransform(Node node, float[][] modelRotation, float width);

    /**
     * Reads asynchronously a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens
     * @throws IllegalStateException if the current thread isn't the Event Dispatch Thread.
     */
    public void loadModel(Content content, ModelObserver modelObserver);

    /**
     * Reads a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param synchronous if <code>true</code>, this method will return only once model content is loaded
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens. When the model is loaded synchronously, the observer will be notified
     *    in the same thread as the caller, otherwise the observer will be notified in the Event
     *    Dispatch Thread and this method must be called in Event Dispatch Thread too.
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadModel(final Content content, boolean synchronous, ModelObserver modelObserver);

    /**
     * Returns a clone of the given <code>node</code>.
     * All the children and the attributes of the given node are duplicated except the geometries
     * and the texture images of shapes.
     */
    public Node cloneNode(Node node);

    private Node cloneNode(Node node, Map<SharedGroup, SharedGroup> clonedSharedGroups);

    /**
     * Returns the node loaded synchronously from <code>content</code> with supported loaders.
     * This method is threadsafe and may be called from any thread.
     * @param content an object containing a model
     */
    public BranchGroup loadModel(Content content) throws IOException;

    /**
     * Updates the name of scene shapes and transparency window panes shapes.
     */
    @SuppressWarnings(""unchecked"")
    private void updateShapeNamesAndWindowPanesTransparency(Scene scene);

    /**
     * Turns off light nodes of <code>node</code> children,
     * and modulates textures if needed.
     */
    private void turnOffLightsShareAndModulateTextures(Node node);

    /**
     * Returns the 2D area of the 3D shapes children of the given <code>node</code>
     * projected on the floor (plan y = 0).
     */
    public Area getAreaOnFloor(Node node);

    /**
     * Returns the total count of vertices in all geometries.
     */
    private int getVertexCount(Node node);

    /**
     * Computes the vertices coordinates projected on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeVerticesOnFloor(Node node, List<float[]> vertices, Transform3D parentTransformations);

    /**
     * Computes the 2D area on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeAreaOnFloor(Node node, Area nodeArea, Transform3D parentTransformations);

    /**
     * Computes the area on floor of a 3D geometry.
     */
    private void computeGeometryAreaOnFloor(Geometry geometry, Transform3D parentTransformations, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices.
     */
    private void addIndexedTriangleToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices.
     */
    private void addIndexedQuadrilateralToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices,
     * only if the triangle has a positive orientation.
     */
    private void addTriangleToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea);

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices,
     * only if the quadrilateral has a positive orientation.
     */
    private void addQuadrilateralToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea);

    /**
     * Returns the convex polygon that surrounds the given <code>vertices</code>.
     * From Andrew's monotone chain 2D convex hull algorithm described at
     * http://softsurfer.com/Archive/algorithm%5F0109/algorithm%5F0109.htm
     */
    private float[][] getSurroundingPolygon(float[][] vertices);

    private float isLeft(float[] vertex0, float[] vertex1, float[] vertex2);

    /**
     * Returns the area on the floor of the given staircase.
     */
    public Area getAreaOnFloor(HomePieceOfFurniture staircase);

    /**
     * Returns the mirror area of the given <code>area</code>.
     */
    private Area getMirroredArea(Area area);

    /**
     * Returns the AWT shape matching the given <a href=""http://www.w3.org/TR/SVG/paths.html"">SVG path shape</a>.
     */
    private Shape parseShape(String svgPathShape);

    /**
     * Separated static class to be able to exclude Batik library from classpath.
     */
    private static class SVGPathSupport {

        public static Shape parsePathShape(String svgPathShape) {
            try {
                AWTPathProducer pathProducer = new AWTPathProducer();
                PathParser pathParser = new PathParser();
                pathParser.setPathHandler(pathProducer);
                pathParser.parse(svgPathShape);
                return pathProducer.getShape();
            } catch (ParseException ex) {
                // Fallback to default square shape if shape is incorrect
                return new Rectangle2D.Float(0, 0, 1, 1);
            }
        }
    }

    /**
     * An observer that receives model loading notifications.
     */
    public static interface ModelObserver {

        public void modelUpdated(BranchGroup modelRoot);

        public void modelError(Exception ex);
    }
}
","// ModelManager_3Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains ten unit test cases for the {@link ModelManager#loadModel(Content)} method.
*/
class ModelManager_3Test {","// ModelManager_3Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains ten unit test cases for the {@link ModelManager#loadModel(Content)} method.
*/
class ModelManager_3Test {
"
cmpl-6xFLyNVKTpD4Ab8wxbFdFC2IKrtca,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/TextureManager.java,9.79275393486023,stop,"// TextureManager.java
package com.eteks.sweethome3d.j3d;

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.media.j3d.ImageComponent;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.Texture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.URLContent;
import com.sun.j3d.utils.image.TextureLoader;

/**
 * Singleton managing texture image cache.
 *
 * @author Emmanuel Puybaret
 */
public class TextureManager {

    private static TextureManager instance;

    // Image used if an image content couldn't be loaded
    private final Texture errorTexture;

    // Image used while an image content is loaded
    private final Texture waitTexture;

    // Map storing loaded texture contents
    private final Map<Content, TextureKey> contentTextureKeys;

    // Map storing loaded textures
    private final Map<TextureKey, Texture> textures;

    // Map storing model nodes being loaded
    private Map<Content, List<TextureObserver>> loadingTextureObservers;

    // Executor used to load images
    private ExecutorService texturesLoader;

    private TextureManager() {
    }

    /**
     * Returns an instance of this singleton.
     */
    public static TextureManager getInstance();

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear();

    /**
     * Returns a texture image of one pixel of the given <code>color</code>.
     */
    private Texture getColoredImageTexture(Color color);

    /**
     * Reads a texture image from <code>content</code> notified to <code>textureObserver</code>
     * If the texture isn't loaded in cache yet, a one pixel white image texture will be notified
     * immediately to the given <code>textureObserver</code>, then a second notification will
     * be given in Event Dispatch Thread once the image texture is loaded. If the texture is in cache,
     * it will be notified immediately to the given <code>textureObserver</code>.
     * @param content an object containing an image
     * @param textureObserver the observer that will be notified once the texture is available
     */
    public void loadTexture(final Content content, final TextureObserver textureObserver);

    /**
     * Reads a texture image from <code>content</code> notified to <code>textureObserver</code>.
     * If the texture isn't loaded in cache yet and <code>synchronous</code> is false, a one pixel
     * white image texture will be notified immediately to the given <code>textureObserver</code>,
     * then a second notification will be given in Event Dispatch Thread once the image texture is loaded.
     * If the texture is in cache, it will be notified immediately to the given <code>textureObserver</code>.
     * @param content an object containing an image
     * @param synchronous if <code>true</code>, this method will return only once image content is loaded.
     * @param textureObserver the observer that will be notified once the texture is available
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadTexture(final Content content, boolean synchronous, final TextureObserver textureObserver);

    /**
     * Returns a texture created from the image from <code>content</code>.
     */
    public Texture loadTexture(final Content content);

    /**
     * Returns either the <code>texture</code> in parameter or a shared texture
     * if the same texture as the one in parameter is already shared.
     */
    public Texture shareTexture(Texture texture);

    /**
     * Returns the texture matching <code>content</code>, either
     * the <code>texture</code> in parameter or a shared texture if the
     * same texture as the one in parameter is already shared.
     */
    private Texture shareTexture(final Texture texture, final Content content);

    /**
     * Sets the attributes and capabilities of a shared <code>texture</code>.
     */
    private void setSharedTextureAttributesAndCapabilities(Texture texture);

    /**
     * Returns <code>true</code> if the texture is shared and its image contains
     * at least one transparent pixel.
     */
    public boolean isTextureTransparent(Texture texture);

    /**
     * An observer that receives texture loading notifications.
     */
    public static interface TextureObserver {

        public void textureUpdated(Texture texture);
    }

    /**
     * Key used to ensure texture uniqueness in textures map.
     * Image bits of the texture are stored in a weak reference to avoid grabbing memory uselessly.
     */
    private static class TextureKey {

        private Texture texture;

        private WeakReference<int[]> imageBits;

        private int hashCodeCache;

        private boolean hashCodeSet;

        private boolean transparent;

        public TextureKey(Texture texture) {
            this.texture = texture;
        }

        public Texture getTexture() {
            return this.texture;
        }

        /**
         * Returns the pixels of the given <code>image</code>.
         */
        private int[] getImagePixels() {
            int[] imageBits = null;
            if (this.imageBits != null) {
                imageBits = this.imageBits.get();
            }
            if (imageBits == null) {
                BufferedImage image = ((ImageComponent2D) this.texture.getImage(0)).getImage();
                if (image.getType() != BufferedImage.TYPE_INT_RGB && image.getType() != BufferedImage.TYPE_INT_ARGB) {
                    // Transform as TYPE_INT_ARGB or TYPE_INT_RGB (much faster than calling image.getRGB())
                    BufferedImage tmp = new BufferedImage(image.getWidth(), image.getHeight(), this.texture.getFormat() == Texture.RGBA ? BufferedImage.TYPE_INT_ARGB : BufferedImage.TYPE_INT_RGB);
                    Graphics2D g = (Graphics2D) tmp.getGraphics();
                    g.drawImage(image, null, 0, 0);
                    g.dispose();
                    image = tmp;
                }
                imageBits = (int[]) image.getRaster().getDataElements(0, 0, image.getWidth(), image.getHeight(), null);
                this.transparent = image.getTransparency() != BufferedImage.OPAQUE;
                this.imageBits = new WeakReference<int[]>(imageBits);
            }
            return imageBits;
        }

        /**
         * Returns <code>true</code> if the image of the texture contains at least one transparent pixel.
         */
        public boolean isTransparent() {
            return this.transparent;
        }

        /**
         * Returns <code>true</code> if the image of this texture and
         * the image of the object in parameter are the same.
         */
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            } else if (obj instanceof TextureKey) {
                TextureKey textureKey = (TextureKey) obj;
                if (this.texture == textureKey.texture) {
                    return true;
                } else if (hashCode() == textureKey.hashCode()) {
                    return Arrays.equals(getImagePixels(), textureKey.getImagePixels());
                }
            }
            return false;
        }

        @Override
        public int hashCode() {
            if (!this.hashCodeSet) {
                this.hashCodeCache = Arrays.hashCode(getImagePixels());
                this.hashCodeSet = true;
            }
            return this.hashCodeCache;
        }
    }
}
","// TextureManagerTest.java
package com.eteks.sweethome3d.j3d;

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.media.j3d.ImageComponent;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.Texture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.URLContent;
import com.sun.j3d.utils.image.TextureLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextureManager}.
* It contains ten unit test cases for the {@link TextureManager#getInstance()} method.
*/
class TextureManagerTest {","// TextureManagerTest.java
package com.eteks.sweethome3d.j3d;

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.media.j3d.ImageComponent;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.Texture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.URLContent;
import com.sun.j3d.utils.image.TextureLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextureManager}.
* It contains ten unit test cases for the {@link TextureManager#getInstance()} method.
*/
class TextureManagerTest {

		@Test
		public void testGetInstance() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
		
		@Test
		public void testGetInstance2() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
		
		@Test
		public void testGetInstance3() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
		
		@Test
		public void testGetInstance4() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
		
		@Test
		public void testGetInstance5() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
		
		@Test
		public void testGetInstance6() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
		
		@Test
		public void testGetInstance7() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
		
		@Test
		public void testGetInstance8() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
		
		@Test
		public void testGetInstance9() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
		
		@Test
		public void testGetInstance10() {
				TextureManager textureManager = TextureManager.getInstance();
				assertNotNull(textureManager);
		}
}"
d2457032-ab4a-45f8-bc53-c3703a2f51e0,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 19287 tokens (15287 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HomePane.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 *
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction);

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller);

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action);

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins);

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller);

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home);

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected);

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home);

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController);

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener();

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy();

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent);

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu);

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu);

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component);

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences);

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key);

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences);

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup);

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home);

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener);

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller);

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup);

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup);

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller);

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name);

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled);

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener();

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller);

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller);

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible);

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar);

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view);

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height);

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view);

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName);

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog();

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName);

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName);

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName);

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName);

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName);

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message);

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message);

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey);

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit();

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog();

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog();

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName);

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName);

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName);

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException;

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection();

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName);

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty();

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable);

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_0Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showOpenDialog()} method.
*/
class HomePane_0Test {","// HomePane_0Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showOpenDialog()} method.
*/
class HomePane_0Test {
"
256ee1d6-2eff-46f1-bf6b-cb01333f251c,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 19289 tokens (15289 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HomePane.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 *
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction);

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller);

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action);

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins);

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller);

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home);

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected);

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home);

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController);

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener();

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy();

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent);

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu);

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu);

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component);

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences);

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key);

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences);

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup);

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home);

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener);

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller);

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup);

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup);

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller);

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name);

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled);

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener();

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller);

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller);

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible);

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar);

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view);

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height);

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view);

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName);

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog();

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName);

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName);

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName);

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName);

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName);

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message);

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message);

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey);

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit();

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog();

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog();

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName);

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName);

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName);

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException;

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection();

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName);

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty();

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable);

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_1Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showImportLanguageLibraryDialog()} method.
*/
class HomePane_1Test {","// HomePane_1Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showImportLanguageLibraryDialog()} method.
*/
class HomePane_1Test {
"
a25ace78-709b-48f9-a5d2-1e6ef2989a72,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 19291 tokens (15291 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HomePane.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 *
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction);

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller);

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action);

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins);

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller);

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home);

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected);

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home);

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController);

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener();

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy();

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent);

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu);

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu);

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component);

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences);

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key);

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences);

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup);

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home);

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener);

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller);

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup);

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup);

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller);

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name);

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled);

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener();

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller);

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller);

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible);

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar);

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view);

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height);

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view);

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName);

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog();

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName);

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName);

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName);

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName);

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName);

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message);

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message);

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey);

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit();

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog();

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog();

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName);

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName);

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName);

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException;

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection();

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName);

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty();

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable);

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_2Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showImportFurnitureLibraryDialog()} method.
*/
class HomePane_2Test {","// HomePane_2Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showImportFurnitureLibraryDialog()} method.
*/
class HomePane_2Test {
"
d0d52130-ce04-498d-b8dc-efc76e0ff9a1,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 19289 tokens (15289 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HomePane.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 *
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction);

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller);

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action);

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins);

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller);

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home);

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected);

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home);

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController);

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener();

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy();

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent);

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu);

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu);

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component);

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences);

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key);

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences);

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup);

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home);

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener);

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller);

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup);

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup);

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller);

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name);

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled);

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener();

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller);

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller);

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible);

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar);

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view);

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height);

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view);

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName);

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog();

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName);

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName);

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName);

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName);

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName);

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message);

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message);

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey);

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit();

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog();

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog();

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName);

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName);

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName);

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException;

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection();

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName);

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty();

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable);

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_3Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showImportTexturesLibraryDialog()} method.
*/
class HomePane_3Test {","// HomePane_3Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showImportTexturesLibraryDialog()} method.
*/
class HomePane_3Test {
"
184e2ebb-256b-4d03-b9e5-f4eefe494739,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 19287 tokens (15287 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HomePane.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 *
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction);

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller);

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action);

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins);

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller);

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home);

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected);

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home);

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController);

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener();

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy();

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent);

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu);

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu);

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component);

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences);

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key);

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences);

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup);

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home);

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener);

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller);

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup);

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup);

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller);

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name);

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled);

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener();

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller);

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller);

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible);

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar);

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view);

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height);

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view);

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName);

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog();

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName);

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName);

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName);

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName);

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName);

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message);

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message);

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey);

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit();

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog();

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog();

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName);

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName);

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName);

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException;

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection();

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName);

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty();

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable);

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_4Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#confirmExit()} method.
*/
class HomePane_4Test {","// HomePane_4Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#confirmExit()} method.
*/
class HomePane_4Test {
"
25c1fa95-b0a4-42da-a620-e457f9e210e7,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 19287 tokens (15287 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HomePane.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 *
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction);

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller);

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action);

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins);

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller);

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home);

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected);

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home);

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController);

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener();

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy();

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent);

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu);

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu);

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component);

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences);

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key);

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences);

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup);

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home);

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener);

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller);

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup);

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup);

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller);

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name);

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled);

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener();

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller);

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller);

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible);

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar);

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view);

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height);

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view);

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName);

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog();

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName);

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName);

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName);

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName);

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName);

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message);

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message);

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey);

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit();

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog();

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog();

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName);

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName);

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName);

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException;

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection();

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName);

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty();

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable);

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_5Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showPrintDialog()} method.
*/
class HomePane_5Test {","// HomePane_5Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#showPrintDialog()} method.
*/
class HomePane_5Test {
"
d65dc510-ab47-4bb2-8909-b2ca806b9d76,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 19290 tokens (15290 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HomePane.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 *
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters);

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction);

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller);

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action);

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins);

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller);

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home);

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected);

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home);

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController);

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener();

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy();

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent);

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu);

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton);

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu);

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu);

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component);

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences);

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key);

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences);

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup);

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home);

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences);

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener);

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup);

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup);

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller);

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup);

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup);

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller);

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar);

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText);

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name);

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled);

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener();

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller);

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller);

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller);

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences);

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible);

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar);

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view);

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height);

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view);

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName);

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog();

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName);

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName);

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog();

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName);

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName);

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName);

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message);

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message);

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey);

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName);

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit();

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog();

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog();

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName);

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName);

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException;

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName);

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException;

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection();

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName);

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty();

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable);

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_6Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#confirmDeleteCatalogSelection()} method.
*/
class HomePane_6Test {","// HomePane_6Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains ten unit test cases for the {@link HomePane#confirmDeleteCatalogSelection()} method.
*/
class HomePane_6Test {
"
cmpl-6xFTpqf8qjSuKTFf4gecBcqJ0ZYT9,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/IconManager_0Test.java,78.66801238059998,stop,"// IconManager.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;

/**
 * Singleton managing icons cache.
 *
 * @author Emmanuel Puybaret
 */
public class IconManager {

    private static IconManager instance;

    // Icon used if an image content couldn't be loaded
    private final Content errorIconContent;

    // Icon used while an image content is loaded
    private final Content waitIconContent;

    // Map storing loaded icons
    private final Map<Content, Map<Integer, Icon>> icons;

    // Executor used by IconProxy to load images
    private ExecutorService iconsLoader;

    private IconManager() {
    }

    /**
     * Returns an instance of this singleton.
     */
    public static IconManager getInstance();

    /**
     * Clears the loaded resources cache and shutdowns the multithreaded service
     * that loads icons.
     */
    public void clear();

    /**
     * Returns the icon displayed for wrong content resized at a given height.
     */
    public Icon getErrorIcon(int height);

    /**
     * Returns the icon displayed for wrong content.
     */
    public Icon getErrorIcon();

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the error icon
     * used by this manager to indicate it couldn't load an icon.
     */
    public boolean isErrorIcon(Icon icon);

    /**
     * Returns the icon displayed while a content is loaded resized at a given height.
     */
    public Icon getWaitIcon(int height);

    /**
     * Returns the icon displayed while a content is loaded.
     */
    public Icon getWaitIcon();

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the wait icon
     * used by this manager to indicate it's currently loading an icon.
     */
    public boolean isWaitIcon(Icon icon);

    /**
     * Returns an icon read from <code>content</code>.
     * @param content an object containing an image
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, Component waitingComponent);

    /**
     * Returns an icon read from <code>content</code> and rescaled at a given <code>height</code>.
     * @param content an object containing an image
     * @param height  the desired height of the returned icon
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, final int height, Component waitingComponent);

    /**
     * Returns an icon created and scaled from its content.
     * @param content the content from which the icon image is read
     * @param height  the desired height of the returned icon
     * @param errorIcon the returned icon in case of error
     */
    private Icon createIcon(Content content, int height, Icon errorIcon);

    /**
     * Proxy icon that displays a temporary icon while waiting
     * image loading completion.
     */
    private class IconProxy implements Icon {

        private Icon icon;

        public IconProxy(final Content content, final int height, final Component waitingComponent, final Icon errorIcon, Icon waitIcon) {
            this.icon = waitIcon;
            if (iconsLoader == null) {
                iconsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
            }
            // Load the icon in a different thread
            iconsLoader.execute(new Runnable() {

                public void run() {
                    icon = createIcon(content, height, errorIcon);
                    waitingComponent.repaint();
                }
            });
        }

        public int getIconWidth() {
            return this.icon.getIconWidth();
        }

        public int getIconHeight() {
            return this.icon.getIconHeight();
        }

        public void paintIcon(Component c, Graphics g, int x, int y) {
            this.icon.paintIcon(c, g, x, y);
        }

        public Icon getIcon() {
            return this.icon;
        }
    }
}
","// IconManager_0Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getInstance()} method.
*/
class IconManager_0Test {","// IconManager_0Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getInstance()} method.
*/
class IconManager_0Test {

		/**
		* Test case for the {@link IconManager#getInstance()} method.
		*/
		@Test
		void testGetInstance() {
				IconManager iconManager = IconManager.getInstance();
				assertNotNull(iconManager);
		}
}

// IconManager_1Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#clear()} method.
*/
class IconManager_1Test {
		
		/**
		* Test case for the {@link IconManager#clear()} method.
		*/
		@Test
		void testClear() {
				IconManager iconManager = IconManager.getInstance();
				iconManager.clear();
		}
}

// IconManager_2Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getErrorIcon(int)} method.
*/
class IconManager_2Test {
		
		/**
		* Test case for the {@link IconManager#getErrorIcon(int)} method.
		*/
		@Test
		void testGetErrorIcon() {
				IconManager iconManager = IconManager.getInstance();
				Icon errorIcon = iconManager.getErrorIcon(0);
				assertNotNull(errorIcon);
		}
}

// IconManager_3Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getErrorIcon()} method.
*/
class IconManager_3Test {
		
		/**
		* Test case for the {@link IconManager#getErrorIcon()} method.
		*/
		@Test
		void testGetErrorIcon() {
				IconManager iconManager = IconManager.getInstance();
				Icon errorIcon = iconManager.getErrorIcon();
				assertNotNull(errorIcon);
		}
}

// IconManager_4Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#isErrorIcon(Icon)} method.
*/
class IconManager_4Test {
		
		/**
		* Test case for the {@link IconManager#isErrorIcon(Icon)} method.
		*/
		@Test
		void testIsErrorIcon() {
				IconManager iconManager = IconManager.getInstance();
				Icon errorIcon = iconManager.getErrorIcon();
				assertTrue(iconManager.isErrorIcon(errorIcon));
		}
}

// IconManager_5Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getWaitIcon(int)} method.
*/
class IconManager_5Test {
		
		/**
		* Test case for the {@link IconManager#getWaitIcon(int)} method.
		*/
		@Test
		void testGetWaitIcon() {
				IconManager iconManager = IconManager.getInstance();
				Icon waitIcon = iconManager.getWaitIcon(0);
				assertNotNull(waitIcon);
		}
}

// IconManager_6Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getWaitIcon()} method.
*/
class IconManager_6Test {
		
		/**
		* Test case for the {@link IconManager#getWaitIcon()} method.
		*/
		@Test
		void testGetWaitIcon() {
				IconManager iconManager = IconManager.getInstance();
				Icon waitIcon = iconManager.getWaitIcon();
				assertNotNull(waitIcon);
		}
}

// IconManager_7Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#isWaitIcon(Icon)} method.
*/
class IconManager_7Test {
		
		/**
		* Test case for the {@link IconManager#isWaitIcon(Icon)} method.
		*/
		@Test
		void testIsWaitIcon() {
				IconManager iconManager = IconManager.getInstance();
				Icon waitIcon = iconManager.getWaitIcon();
				assertTrue(iconManager.isWaitIcon(waitIcon));
		}
}

// IconManager_8Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getIcon(Content, Component)} method.
*/
class IconManager_8Test {
		
		/**
		* Test case for the {@link IconManager#getIcon(Content, Component)} method.
		*/
		@Test
		void testGetIcon() {
				IconManager iconManager = IconManager.getInstance();
				Icon icon = iconManager.getIcon(null, null);
				assertNotNull(icon);
		}
}

// IconManager_9Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getIcon(Content, int, Component)} method.
*/
class IconManager_9Test {
		
		/**
		* Test case for the {@link IconManager#getIcon(Content, int, Component)} method.
		*/
		@Test
		void testGetIcon() {
				IconManager iconManager = IconManager.getInstance();
				Icon icon = iconManager.getIcon(null, 0, null);
				assertNotNull(icon);
		}
}"
cmpl-6xFV68sf6YNjjsp0SlR9wuEKAA9Y3,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/IconManager_1Test.java,98.36845660209656,length,"// IconManager.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;

/**
 * Singleton managing icons cache.
 *
 * @author Emmanuel Puybaret
 */
public class IconManager {

    private static IconManager instance;

    // Icon used if an image content couldn't be loaded
    private final Content errorIconContent;

    // Icon used while an image content is loaded
    private final Content waitIconContent;

    // Map storing loaded icons
    private final Map<Content, Map<Integer, Icon>> icons;

    // Executor used by IconProxy to load images
    private ExecutorService iconsLoader;

    private IconManager() {
    }

    /**
     * Returns an instance of this singleton.
     */
    public static IconManager getInstance();

    /**
     * Clears the loaded resources cache and shutdowns the multithreaded service
     * that loads icons.
     */
    public void clear();

    /**
     * Returns the icon displayed for wrong content resized at a given height.
     */
    public Icon getErrorIcon(int height);

    /**
     * Returns the icon displayed for wrong content.
     */
    public Icon getErrorIcon();

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the error icon
     * used by this manager to indicate it couldn't load an icon.
     */
    public boolean isErrorIcon(Icon icon);

    /**
     * Returns the icon displayed while a content is loaded resized at a given height.
     */
    public Icon getWaitIcon(int height);

    /**
     * Returns the icon displayed while a content is loaded.
     */
    public Icon getWaitIcon();

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the wait icon
     * used by this manager to indicate it's currently loading an icon.
     */
    public boolean isWaitIcon(Icon icon);

    /**
     * Returns an icon read from <code>content</code>.
     * @param content an object containing an image
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, Component waitingComponent);

    /**
     * Returns an icon read from <code>content</code> and rescaled at a given <code>height</code>.
     * @param content an object containing an image
     * @param height  the desired height of the returned icon
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, final int height, Component waitingComponent);

    /**
     * Returns an icon created and scaled from its content.
     * @param content the content from which the icon image is read
     * @param height  the desired height of the returned icon
     * @param errorIcon the returned icon in case of error
     */
    private Icon createIcon(Content content, int height, Icon errorIcon);

    /**
     * Proxy icon that displays a temporary icon while waiting
     * image loading completion.
     */
    private class IconProxy implements Icon {

        private Icon icon;

        public IconProxy(final Content content, final int height, final Component waitingComponent, final Icon errorIcon, Icon waitIcon) {
            this.icon = waitIcon;
            if (iconsLoader == null) {
                iconsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
            }
            // Load the icon in a different thread
            iconsLoader.execute(new Runnable() {

                public void run() {
                    icon = createIcon(content, height, errorIcon);
                    waitingComponent.repaint();
                }
            });
        }

        public int getIconWidth() {
            return this.icon.getIconWidth();
        }

        public int getIconHeight() {
            return this.icon.getIconHeight();
        }

        public void paintIcon(Component c, Graphics g, int x, int y) {
            this.icon.paintIcon(c, g, x, y);
        }

        public Icon getIcon() {
            return this.icon;
        }
    }
}
","// IconManager_1Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getIcon(Content, Component)} method.
*/
class IconManager_1Test {","// IconManager_1Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getIcon(Content, Component)} method.
*/
class IconManager_1Test {

		/**
		* Test case 1 for method {@link IconManager#getIcon(Content, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component"
cmpl-6xFWgObU9kws6dDJXGn559Y4j6TX9,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/IconManager_2Test.java,96.42033529281616,length,"// IconManager.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;

/**
 * Singleton managing icons cache.
 *
 * @author Emmanuel Puybaret
 */
public class IconManager {

    private static IconManager instance;

    // Icon used if an image content couldn't be loaded
    private final Content errorIconContent;

    // Icon used while an image content is loaded
    private final Content waitIconContent;

    // Map storing loaded icons
    private final Map<Content, Map<Integer, Icon>> icons;

    // Executor used by IconProxy to load images
    private ExecutorService iconsLoader;

    private IconManager() {
    }

    /**
     * Returns an instance of this singleton.
     */
    public static IconManager getInstance();

    /**
     * Clears the loaded resources cache and shutdowns the multithreaded service
     * that loads icons.
     */
    public void clear();

    /**
     * Returns the icon displayed for wrong content resized at a given height.
     */
    public Icon getErrorIcon(int height);

    /**
     * Returns the icon displayed for wrong content.
     */
    public Icon getErrorIcon();

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the error icon
     * used by this manager to indicate it couldn't load an icon.
     */
    public boolean isErrorIcon(Icon icon);

    /**
     * Returns the icon displayed while a content is loaded resized at a given height.
     */
    public Icon getWaitIcon(int height);

    /**
     * Returns the icon displayed while a content is loaded.
     */
    public Icon getWaitIcon();

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the wait icon
     * used by this manager to indicate it's currently loading an icon.
     */
    public boolean isWaitIcon(Icon icon);

    /**
     * Returns an icon read from <code>content</code>.
     * @param content an object containing an image
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, Component waitingComponent);

    /**
     * Returns an icon read from <code>content</code> and rescaled at a given <code>height</code>.
     * @param content an object containing an image
     * @param height  the desired height of the returned icon
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, final int height, Component waitingComponent);

    /**
     * Returns an icon created and scaled from its content.
     * @param content the content from which the icon image is read
     * @param height  the desired height of the returned icon
     * @param errorIcon the returned icon in case of error
     */
    private Icon createIcon(Content content, int height, Icon errorIcon);

    /**
     * Proxy icon that displays a temporary icon while waiting
     * image loading completion.
     */
    private class IconProxy implements Icon {

        private Icon icon;

        public IconProxy(final Content content, final int height, final Component waitingComponent, final Icon errorIcon, Icon waitIcon) {
            this.icon = waitIcon;
            if (iconsLoader == null) {
                iconsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
            }
            // Load the icon in a different thread
            iconsLoader.execute(new Runnable() {

                public void run() {
                    icon = createIcon(content, height, errorIcon);
                    waitingComponent.repaint();
                }
            });
        }

        public int getIconWidth() {
            return this.icon.getIconWidth();
        }

        public int getIconHeight() {
            return this.icon.getIconHeight();
        }

        public void paintIcon(Component c, Graphics g, int x, int y) {
            this.icon.paintIcon(c, g, x, y);
        }

        public Icon getIcon() {
            return this.icon;
        }
    }
}
","// IconManager_2Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getIcon(Content, int, Component)} method.
*/
class IconManager_2Test {","// IconManager_2Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains ten unit test cases for the {@link IconManager#getIcon(Content, int, Component)} method.
*/
class IconManager_2Test {

		/**
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int, Component)}.
		* Test case 1 for method {@link IconManager#getIcon(Content, int"
8ced4552-2781-45c1-94f7-c68ae2e21caf,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/SwingTools.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8051 tokens (4051 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// SwingTools.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.Window;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Area;
import java.awt.image.BufferedImage;
import java.awt.image.FilteredImageSource;
import java.awt.image.RGBImageFilter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.jnlp.BasicService;
import javax.jnlp.ServiceManager;
import javax.jnlp.UnavailableServiceException;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JToggleButton;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.border.AbstractBorder;
import javax.swing.border.Border;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;

/**
 * Gathers some useful tools for Swing.
 *
 * @author Emmanuel Puybaret
 */
public class SwingTools {

    // Borders for focused views
    private static Border unfocusedViewBorder;

    private static Border focusedViewBorder;

    private SwingTools() {
    }

    /**
     * Updates the border of <code>component</code> with an empty border
     * changed to a colored border when it will gain focus.
     * If the <code>component</code> component is the child of a <code>JViewPort</code>
     * instance this border will be installed on its scroll pane parent.
     */
    public static void installFocusBorder(JComponent component);

    /**
     * Updates the Swing resource bundles in use from the current Locale and class loader.
     */
    public static void updateSwingResourceLanguage();

    /**
     * Updates the Swing resource bundles in use from the current Locale and the class loaders of preferences.
     */
    public static void updateSwingResourceLanguage(UserPreferences preferences);

    /**
     * Updates the Swing resource bundles in use from the current Locale and class loaders.
     */
    private static void updateSwingResourceLanguage(List<ClassLoader> classLoaders);

    /**
     * Updates a Swing resource bundle in use from the current Locale.
     */
    private static void updateSwingResourceBundle(String swingResource, List<ClassLoader> classLoaders);

    /**
     * Returns a localized text for menus items and labels depending on the system.
     */
    public static String getLocalizedLabelText(UserPreferences preferences, Class<?> resourceClass, String resourceKey, Object... resourceParameters);

    /**
     * Adds focus and mouse listeners to the given <code>textComponent</code> that will
     * select all its text when it gains focus by transfer.
     */
    public static void addAutoSelectionOnFocusGain(final JTextComponent textComponent);

    /**
     * Forces radio buttons to be deselected even if they belong to a button group.
     */
    public static void deselectAllRadioButtons(JRadioButton... radioButtons);

    /**
     * Displays <code>messageComponent</code> in a modal dialog box, giving focus to one of its components.
     */
    public static int showConfirmDialog(JComponent parentComponent, JComponent messageComponent, String title, final JComponent focusedComponent);

    /**
     * Displays <code>messageComponent</code> in a modal dialog box, giving focus to one of its components.
     */
    public static void showMessageDialog(JComponent parentComponent, JComponent messageComponent, String title, int messageType, final JComponent focusedComponent);

    private static Map<TextureImage, BufferedImage> patternImages;

    /**
     * Returns the image matching a given pattern.
     */
    public static BufferedImage getPatternImage(TextureImage pattern, Color backgroundColor, Color foregroundColor);

    /**
     * Returns the border of a component where a user may drop objects.
     */
    public static Border getDropableComponentBorder();

    /**
     * Displays the image referenced by <code>imageUrl</code> in an AWT window
     * disposed once an other AWT frame is created.
     * If the <code>imageUrl</code> is incorrect, nothing happens.
     */
    public static void showSplashScreenWindow(URL imageUrl);

    /**
     * Returns a new panel with a border and the given <code>title</code>
     */
    public static JPanel createTitledPanel(String title);

    /**
     * Returns a scroll pane containing the given <code>component</code>
     * that always displays scroll bars under Mac OS X.
     */
    public static JScrollPane createScrollPane(JComponent component);

    /**
     * Adds a listener that will update the given popup menu to hide disabled menu items.
     */
    public static void hideDisabledMenuItems(JPopupMenu popupMenu);

    /**
     * A popup menu listener that displays only enabled menu items.
     */
    private static class MenuItemsVisibilityListener implements PopupMenuListener {

        public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
            JPopupMenu popupMenu = (JPopupMenu) ev.getSource();
            hideDisabledMenuItems(popupMenu);
            // Ensure at least one item is visible
            boolean allItemsInvisible = true;
            for (int i = 0; i < popupMenu.getComponentCount(); i++) {
                if (popupMenu.getComponent(i).isVisible()) {
                    allItemsInvisible = false;
                    break;
                }
            }
            if (allItemsInvisible) {
                popupMenu.getComponent(0).setVisible(true);
            }
        }

        /**
         * Makes useless menu items invisible.
         */
        private void hideDisabledMenuItems(JPopupMenu popupMenu) {
            for (int i = 0; i < popupMenu.getComponentCount(); i++) {
                Component component = popupMenu.getComponent(i);
                if (component instanceof JMenu) {
                    boolean containsEnabledItems = containsEnabledItems((JMenu) component);
                    component.setVisible(containsEnabledItems);
                    if (containsEnabledItems) {
                        hideDisabledMenuItems(((JMenu) component).getPopupMenu());
                    }
                } else if (component instanceof JMenuItem) {
                    component.setVisible(component.isEnabled());
                }
            }
            hideUselessSeparators(popupMenu);
        }

        /**
         * Makes useless separators invisible.
         */
        private void hideUselessSeparators(JPopupMenu popupMenu) {
            boolean allMenuItemsInvisible = true;
            int lastVisibleSeparatorIndex = -1;
            for (int i = 0; i < popupMenu.getComponentCount(); i++) {
                Component component = popupMenu.getComponent(i);
                if (allMenuItemsInvisible && (component instanceof JMenuItem)) {
                    if (component.isVisible()) {
                        allMenuItemsInvisible = false;
                    }
                } else if (component instanceof JSeparator) {
                    component.setVisible(!allMenuItemsInvisible);
                    if (!allMenuItemsInvisible) {
                        lastVisibleSeparatorIndex = i;
                    }
                    allMenuItemsInvisible = true;
                }
            }
            if (lastVisibleSeparatorIndex != -1 && allMenuItemsInvisible) {
                // Check if last separator is the first visible component
                boolean allComponentsBeforeLastVisibleSeparatorInvisible = true;
                for (int i = lastVisibleSeparatorIndex - 1; i >= 0; i--) {
                    if (popupMenu.getComponent(i).isVisible()) {
                        allComponentsBeforeLastVisibleSeparatorInvisible = false;
                        break;
                    }
                }
                boolean allComponentsAfterLastVisibleSeparatorInvisible = true;
                for (int i = lastVisibleSeparatorIndex; i < popupMenu.getComponentCount(); i++) {
                    if (popupMenu.getComponent(i).isVisible()) {
                        allComponentsBeforeLastVisibleSeparatorInvisible = false;
                        break;
                    }
                }
                popupMenu.getComponent(lastVisibleSeparatorIndex).setVisible(!allComponentsBeforeLastVisibleSeparatorInvisible && !allComponentsAfterLastVisibleSeparatorInvisible);
            }
        }

        /**
         * Returns <code>true</code> if the given <code>menu</code> contains
         * at least one enabled menu item.
         */
        private boolean containsEnabledItems(JMenu menu) {
            boolean menuContainsEnabledItems = false;
            for (int i = 0; i < menu.getMenuComponentCount() && !menuContainsEnabledItems; i++) {
                Component component = menu.getMenuComponent(i);
                if (component instanceof JMenu) {
                    menuContainsEnabledItems = containsEnabledItems((JMenu) component);
                } else if (component instanceof JMenuItem) {
                    menuContainsEnabledItems = component.isEnabled();
                }
            }
            return menuContainsEnabledItems;
        }

        public void popupMenuCanceled(PopupMenuEvent ev) {
        }

        public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
        }
    }

    /**
     * Attempts to display the given <code>url</code> in a browser and returns <code>true</code>
     * if it was done successfully.
     */
    public static boolean showDocumentInBrowser(URL url);

    /**
     * Separated static class to be able to exclude JNLP library from classpath.
     */
    private static class BrowserSupport {

        public static boolean showDocumentInBrowser(URL url) {
            try {
                // Lookup the javax.jnlp.BasicService object
                BasicService basicService = (BasicService) ServiceManager.lookup(""javax.jnlp.BasicService"");
                // Ignore the basic service, if it doesn't support web browser
                if (basicService.isWebBrowserSupported()) {
                    return basicService.showDocument(url);
                }
            } catch (UnavailableServiceException ex) {
                // Too bad : service is unavailable
            } catch (LinkageError ex) {
                // JNLP classes not available in classpath
                System.err.println(""Can't show document in browser. JNLP classes not available in classpath."");
            }
            return false;
        }
    }

    /**
     * Returns the children of a component of the given class.
     */
    public static <T extends JComponent> List<T> findChildren(JComponent parent, Class<T> childrenClass);

    private static <T extends JComponent> void findChildren(JComponent parent, Class<T> childrenClass, List<T> children);

    /**
     * Returns <code>true</code> if the given rectangle is fully visible at screen.
     */
    public static boolean isRectangleVisibleAtScreen(Rectangle rectangle);
}
","// SwingToolsTest.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.Window;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Area;
import java.awt.image.BufferedImage;
import java.awt.image.FilteredImageSource;
import java.awt.image.RGBImageFilter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.jnlp.BasicService;
import javax.jnlp.ServiceManager;
import javax.jnlp.UnavailableServiceException;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JToggleButton;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.border.AbstractBorder;
import javax.swing.border.Border;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SwingTools}.
* It contains ten unit test cases for the {@link SwingTools#getDropableComponentBorder()} method.
*/
class SwingToolsTest {","// SwingToolsTest.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.Window;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Area;
import java.awt.image.BufferedImage;
import java.awt.image.FilteredImageSource;
import java.awt.image.RGBImageFilter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.jnlp.BasicService;
import javax.jnlp.ServiceManager;
import javax.jnlp.UnavailableServiceException;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JToggleButton;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.border.AbstractBorder;
import javax.swing.border.Border;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SwingTools}.
* It contains ten unit test cases for the {@link SwingTools#getDropableComponentBorder()} method.
*/
class SwingToolsTest {
"
c6577d86-f2ee-464f-95b4-c754d71d99a3,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/TextureChoiceComponent.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 10002 tokens (6002 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// TextureChoiceComponent.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import javax.swing.AbstractListModel;
import javax.swing.BorderFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.TransferHandler;
import javax.swing.border.EtchedBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.HomeTexture;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceController;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * Button displaying a texture as an icon. When the user clicks
 * on this button a dialog appears to let him choose an other texture.
 */
public class TextureChoiceComponent extends JButton implements TextureChoiceView {

    private final UserPreferences preferences;

    /**
     * Creates a texture button.
     */
    public TextureChoiceComponent(final UserPreferences preferences, final TextureChoiceController controller) {
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected texture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteSelectedCatalogTexture();

    /**
     * A panel that displays available textures in a list to let user make choose one.
     */
    private static class TexturePanel extends JPanel {

        private static final int PREVIEW_ICON_HEIGHT = 64;

        private TextureChoiceController controller;

        private TextureImage previewTexture;

        private JLabel chosenTextureLabel;

        private JLabel texturePreviewLabel;

        private JLabel availableTexturesLabel;

        private JList availableTexturesList;

        private JButton importTextureButton;

        private JButton modifyTextureButton;

        private JButton deleteTextureButton;

        public TexturePanel(UserPreferences preferences, TextureChoiceController controller) {
            super(new GridBagLayout());
            this.controller = controller;
            createComponents(preferences, controller);
            setMnemonics(preferences);
            layoutComponents();
        }

        /**
         * Creates and initializes components.
         */
        private void createComponents(final UserPreferences preferences, final TextureChoiceController controller) {
            this.availableTexturesLabel = new JLabel(SwingTools.getLocalizedLabelText(preferences, TextureChoiceComponent.class, ""availableTexturesLabel.text""));
            this.availableTexturesList = new JList(createListModel(preferences.getTexturesCatalog()));
            this.availableTexturesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
            this.availableTexturesList.setCellRenderer(new TextureListCellRenderer());
            this.availableTexturesList.getSelectionModel().addListSelectionListener(new ListSelectionListener() {

                public void valueChanged(ListSelectionEvent ev) {
                    CatalogTexture selectedTexture = (CatalogTexture) availableTexturesList.getSelectedValue();
                    setPreviewTexture(selectedTexture);
                    if (modifyTextureButton != null) {
                        modifyTextureButton.setEnabled(selectedTexture != null && selectedTexture.isModifiable());
                    }
                    if (deleteTextureButton != null) {
                        deleteTextureButton.setEnabled(selectedTexture != null && selectedTexture.isModifiable());
                    }
                }
            });
            this.chosenTextureLabel = new JLabel(preferences.getLocalizedString(TextureChoiceComponent.class, ""chosenTextureLabel.text""));
            this.texturePreviewLabel = new JLabel() {

                private int lastIconWidth;

                @Override
                protected void paintComponent(Graphics g) {
                    // If icon width changed after its loading
                    Icon icon = getIcon();
                    if (icon != null && icon.getIconWidth() != this.lastIconWidth) {
                        // Revalidate label to layout again texture panel
                        this.lastIconWidth = icon.getIconWidth();
                        revalidate();
                    } else {
                        super.paintComponent(g);
                    }
                }

                @Override
                public void setIcon(Icon icon) {
                    if (icon != null) {
                        this.lastIconWidth = icon.getIconWidth();
                    }
                    super.setIcon(icon);
                }
            };
            // Update edited texture in texture panel
            setPreviewTexture(controller.getTexture());
            try {
                String importTextureButtonText = SwingTools.getLocalizedLabelText(preferences, TextureChoiceComponent.class, ""importTextureButton.text"");
                this.texturePreviewLabel.setBorder(SwingTools.getDropableComponentBorder());
                // Add to label a transfer handler to let user drag and drop a file on it
                this.texturePreviewLabel.setTransferHandler(new TransferHandler() {

                    @Override
                    public boolean canImport(JComponent comp, DataFlavor[] flavors) {
                        return Arrays.asList(flavors).contains(DataFlavor.javaFileListFlavor);
                    }

                    @Override
                    public boolean importData(JComponent comp, Transferable transferedFiles) {
                        try {
                            List<File> files = (List<File>) transferedFiles.getTransferData(DataFlavor.javaFileListFlavor);
                            final String textureName = files.get(0).getAbsolutePath();
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    controller.importTexture(textureName);
                                }
                            });
                            return true;
                        } catch (UnsupportedFlavorException ex) {
                            return false;
                        } catch (IOException ex) {
                            return false;
                        }
                    }
                });
                this.importTextureButton = new JButton(importTextureButtonText);
                this.importTextureButton.addActionListener(new ActionListener() {

                    public void actionPerformed(ActionEvent ev) {
                        controller.importTexture();
                    }
                });
                this.modifyTextureButton = new JButton(SwingTools.getLocalizedLabelText(preferences, TextureChoiceComponent.class, ""modifyTextureButton.text""));
                this.modifyTextureButton.setEnabled(false);
                this.modifyTextureButton.addActionListener(new ActionListener() {

                    public void actionPerformed(ActionEvent ev) {
                        controller.modifyTexture((CatalogTexture) availableTexturesList.getSelectedValue());
                    }
                });
                this.deleteTextureButton = new JButton(SwingTools.getLocalizedLabelText(preferences, TextureChoiceComponent.class, ""deleteTextureButton.text""));
                this.deleteTextureButton.setEnabled(false);
                this.deleteTextureButton.addActionListener(new ActionListener() {

                    public void actionPerformed(ActionEvent ev) {
                        controller.deleteTexture((CatalogTexture) availableTexturesList.getSelectedValue());
                    }
                });
                preferences.getTexturesCatalog().addTexturesListener(new TexturesCatalogListener(this));
            } catch (IllegalArgumentException ex) {
                // Do not support import texture if importTextureText isn't defined
                this.texturePreviewLabel.setBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED));
            }
        }

        /**
         * Renderer used to display the textures in list.
         */
        private static class TextureListCellRenderer extends DefaultListCellRenderer {

            private Font defaultFont;

            private Font modifiablePieceFont;

            @Override
            public Component getListCellRendererComponent(final JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                // Initialize fonts if not done
                if (this.defaultFont == null) {
                    this.defaultFont = getFont();
                    this.modifiablePieceFont = new Font(this.defaultFont.getFontName(), Font.ITALIC, this.defaultFont.getSize());
                }
                final CatalogTexture texture = (CatalogTexture) value;
                value = texture.getName();
                value = texture.getCategory().getName() + "" - "" + value;
                Component component = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                setIcon(new Icon() {

                    public int getIconWidth() {
                        return 16;
                    }

                    public int getIconHeight() {
                        return 16;
                    }

                    public void paintIcon(Component c, Graphics g, int x, int y) {
                        Icon icon = IconManager.getInstance().getIcon(texture.getImage(), getIconHeight(), list);
                        if (icon.getIconWidth() != icon.getIconHeight()) {
                            Graphics2D g2D = (Graphics2D) g;
                            AffineTransform previousTransform = g2D.getTransform();
                            g2D.translate(x, y);
                            g2D.scale((float) icon.getIconHeight() / icon.getIconWidth(), 1);
                            icon.paintIcon(c, g2D, 0, 0);
                            g2D.setTransform(previousTransform);
                        } else {
                            icon.paintIcon(c, g, x, y);
                        }
                    }
                });
                setFont(texture.isModifiable() ? this.modifiablePieceFont : this.defaultFont);
                return component;
            }
        }

        /**
         * Catalog listener that updates textures list each time a texture
         * is deleted or added in textures catalog. This listener is bound to this component
         * with a weak reference to avoid strong link between catalog and this component.
         */
        private static class TexturesCatalogListener implements CollectionListener<CatalogTexture> {

            private WeakReference<TexturePanel> texturePanel;

            public TexturesCatalogListener(TexturePanel texturePanel) {
                this.texturePanel = new WeakReference<TexturePanel>(texturePanel);
            }

            public void collectionChanged(CollectionEvent<CatalogTexture> ev) {
                // If controller was garbage collected, remove this listener from catalog
                final TexturePanel texturePanel = this.texturePanel.get();
                if (texturePanel == null) {
                    ((TexturesCatalog) ev.getSource()).removeTexturesListener(this);
                } else {
                    texturePanel.availableTexturesList.setModel(texturePanel.createListModel((TexturesCatalog) ev.getSource()));
                    switch(ev.getType()) {
                        case ADD:
                            texturePanel.availableTexturesList.setSelectedValue(ev.getItem(), true);
                            break;
                        case DELETE:
                            texturePanel.availableTexturesList.clearSelection();
                            break;
                    }
                }
            }
        }

        /**
         * Sets components mnemonics and label / component associations.
         */
        private void setMnemonics(UserPreferences preferences) {
            if (!OperatingSystem.isMacOSX()) {
                this.availableTexturesLabel.setDisplayedMnemonic(KeyStroke.getKeyStroke(preferences.getLocalizedString(TextureChoiceComponent.class, ""availableTexturesLabel.mnemonic"")).getKeyCode());
                this.availableTexturesLabel.setLabelFor(this.availableTexturesList);
                if (this.importTextureButton != null) {
                    this.importTextureButton.setMnemonic(KeyStroke.getKeyStroke(preferences.getLocalizedString(TextureChoiceComponent.class, ""importTextureButton.mnemonic"")).getKeyCode());
                    this.modifyTextureButton.setMnemonic(KeyStroke.getKeyStroke(preferences.getLocalizedString(TextureChoiceComponent.class, ""modifyTextureButton.mnemonic"")).getKeyCode());
                    this.deleteTextureButton.setMnemonic(KeyStroke.getKeyStroke(preferences.getLocalizedString(TextureChoiceComponent.class, ""deleteTextureButton.mnemonic"")).getKeyCode());
                }
            }
        }

        /**
         * Layouts components in panel with their labels.
         */
        private void layoutComponents() {
            // First row
            add(this.availableTexturesLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.LINE_START, GridBagConstraints.NONE, new Insets(0, 0, 5, 15), 0, 0));
            add(this.chosenTextureLabel, new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.LINE_START, GridBagConstraints.NONE, new Insets(0, 0, 5, 0), 0, 0));
            // Second row
            add(new JScrollPane(this.availableTexturesList), new GridBagConstraints(0, 1, 1, 2, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0, 0, 5, 15), 50, 0));
            SwingTools.installFocusBorder(this.availableTexturesList);
            add(this.texturePreviewLabel, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            if (this.importTextureButton != null) {
                // Third row
                JPanel buttonsPanel = new JPanel(new GridLayout(3, 1, 2, 2));
                buttonsPanel.add(this.importTextureButton);
                buttonsPanel.add(this.modifyTextureButton);
                buttonsPanel.add(this.deleteTextureButton);
                add(buttonsPanel, new GridBagConstraints(1, 2, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            }
        }

        /**
         * Returns the chosen texture.
         */
        public TextureImage getPreviewTexture() {
            return this.previewTexture;
        }

        /**
         * Sets the chosen texture.
         */
        public void setPreviewTexture(TextureImage previewTexture) {
            this.previewTexture = previewTexture;
            if (previewTexture != null) {
                this.texturePreviewLabel.setIcon(IconManager.getInstance().getIcon(previewTexture.getImage(), PREVIEW_ICON_HEIGHT, this.texturePreviewLabel));
            } else {
                // Preview a dummy empty icon
                this.texturePreviewLabel.setIcon(new Icon() {

                    public int getIconHeight() {
                        return PREVIEW_ICON_HEIGHT;
                    }

                    public int getIconWidth() {
                        return PREVIEW_ICON_HEIGHT;
                    }

                    public void paintIcon(Component c, Graphics g, int x, int y) {
                    }
                });
            }
            // Update selection in texture list
            this.availableTexturesList.setSelectedValue(previewTexture, true);
            if (this.availableTexturesList.getSelectedValue() != previewTexture) {
                int selectedIndex = this.availableTexturesList.getSelectedIndex();
                this.availableTexturesList.removeSelectionInterval(selectedIndex, selectedIndex);
            }
        }

        /**
         * Returns a list model from textures catalog.
         */
        private AbstractListModel createListModel(TexturesCatalog texturesCatalog) {
            final CatalogTexture[] textures = getTextures(texturesCatalog);
            return new AbstractListModel() {

                public Object getElementAt(int index) {
                    return textures[index];
                }

                public int getSize() {
                    return textures.length;
                }
            };
        }

        /**
         * Returns the array of textures in catalog.
         */
        private CatalogTexture[] getTextures(TexturesCatalog texturesCatalog) {
            List<CatalogTexture> textures = new ArrayList<CatalogTexture>();
            for (TexturesCategory category : texturesCatalog.getCategories()) {
                for (CatalogTexture texture : category.getTextures()) {
                    textures.add(texture);
                }
            }
            return textures.toArray(new CatalogTexture[textures.size()]);
        }

        public void displayView(View textureChoiceComponent) {
            // Show panel in a resizable modal dialog
            final JOptionPane optionPane = new JOptionPane(this, JOptionPane.PLAIN_MESSAGE, JOptionPane.OK_CANCEL_OPTION);
            JComponent parentComponent = SwingUtilities.getRootPane((JComponent) textureChoiceComponent);
            if (parentComponent != null) {
                optionPane.setComponentOrientation(parentComponent.getComponentOrientation());
            }
            final JDialog dialog = optionPane.createDialog(parentComponent, controller.getDialogTitle());
            dialog.applyComponentOrientation(ComponentOrientation.getOrientation(Locale.getDefault()));
            dialog.setResizable(true);
            // Pack again because resize decorations may have changed dialog preferred size
            dialog.pack();
            dialog.setMinimumSize(getPreferredSize());
            // Add a listener that transfer focus to focusable field of texture panel when dialog is shown
            dialog.addComponentListener(new ComponentAdapter() {

                @Override
                public void componentShown(ComponentEvent ev) {
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().focusNextComponent(TexturePanel.this);
                    dialog.removeComponentListener(this);
                }
            });
            this.availableTexturesList.addMouseListener(new MouseAdapter() {

                @Override
                public void mouseClicked(MouseEvent ev) {
                    // Close on double clicks in texture list
                    if (ev.getClickCount() == 2) {
                        optionPane.setValue(JOptionPane.OK_OPTION);
                        availableTexturesList.removeMouseListener(this);
                    }
                }
            });
            dialog.setVisible(true);
            dialog.dispose();
            if (Integer.valueOf(JOptionPane.OK_OPTION).equals(optionPane.getValue())) {
                TextureImage selectedTexture = getPreviewTexture();
                if (selectedTexture instanceof HomeTexture || selectedTexture == null) {
                    this.controller.setTexture((HomeTexture) selectedTexture);
                } else {
                    this.controller.setTexture(new HomeTexture(selectedTexture));
                }
            }
        }
    }
}
","// TextureChoiceComponentTest.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import javax.swing.AbstractListModel;
import javax.swing.BorderFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.TransferHandler;
import javax.swing.border.EtchedBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.HomeTexture;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceController;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextureChoiceComponent}.
* It contains ten unit test cases for the {@link TextureChoiceComponent#confirmDeleteSelectedCatalogTexture()} method.
*/
class TextureChoiceComponentTest {","// TextureChoiceComponentTest.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import javax.swing.AbstractListModel;
import javax.swing.BorderFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.TransferHandler;
import javax.swing.border.EtchedBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.HomeTexture;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceController;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextureChoiceComponent}.
* It contains ten unit test cases for the {@link TextureChoiceComponent#confirmDeleteSelectedCatalogTexture()} method.
*/
class TextureChoiceComponentTest {
"
cmpl-6xFaBmptxV0cnVfhSi9fGfvAvzcu3,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_0Test.java,39.3935341835022,stop,"// OperatingSystem.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 *
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux();

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows();

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX();

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior();

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException;

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles();

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException;

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException;

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_0Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_0Test {","// OperatingSystem_0Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_0Test {

		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_1Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_1Test {
		
		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_2Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_2Test {
		
		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_3Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_3Test {
		
		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_5Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_5Test {
		
		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_6Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_6Test {
		
		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_7Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_7Test {
		
		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_8Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_8Test {
		
		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_9Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_9Test {
		
		@Test
		void testIsLinux() {
				assertTrue(OperatingSystem.isLinux());
		}
}"
cmpl-6xFbEPlzUAwVisnQZvz5AesGiQ6Em,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_1Test.java,40.15885281562805,stop,"// OperatingSystem.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 *
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux();

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows();

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX();

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior();

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException;

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles();

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException;

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException;

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_1Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isWindows()} method.
*/
class OperatingSystem_1Test {","// OperatingSystem_1Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isWindows()} method.
*/
class OperatingSystem_1Test {

		@Test
		void testIsWindows() {
				assertTrue(OperatingSystem.isWindows());
		}
}

// OperatingSystem_2Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isMacOSX()} method.
*/
class OperatingSystem_2Test {
		
		@Test
		void testIsMacOSX() {
				assertFalse(OperatingSystem.isMacOSX());
		}
}

// OperatingSystem_3Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_3Test {
		
		@Test
		void testIsLinux() {
				assertFalse(OperatingSystem.isLinux());
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isMacOSXLeopardOrSuperior()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testIsMacOSXLeopardOrSuperior() {
				assertFalse(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
}

// OperatingSystem_5Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#createTemporaryFile(String, String)} method.
*/
class OperatingSystem_5Test {
		
		@Test
		void testCreateTemporaryFile() {
				assertNotNull(OperatingSystem.createTemporaryFile(""prefix"", ""suffix""));
		}
}

// OperatingSystem_6Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#deleteTemporaryFiles()} method.
*/
class OperatingSystem_6Test {
		
		@Test
		void testDeleteTemporaryFiles() {
				OperatingSystem.deleteTemporaryFiles();
		}
}

// OperatingSystem_7Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultTemporaryFolder(boolean)} method.
*/
class OperatingSystem_7Test {
		
		@Test
		void testGetDefaultTemporaryFolder() {
				assertNotNull(OperatingSystem.getDefaultTemporaryFolder(true));
		}
}

// OperatingSystem_8Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_8Test {
		
		@Test
		void testGetDefaultApplicationFolder() {
				assertNotNull(OperatingSystem.getDefaultApplicationFolder());
		}
}

// OperatingSystem_9Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#MacOSXFileManager#getApplicationSupportFolder()} method.
*/
class OperatingSystem_9Test {
		
		@Test
		void testGetApplicationSupportFolder() {
				assertNotNull(OperatingSystem.MacOSXFileManager.getApplicationSupportFolder());
		}
}"
cmpl-6xFcHUeEC2Lbmd5GbNmHHz7LoxIYo,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_2Test.java,80.55091595649719,length,"// OperatingSystem.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 *
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux();

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows();

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX();

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior();

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException;

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles();

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException;

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException;

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_2Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isMacOSX()} method.
*/
class OperatingSystem_2Test {","// OperatingSystem_2Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isMacOSX()} method.
*/
class OperatingSystem_2Test {

		@Test
		void testIsMacOSX() {
				// Test case 1
				assertTrue(OperatingSystem.isMacOSX());
				// Test case 2
				assertTrue(OperatingSystem.isMacOSX());
				// Test case 3
				assertTrue(OperatingSystem.isMacOSX());
				// Test case 4
				assertTrue(OperatingSystem.isMacOSX());
				// Test case 5
				assertTrue(OperatingSystem.isMacOSX());
				// Test case 6
				assertTrue(OperatingSystem.isMacOSX());
				// Test case 7
				assertTrue(OperatingSystem.isMacOSX());
				// Test case 8
				assertTrue(OperatingSystem.isMacOSX());
				// Test case 9
				assertTrue(OperatingSystem.isMacOSX());
				// Test case 10
				assertTrue(OperatingSystem.isMacOSX());
		}
}

// OperatingSystem_3Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isMacOSXLeopardOrSuperior()} method.
*/
class OperatingSystem_3Test {
		
		@Test
		void testIsMacOSXLeopardOrSuperior() {
				// Test case 1
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
				// Test case 2
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
				// Test case 3
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
				// Test case 4
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
				// Test case 5
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
				// Test case 6
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
				// Test case 7
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
				// Test case 8
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
				// Test case 9
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
				// Test case 10
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#createTemporaryFile(String, String)} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testCreateTemporaryFile() {
				// Test case 1
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
				// Test case 2
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
				// Test case 3
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
				// Test case 4
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
				// Test case 5
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
				// Test case 6
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
				// Test case 7
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
				// Test case 8
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
				// Test case 9
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
				// Test case 10
				assertTrue(OperatingSystem.createTemporaryFile(""prefix"", ""suffix"") != null);
		}
}

// OperatingSystem_5Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#deleteTemporaryFiles()} method.
*/
class OperatingSystem_5Test {
		
		@Test
		void testDeleteTemporaryFiles() {
				// Test case 1
				OperatingSystem.deleteTemporaryFiles();
				// Test case 2
				OperatingSystem.deleteTemporaryFiles();
				// Test case 3
				OperatingSystem.deleteTemporaryFiles();
				// Test case 4
				OperatingSystem.deleteTemporaryFiles();
				// Test case 5
				OperatingSystem.deleteTemporaryFiles();
				// Test case 6
				OperatingSystem.deleteTemporaryFiles();
				// Test case 7
				OperatingSystem.deleteTemporaryFiles();
				// Test case 8
				OperatingSystem.deleteTemporaryFiles();
				// Test case 9
				OperatingSystem.deleteTemporaryFiles();
				// Test case 10
				OperatingSystem.deleteTemporaryFiles();
		}
}

// OperatingSystem_6Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultTemporaryFolder(boolean)} method.
*/
class OperatingSystem_6Test {
		
		@Test
		void testGetDefaultTemporaryFolder() {
				// Test case 1
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
				// Test case 2
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
				// Test case 3
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
				// Test case 4
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
				// Test case 5
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
				// Test case 6
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
				// Test case 7
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
				// Test case 8
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
				// Test case 9
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
				// Test case 10
				assertTrue(OperatingSystem.getDefaultTemporaryFolder(true) != null);
		}
}

// OperatingSystem_7Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_7Test {
		
		@Test
		void testGetDefaultApplicationFolder() {
				// Test case 1
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
				// Test case 2
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
				// Test case 3
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
				// Test case 4
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
				// Test case 5
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
				// Test case 6
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
				// Test case 7
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
				// Test case 8
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
				// Test case 9
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
				// Test case 10
				assertTrue(OperatingSystem.getDefaultApplicationFolder() != null);
		}
}

// OperatingSystem_8Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getApplicationSupportFolder()} method.
*/
class OperatingSystem_8Test {
		
		@Test
		void testGetApplicationSupportFolder() {
				// Test case 1
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 2
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 3
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 4
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 5
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 6
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 7
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 8
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 9
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 10
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
		}
}

// OperatingSystem_9Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getApplicationSupportFolder()} method.
*/
class OperatingSystem_9Test {
		
		@Test
		void testGetApplicationSupportFolder() {
				// Test case 1
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 2
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 3
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 4
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 5
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 6
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 7
				assertTrue(OperatingSystem.getApplicationSupportFolder() != null);
				// Test case 8
				assertTrue(OperatingSystem"
cmpl-6xFdaLoJeGhIOKdUnOJFo8aOSbSJz,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_3Test.java,87.6517026424408,length,"// OperatingSystem.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 *
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux();

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows();

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX();

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior();

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException;

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles();

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException;

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException;

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_3Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isMacOSXLeopardOrSuperior()} method.
*/
class OperatingSystem_3Test {","// OperatingSystem_3Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isMacOSXLeopardOrSuperior()} method.
*/
class OperatingSystem_3Test {

		@Test
		void testIsMacOSXLeopardOrSuperior_1() {
				// Test case 1
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
		
		@Test
		void testIsMacOSXLeopardOrSuperior_2() {
				// Test case 2
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
		
		@Test
		void testIsMacOSXLeopardOrSuperior_3() {
				// Test case 3
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
		
		@Test
		void testIsMacOSXLeopardOrSuperior_4() {
				// Test case 4
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
		
		@Test
		void testIsMacOSXLeopardOrSuperior_5() {
				// Test case 5
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
		
		@Test
		void testIsMacOSXLeopardOrSuperior_6() {
				// Test case 6
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
		
		@Test
		void testIsMacOSXLeopardOrSuperior_7() {
				// Test case 7
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
		
		@Test
		void testIsMacOSXLeopardOrSuperior_8() {
				// Test case 8
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
		
		@Test
		void testIsMacOSXLeopardOrSuperior_9() {
				// Test case 9
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
		
		@Test
		void testIsMacOSXLeopardOrSuperior_10() {
				// Test case 10
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSXLeopardOrSuperior());
		}
}

// OperatingSystem_2Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isMacOSX()} method.
*/
class OperatingSystem_2Test {
		
		@Test
		void testIsMacOSX_1() {
				// Test case 1
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
		
		@Test
		void testIsMacOSX_2() {
				// Test case 2
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
		
		@Test
		void testIsMacOSX_3() {
				// Test case 3
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
		
		@Test
		void testIsMacOSX_4() {
				// Test case 4
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
		
		@Test
		void testIsMacOSX_5() {
				// Test case 5
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
		
		@Test
		void testIsMacOSX_6() {
				// Test case 6
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
		
		@Test
		void testIsMacOSX_7() {
				// Test case 7
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
		
		@Test
		void testIsMacOSX_8() {
				// Test case 8
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
		
		@Test
		void testIsMacOSX_9() {
				// Test case 9
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
		
		@Test
		void testIsMacOSX_10() {
				// Test case 10
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isMacOSX());
		}
}

// OperatingSystem_1Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_1Test {
		
		@Test
		void testIsLinux_1() {
				// Test case 1
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
		
		@Test
		void testIsLinux_2() {
				// Test case 2
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
		
		@Test
		void testIsLinux_3() {
				// Test case 3
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
		
		@Test
		void testIsLinux_4() {
				// Test case 4
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
		
		@Test
		void testIsLinux_5() {
				// Test case 5
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
		
		@Test
		void testIsLinux_6() {
				// Test case 6
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
		
		@Test
		void testIsLinux_7() {
				// Test case 7
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
		
		@Test
		void testIsLinux_8() {
				// Test case 8
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
		
		@Test
		void testIsLinux_9() {
				// Test case 9
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
		
		@Test
		void testIsLinux_10() {
				// Test case 10
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isLinux());
		}
}

// OperatingSystem_0Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#isWindows()} method.
*/
class OperatingSystem_0Test {
		
		@Test
		void testIsWindows_1() {
				// Test case 1
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isWindows());
		}
		
		@Test
		void testIsWindows_2() {
				// Test case 2
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isWindows());
		}
		
		@Test
		void testIsWindows_3() {
				// Test case 3
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isWindows());
		}
		
		@Test
		void testIsWindows_4() {
				// Test case 4
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isWindows());
		}
		
		@Test
		void testIsWindows_5() {
				// Test case 5
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isWindows());
		}
		
		@Test
		void testIsWindows_6() {
				// Test case 6
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isWindows());
		}
		
		@Test
		void testIsWindows_7() {
				// Test case 7
				// Inputs:
				// Outputs:
				// Expected result:
				// Assertion:
				assertTrue(OperatingSystem.isWindows());
		}
		
		@Test
		void testIsWindows_8() {
				//"
cmpl-6xFezCIQXB43nZLiXdXbf2qpdnOPA,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_4Test.java,92.97496914863586,length,"// OperatingSystem.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 *
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux();

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows();

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX();

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior();

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException;

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles();

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException;

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException;

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {","// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {

		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
		}
}

// OperatingSystem_4Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains ten unit test cases for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_4Test {
		
		@Test
		void testGetDefaultApplicationFolder() throws IOException {
				// Test 1
				// Test 2
				// Test 3
				// Test 4
				// Test 5
				// Test 6
				// Test 7
				// Test 8
				// Test 9
				// Test 10
"
cmpl-6xFgUD1KnbUVdYBar1YlGTTUFwoZf,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/URLContent.java,26.119099617004395,stop,"// URLContent.java
package com.eteks.sweethome3d.tools;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import com.eteks.sweethome3d.model.Content;

/**
 * URL content for files, images...
 *
 * @author Emmanuel Puybaret
 */
public class URLContent implements Content {

    private static final long serialVersionUID = 1L;

    private URL url;

    public URLContent(URL url) {
    }

    /**
     * Returns the URL of this content.
     */
    public URL getURL();

    /**
     * Returns an InputStream on the URL content.
     * @throws IOException if URL stream can't be opened.
     */
    public InputStream openStream() throws IOException;

    /**
     * Returns <code>true</code> if the URL stored by this content
     * references an entry in a JAR.
     */
    public boolean isJAREntry();

    /**
     * Returns the URL base of a JAR entry.
     * @throws IllegalStateException if the URL of this content
     *                    doesn't reference an entry in a JAR.
     */
    public URL getJAREntryURL();

    /**
     * Returns the name of a JAR entry.
     * If the JAR entry in the URL given at creation time was encoded in application/x-www-form-urlencoded format,
     * this method will return it unchanged and not decoded.
     * @throws IllegalStateException if the URL of this content
     *                    doesn't reference an entry in a JAR URL.
     */
    public String getJAREntryName();

    /**
     * Returns <code>true</code> if the object in parameter is an URL content
     * that references the same URL as this object.
     */
    @Override
    public boolean equals(Object obj);

    @Override
    public int hashCode();
}
","// URLContentTest.java
package com.eteks.sweethome3d.tools;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import com.eteks.sweethome3d.model.Content;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link URLContent}.
* It contains ten unit test cases for the {@link URLContent#openStream()} method.
*/
class URLContentTest {","// URLContentTest.java
package com.eteks.sweethome3d.tools;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import com.eteks.sweethome3d.model.Content;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link URLContent}.
* It contains ten unit test cases for the {@link URLContent#openStream()} method.
*/
class URLContentTest {

	@Test
	public void testOpenStream() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""http://www.eteks.com/""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntry() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntryWithEncodedURL() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home%20%26%20Furniture.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntryWithEncodedURLAndEncodedJAREntry() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home%20%26%20Furniture.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntryWithEncodedURLAndEncodedJAREntryAndEncodedURL() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home%20%26%20Furniture.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntryWithEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntry() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home%20%26%20Furniture.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntryWithEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntryAndEncodedURL() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home%20%26%20Furniture.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntryWithEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntry() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home%20%26%20Furniture.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntryWithEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntryAndEncodedURL() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home%20%26%20Furniture.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntryWithEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntry() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home%20%26%20Furniture.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
	
	@Test
	public void testOpenStreamWithJAREntryWithEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntryAndEncodedURLAndEncodedJAREntryAndEncodedURL() throws MalformedURLException, IOException {
		URLContent urlContent = new URLContent(new URL(""jar:http://www.eteks.com/sweethome3d.jar!/com/eteks/sweethome3d/model/Home%20%26%20Furniture.class""));
		InputStream stream = urlContent.openStream();
		assertNotNull(stream);
		stream.close();
	}
}"
cmpl-6xFhXpebCGHb2736n82iwgdxvyvF2,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/viewcontroller/UserPreferencesController.java,99.20935392379761,length,"// UserPreferencesController.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;

/**
 * A MVC controller for user preferences view.
 *
 * @author Emmanuel Puybaret
 */
public class UserPreferencesController implements Controller {

    /**
     * The properties that may be edited by the view associated to this controller.
     */
    public enum Property {

        LANGUAGE,
        UNIT,
        MAGNETISM_ENABLED,
        RULERS_VISIBLE,
        GRID_VISIBLE,
        FURNITURE_VIEWED_FROM_TOP,
        ROOM_FLOOR_COLORED_OR_TEXTURED,
        WALL_PATTERN,
        NEW_WALL_THICKNESS,
        NEW_WALL_HEIGHT,
        NEW_FLOOR_THICKNESS,
        FURNITURE_CATALOG_VIEWED_IN_TREE,
        NAVIGATION_PANEL_VISIBLE,
        AUTO_SAVE_DELAY_FOR_RECOVERY,
        AUTO_SAVE_FOR_RECOVERY_ENABLED
    }

    private final UserPreferences preferences;

    private final ViewFactory viewFactory;

    private final HomeController homeController;

    private final PropertyChangeSupport propertyChangeSupport;

    private DialogView userPreferencesView;

    private String language;

    private LengthUnit unit;

    private boolean furnitureCatalogViewedInTree;

    private boolean navigationPanelVisible;

    private boolean magnetismEnabled;

    private boolean rulersVisible;

    private boolean gridVisible;

    private boolean furnitureViewedFromTop;

    private boolean roomFloorColoredOrTextured;

    private TextureImage wallPattern;

    private float newWallThickness;

    private float newWallHeight;

    private float newFloorThickness;

    private int autoSaveDelayForRecovery;

    private boolean autoSaveForRecoveryEnabled;

    /**
     * Creates the controller of user preferences view.
     */
    public UserPreferencesController(UserPreferences preferences, ViewFactory viewFactory, ContentManager contentManager) {
    }

    /**
     * Creates the controller of user preferences view.
     */
    public UserPreferencesController(UserPreferences preferences, ViewFactory viewFactory, ContentManager contentManager, HomeController homeController) {
    }

    /**
     * Returns the view associated with this controller.
     */
    public DialogView getView();

    /**
     * Displays the view controlled by this controller.
     */
    public void displayView(View parentView);

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     */
    public void addPropertyChangeListener(Property property, PropertyChangeListener listener);

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     */
    public void removePropertyChangeListener(Property property, PropertyChangeListener listener);

    /**
     * Updates preferences properties edited by this controller.
     */
    protected void updateProperties();

    /**
     * Returns <code>true</code> if the given <code>property</code> is editable.
     * Depending on whether a property is editable or not, the view associated to this controller
     * may render it differently.
     * The implementation of this method always returns <code>true</code> except for <code>LANGUAGE</code> if it's not editable.
     */
    public boolean isPropertyEditable(Property property);

    /**
     * Sets the edited language.
     */
    public void setLanguage(String language);

    /**
     * Returns the edited language.
     */
    public String getLanguage();

    /**
     * Sets the edited unit.
     */
    public void setUnit(LengthUnit unit);

    /**
     * Returns the edited unit.
     */
    public LengthUnit getUnit();

    /**
     * Sets whether the furniture catalog should be viewed in a tree or a different way.
     */
    public void setFurnitureCatalogViewedInTree(boolean furnitureCatalogViewedInTree);

    /**
     * Returns <code>true</code> if furniture catalog should be viewed in a tree.
     */
    public boolean isFurnitureCatalogViewedInTree();

    /**
     * Sets whether the navigation panel should be displayed or not.
     */
    public void setNavigationPanelVisible(boolean navigationPanelVisible);

    /**
     * Returns <code>true</code> if the navigation panel should be displayed.
     */
    public boolean isNavigationPanelVisible();

    /**
     * Sets whether magnetism is enabled or not.
     */
    public void setMagnetismEnabled(boolean magnetismEnabled);

    /**
     * Returns whether magnetism is enabled or not.
     */
    public boolean isMagnetismEnabled();

    /**
     * Sets whether rulers are visible or not.
     */
    public void setRulersVisible(boolean rulersVisible);

    /**
     * Returns whether rulers are visible or not.
     */
    public boolean isRulersVisible();

    /**
     * Sets whether grid is visible or not.
     */
    public void setGridVisible(boolean gridVisible);

    /**
     * Returns whether grid is visible or not.
     */
    public boolean isGridVisible();

    /**
     * Sets how furniture should be displayed in plan.
     */
    public void setFurnitureViewedFromTop(boolean furnitureViewedFromTop);

    /**
     * Returns how furniture should be displayed in plan.
     */
    public boolean isFurnitureViewedFromTop();

    /**
     * Sets whether floor texture is visible in plan or not.
     */
    public void setRoomFloorColoredOrTextured(boolean floorTextureVisible);

    /**
     * Returns <code>true</code> if floor texture is visible in plan.
     */
    public boolean isRoomFloorColoredOrTextured();

    /**
     * Sets how furniture should be displayed in plan, and notifies
     * listeners of this change.
     */
    public void setWallPattern(TextureImage wallPattern);

    /**
     * Returns the wall pattern in plan.
     */
    public TextureImage getWallPattern();

    /**
     * Sets the edited new wall thickness.
     */
    public void setNewWallThickness(float newWallThickness);

    /**
     * Returns the edited new wall thickness.
     */
    public float getNewWallThickness();

    /**
     * Sets the edited new wall height.
     */
    public void setNewWallHeight(float newWallHeight);

    /**
     * Returns the edited new wall height.
     */
    public float getNewWallHeight();

    /**
     * Sets the edited new floor thickness.
     */
    public void setNewFloorThickness(float newFloorThickness);

    /**
     * Returns the edited new floor thickness.
     */
    public float getNewFloorThickness();

    /**
     * Sets the edited auto recovery save delay.
     */
    public void setAutoSaveDelayForRecovery(int autoSaveDelayForRecovery);

    /**
     * Returns the edited auto recovery save delay.
     */
    public int getAutoSaveDelayForRecovery();

    /**
     * Sets whether auto recovery save is enabled or not.
     */
    public void setAutoSaveForRecoveryEnabled(boolean autoSaveForRecoveryEnabled);

    /**
     * Returns <code>true</code> if auto recovery save is enabled.
     */
    public boolean isAutoSaveForRecoveryEnabled();

    /**
     * Returns <code>true</code> if language libraries can be imported.
     */
    public boolean mayImportLanguageLibrary();

    /**
     * Imports a language library chosen by the user.
     */
    public void importLanguageLibrary();

    /**
     * Controls the modification of user preferences.
     */
    public void modifyUserPreferences();

    /**
     * Resets the displayed flags of action tips.
     */
    public void resetDisplayedActionTips();
}
","// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {","// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {

		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {
		
		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {
		
		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {
		
		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {
		
		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {
		
		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {
		
		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {
		
		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {
		
		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains ten unit test cases for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesControllerTest {
		
		@Test
		public void testMayImportLanguageLibrary() {
				UserPreferences preferences = new UserPreferences();
				ViewFactory viewFactory = new ViewFactory() {
						@Override
						public DialogView createUserPreferencesView(UserPreferencesController controller, View parentView) {
								return null;
						}
				};
				ContentManager contentManager = new ContentManager() {
						@Override
						public void importLanguageLibrary(String languageLibraryName) {
						}
				};
				UserPreferencesController controller = new UserPreferencesController(preferences, viewFactory, contentManager);
				assertTrue(controller.mayImportLanguageLibrary());
		}
}

// UserPreferencesControllerTest.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController"
