ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wsTzR2NhFAz6IrhrnHTmfwK8jN2N,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer0.java,78.26034355163574,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {

		@Test
		void testGetComponent() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				
				FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""FINDLABEL"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""FINDLABEL"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""TEXTFIELD"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""TEXTFIELD"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""FINDBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""FINDBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB11"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB11"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB12"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB12"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB21"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB21"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB22"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB22"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CANSELBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CANSELBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""FINDLABEL"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""FINDLABEL"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""TEXTFIELD"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""TEXTFIELD"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""FINDBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""FINDBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB11"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB11"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB12"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB12"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB21"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB21"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB22"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB22"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CANSELBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CANSELBUTTON"").getComponent());
		}
}

// FunctionsOnComponent.java
package glengineer.agents;

import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * This interface is implemented by the {@link ComponentAgent} class.
 * It provides methods for setting the alignment and the size of a component.
 *
 * @author Yevgen Ivakhno
 * @version 1.0, 07/05/2009
 */
public interface FunctionsOnComponent {

    /**
     * Sets the alignment of the component.
     *
     * @param alignment the alignment of the component
     * @return the {@link ComponentAgent} object itself
     */
    public ComponentAgent setAlignment(Alignment alignment);

    /**
     * Sets the size of the component.
     *
     * @param size the size of the component
     * @return the {@link ComponentAgent} object itself
     */
    public ComponentAgent setSize(int size);

    /**
     * Sets the size of the component.
     *
     * @param minSize the minimum size of the component
     * @param prefSize the preferred size of the component
     * @param maxSize the maximum size of the component
     * @return the {@link ComponentAgent} object itself
     */
    public ComponentAgent setSize(int minSize, int prefSize, int maxSize);

    /**
     * Sets the size of the component.
     *
     * @param size the size of the component
     * @return the {@link ComponentAgent} object itself
     */
    public ComponentAgent setSize(int[] size);

    /**
     * Sets the size of the component.
     *
     * @param size the size of the component
     * @return the {@link ComponentAgent} object itself
     */
    public ComponentAgent setSize(Size size);

    /**
     * Sets the size of the component.
     *
     * @param size the size of the component
     * @return the {@link ComponentAgent} object itself
     */
    public ComponentAgent setSize(Size[] size);

    /**
     * Sets the size of the component.
     *
     * @param size the size of the component
     * @return the {@link ComponentAgent} object itself
     */
    public Component"
cmpl-6wsVFd8RRLF5ve9BjUyoYwKfrlIbb,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer1.java,58.676491022109985,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

		/**
		* Test case 1.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are not in the same group.
		* <p>
		* The expected result is {@code null}.
		*/
		@Test
		void testGetGroup1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""C""));
		}
		
		/**
		* Test case 2.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""B""));
		}
		
		/**
		* Test case 3.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a parallel group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.VERTICAL, ""D"", ""F""));
		}
		
		/**
		* Test case 4.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a sequential group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup4() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""C""));
		}
		
		/**
		* Test case 5.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a sequential group,
		* and the group is a subgroup of another group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup5() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""B""));
		}
		
		/**
		* Test case 6.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a parallel group,
		* and the group is a subgroup of another group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup6() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"","
cmpl-6wsWIdlW3TxmqxA7EvjrMPApQbOGp,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer2.java,57.64906859397888,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

		@Test
		void testGetParallelGroup1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 3);
		}
		
		@Test
		void testGetParallelGroup2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 3);
		}
		
		@Test
		void testGetParallelGroup3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 3);
		}
		
		@Test
		void testGetParallelGroup4() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 3);
		}
		
		@Test
		void testGetParallelGroup5() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis"
cmpl-6wsXL5bCvRJYIm8tVcRt4zDOlcMoB,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer3.java,66.98602676391602,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

		@Test
		void testGetSequentialGroup1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup4() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getGroup(""FINDLABEL"", ""FINDBUTTON"").getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup5() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel"")"
cmpl-6wsYQWqw8yyKwojHgcdprx4CXAi68,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer4.java,68.90413069725037,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {

		@Test
		void testGetTopSequentialGroup() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
				gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
						.setContentAlignment(Alignment.BASELINE);
				gle.setAutoCreateGaps(true);
				gle.setAutoCreateContainerGaps(true);
				gle.engineer();
				
				FunctionsOnTopSequentialGroup topSequentialGroup = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getComponentCount(), 0);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getAlignment(), Alignment.LEADING);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getResizeBehavior(), ResizeBehavior.NONE);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getSize(), 0);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getPreferredSize(), 0);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getMaximumSize(), 0);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getMinimumSize(), 0);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"", ""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"", ""CB22"").getGroup().getLayoutStyle(), null);
				assertEquals(topSequentialGroup.getGroup(""FINDLABEL"", ""TEX"
cmpl-6wsZXClWPPgtUpD4gkKMd9goFrXPt,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent0.java,79.15557837486267,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {

	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertTrue(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_3() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_4() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_5() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_6() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_7() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_8() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_9() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_10() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
}

// ParallelGroupSettings.java
package glengineer.agents.settings;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ������������� ������������� ������������ ������.
 */
public class ParallelGroupSettings {

    private Alignment alignment;
    private boolean resizable;
    private boolean containsGapsOnly;

    public ParallelGroupSettings(Alignment alignment, boolean resizable, boolean containsGapsOnly) {
        this.alignment = alignment;
        this.resizable = resizable;
        this.containsGapsOnly = containsGapsOnly;
    }

    public Alignment getAlignment() {
        return alignment;
    }

    public boolean isResizable() {
        return resizable;
    }

    public boolean isContainsGapsOnly() {
        return containsGapsOnly;
    }
}

// SequentialGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class SequentialGroupAgent extends GroupAgent {

    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }
}

// SequentialGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#containsGapsOnly()} method.
*/
class SequentialGroupAgentTest {
		
	@Test
	void testContainsGapsOnly_1() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertTrue(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_2() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_3() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_4() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_5() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
"
cmpl-6wsaoJIO1rZJA7TZsz6pH5dxWnJE8,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent1.java,74.85376405715942,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {

	/**
	* Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has no children.
	*/
	@Test
	void testGroupContent_noChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addComponentToGroup(ParallelGroup group, Agent agent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(0, result.getSize());
	}
	
	/**
	* Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has one child.
	*/
	@Test
	void testGroupContent_oneChild() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new ComponentAgent());
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addComponentToGroup(ParallelGroup group, Agent agent) {
				group.addComponent(agent.getComponent());
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(1, result.getSize());
		Iterator<FunctionsOnParallelGroupAndElement> iterator = result.iterator();
		FunctionsOnParallelGroupAndElement element = iterator.next();
		assertEquals(FunctionsOnParallelGroup.ADD_COMPONENT, element.getFunction());
		assertEquals(agent.getChildrenAgents().get(0).getComponent(), element.getElement());
	}
	
	/**
	* Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has two children.
	*/
	@Test
	void testGroupContent_twoChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addComponentToGroup(ParallelGroup group, Agent agent) {
				group.addComponent(agent.getComponent());
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(2, result.getSize());
		Iterator<FunctionsOnParallelGroupAndElement> iterator = result.iterator();
		FunctionsOnParallelGroupAndElement element = iterator.next();
		assertEquals(FunctionsOnParallelGroup.ADD_COMPONENT, element.getFunction());
		assertEquals(agent.getChildrenAgents().get(0).getComponent(), element.getElement());
		element = iterator.next();
		assertEquals(FunctionsOnParallelGroup.ADD_COMPONENT, element.getFunction());
		assertEquals(agent.getChildrenAgents().get(1).getComponent(), element.getElement());
	}
	
	/**
	* Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has three children.
	*/
	@Test
	void testGroupContent_threeChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addComponentToGroup(ParallelGroup group, Agent agent) {
				group.addComponent(agent.getComponent());
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(3, result.getSize());
		Iterator<FunctionsOnParallelGroupAndElement> iterator = result.iterator();
		FunctionsOnParallelGroupAndElement element = iterator.next();
		assertEquals(FunctionsOnParallelGroup.ADD_COMPONENT, element.getFunction());
		assertEquals(agent.getChildrenAgents().get(0).getComponent(), element.getElement());
		element = iterator.next();
		assertEquals(FunctionsOnParallelGroup.ADD_COMPONENT, element.getFunction());
		assertEquals(agent.getChildrenAgents().get(1).getComponent(), element.getElement());
		element = iterator.next();
		assertEquals(FunctionsOnParallelGroup.ADD_COMPONENT, element.getFunction());
		assertEquals(agent.getChildrenAgents().get(2).getComponent(), element.getElement());
	}
	
	/**
	* Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the agent has four children.
	*/
	@Test
	void testGroupContent_fourChildren() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings(Alignment.LEADING));
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		ParallelGroup result = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(settings.getAlignment());
			}
			@Override
			public void addComponentToGroup(ParallelGroup group, Agent agent) {
				group.addComponent(agent.getComponent());
			}
		});
		assertEquals(Alignment.LEADING, result.getAlignment());
		assertEquals(4, result.getSize());
		Iterator<FunctionsOnParallelGroupAndElement> iterator = result.iterator();
		FunctionsOnParallelGroupAndElement element = iterator.next();
		assertEquals(FunctionsOnParallelGroup.ADD_COMPONENT, element.getFunction());
		assertEquals(agent.getChildrenAgents().get(0).getComponent(), element.getElement());
		element = iterator.next();
		assertEquals(FunctionsOnParallelGroup.ADD_COMPONENT, element.getFunction());
		assertEquals(agent.getChildrenAgents().get(1).getComponent(), element.getElement());
		element = iterator.next();
		assert"
cmpl-6wsc1eFpiEW3oL21mc0xRe9o5fsOq,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java,68.01966333389282,length,"// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * �����, �������������� ���������������� ������.
 */
public class SequentialGroupAgent extends GroupAgent {

    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }
}
","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {

	@Test
	void testGroupContent_empty() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(0, result.getChildCount());
	}
	
	@Test
	void testGroupContent_oneChild() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(1, result.getChildCount());
	}
	
	@Test
	void testGroupContent_twoChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(2, result.getChildCount());
	}
	
	@Test
	void testGroupContent_threeChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(3, result.getChildCount());
	}
	
	@Test
	void testGroupContent_fourChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(4, result.getChildCount());
	}
	
	@Test
	void testGroupContent_fiveChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(5, result.getChildCount());
	}
	
	@Test
	void testGroupContent_sixChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(6, result.getChildCount());
	}
	
	@Test
	void testGroupContent_sevenChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(7, result.getChildCount());
	}
	
	@Test
	void testGroupContent_eightChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(8, result.getChildCount());
	}
	
	@Test
	void testGroupContent_nineChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(9, result.getChildCount());
	}
	
	@Test
	void testGroupContent_tenChildren() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		agent.addChild(new ParallelGroupAgent());
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder();
		SequentialGroup result = agent.groupContent(creatorAndAdder);
		assertEquals(10, result.getChildCount());
	}
}

// GroupCreatorAndElementAdder.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * �����, �������������� ���������������� ������.
 */
public class GroupCreatorAndElementAdder {

    public SequentialGroup createSequentialGroup() {
        return new SequentialGroup();
    }

    public ParallelGroup createParallelGroup() {
        return new ParallelGroup();
    }

    public void addComponentToGroup(ComponentAgent componentAgent, ParallelGroup group) {
        group.addComponent(componentAgent.getComponent());
    }

    public void addGroupToGroup(GroupAgent groupAgent, SequentialGroup group) {
        group.addGroup(groupAgent.groupContent(this));
    }
}

// GroupCreatorAndElementAdderTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax."
cmpl-6wseOco6g4dTu7yzYryCqXsARZKg2,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java,146.95699501037598,length,"// TopSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * �����, �������������� ���������������� ������ �������� ������.
 * <p>
 * ��������� ��������� {@code FunctionsOnTopSequentialGroup}
 * ���������� �������������� ������������ �����������
 * � ������ � � ����� ���������������� ������ �������� ������.
 */
public class TopSequentialGroupAgent extends SequentialGroupAgent {

    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        if (precedingContainerGap != null)
            precedingContainerGap.addOneselfToGroup(result);
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        if (followingContainerGap != null)
            followingContainerGap.addOneselfToGroup(result);
        return result;
    }
}
","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {

	@Test
	void testGroupContent_1() {
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		agent.addChild(new ComponentAgent(""component4""));
		agent.addChild(new ComponentAgent(""component5""));
		agent.addChild(new ComponentAgent(""component6""));
		agent.addChild(new ComponentAgent(""component7""));
		agent.addChild(new ComponentAgent(""component8""));
		agent.addChild(new ComponentAgent(""component9""));
		agent.addChild(new ComponentAgent(""component10""));
		agent.addChild(new ComponentAgent(""component11""));
		agent.addChild(new ComponentAgent(""component12""));
		agent.addChild(new ComponentAgent(""component13""));
		agent.addChild(new ComponentAgent(""component14""));
		agent.addChild(new ComponentAgent(""component15""));
		agent.addChild(new ComponentAgent(""component16""));
		agent.addChild(new ComponentAgent(""component17""));
		agent.addChild(new ComponentAgent(""component18""));
		agent.addChild(new ComponentAgent(""component19""));
		agent.addChild(new ComponentAgent(""component20""));
		agent.addChild(new ComponentAgent(""component21""));
		agent.addChild(new ComponentAgent(""component22""));
		agent.addChild(new ComponentAgent(""component23""));
		agent.addChild(new ComponentAgent(""component24""));
		agent.addChild(new ComponentAgent(""component25""));
		agent.addChild(new ComponentAgent(""component26""));
		agent.addChild(new ComponentAgent(""component27""));
		agent.addChild(new ComponentAgent(""component28""));
		agent.addChild(new ComponentAgent(""component29""));
		agent.addChild(new ComponentAgent(""component30""));
		agent.addChild(new ComponentAgent(""component31""));
		agent.addChild(new ComponentAgent(""component32""));
		agent.addChild(new ComponentAgent(""component33""));
		agent.addChild(new ComponentAgent(""component34""));
		agent.addChild(new ComponentAgent(""component35""));
		agent.addChild(new ComponentAgent(""component36""));
		agent.addChild(new ComponentAgent(""component37""));
		agent.addChild(new ComponentAgent(""component38""));
		agent.addChild(new ComponentAgent(""component39""));
		agent.addChild(new ComponentAgent(""component40""));
		agent.addChild(new ComponentAgent(""component41""));
		agent.addChild(new ComponentAgent(""component42""));
		agent.addChild(new ComponentAgent(""component43""));
		agent.addChild(new ComponentAgent(""component44""));
		agent.addChild(new ComponentAgent(""component45""));
		agent.addChild(new ComponentAgent(""component46""));
		agent.addChild(new ComponentAgent(""component47""));
		agent.addChild(new ComponentAgent(""component48""));
		agent.addChild(new ComponentAgent(""component49""));
		agent.addChild(new ComponentAgent(""component50""));
		agent.addChild(new ComponentAgent(""component51""));
		agent.addChild(new ComponentAgent(""component52""));
		agent.addChild(new ComponentAgent(""component53""));
		agent.addChild(new ComponentAgent(""component54""));
		agent.addChild(new ComponentAgent(""component55""));
		agent.addChild(new ComponentAgent(""component56""));
		agent.addChild(new ComponentAgent(""component57""));
		agent.addChild(new ComponentAgent(""component58""));
		agent.addChild(new ComponentAgent(""component59""));
		agent.addChild(new ComponentAgent(""component60""));
		agent.addChild(new ComponentAgent(""component61""));
		agent.addChild(new ComponentAgent(""component62""));
		agent.addChild(new ComponentAgent(""component63""));
		agent.addChild(new ComponentAgent(""component64""));
		agent.addChild(new ComponentAgent(""component65""));
		agent.addChild(new ComponentAgent(""component66""));
		agent.addChild(new ComponentAgent(""component67""));
		agent.addChild(new ComponentAgent(""component68""));
		agent.addChild(new ComponentAgent(""component69""));
		agent.addChild(new ComponentAgent(""component70""));
		agent.addChild(new ComponentAgent(""component71""));
		agent.addChild(new ComponentAgent(""component72""));
		agent.addChild(new ComponentAgent(""component73""));
		agent.addChild(new ComponentAgent(""component74""));
		agent.addChild(new ComponentAgent(""component75""));
		agent.addChild(new ComponentAgent(""component76""));
		agent.addChild(new ComponentAgent(""component77""));
		agent.addChild(new ComponentAgent(""component78""));
		agent.addChild(new ComponentAgent(""component79""));
		agent.addChild(new ComponentAgent(""component80""));
		agent.addChild(new ComponentAgent(""component81""));
		agent.addChild(new ComponentAgent(""component82""));
		agent.addChild(new ComponentAgent(""component83""));
		agent.addChild(new ComponentAgent(""component84""));
		agent.addChild(new ComponentAgent(""component85""));
		agent.addChild(new ComponentAgent(""component86""));
		agent.addChild(new ComponentAgent(""component87""));
		agent.addChild(new ComponentAgent(""component88""));
		agent.addChild(new ComponentAgent(""component89""));
		agent.addChild(new ComponentAgent(""component90""));
		agent.addChild(new ComponentAgent(""component91""));
		agent.addChild(new ComponentAgent(""component92""));
		agent.addChild(new ComponentAgent(""component93""));
		agent.addChild(new ComponentAgent(""component94""));
		agent.addChild(new ComponentAgent(""component95""));
		agent.addChild(new ComponentAgent(""component96""));
		agent.addChild(new ComponentAgent(""component97""));
		agent.addChild(new ComponentAgent(""component98""));
		agent.addChild(new ComponentAgent(""component99""));
		agent.addChild(new ComponentAgent(""component100""));
		agent.addChild(new ComponentAgent(""component101""));
		agent.addChild(new ComponentAgent(""component102""));
		agent.addChild(new ComponentAgent(""component103""));
		agent.addChild(new ComponentAgent(""component104""));
		agent.addChild(new ComponentAgent(""component105""));
		agent.addChild(new ComponentAgent(""component106""));
		agent.addChild(new ComponentAgent(""component107""));
		agent.addChild(new ComponentAgent(""component108""));
		agent.addChild(new ComponentAgent(""component109""));
		agent.addChild(new ComponentAgent(""component110""));
		agent.addChild(new ComponentAgent(""component111""));
		agent.addChild(new ComponentAgent(""component112""));
		agent.addChild(new ComponentAgent(""component113""));
		agent.addChild(new ComponentAgent(""component114""));
		agent.addChild(new ComponentAgent(""component115""));
		agent.addChild(new ComponentAgent(""component116""));
		agent.addChild(new ComponentAgent(""component117""));
		agent.addChild(new ComponentAgent(""component118""));
		agent.addChild(new ComponentAgent(""component119""));
		agent.addChild(new ComponentAgent(""component120""));
		agent.addChild(new ComponentAgent(""component121""));
		agent.addChild(new ComponentAgent(""component122""));
		agent.addChild(new ComponentAgent(""component123""));
"
cmpl-6wsfUrf9C7cBSyisAsuSYAOVAZtFw,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock0.java,91.8000259399414,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        HorizontalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {

    @Test
    void testExtractSequentialSubblocks1() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(0, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(0, result.size());
    }

    @Test
    void testExtractSequentialSubblocks2() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(1, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(1, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
    }

    @Test
    void testExtractSequentialSubblocks3() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(2, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(2, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
    }

    @Test
    void testExtractSequentialSubblocks4() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(3, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(3, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
    }

    @Test
    void testExtractSequentialSubblocks5() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(4, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(4, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
    }

    @Test
    void testExtractSequentialSubblocks6() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(5, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(5, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
        assertEquals(new CharPosition1(4, 0), result.get(4).x1);
        assertEquals(new CharPosition1(5, 0), result.get(4).x2);
    }

    @Test
    void testExtractSequentialSubblocks7() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(6, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(6, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
        assertEquals(new CharPosition1(4, 0), result.get(4).x1);
        assertEquals(new CharPosition1(5, 0), result.get(4).x2);
        assertEquals(new CharPosition1(5, 0), result.get(5).x1);
        assertEquals(new CharPosition1(6, 0), result.get(5).x2);
    }

    @Test
    void testExtractSequentialSubblocks8() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(7, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(7, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
        assertEquals(new CharPosition1(4, 0), result.get(4).x1);
        assertEquals(new CharPosition1(5, 0), result.get(4).x2);
        assertEquals(new CharPosition1(5, 0), result.get(5).x1);
        assertEquals(new CharPosition1(6, 0), result.get(5).x2);
        assertEquals(new CharPosition1(6, 0), result.get(6).x1);
        assertEquals(new CharPosition1(7, 0), result.get(6).x2);
    }

    @Test
    void testExtractSequentialSubblocks9() {
        HorizontalBlock block ="
cmpl-6wsgynZ1PRWyv6HuNmIEJQLD8WWY6,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock1.java,73.46156287193298,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<HWordPosition> hLines = getIntersectingHLines();
        if (hLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(hLines);
        else
            return extractParallelSubblocksWithoutLines();
    }
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {

	/**
	* Test case 1.
	* The block is empty.
	*/
	@Test
	void testCase1() {
		HorizontalBlock block = new HorizontalBlock();
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	* Test case 2.
	* The block contains one word.
	*/
	@Test
	void testCase2() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, 10, 10));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	* Test case 3.
	* The block contains two words.
	*/
	@Test
	void testCase3() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, 10, 10));
		block.add(new HWordPosition(20, 0, 30, 10));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	* Test case 4.
	* The block contains three words.
	*/
	@Test
	void testCase4() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, 10, 10));
		block.add(new HWordPosition(20, 0, 30, 10));
		block.add(new HWordPosition(40, 0, 50, 10));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	* Test case 5.
	* The block contains three words and one line.
	*/
	@Test
	void testCase5() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, 10, 10));
		block.add(new HWordPosition(20, 0, 30, 10));
		block.add(new HWordPosition(40, 0, 50, 10));
		block.add(new HLinePosition(0, 0, 50, 0));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(3, subblocks.get(0).size());
	}
	
	/**
	* Test case 6.
	* The block contains three words and two lines.
	*/
	@Test
	void testCase6() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, 10, 10));
		block.add(new HWordPosition(20, 0, 30, 10));
		block.add(new HWordPosition(40, 0, 50, 10));
		block.add(new HLinePosition(0, 0, 50, 0));
		block.add(new HLinePosition(0, 10, 50, 10));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
		assertEquals(1, subblocks.get(1).size());
	}
	
	/**
	* Test case 7.
	* The block contains three words and three lines.
	*/
	@Test
	void testCase7() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, 10, 10));
		block.add(new HWordPosition(20, 0, 30, 10));
		block.add(new HWordPosition(40, 0, 50, 10));
		block.add(new HLinePosition(0, 0, 50, 0));
		block.add(new HLinePosition(0, 10, 50, 10));
		block.add(new HLinePosition(0, 20, 50, 20));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(1, subblocks.get(0).size());
		assertEquals(1, subblocks.get(1).size());
		assertEquals(1, subblocks.get(2).size());
	}
	
	/**
	* Test case 8.
	* The block contains three words and four lines.
	*/
	@Test
	void testCase8() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, 10, 10));
		block.add(new HWordPosition(20, 0, 30, 10));
		block.add(new HWordPosition(40, 0, 50, 10));
		block.add(new HLinePosition(0, 0, 50, 0));
		block.add(new HLinePosition(0, 10, 50, 10));
		block.add(new HLinePosition(0, 20, 50, 20));
		block.add(new HLinePosition(0, 30, 50, 30));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(1, subblocks.get(0).size());
		assertEquals(1, subblocks.get(1).size());
		assertEquals(1, subblocks.get(2).size());
		assertEquals(0, subblocks.get(3).size());
	}
	
	/**
	* Test case 9.
	* The block contains three words and five lines.
	*/
	@Test
	void testCase9() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, 10, 10));
		block.add(new HWordPosition(20, 0, 30, 10));
		block.add(new HWordPosition(40, 0, 50, 10));
		block.add(new HLinePosition(0, 0, 50, 0));
		block.add(new HLinePosition(0, 10, 50, 10));
		block.add(new HLinePosition(0, 20, 50, 20));
		block.add(new HLinePosition(0, 30, 50, 30));
		block.add(new HLinePosition(0, 40, 50, 40));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(1, subblocks.get(0).size());
		assertEquals(1, subblocks.get(1).size());
		assertEquals(1, subblocks.get(2).size());
		assertEquals(0, subblocks.get(3).size());
		assertEquals(0, subblocks.get(4).size());
	}
	
	/**
	* Test case 10.
	* The block contains three words and six lines.
	*/
	@Test
	void testCase10() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new HWordPosition(0, 0, 10, 10));
		block.add(new HWordPosition(20, 0, 30, 10));
		block.add(new HWordPosition(40, 0, 50, 10));
		block.add(new HLinePosition(0, 0, 50, 0));
		block.add(new HLinePosition(0, 10, 50, 10));
		block.add(new HLinePosition(0, 20, 50, 20));
		block.add(new HLinePosition(0, 30, 50, 30));
		block.add(new HLinePosition(0, 40, 50, 40));
		block.add(new HLinePosition(0, 50, 50, 50));
"
cmpl-6wsi9RGFFGnKOQVw914KVJB7kmx7R,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock0.java,69.1885769367218,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        VerticalBlock firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {

	@Test
	void testExtractSequentialSubblocks1() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}
	
	@Test
	void testExtractSequentialSubblocks2() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 5)), result.get(1));
	}
	
	@Test
	void testExtractSequentialSubblocks3() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 3), new CharPosition1(1, 3)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 5), new CharPosition1(1, 5)), result.get(2));
	}
	
	@Test
	void testExtractSequentialSubblocks4() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 3), new CharPosition1(1, 4)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 5), new CharPosition1(1, 5)), result.get(2));
	}
	
	@Test
	void testExtractSequentialSubblocks5() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 3), new CharPosition1(1, 4)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 6), new CharPosition1(1, 6)), result.get(2));
	}
	
	@Test
	void testExtractSequentialSubblocks6() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		block.add(new CharPosition1(1, 7));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(4, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 3), new CharPosition1(1, 4)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 6), new CharPosition1(1, 6)), result.get(2));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(3));
	}
	
	@Test
	void testExtractSequentialSubblocks7() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		block.add(new CharPosition1(1, 7));
		block.add(new CharPosition1(1, 8));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(4, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 3), new CharPosition1(1, 4)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 6), new CharPosition1(1, 7)), result.get(2));
		assertEquals(new VerticalBlock(new CharPosition1(1, 8), new CharPosition1(1, 8)), result.get(3));
	}
	
	@Test
	void testExtractSequentialSubblocks8() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		block.add(new CharPosition1(1, 7));
		block.add(new CharPosition1(1, 8));
		block.add(new CharPosition1(1, 9));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(4, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 3), new CharPosition1(1, 4)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 6), new CharPosition1(1, 7)), result.get(2));
		assertEquals(new VerticalBlock(new CharPosition1(1, 9), new CharPosition1(1, 9)), result.get(3));
	}
	
	@Test
	void testExtractSequentialSubblocks9() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block."
cmpl-6wsjH8A7G2Y2LSWvsR7rjDQvFxktP,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock1.java,74.48670625686646,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {

	/**
	* Test case 1.
	* The block contains one word.
	*/
	@Test
	void testCase1() {
		List<VWordPosition> positions = new LinkedList<VWordPosition>();
		positions.add(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"
cmpl-6wskTbzEHIbIPFfCZ89lfyeEbTpIz,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/positions/HWordPosition.java,63.61536240577698,length,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {

	@Test
	void testTextAt() {
		CharTable ct = new CharTable(5, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(1, 0, 'b');
		ct.setCharAt(2, 0, 'c');
		ct.setCharAt(3, 0, 'd');
		ct.setCharAt(4, 0, 'e');
		
		HWordPosition wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 0, 0);
		assertEquals(""a"", wp.textAt(ct));
		
		wp = new HWordPosition(4, 0, 4, 0);
		assertEquals(""e"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 1, 0);
		assertEquals(""ab"", wp.textAt(ct));
		
		wp = new HWordPosition(1, 0, 4, 0);
		assertEquals(""bcde"", wp.textAt(ct));
		
		wp = new HWordPosition(1, 0, 2, 0);
		assertEquals(""bc"", wp.textAt(ct));
		
		wp = new HWordPosition(2, 0, 3, 0);
		assertEquals(""cd"", wp.textAt(ct));
		
		wp = new HWordPosition(3, 0, 4, 0);
		assertEquals(""de"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 2, 0);
		assertEquals(""abc"", wp.textAt(ct));
		
		wp = new HWordPosition(2, 0, 4, 0);
		assertEquals(""cde"", wp.textAt(ct));
	}
}

// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition {

    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}

// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(5, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(0, 1, 'b');
		ct.setCharAt(0, 2, 'c');
		ct.setCharAt(0, 3, 'd');
		ct.setCharAt(0, 4, 'e');
		
		VWordPosition wp = new VWordPosition(0, 0, 0, 4);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 0);
		assertEquals(""a"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 4, 0, 4);
		assertEquals(""e"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 1);
		assertEquals(""ab"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 1, 0, 4);
		assertEquals(""bcde"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 1, 0, 2);
		assertEquals(""bc"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 2, 0, 3);
		assertEquals(""cd"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 3, 0, 4);
		assertEquals(""de"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 2);
		assertEquals(""abc"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 2, 0, 4);
		assertEquals(""cde"", wp.textAt(ct));
	}
}

// WordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying on the scheme.
 */
public abstract class WordPosition {

    private final int startX;
    private final int startY;
    private final int endX;
    private final int endY;

    public WordPosition(int startX, int startY, int endX, int endY) {
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
    }

    public int getStartX() {
        return startX;
    }

    public int getStartY() {
        return startY;
    }

    public int getEndX() {
        return endX;
    }

    public int getEndY() {
        return endY;
    }

    public abstract String textAt(CharTable ct);
}

// WordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPosition}.
* It contains ten unit test cases for the {@link WordPosition#textAt(CharTable)} method.
*/
class WordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(5, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(1, 0, 'b');
		ct.setCharAt(2, 0, 'c');
		ct.setCharAt(3, 0, 'd');
		ct.setCharAt(4, 0, 'e');
		
		WordPosition wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 0, 0);
		assertEquals(""a"", wp.textAt(ct));
		
		wp = new HWordPosition(4, 0, 4, 0);
		assertEquals(""e"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 1, 0);
		assertEquals(""ab"", wp.textAt(ct));
		
		wp = new HWordPosition(1, 0, 4, 0);
		assertEquals(""bcde"", wp.textAt(ct));
		
		wp = new HWordPosition(1, 0, 2, 0);
		assertEquals(""bc"", wp.textAt(ct));
		
		wp = new HWordPosition(2, 0, 3, 0);
		assertEquals(""cd"", wp.textAt(ct));
		
		wp = new HWordPosition"
cmpl-6wslV5k4jKgxVhAjvBhO0cRb2zQza,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/positions/VWordPosition.java,60.841442823410034,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {

	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(0, 1, 'b');
		ct.setCharAt(0, 2, 'c');
		ct.setCharAt(0, 3, 'd');
		ct.setCharAt(0, 4, 'e');
		ct.setCharAt(0, 5, 'f');
		ct.setCharAt(0, 6, 'g');
		ct.setCharAt(0, 7, 'h');
		ct.setCharAt(0, 8, 'i');
		ct.setCharAt(0, 9, 'j');
		ct.setCharAt(1, 0, 'k');
		ct.setCharAt(1, 1, 'l');
		ct.setCharAt(1, 2, 'm');
		ct.setCharAt(1, 3, 'n');
		ct.setCharAt(1, 4, 'o');
		ct.setCharAt(1, 5, 'p');
		ct.setCharAt(1, 6, 'q');
		ct.setCharAt(1, 7, 'r');
		ct.setCharAt(1, 8, 's');
		ct.setCharAt(1, 9, 't');
		ct.setCharAt(2, 0, 'u');
		ct.setCharAt(2, 1, 'v');
		ct.setCharAt(2, 2, 'w');
		ct.setCharAt(2, 3, 'x');
		ct.setCharAt(2, 4, 'y');
		ct.setCharAt(2, 5, 'z');
		ct.setCharAt(2, 6, 'a');
		ct.setCharAt(2, 7, 'b');
		ct.setCharAt(2, 8, 'c');
		ct.setCharAt(2, 9, 'd');
		ct.setCharAt(3, 0, 'e');
		ct.setCharAt(3, 1, 'f');
		ct.setCharAt(3, 2, 'g');
		ct.setCharAt(3, 3, 'h');
		ct.setCharAt(3, 4, 'i');
		ct.setCharAt(3, 5, 'j');
		ct.setCharAt(3, 6, 'k');
		ct.setCharAt(3, 7, 'l');
		ct.setCharAt(3, 8, 'm');
		ct.setCharAt(3, 9, 'n');
		ct.setCharAt(4, 0, 'o');
		ct.setCharAt(4, 1, 'p');
		ct.setCharAt(4, 2, 'q');
		ct.setCharAt(4, 3, 'r');
		ct.setCharAt(4, 4, 's');
		ct.setCharAt(4, 5, 't');
		ct.setCharAt(4, 6, 'u');
		ct.setCharAt(4, 7, 'v');
		ct.setCharAt(4, 8, 'w');
		ct.setCharAt(4, 9, 'x');
		ct.setCharAt(5, 0, 'y');
		ct.setCharAt(5, 1, 'z');
		ct.setCharAt(5, 2, 'a');
		ct.setCharAt(5, 3, 'b');
		ct.setCharAt(5, 4, 'c');
		ct.setCharAt(5, 5, 'd');
		ct.setCharAt(5, 6, 'e');
		ct.setCharAt(5, 7, 'f');
		ct.setCharAt(5, 8, 'g');
		ct.setCharAt(5, 9, 'h');
		ct.setCharAt(6, 0, 'i');
		ct.setCharAt(6, 1, 'j');
		ct.setCharAt(6, 2, 'k');
		ct.setCharAt(6, 3, 'l');
		ct.setCharAt(6, 4, 'm');
		ct.setCharAt(6, 5, 'n');
		ct.setCharAt(6, 6, 'o');
		ct.setCharAt(6, 7, 'p');
		ct.setCharAt(6, 8, 'q');
		ct.setCharAt(6, 9, 'r');
		ct.setCharAt(7, 0, 's');
		ct.setCharAt(7, 1, 't');
		ct.setCharAt(7, 2, 'u');
		ct.setCharAt(7, 3, 'v');
		ct.setCharAt(7, 4, 'w');
		ct.setCharAt(7, 5, 'x');
		ct.setCharAt(7, 6, 'y');
		ct.setCharAt(7, 7, 'z');
		ct.setCharAt(7, 8, 'a');
		ct.setCharAt(7, 9, 'b');
		ct.setCharAt(8, 0, 'c');
		ct.setCharAt(8, 1, 'd');
		ct.setCharAt(8, 2, 'e');
		ct.setCharAt(8, 3, 'f');
		ct.setCharAt(8, 4, 'g');
		ct.setCharAt(8, 5, 'h');
		ct.setCharAt(8, 6, 'i');
		ct.setCharAt(8, 7, 'j');
		ct.setCharAt(8, 8, 'k');
		ct.setCharAt(8, 9, 'l');
		ct.setCharAt(9, 0, 'm');
		ct.setCharAt(9, 1, 'n');
		ct.setCharAt(9, 2, 'o');
		ct.setCharAt(9, 3, 'p');
		ct.setCharAt(9, 4, 'q');
		ct.setCharAt(9, 5, 'r');
		ct.setCharAt(9, 6, 's');
		ct.setCharAt(9, 7, 't');
		ct.setCharAt(9, 8, 'u');
		ct.setCharAt(9, 9, 'v');
		
		VWordPosition wp1 = new VWordPosition(0, 0, 0, 9);
		assertEquals(""abcdefghij"", wp1.textAt(ct));
		
		VWordPosition wp2 = new VWordPosition(0, 1, 0, 8);
		assertEquals(""bcdefghi"", wp2.textAt(ct));
		
		VWordPosition wp3 = new VWordPosition(0, 2, 0, 7);
		assertEquals(""cdefgh"", wp3.textAt(ct));
		
		VWordPosition wp4 = new VWordPosition(0, 3, 0, 6);
		assertEquals(""defg"", wp4.textAt(ct));
		
		VWordPosition wp5 = new VWordPosition(0, 4, 0, 5);
		assertEquals(""ef"", wp5.textAt(ct));
		
		VWordPosition wp6 = new VWordPosition(0, 5, 0, 4);
		assertEquals(""f"", wp6.textAt(ct));
		
		VWordPosition wp7 = new VWordPosition(0, 6, 0, 3);
		assertEquals(""g"", wp7.textAt(ct));
		
		VWordPosition wp8 = new VWordPosition(0, 7, 0, 2);
		assertEquals(""h"", wp8.textAt(ct));
		
		VWordPosition wp"
