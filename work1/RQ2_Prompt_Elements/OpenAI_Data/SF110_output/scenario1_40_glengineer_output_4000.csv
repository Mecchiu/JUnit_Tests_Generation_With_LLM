ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6x8SPfJuxIKACCZrWKByBCZqs7SKE,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer0.java,144.84674882888794,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {

		@Test
		void testGetComponent() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				
				FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""FINDLABEL"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""FINDLABEL"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""TEXTFIELD"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""TEXTFIELD"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""FINDBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""FINDBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB11"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB11"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB12"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB12"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB21"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB21"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB22"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB22"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CANSELBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CANSELBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""FINDLABEL"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""FINDLABEL"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""TEXTFIELD"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""TEXTFIELD"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""FINDBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""FINDBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB11"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB11"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB12"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB12"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB21"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB21"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB22"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB22"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CANSELBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CANSELBUTTON"").getComponent());
		}
}

// GroupLayoutEngineerTest2.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest2 {
		
		@Test
		void testGetComponent() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				
				FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""FINDLABEL"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""FINDLABEL"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""TEXTFIELD"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""TEXTFIELD"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""FINDBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""FINDBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB11"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB11"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB12"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB12"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB21"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB21"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB22"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB22"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CANSELBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CANSELBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""FINDLABEL"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""FINDLABEL"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""TEXTFIELD"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""TEXTFIELD"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""FINDBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""FINDBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB11"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB11"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB12"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB12"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB21"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB21"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CB22"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CB22"").getComponent());
				
				foc = gle.getComponent(Axis.VERTICAL, ""CANSELBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.VERTICAL, ""CANSELBUTTON"").getComponent());
		}
}

// GroupLayoutEngineerTest3.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest3 {
		
		@Test
		void testGetComponent() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				
				FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""FINDLABEL"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""FINDLABEL"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""TEXTFIELD"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""TEXTFIELD"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""FINDBUTTON"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""FINDBUTTON"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB11"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB11"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB12"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB12"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL, ""CB21"");
				assertEquals(foc.getComponent(), gle.getAgent(Axis.HORIZONTAL, ""CB21"").getComponent());
				
				foc = gle.getComponent(Axis.HORIZONTAL"
cmpl-6x8UkqZWJ1OgjLUFuYsrQiuJ6WCnR,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer1.java,148.63679456710815,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

		/**
		* Test case 1.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are not in the same group.
		* <p>
		* The expected result is {@code null}.
		*/
		@Test
		void testGetGroup1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""C""));
		}
		
		/**
		* Test case 2.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""B""));
		}
		
		/**
		* Test case 3.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a parallel group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.VERTICAL, ""D"", ""F""));
		}
		
		/**
		* Test case 4.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a sequential group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup4() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""C""));
		}
		
		/**
		* Test case 5.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a sequential group,
		* and the group is a subgroup of another group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup5() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""B""));
		}
		
		/**
		* Test case 6.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a parallel group,
		* and the group is a subgroup of another group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup6() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.VERTICAL, ""D"", ""E""));
		}
		
		/**
		* Test case 7.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a sequential group,
		* and the group is a subgroup of another group,
		* and the group is a subgroup of another group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup7() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""B""));
		}
		
		/**
		* Test case 8.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a parallel group,
		* and the group is a subgroup of another group,
		* and the group is a subgroup of another group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup8() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.VERTICAL, ""D"", ""E""));
		}
		
		/**
		* Test case 9.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a sequential group,
		* and the group is a subgroup of another group,
		* and the group is a subgroup of another group,
		* and the group is a subgroup of another group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup9() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.HORIZONTAL, ""A"", ""B""));
		}
		
		/**
		* Test case 10.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are in the same group,
		* and the group is a parallel group,
		* and the group is a subgroup of another group,
		* and the group is a subgroup of another group,
		* and the group is a subgroup of another group.
		* <p>
		* The expected result is not {@code null}.
		*/
		@Test
		void testGetGroup10() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"",
						""D E F"");
				gle.associate(""A"", new JButton(""A""));
				gle.associate(""B"", new JButton(""B""));
				gle.associate(""C"", new JButton(""C""));
				gle.associate(""D"", new JButton(""D""));
				gle.associate(""E"", new JButton(""E""));
				gle.associate(""F"", new JButton(""F""));
				gle.engineer();
				assertNotNull(gle.getGroup(Axis.VERTICAL, ""D"", ""E""));
		}
}

// GroupLayoutEngineerTest2.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest2 {
		
		/**
		* Test case 1.
		* <p>
		* The method {@link GroupLayoutEngineer#getGroup(Axis, String, String)}
		* is tested for the case when the first and the last names
		* are the names of the components which are not in the same group.
		* <p>
		* The expected result is {@code null}.
		*/
		@Test
		void testGetGroup1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""A B C"","
cmpl-6x8X8O9hcu51i1C2x95Ua4ZPu7MFP,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer2.java,147.00580430030823,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

		@Test
		void testGetParallelGroup1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 3);
		}
		
		@Test
		void testGetParallelGroup2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""CANSELBUTTON"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 2);
		}
		
		@Test
		void testGetParallelGroup3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""CB22"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 2);
		}
		
		@Test
		void testGetParallelGroup4() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 2);
		}
		
		@Test
		void testGetParallelGroup5() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""CB11"", ""CANSELBUTTON"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 2);
		}
		
		@Test
		void testGetParallelGroup6() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""CB11"", ""CB12"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 2);
		}
		
		@Test
		void testGetParallelGroup7() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""CB11"", ""CB21"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 2);
		}
		
		@Test
		void testGetParallelGroup8() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 2);
		}
		
		@Test
		void testGetParallelGroup9() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""CB11"", ""CB12"");
				assertEquals(fopg.getParallelGroup().getChildCount(), 2);
		}
		
		@Test
		void testGetParallelGroup10() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle"
cmpl-6x8ZVUPgBsDeOI9R4qfmDg6CqRsYr,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer3.java,167.78626823425293,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

		@Test
		void testGetSequentialGroup1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getSequentialGroup().getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getSequentialGroup().getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getSequentialGroup().getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup4() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getSequentialGroup().getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup5() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getSequentialGroup().getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup6() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getSequentialGroup().getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup7() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getSequentialGroup().getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup8() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getSequentialGroup().getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup9() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.engineer();
				FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""FINDLABEL"", ""FINDBUTTON"");
				assertEquals(fosg.getSequentialGroup().getComponentCount(), 3);
		}
		
		@Test
		void testGetSequentialGroup10() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate"
cmpl-6x8cD8F74fCpza7KKJKieV56CuExu,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer4.java,163.98900604248047,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {

		@Test
		void testGetTopSequentialGroup() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						new JPanel(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
				gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
						.setContentAlignment(Alignment.BASELINE);
				gle.setAutoCreateGaps(true);
				gle.setAutoCreateContainerGaps(true);
				gle.engineer();
				FunctionsOnTopSequentialGroup fotg = gle.getTopSequentialGroup(Axis.HORIZONTAL);
				assertEquals(fotg.getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB12"").getGroup(""CANSELBUTTON"").getGroup(""CB21"").getGroup(""CB22"").getGroup(""FINDLABEL"").getGroup(""TEXTFIELD"").getGroup(""FINDBUTTON"").getGroup(""CB11"").getGroup(""CB"
cmpl-6x8erpHNVkc73xPrezh3fehsVAA3l,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent0.java,152.35367798805237,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {

	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertTrue(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_3() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_4() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_5() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_6() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_7() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_8() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_9() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_10() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
}

// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }
}

// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {
		
	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertTrue(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_3() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_4() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_5() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_6() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_7() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_8() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_9() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_10() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
}

// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }
}

// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {
		
	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertTrue(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_3() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_4() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_5() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_6() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_7() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_8() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_9() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_10() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new ComponentAgent());
		assertFalse(agent.containsGapsOnly());
	}
}

// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }
}

// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {
		
	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		agent.addChild(new GapAgent());
		assertTrue(agent.containsGapsOnly());
	}
	
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addChild(new GapAgent());
		agent.addChild"
cmpl-6x8hJdooPWI5iBgFcROXWnryrKyVI,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent1.java,238.1232876777649,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {

		/**
		* Test case 1.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has no children.
		*/
		@Test
		void testGroupContent_1() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
								return new ParallelGroup(Alignment.LEADING);
						}
						@Override
						public void addComponentToGroup(ParallelGroup group, Agent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
						@Override
						public void addGroupToGroup(ParallelGroup group, GroupAgent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
				});
				assertEquals(Alignment.LEADING, result.getAlignment());
				assertEquals(0, result.getSize());
		}
		
		/**
		* Test case 2.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has one child.
		*/
		@Test
		void testGroupContent_2() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				instance.addChild(new ComponentAgent());
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
								return new ParallelGroup(Alignment.LEADING);
						}
						@Override
						public void addComponentToGroup(ParallelGroup group, Agent agent) {
								group.addComponent(agent.getComponent());
						}
						@Override
						public void addGroupToGroup(ParallelGroup group, GroupAgent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
				});
				assertEquals(Alignment.LEADING, result.getAlignment());
				assertEquals(1, result.getSize());
		}
		
		/**
		* Test case 3.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has two children.
		*/
		@Test
		void testGroupContent_3() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
								return new ParallelGroup(Alignment.LEADING);
						}
						@Override
						public void addComponentToGroup(ParallelGroup group, Agent agent) {
								group.addComponent(agent.getComponent());
						}
						@Override
						public void addGroupToGroup(ParallelGroup group, GroupAgent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
				});
				assertEquals(Alignment.LEADING, result.getAlignment());
				assertEquals(2, result.getSize());
		}
		
		/**
		* Test case 4.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has three children.
		*/
		@Test
		void testGroupContent_4() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
								return new ParallelGroup(Alignment.LEADING);
						}
						@Override
						public void addComponentToGroup(ParallelGroup group, Agent agent) {
								group.addComponent(agent.getComponent());
						}
						@Override
						public void addGroupToGroup(ParallelGroup group, GroupAgent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
				});
				assertEquals(Alignment.LEADING, result.getAlignment());
				assertEquals(3, result.getSize());
		}
		
		/**
		* Test case 5.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has four children.
		*/
		@Test
		void testGroupContent_5() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
								return new ParallelGroup(Alignment.LEADING);
						}
						@Override
						public void addComponentToGroup(ParallelGroup group, Agent agent) {
								group.addComponent(agent.getComponent());
						}
						@Override
						public void addGroupToGroup(ParallelGroup group, GroupAgent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
				});
				assertEquals(Alignment.LEADING, result.getAlignment());
				assertEquals(4, result.getSize());
		}
		
		/**
		* Test case 6.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has five children.
		*/
		@Test
		void testGroupContent_6() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
								return new ParallelGroup(Alignment.LEADING);
						}
						@Override
						public void addComponentToGroup(ParallelGroup group, Agent agent) {
								group.addComponent(agent.getComponent());
						}
						@Override
						public void addGroupToGroup(ParallelGroup group, GroupAgent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
				});
				assertEquals(Alignment.LEADING, result.getAlignment());
				assertEquals(5, result.getSize());
		}
		
		/**
		* Test case 7.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has six children.
		*/
		@Test
		void testGroupContent_7() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
								return new ParallelGroup(Alignment.LEADING);
						}
						@Override
						public void addComponentToGroup(ParallelGroup group, Agent agent) {
								group.addComponent(agent.getComponent());
						}
						@Override
						public void addGroupToGroup(ParallelGroup group, GroupAgent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
				});
				assertEquals(Alignment.LEADING, result.getAlignment());
				assertEquals(6, result.getSize());
		}
		
		/**
		* Test case 8.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has seven children.
		*/
		@Test
		void testGroupContent_8() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
								return new ParallelGroup(Alignment.LEADING);
						}
						@Override
						public void addComponentToGroup(ParallelGroup group, Agent agent) {
								group.addComponent(agent.getComponent());
						}
						@Override
						public void addGroupToGroup(ParallelGroup group, GroupAgent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
				});
				assertEquals(Alignment.LEADING, result.getAlignment());
				assertEquals(7, result.getSize());
		}
		
		/**
		* Test case 9.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has eight children.
		*/
		@Test
		void testGroupContent_9() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
								return new ParallelGroup(Alignment.LEADING);
						}
						@Override
						public void addComponentToGroup(ParallelGroup group, Agent agent) {
								group.addComponent(agent.getComponent());
						}
						@Override
						public void addGroupToGroup(ParallelGroup group, GroupAgent agent) {
								throw new UnsupportedOperationException(""Not supported yet."");
						}
				});
				assertEquals(Alignment.LEADING, result.getAlignment());
				assertEquals(8, result.getSize());
		}
		
		/**
		* Test case 10.
		* The method {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} is tested.
		* The test case checks the correctness of the method when the {@link ParallelGroupAgent} has nine children.
		*/
		@Test
		void testGroupContent_10() {
				ParallelGroupAgent instance = new ParallelGroupAgent();
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				instance.addChild(new ComponentAgent());
				ParallelGroup result = instance.groupContent(new GroupCreatorAndElementAdder() {
						@Override
						public ParallelGroup create"
1dba64e5-eb57-4265-8fa7-a843853582fd,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java,-1,"ERROR - Error communicating with OpenAI: (""Connection broken: ConnectionResetError(104, 'Connection reset by peer')"", ConnectionResetError(104, 'Connection reset by peer'))","// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * ,   .
 */
public class SequentialGroupAgent extends GroupAgent {

    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }
}
","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {
"
cmpl-6x8qM46dfboLSFFgtBi3ooWq8Ujpj,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java,212.40951013565063,length,"// TopSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * ,     .
 * <p>
 *   {@code FunctionsOnTopSequentialGroup}
 *    
 *         .
 */
public class TopSequentialGroupAgent extends SequentialGroupAgent {

    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        if (precedingContainerGap != null)
            precedingContainerGap.addOneselfToGroup(result);
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        if (followingContainerGap != null)
            followingContainerGap.addOneselfToGroup(result);
        return result;
    }
}
","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {

	@Test
	void testGroupContent_1() {
		TopSequentialGroupAgent agent = new TopSequentialGroupAgent();
		agent.addChild(new ComponentAgent(""component1""));
		agent.addChild(new ComponentAgent(""component2""));
		agent.addChild(new ComponentAgent(""component3""));
		agent.addChild(new ComponentAgent(""component4""));
		agent.addChild(new ComponentAgent(""component5""));
		agent.addChild(new ComponentAgent(""component6""));
		agent.addChild(new ComponentAgent(""component7""));
		agent.addChild(new ComponentAgent(""component8""));
		agent.addChild(new ComponentAgent(""component9""));
		agent.addChild(new ComponentAgent(""component10""));
		agent.addChild(new ComponentAgent(""component11""));
		agent.addChild(new ComponentAgent(""component12""));
		agent.addChild(new ComponentAgent(""component13""));
		agent.addChild(new ComponentAgent(""component14""));
		agent.addChild(new ComponentAgent(""component15""));
		agent.addChild(new ComponentAgent(""component16""));
		agent.addChild(new ComponentAgent(""component17""));
		agent.addChild(new ComponentAgent(""component18""));
		agent.addChild(new ComponentAgent(""component19""));
		agent.addChild(new ComponentAgent(""component20""));
		agent.addChild(new ComponentAgent(""component21""));
		agent.addChild(new ComponentAgent(""component22""));
		agent.addChild(new ComponentAgent(""component23""));
		agent.addChild(new ComponentAgent(""component24""));
		agent.addChild(new ComponentAgent(""component25""));
		agent.addChild(new ComponentAgent(""component26""));
		agent.addChild(new ComponentAgent(""component27""));
		agent.addChild(new ComponentAgent(""component28""));
		agent.addChild(new ComponentAgent(""component29""));
		agent.addChild(new ComponentAgent(""component30""));
		agent.addChild(new ComponentAgent(""component31""));
		agent.addChild(new ComponentAgent(""component32""));
		agent.addChild(new ComponentAgent(""component33""));
		agent.addChild(new ComponentAgent(""component34""));
		agent.addChild(new ComponentAgent(""component35""));
		agent.addChild(new ComponentAgent(""component36""));
		agent.addChild(new ComponentAgent(""component37""));
		agent.addChild(new ComponentAgent(""component38""));
		agent.addChild(new ComponentAgent(""component39""));
		agent.addChild(new ComponentAgent(""component40""));
		agent.addChild(new ComponentAgent(""component41""));
		agent.addChild(new ComponentAgent(""component42""));
		agent.addChild(new ComponentAgent(""component43""));
		agent.addChild(new ComponentAgent(""component44""));
		agent.addChild(new ComponentAgent(""component45""));
		agent.addChild(new ComponentAgent(""component46""));
		agent.addChild(new ComponentAgent(""component47""));
		agent.addChild(new ComponentAgent(""component48""));
		agent.addChild(new ComponentAgent(""component49""));
		agent.addChild(new ComponentAgent(""component50""));
		agent.addChild(new ComponentAgent(""component51""));
		agent.addChild(new ComponentAgent(""component52""));
		agent.addChild(new ComponentAgent(""component53""));
		agent.addChild(new ComponentAgent(""component54""));
		agent.addChild(new ComponentAgent(""component55""));
		agent.addChild(new ComponentAgent(""component56""));
		agent.addChild(new ComponentAgent(""component57""));
		agent.addChild(new ComponentAgent(""component58""));
		agent.addChild(new ComponentAgent(""component59""));
		agent.addChild(new ComponentAgent(""component60""));
		agent.addChild(new ComponentAgent(""component61""));
		agent.addChild(new ComponentAgent(""component62""));
		agent.addChild(new ComponentAgent(""component63""));
		agent.addChild(new ComponentAgent(""component64""));
		agent.addChild(new ComponentAgent(""component65""));
		agent.addChild(new ComponentAgent(""component66""));
		agent.addChild(new ComponentAgent(""component67""));
		agent.addChild(new ComponentAgent(""component68""));
		agent.addChild(new ComponentAgent(""component69""));
		agent.addChild(new ComponentAgent(""component70""));
		agent.addChild(new ComponentAgent(""component71""));
		agent.addChild(new ComponentAgent(""component72""));
		agent.addChild(new ComponentAgent(""component73""));
		agent.addChild(new ComponentAgent(""component74""));
		agent.addChild(new ComponentAgent(""component75""));
		agent.addChild(new ComponentAgent(""component76""));
		agent.addChild(new ComponentAgent(""component77""));
		agent.addChild(new ComponentAgent(""component78""));
		agent.addChild(new ComponentAgent(""component79""));
		agent.addChild(new ComponentAgent(""component80""));
		agent.addChild(new ComponentAgent(""component81""));
		agent.addChild(new ComponentAgent(""component82""));
		agent.addChild(new ComponentAgent(""component83""));
		agent.addChild(new ComponentAgent(""component84""));
		agent.addChild(new ComponentAgent(""component85""));
		agent.addChild(new ComponentAgent(""component86""));
		agent.addChild(new ComponentAgent(""component87""));
		agent.addChild(new ComponentAgent(""component88""));
		agent.addChild(new ComponentAgent(""component89""));
		agent.addChild(new ComponentAgent(""component90""));
		agent.addChild(new ComponentAgent(""component91""));
		agent.addChild(new ComponentAgent(""component92""));
		agent.addChild(new ComponentAgent(""component93""));
		agent.addChild(new ComponentAgent(""component94""));
		agent.addChild(new ComponentAgent(""component95""));
		agent.addChild(new ComponentAgent(""component96""));
		agent.addChild(new ComponentAgent(""component97""));
		agent.addChild(new ComponentAgent(""component98""));
		agent.addChild(new ComponentAgent(""component99""));
		agent.addChild(new ComponentAgent(""component100""));
		agent.addChild(new ComponentAgent(""component101""));
		agent.addChild(new ComponentAgent(""component102""));
		agent.addChild(new ComponentAgent(""component103""));
		agent.addChild(new ComponentAgent(""component104""));
		agent.addChild(new ComponentAgent(""component105""));
		agent.addChild(new ComponentAgent(""component106""));
		agent.addChild(new ComponentAgent(""component107""));
		agent.addChild(new ComponentAgent(""component108""));
		agent.addChild(new ComponentAgent(""component109""));
		agent.addChild(new ComponentAgent(""component110""));
		agent.addChild(new ComponentAgent(""component111""));
		agent.addChild(new ComponentAgent(""component112""));
		agent.addChild(new ComponentAgent(""component113""));
		agent.addChild(new ComponentAgent(""component114""));
		agent.addChild(new ComponentAgent(""component115""));
		agent.addChild(new ComponentAgent(""component116""));
		agent.addChild(new ComponentAgent(""component117""));
		agent.addChild(new ComponentAgent(""component118""));
		agent.addChild(new ComponentAgent(""component119""));
		agent.addChild(new ComponentAgent(""component120""));
		agent.addChild(new ComponentAgent(""component121""));
		agent.addChild(new ComponentAgent(""component122""));
		agent.addChild(new ComponentAgent(""component123""));
		agent.addChild(new ComponentAgent(""component124""));
		agent.addChild(new ComponentAgent(""component125""));
		agent.addChild(new ComponentAgent(""component126""));
		agent.addChild(new ComponentAgent(""component127""));
		agent.addChild(new ComponentAgent(""component128""));
		agent.addChild(new ComponentAgent(""component129""));
		agent.addChild(new ComponentAgent(""component130""));
		agent.addChild(new ComponentAgent(""component131""));
		agent.addChild(new ComponentAgent(""component132""));
		agent.addChild(new ComponentAgent(""component133""));
		agent.addChild(new ComponentAgent(""component134""));
		agent.addChild(new ComponentAgent(""component135""));
		agent.addChild(new ComponentAgent(""component136""));
		agent.addChild(new ComponentAgent(""component137""));
		agent.addChild(new ComponentAgent(""component138""));
		agent.addChild(new ComponentAgent(""component139""));
		agent.addChild(new ComponentAgent(""component140""));
		agent.addChild(new ComponentAgent(""component141""));
		agent.addChild(new ComponentAgent(""component142""));
		agent.addChild(new ComponentAgent(""component143""));
		agent.addChild(new ComponentAgent(""component144""));
		agent.addChild(new ComponentAgent(""component145""));
		agent.addChild(new ComponentAgent(""component146""));
		agent.addChild(new ComponentAgent(""component147""));
		agent.addChild(new ComponentAgent(""component148""));
		agent.addChild(new ComponentAgent(""component149""));
		agent.addChild(new ComponentAgent(""component150""));
		agent.addChild(new ComponentAgent(""component151""));
		agent.addChild(new ComponentAgent(""component152""));
		agent.addChild(new ComponentAgent(""component153""));
		agent.addChild(new ComponentAgent(""component154""));
		agent.addChild(new ComponentAgent(""component155""));
		agent.addChild(new ComponentAgent(""component156""));
		agent.addChild(new ComponentAgent(""component157""));
		agent.addChild(new ComponentAgent(""component158""));
		agent.addChild(new ComponentAgent(""component159""));
		agent.addChild(new ComponentAgent(""component160""));
		agent.addChild(new ComponentAgent(""component161""));
		agent.addChild(new ComponentAgent(""component162""));
		agent.addChild(new ComponentAgent(""component163""));
		agent.addChild(new ComponentAgent(""component164""));
		agent.addChild(new ComponentAgent(""component165""));
		agent.addChild(new ComponentAgent(""component166""));
		agent.addChild(new ComponentAgent(""component167""));
		agent.addChild(new ComponentAgent(""component168""));
		agent.addChild(new ComponentAgent(""component169""));
		agent.addChild(new ComponentAgent(""component170""));
		agent.addChild(new ComponentAgent(""component171""));
		agent.addChild(new ComponentAgent(""component172""));
		agent.addChild(new ComponentAgent(""component173""));
		agent.addChild(new ComponentAgent(""component174""));
		agent.addChild(new ComponentAgent(""component175""));
		agent.addChild(new ComponentAgent(""component176""));
		agent.addChild(new ComponentAgent(""component177""));
		agent.addChild(new ComponentAgent(""component178""));
		agent.addChild(new ComponentAgent(""component179""));
		agent.addChild(new ComponentAgent(""component180""));
		agent.addChild(new ComponentAgent(""component181""));
		agent.addChild(new ComponentAgent(""component182""));
		agent.addChild(new ComponentAgent(""component183""));
		agent.addChild(new ComponentAgent(""component184""));
		agent.addChild(new ComponentAgent(""component185""));
		agent.addChild(new ComponentAgent(""component186""));
		agent.addChild(new ComponentAgent(""component187""));
		agent.addChild(new ComponentAgent(""component188""));
		agent.addChild(new ComponentAgent(""component189""));
		agent.addChild(new ComponentAgent(""component190""));
		agent.addChild(new ComponentAgent(""component191""));
		agent.addChild(new ComponentAgent(""component192""));
		agent.addChild(new ComponentAgent(""component193""));
		agent.addChild(new ComponentAgent(""component194""));
		agent.addChild(new ComponentAgent(""component195""));
		agent.addChild(new ComponentAgent(""component196""));
		agent.addChild(new ComponentAgent(""component197""));
		agent.addChild(new ComponentAgent(""component198""));
		agent.addChild(new ComponentAgent(""component199""));
		agent.addChild(new ComponentAgent(""component200""));
		agent.addChild(new ComponentAgent(""component201""));
		agent.addChild(new ComponentAgent(""component202""));
		agent.addChild(new ComponentAgent(""component203""));
		agent.addChild(new ComponentAgent(""component204""));
		agent.addChild(new ComponentAgent(""component205""));
		agent.addChild(new ComponentAgent(""component206""));
		agent.addChild(new ComponentAgent(""component207""));
		agent.addChild(new ComponentAgent(""component208""));
		agent.addChild(new ComponentAgent(""component209""));
		agent.addChild(new ComponentAgent(""component210""));
		agent.addChild(new ComponentAgent(""component211""));
		agent.addChild(new ComponentAgent(""component212""));
		agent.addChild(new ComponentAgent(""component213""));
		agent.addChild(new ComponentAgent(""component214""));
		agent.addChild(new ComponentAgent(""component215""));
		agent.addChild(new ComponentAgent(""component216""));
		agent.addChild(new ComponentAgent(""component217""));
		agent.addChild(new ComponentAgent(""component218""));
		agent.addChild(new ComponentAgent(""component219""));
		agent.addChild(new ComponentAgent(""component220""));
		agent.addChild(new ComponentAgent(""component221""));
		agent.addChild(new ComponentAgent(""component222""));
		agent.addChild(new ComponentAgent(""component223""));
		agent.addChild(new ComponentAgent(""component224""));
		agent.addChild(new ComponentAgent(""component225""));
		agent.addChild(new ComponentAgent(""component226""));
		agent.addChild(new ComponentAgent(""component227""));
		agent.addChild(new ComponentAgent(""component228""));
		agent.addChild(new ComponentAgent(""component229""));
		agent.addChild(new ComponentAgent(""component230""));
		agent.addChild(new ComponentAgent(""component231""));
		agent.addChild(new ComponentAgent(""component232""));
		agent.addChild(new ComponentAgent(""component233""));
		agent.addChild(new ComponentAgent(""component234""));
		agent.addChild(new ComponentAgent(""component235""));
		agent.addChild(new ComponentAgent(""component236""));
		agent.addChild(new ComponentAgent(""component237""));
		agent.addChild(new ComponentAgent(""component238""));
		agent.addChild(new ComponentAgent(""component239""));
		agent.addChild(new ComponentAgent(""component240""));
		agent.addChild(new ComponentAgent(""component241""));
		agent.addChild(new ComponentAgent(""component242""));
		agent.addChild(new ComponentAgent(""component243""));
		agent.addChild(new ComponentAgent(""component244""));
		agent.addChild(new ComponentAgent(""component245""));
		agent.addChild(new ComponentAgent(""component246""));
		agent.addChild(new ComponentAgent(""component247""));
		agent.addChild(new ComponentAgent(""component248""));
"
cmpl-6x8tmF169pnI3WR51k5w2BLl7qUKa,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock0.java,187.09946632385254,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        HorizontalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {

    @Test
    void testExtractSequentialSubblocks1() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(0, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(0, result.size());
    }

    @Test
    void testExtractSequentialSubblocks2() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(1, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(1, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
    }

    @Test
    void testExtractSequentialSubblocks3() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(2, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(2, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
    }

    @Test
    void testExtractSequentialSubblocks4() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(3, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(3, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
    }

    @Test
    void testExtractSequentialSubblocks5() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(4, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(4, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
    }

    @Test
    void testExtractSequentialSubblocks6() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(5, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(5, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
        assertEquals(new CharPosition1(4, 0), result.get(4).x1);
        assertEquals(new CharPosition1(5, 0), result.get(4).x2);
    }

    @Test
    void testExtractSequentialSubblocks7() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(6, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(6, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
        assertEquals(new CharPosition1(4, 0), result.get(4).x1);
        assertEquals(new CharPosition1(5, 0), result.get(4).x2);
        assertEquals(new CharPosition1(5, 0), result.get(5).x1);
        assertEquals(new CharPosition1(6, 0), result.get(5).x2);
    }

    @Test
    void testExtractSequentialSubblocks8() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(7, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(7, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
        assertEquals(new CharPosition1(4, 0), result.get(4).x1);
        assertEquals(new CharPosition1(5, 0), result.get(4).x2);
        assertEquals(new CharPosition1(5, 0), result.get(5).x1);
        assertEquals(new CharPosition1(6, 0), result.get(5).x2);
        assertEquals(new CharPosition1(6, 0), result.get(6).x1);
        assertEquals(new CharPosition1(7, 0), result.get(6).x2);
    }

    @Test
    void testExtractSequentialSubblocks9() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(8, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(8, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
        assertEquals(new CharPosition1(4, 0), result.get(4).x1);
        assertEquals(new CharPosition1(5, 0), result.get(4).x2);
        assertEquals(new CharPosition1(5, 0), result.get(5).x1);
        assertEquals(new CharPosition1(6, 0), result.get(5).x2);
        assertEquals(new CharPosition1(6, 0), result.get(6).x1);
        assertEquals(new CharPosition1(7, 0), result.get(6).x2);
        assertEquals(new CharPosition1(7, 0), result.get(7).x1);
        assertEquals(new CharPosition1(8, 0), result.get(7).x2);
    }

    @Test
    void testExtractSequentialSubblocks10() {
        HorizontalBlock block = new HorizontalBlock(new CharPosition1(0, 0), new CharPosition1(9, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(9, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).x1);
        assertEquals(new CharPosition1(1, 0), result.get(0).x2);
        assertEquals(new CharPosition1(1, 0), result.get(1).x1);
        assertEquals(new CharPosition1(2, 0), result.get(1).x2);
        assertEquals(new CharPosition1(2, 0), result.get(2).x1);
        assertEquals(new CharPosition1(3, 0), result.get(2).x2);
        assertEquals(new CharPosition1(3, 0), result.get(3).x1);
        assertEquals(new CharPosition1(4, 0), result.get(3).x2);
        assertEquals(new CharPosition1(4, 0), result.get(4).x1);
        assertEquals(new CharPosition1(5, 0), result.get(4).x2);
        assertEquals(new CharPosition1(5, 0), result.get(5).x1);
        assertEquals(new CharPosition1(6, 0), result.get(5).x2);
        assertEquals(new CharPosition1(6, 0), result.get(6).x1);
        assertEquals(new CharPosition1(7, 0), result.get(6).x2);
        assertEquals(new CharPosition1(7, 0), result.get(7).x1);
        assertEquals(new CharPosition1(8, 0), result.get(7).x2);
        assertEquals(new CharPosition1(8, 0), result.get(8).x1);
        assertEquals(new CharPosition1(9, 0), result.get(8).x2);
    }
}

// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}

// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {
		
    @Test
    void testExtractSequentialSubblocks1() {
        VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 0));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(0, result.size());
    }

    @Test
    void testExtractSequentialSubblocks2() {
        VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 1));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(1, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).y1);
        assertEquals(new CharPosition1(0, 1), result.get(0).y2);
    }

    @Test
    void testExtractSequentialSubblocks3() {
        VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 2));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(2, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).y1);
        assertEquals(new CharPosition1(0, 1), result.get(0).y2);
        assertEquals(new CharPosition1(0, 1), result.get(1).y1);
        assertEquals(new CharPosition1(0, 2), result.get(1).y2);
    }

    @Test
    void testExtractSequentialSubblocks4() {
        VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 3));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(3, result.size());
        assertEquals(new CharPosition1(0, 0), result.get(0).y1);
        assertEquals(new CharPosition1(0, 1), result.get(0).y2);
        assertEquals(new CharPosition1(0, 1), result.get(1).y1);
        assertEquals(new CharPosition1(0, 2), result.get(1).y2);
        assertEquals(new CharPosition1(0, 2), result.get(2).y1);
        assertEquals(new CharPosition1(0, 3), result.get(2).y2);
    }

    @Test
    void testExtractSequentialSubblocks5() {
        VerticalBlock block = new VerticalBlock(new CharPosition1(0, 0), new CharPosition1(0, 4));
        List<Block> result = block.extractSequentialSubblocks();
        assertEquals(4, result.size());
        assertEquals(new CharPosition1(0, 0),"
cmpl-6x8wnInc9Bb8NAFzSIVNopRt6vDrQ,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock1.java,244.21832704544067,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<HWordPosition> hLines = getIntersectingHLines();
        if (hLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(hLines);
        else
            return extractParallelSubblocksWithoutLines();
    }
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {

    /**
     * Test case 1.
     * The block is empty.
     */
    @Test
    void testExtractParallelSubblocks1() {
        HorizontalBlock block = new HorizontalBlock();
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(0, subblocks.size());
    }

    /**
     * Test case 2.
     * The block contains one word.
     */
    @Test
    void testExtractParallelSubblocks2() {
        HorizontalBlock block = new HorizontalBlock();
        block.add(new HWordPosition(0, 0, 10, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(1, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
    }

    /**
     * Test case 3.
     * The block contains two words.
     */
    @Test
    void testExtractParallelSubblocks3() {
        HorizontalBlock block = new HorizontalBlock();
        block.add(new HWordPosition(0, 0, 10, 10));
        block.add(new HWordPosition(20, 0, 30, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(1, subblocks.size());
        assertEquals(2, subblocks.get(0).size());
    }

    /**
     * Test case 4.
     * The block contains three words.
     */
    @Test
    void testExtractParallelSubblocks4() {
        HorizontalBlock block = new HorizontalBlock();
        block.add(new HWordPosition(0, 0, 10, 10));
        block.add(new HWordPosition(20, 0, 30, 10));
        block.add(new HWordPosition(40, 0, 50, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(1, subblocks.size());
        assertEquals(3, subblocks.get(0).size());
    }

    /**
     * Test case 5.
     * The block contains three words and one line.
     */
    @Test
    void testExtractParallelSubblocks5() {
        HorizontalBlock block = new HorizontalBlock();
        block.add(new HWordPosition(0, 0, 10, 10));
        block.add(new HWordPosition(20, 0, 30, 10));
        block.add(new HWordPosition(40, 0, 50, 10));
        block.add(new HLinePosition(30, 0, 30, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(2, subblocks.size());
        assertEquals(2, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
    }

    /**
     * Test case 6.
     * The block contains three words and two lines.
     */
    @Test
    void testExtractParallelSubblocks6() {
        HorizontalBlock block = new HorizontalBlock();
        block.add(new HWordPosition(0, 0, 10, 10));
        block.add(new HWordPosition(20, 0, 30, 10));
        block.add(new HWordPosition(40, 0, 50, 10));
        block.add(new HLinePosition(30, 0, 30, 10));
        block.add(new HLinePosition(10, 0, 10, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(3, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
        assertEquals(1, subblocks.get(2).size());
    }

    /**
     * Test case 7.
     * The block contains three words and three lines.
     */
    @Test
    void testExtractParallelSubblocks7() {
        HorizontalBlock block = new HorizontalBlock();
        block.add(new HWordPosition(0, 0, 10, 10));
        block.add(new HWordPosition(20, 0, 30, 10));
        block.add(new HWordPosition(40, 0, 50, 10));
        block.add(new HLinePosition(30, 0, 30, 10));
        block.add(new HLinePosition(10, 0, 10, 10));
        block.add(new HLinePosition(50, 0, 50, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(3, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
        assertEquals(1, subblocks.get(2).size());
    }

    /**
     * Test case 8.
     * The block contains three words and four lines.
     */
    @Test
    void testExtractParallelSubblocks8() {
        HorizontalBlock block = new HorizontalBlock();
        block.add(new HWordPosition(0, 0, 10, 10));
        block.add(new HWordPosition(20, 0, 30, 10));
        block.add(new HWordPosition(40, 0, 50, 10));
        block.add(new HLinePosition(30, 0, 30, 10));
        block.add(new HLinePosition(10, 0, 10, 10));
        block.add(new HLinePosition(50, 0, 50, 10));
        block.add(new HLinePosition(0, 0, 0, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(4, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
        assertEquals(1, subblocks.get(2).size());
        assertEquals(1, subblocks.get(3).size());
    }

    /**
     * Test case 9.
     * The block contains three words and five lines.
     */
    @Test
    void testExtractParallelSubblocks9() {
        HorizontalBlock block = new HorizontalBlock();
        block.add(new HWordPosition(0, 0, 10, 10));
        block.add(new HWordPosition(20, 0, 30, 10));
        block.add(new HWordPosition(40, 0, 50, 10));
        block.add(new HLinePosition(30, 0, 30, 10));
        block.add(new HLinePosition(10, 0, 10, 10));
        block.add(new HLinePosition(50, 0, 50, 10));
        block.add(new HLinePosition(0, 0, 0, 10));
        block.add(new HLinePosition(60, 0, 60, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(5, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
        assertEquals(1, subblocks.get(2).size());
        assertEquals(1, subblocks.get(3).size());
        assertEquals(1, subblocks.get(4).size());
    }

    /**
     * Test case 10.
     * The block contains three words and six lines.
     */
    @Test
    void testExtractParallelSubblocks10() {
        HorizontalBlock block = new HorizontalBlock();
        block.add(new HWordPosition(0, 0, 10, 10));
        block.add(new HWordPosition(20, 0, 30, 10));
        block.add(new HWordPosition(40, 0, 50, 10));
        block.add(new HLinePosition(30, 0, 30, 10));
        block.add(new HLinePosition(10, 0, 10, 10));
        block.add(new HLinePosition(50, 0, 50, 10));
        block.add(new HLinePosition(0, 0, 0, 10));
        block.add(new HLinePosition(60, 0, 60, 10));
        block.add(new HLinePosition(70, 0, 70, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(6, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
        assertEquals(1, subblocks.get(2).size());
        assertEquals(1, subblocks.get(3).size());
        assertEquals(1, subblocks.get(4).size());
        assertEquals(1, subblocks.get(5).size());
    }
}

// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }
}

// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {
		
    /**
     * Test case 1.
     * The block is empty.
     */
    @Test
    void testExtractParallelSubblocks1() {
        VerticalBlock block = new VerticalBlock();
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(0, subblocks.size());
    }

    /**
     * Test case 2.
     * The block contains one word.
     */
    @Test
    void testExtractParallelSubblocks2() {
        VerticalBlock block = new VerticalBlock();
        block.add(new VWordPosition(0, 0, 10, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(1, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
    }

    /**
     * Test case 3.
     * The block contains two words.
     */
    @Test
    void testExtractParallelSubblocks3() {
        VerticalBlock block = new VerticalBlock();
        block.add(new VWordPosition(0, 0, 10, 10));
        block.add(new VWordPosition(0, 20, 10, 30));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(1, subblocks.size());
        assertEquals(2, subblocks.get(0).size());
    }

    /**
     * Test case 4.
     * The block contains three words.
     */
    @Test
    void testExtractParallelSubblocks4() {
        VerticalBlock block = new VerticalBlock();
        block.add(new VWordPosition(0, 0, 10, 10));
        block.add(new VWordPosition(0, 20, 10, 30));
        block.add(new VWordPosition(0, 40, 10, 50));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(1, subblocks.size());
        assertEquals(3, subblocks.get(0).size());
    }

    /**
     * Test case 5.
     * The block contains three words and one line.
     */
    @Test
    void testExtractParallelSubblocks5() {
        VerticalBlock block = new VerticalBlock();
        block.add(new VWordPosition(0, 0, 10, 10));
        block.add(new VWordPosition(0, 20, 10, 30));
        block.add(new VWordPosition(0, 40, 10, 50));
        block.add(new VLinePosition(0, 30, 10, 30));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(2, subblocks.size());
        assertEquals(2, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
    }

    /**
     * Test case 6.
     * The block contains three words and two lines.
     */
    @Test
    void testExtractParallelSubblocks6() {
        VerticalBlock block = new VerticalBlock();
        block.add(new VWordPosition(0, 0, 10, 10));
        block.add(new VWordPosition(0, 20, 10, 30));
        block.add(new VWordPosition(0, 40, 10, 50));
        block.add(new VLinePosition(0, 30, 10, 30));
        block.add(new VLinePosition(0, 10, 10, 10));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(3, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
        assertEquals(1, subblocks.get(2).size());
    }

    /**
     * Test case 7.
     * The block contains three words and three lines.
     */
    @Test
    void testExtractParallelSubblocks7() {
        VerticalBlock block = new VerticalBlock();
        block.add(new VWordPosition(0, 0, 10, 10));
        block.add(new VWordPosition(0, 20, 10, 30));
        block.add(new VWordPosition(0, 40, 10, 50));
        block.add(new VLinePosition(0, 30, 10, 30));
        block.add(new VLinePosition(0, 10, 10, 10));
        block.add(new VLinePosition(0, 50, 10, 50));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(3, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
        assertEquals(1, subblocks.get(2).size());
    }

    /**
     * Test case 8.
     * The block contains three words and four lines.
     */
    @Test
    void testExtractParallelSubblocks8() {
        VerticalBlock block = new VerticalBlock();
        block.add(new VWordPosition(0, 0, 10, 10));
        block.add(new VWordPosition(0, 20, 10, 30));
        block.add(new VWordPosition(0, 40, 10, 50));
        block.add(new VLinePosition(0, 30, 10, 30));
        block.add(new VLinePosition(0, 10, 10, 10));
        block.add(new VLinePosition(0, 50, 10, 50));
        block.add(new VLinePosition(0, 0, 10, 0));
        List<Block> subblocks = block.extractParallelSubblocks();
        assertEquals(4, subblocks.size());
        assertEquals(1, subblocks.get(0).size());
        assertEquals(1, subblocks.get(1).size());
        assertEquals(1, subblocks.get(2).size());
        assertEquals(1, subblocks.get(3).size());
    }

    /**
     * Test case 9.
     * The block contains three words and five lines.
     */
    @Test
    void testExtractParallelSubblocks9() {
        VerticalBlock block = new VerticalBlock();
        block.add(new VWordPosition(0, 0, 10, 10));
        block.add"
cmpl-6x90k2X9ZfysXaJQWbDJL41xLi5D5,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock0.java,187.5295000076294,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        VerticalBlock firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {

	@Test
	void testExtractSequentialSubblocks1() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}
	
	@Test
	void testExtractSequentialSubblocks2() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 5)), result.get(1));
	}
	
	@Test
	void testExtractSequentialSubblocks3() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 4)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 5), new CharPosition1(1, 5)), result.get(2));
	}
	
	@Test
	void testExtractSequentialSubblocks4() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 5)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 5), new CharPosition1(1, 5)), result.get(2));
	}
	
	@Test
	void testExtractSequentialSubblocks5() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(4, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 5)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 5), new CharPosition1(1, 5)), result.get(2));
		assertEquals(new VerticalBlock(new CharPosition1(1, 6), new CharPosition1(1, 6)), result.get(3));
	}
	
	@Test
	void testExtractSequentialSubblocks6() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		block.add(new CharPosition1(1, 7));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(4, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 7)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(2));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(3));
	}
	
	@Test
	void testExtractSequentialSubblocks7() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		block.add(new CharPosition1(1, 7));
		block.add(new CharPosition1(1, 8));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(5, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 7)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(2));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(3));
		assertEquals(new VerticalBlock(new CharPosition1(1, 8), new CharPosition1(1, 8)), result.get(4));
	}
	
	@Test
	void testExtractSequentialSubblocks8() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		block.add(new CharPosition1(1, 7));
		block.add(new CharPosition1(1, 8));
		block.add(new CharPosition1(1, 9));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(5, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 7)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(2));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(3));
		assertEquals(new VerticalBlock(new CharPosition1(1, 9), new CharPosition1(1, 9)), result.get(4));
	}
	
	@Test
	void testExtractSequentialSubblocks9() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		block.add(new CharPosition1(1, 7));
		block.add(new CharPosition1(1, 8));
		block.add(new CharPosition1(1, 9));
		block.add(new CharPosition1(1, 10));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(6, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 7)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(2));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(3));
		assertEquals(new VerticalBlock(new CharPosition1(1, 9), new CharPosition1(1, 9)), result.get(4));
		assertEquals(new VerticalBlock(new CharPosition1(1, 10), new CharPosition1(1, 10)), result.get(5));
	}
	
	@Test
	void testExtractSequentialSubblocks10() {
		VerticalBlock block = new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 3));
		block.add(new CharPosition1(1, 4));
		block.add(new CharPosition1(1, 5));
		block.add(new CharPosition1(1, 6));
		block.add(new CharPosition1(1, 7));
		block.add(new CharPosition1(1, 8));
		block.add(new CharPosition1(1, 9));
		block.add(new CharPosition1(1, 10));
		block.add(new CharPosition1(1, 11));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(6, result.size());
		assertEquals(new VerticalBlock(new CharPosition1(1, 1), new CharPosition1(1, 2)), result.get(0));
		assertEquals(new VerticalBlock(new CharPosition1(1, 4), new CharPosition1(1, 7)), result.get(1));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(2));
		assertEquals(new VerticalBlock(new CharPosition1(1, 7), new CharPosition1(1, 7)), result.get(3));
		assertEquals(new VerticalBlock(new CharPosition1(1, 9), new CharPosition1(1, 11)), result.get(4));
		assertEquals(new VerticalBlock(new CharPosition1(1, 11), new CharPosition1(1, 11)), result.get(5));
	}
}

// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        HorizontalBlock firstBlock;
        HorizontalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }
}

// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {
		
	@Test
	void testExtractSequentialSubblocks1() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(1, 1), new CharPosition1(5, 1));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}
	
	@Test
	void testExtractSequentialSubblocks2() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(1, 1), new CharPosition1(5, 1));
		block.add(new CharPosition1(3, 1));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(1, 1), new CharPosition1(2, 1)), result.get(0));
		assertEquals(new HorizontalBlock(new CharPosition1(4, 1), new CharPosition1(5, 1)), result.get(1));
	}
	
	@Test
	void testExtractSequentialSubblocks3() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(1, 1), new CharPosition1(5, 1));
		block.add(new CharPosition1(3, 1));
		block.add(new CharPosition1(4, 1));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(1, 1), new CharPosition1(2, 1)), result.get(0));
		assertEquals(new HorizontalBlock(new CharPosition1(4, 1), new CharPosition1(4, 1)), result.get(1));
		assertEquals(new HorizontalBlock(new CharPosition1(5, 1), new CharPosition1(5, 1)), result.get(2));
	}
	
	@Test
	void testExtractSequentialSubblocks4() {
		HorizontalBlock block = new HorizontalBlock(new CharPosition1(1, 1), new CharPosition1(5, 1));
		block.add(new CharPosition1(3, 1));
		block.add(new CharPosition1(4, 1));
		block.add(new CharPosition1(5, 1));
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(new CharPosition1(1, 1), new CharPosition1(2, 1)), result.get(0));
		assertEquals(new HorizontalBlock(new CharPosition1(4, 1), new CharPosition1(5, 1)), result.get(1));
		assertEquals(new HorizontalBlock(new CharPosition1(5, 1), new CharPosition1(5, 1)), result.get(2));
	}"
cmpl-6x93lelmHdyq9ZbPcWCNdFDZi9SLe,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock1.java,146.60140204429626,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {

	/**
	* Test case 1.
	* The block contains one word.
	*/
	@Test
	void testCase1() {
		List<VWordPosition> positions = new LinkedList<VWordPosition>();
		positions.add(new VWordPosition(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"
cmpl-6x968bex335UP0RnIug1cK3wKvpzA,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/positions/HWordPosition.java,142.54686880111694,length,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {

	@Test
	void testTextAt() {
		CharTable ct = new CharTable(5, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(1, 0, 'b');
		ct.setCharAt(2, 0, 'c');
		ct.setCharAt(3, 0, 'd');
		ct.setCharAt(4, 0, 'e');
		
		HWordPosition wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 0, 0);
		assertEquals(""a"", wp.textAt(ct));
		
		wp = new HWordPosition(4, 0, 4, 0);
		assertEquals(""e"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
	}
}

// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition {

    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}

// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(5, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(0, 1, 'b');
		ct.setCharAt(0, 2, 'c');
		ct.setCharAt(0, 3, 'd');
		ct.setCharAt(0, 4, 'e');
		
		VWordPosition wp = new VWordPosition(0, 0, 0, 4);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 0);
		assertEquals(""a"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 4, 0, 4);
		assertEquals(""e"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 4);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 4);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 4);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 4);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 4);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 4);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 0, 0, 4);
		assertEquals(""abcde"", wp.textAt(ct));
	}
}

// WordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying on the scheme.
 */
public abstract class WordPosition {

    private final int startX;
    private final int startY;
    private final int endX;
    private final int endY;

    public WordPosition(int startX, int startY, int endX, int endY) {
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
    }

    public int getStartX() {
        return startX;
    }

    public int getStartY() {
        return startY;
    }

    public int getEndX() {
        return endX;
    }

    public int getEndY() {
        return endY;
    }

    public abstract String textAt(CharTable ct);
}

// WordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPosition}.
* It contains ten unit test cases for the {@link WordPosition#textAt(CharTable)} method.
*/
class WordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(5, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(1, 0, 'b');
		ct.setCharAt(2, 0, 'c');
		ct.setCharAt(3, 0, 'd');
		ct.setCharAt(4, 0, 'e');
		
		WordPosition wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 0, 0);
		assertEquals(""a"", wp.textAt(ct));
		
		wp = new HWordPosition(4, 0, 4, 0);
		assertEquals(""e"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = new HWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
	}
}

// WordPositionFactory.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Factory class for creating {@link WordPosition} objects.
 */
public class WordPositionFactory {

    public static WordPosition createWordPosition(int startX, int startY, int endX, int endY) {
        if (startX == endX) {
            return new VWordPosition(startX, startY, endX, endY);
        } else if (startY == endY) {
            return new HWordPosition(startX, startY, endX, endY);
        } else {
            throw new IllegalArgumentException(""The word is neither horizontal nor vertical."");
        }
    }
}

// WordPositionFactoryTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPositionFactory}.
* It contains ten unit test cases for the {@link WordPositionFactory#createWordPosition(int, int, int, int)} method.
*/
class WordPositionFactoryTest {
		
	@Test
	void testCreateWordPosition() {
		CharTable ct = new CharTable(5, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(1, 0, 'b');
		ct.setCharAt(2, 0, 'c');
		ct.setCharAt(3, 0, 'd');
		ct.setCharAt(4, 0, 'e');
		
		WordPosition wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 0, 0);
		assertEquals(""a"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(4, 0, 4, 0);
		assertEquals(""e"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
	}
}

// WordPositionFactoryTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPositionFactory}.
* It contains ten unit test cases for the {@link WordPositionFactory#createWordPosition(int, int, int, int)} method.
*/
class WordPositionFactoryTest {
		
	@Test
	void testCreateWordPosition() {
		CharTable ct = new CharTable(5, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(1, 0, 'b');
		ct.setCharAt(2, 0, 'c');
		ct.setCharAt(3, 0, 'd');
		ct.setCharAt(4, 0, 'e');
		
		WordPosition wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 0, 0);
		assertEquals(""a"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(4, 0, 4, 0);
		assertEquals(""e"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
	}
}

// WordPositionFactoryTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPositionFactory}.
* It contains ten unit test cases for the {@link WordPositionFactory#createWordPosition(int, int, int, int)} method.
*/
class WordPositionFactoryTest {
		
	@Test
	void testCreateWordPosition() {
		CharTable ct = new CharTable(5, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(1, 0, 'b');
		ct.setCharAt(2, 0, 'c');
		ct.setCharAt(3, 0, 'd');
		ct.setCharAt(4, 0, 'e');
		
		WordPosition wp = WordPositionFactory.createWordPosition(0, 0, 4, 0);
		assertEquals(""abcde"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(0, 0, 0, 0);
		assertEquals(""a"", wp.textAt(ct));
		
		wp = WordPositionFactory.createWordPosition(4, 0, 4, 0);
		assertEquals(""e"", wp"
cmpl-6x99BusZP97gmxYCFpNY8m3FeCron,/EvoSuiteBenchmark/scenario1/40_glengineer/src/main/java/glengineer/positions/VWordPosition.java,221.31927824020386,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {

	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		ct.setCharAt(0, 0, 'A');
		ct.setCharAt(0, 1, 'B');
		ct.setCharAt(0, 2, 'C');
		ct.setCharAt(0, 3, 'D');
		ct.setCharAt(0, 4, 'E');
		ct.setCharAt(0, 5, 'F');
		ct.setCharAt(0, 6, 'G');
		ct.setCharAt(0, 7, 'H');
		ct.setCharAt(0, 8, 'I');
		ct.setCharAt(0, 9, 'J');
		ct.setCharAt(1, 0, 'K');
		ct.setCharAt(1, 1, 'L');
		ct.setCharAt(1, 2, 'M');
		ct.setCharAt(1, 3, 'N');
		ct.setCharAt(1, 4, 'O');
		ct.setCharAt(1, 5, 'P');
		ct.setCharAt(1, 6, 'Q');
		ct.setCharAt(1, 7, 'R');
		ct.setCharAt(1, 8, 'S');
		ct.setCharAt(1, 9, 'T');
		ct.setCharAt(2, 0, 'U');
		ct.setCharAt(2, 1, 'V');
		ct.setCharAt(2, 2, 'W');
		ct.setCharAt(2, 3, 'X');
		ct.setCharAt(2, 4, 'Y');
		ct.setCharAt(2, 5, 'Z');
		ct.setCharAt(2, 6, 'A');
		ct.setCharAt(2, 7, 'B');
		ct.setCharAt(2, 8, 'C');
		ct.setCharAt(2, 9, 'D');
		ct.setCharAt(3, 0, 'E');
		ct.setCharAt(3, 1, 'F');
		ct.setCharAt(3, 2, 'G');
		ct.setCharAt(3, 3, 'H');
		ct.setCharAt(3, 4, 'I');
		ct.setCharAt(3, 5, 'J');
		ct.setCharAt(3, 6, 'K');
		ct.setCharAt(3, 7, 'L');
		ct.setCharAt(3, 8, 'M');
		ct.setCharAt(3, 9, 'N');
		ct.setCharAt(4, 0, 'O');
		ct.setCharAt(4, 1, 'P');
		ct.setCharAt(4, 2, 'Q');
		ct.setCharAt(4, 3, 'R');
		ct.setCharAt(4, 4, 'S');
		ct.setCharAt(4, 5, 'T');
		ct.setCharAt(4, 6, 'U');
		ct.setCharAt(4, 7, 'V');
		ct.setCharAt(4, 8, 'W');
		ct.setCharAt(4, 9, 'X');
		ct.setCharAt(5, 0, 'Y');
		ct.setCharAt(5, 1, 'Z');
		ct.setCharAt(5, 2, 'A');
		ct.setCharAt(5, 3, 'B');
		ct.setCharAt(5, 4, 'C');
		ct.setCharAt(5, 5, 'D');
		ct.setCharAt(5, 6, 'E');
		ct.setCharAt(5, 7, 'F');
		ct.setCharAt(5, 8, 'G');
		ct.setCharAt(5, 9, 'H');
		ct.setCharAt(6, 0, 'I');
		ct.setCharAt(6, 1, 'J');
		ct.setCharAt(6, 2, 'K');
		ct.setCharAt(6, 3, 'L');
		ct.setCharAt(6, 4, 'M');
		ct.setCharAt(6, 5, 'N');
		ct.setCharAt(6, 6, 'O');
		ct.setCharAt(6, 7, 'P');
		ct.setCharAt(6, 8, 'Q');
		ct.setCharAt(6, 9, 'R');
		ct.setCharAt(7, 0, 'S');
		ct.setCharAt(7, 1, 'T');
		ct.setCharAt(7, 2, 'U');
		ct.setCharAt(7, 3, 'V');
		ct.setCharAt(7, 4, 'W');
		ct.setCharAt(7, 5, 'X');
		ct.setCharAt(7, 6, 'Y');
		ct.setCharAt(7, 7, 'Z');
		ct.setCharAt(7, 8, 'A');
		ct.setCharAt(7, 9, 'B');
		ct.setCharAt(8, 0, 'C');
		ct.setCharAt(8, 1, 'D');
		ct.setCharAt(8, 2, 'E');
		ct.setCharAt(8, 3, 'F');
		ct.setCharAt(8, 4, 'G');
		ct.setCharAt(8, 5, 'H');
		ct.setCharAt(8, 6, 'I');
		ct.setCharAt(8, 7, 'J');
		ct.setCharAt(8, 8, 'K');
		ct.setCharAt(8, 9, 'L');
		ct.setCharAt(9, 0, 'M');
		ct.setCharAt(9, 1, 'N');
		ct.setCharAt(9, 2, 'O');
		ct.setCharAt(9, 3, 'P');
		ct.setCharAt(9, 4, 'Q');
		ct.setCharAt(9, 5, 'R');
		ct.setCharAt(9, 6, 'S');
		ct.setCharAt(9, 7, 'T');
		ct.setCharAt(9, 8, 'U');
		ct.setCharAt(9, 9, 'V');
		
		VWordPosition wp = new VWordPosition(0, 0, 0, 9);
		assertEquals(""ABCDEFGHIJ"", wp.textAt(ct));
		wp = new VWordPosition(0, 0, 9, 0);
		assertEquals(""MNBOCPDQER"", wp.textAt(ct));
		wp = new VWordPosition(0, 0, 9, 9);
		assertEquals(""MNBOCPDQER"", wp.textAt(ct));
		wp = new VWordPosition(0, 9, 0, 0);
		assertEquals(""JIHGFEDCBA"", wp.textAt(ct));
		wp = new VWordPosition(0, 9, 9, 0);
		assertEquals(""JIHGFEDCBA"", wp.textAt(ct));
		wp = new VWordPosition(0, 9, 9, 9);
		assertEquals(""JIHGFEDCBA"", wp.textAt(ct));
		wp = new VWordPosition(9, 0, 0, 0);
		assertEquals(""MNBOCPDQER"", wp.textAt(ct));
		wp = new VWordPosition(9, 0, 0, 9);
		assertEquals(""MNBOCPDQER"", wp.textAt(ct));
		wp = new VWordPosition(9, 0, 9, 0);
		assertEquals(""MNBOCPDQER"", wp.textAt(ct));
		wp = new VWordPosition(9, 0, 9, 9);
		assertEquals(""MNBOCPDQER"", wp.textAt(ct));
	}
}

// WordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying on the scheme.
 */
public abstract class WordPosition {

    protected int startX;
    protected int startY;
    protected int endX;
    protected int endY;

    public WordPosition(int startX, int startY, int endX, int endY) {
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
    }

    public int getStartX() {
        return startX;
    }

    public int getStartY() {
        return startY;
    }

    public int getEndX() {
        return endX;
    }

    public int getEndY() {
        return endY;
    }

    public abstract String textAt(CharTable ct);
}

// WordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordPosition}.
* It contains ten unit test cases for the {@link WordPosition#textAt(CharTable)} method.
*/
class WordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		ct.setCharAt(0, 0, 'A');
		ct.setCharAt(0, 1, 'B');
		ct.setCharAt(0, 2, 'C');
		ct.setCharAt(0, 3, 'D');
		ct.setCharAt(0, 4, 'E');
		ct.setCharAt(0, 5, 'F');
		ct.setCharAt(0, 6, 'G');
		ct.setCharAt(0, 7, 'H');
		ct.setCharAt(0, 8, 'I');
		ct.setCharAt(0, 9, 'J');
		ct.setCharAt(1, 0, 'K');
		ct.setCharAt(1, 1, 'L');
		ct.setCharAt(1, 2, 'M');
		ct.setCharAt(1, 3, 'N');
		ct.setCharAt(1, 4, 'O');
		ct.setCharAt(1, 5, 'P');
		ct.setCharAt(1, 6, 'Q');
		ct.setCharAt(1, 7, 'R');
		ct.setCharAt(1, 8, 'S');
		ct.setCharAt(1, 9, 'T');
		ct.setCharAt(2, 0, 'U');
		ct.setCharAt(2, 1, 'V');
		ct.setCharAt(2, 2, 'W');
		ct.setCharAt(2, 3, 'X');
		ct.setCharAt(2, 4, 'Y');
		ct.setCharAt(2, 5, 'Z');
		ct.setCharAt(2, 6, 'A');
		ct.setCharAt(2, 7, 'B');
		ct.setCharAt(2, 8, 'C');
		ct.setCharAt(2, 9, 'D');
		ct.setCharAt(3, 0, 'E');
		ct.setCharAt(3, 1, 'F');
		ct.setCharAt(3, 2, 'G');
		ct.setCharAt(3, 3, 'H');
		ct.setCharAt(3, 4, 'I');
		ct.setCharAt(3, 5, 'J');
		ct.setCharAt(3, 6, 'K');
		ct.setCharAt(3, 7, 'L');
		ct.setCharAt(3, 8, 'M');
		ct.setCharAt(3, 9, 'N');
		ct.setCharAt(4, 0, 'O');
		ct.setCharAt(4, 1, 'P');
		ct.setCharAt(4, 2, 'Q');
		ct.setCharAt(4, 3, 'R');
		ct.setCharAt(4, 4, 'S');
		ct.setCharAt(4, 5, 'T');
		ct.setCharAt(4, 6, 'U');
		ct.setCharAt(4, 7, 'V');
		ct.setCharAt(4, 8, 'W');
		ct.setCharAt(4, 9, 'X');
		ct.setCharAt(5, 0, 'Y');
		ct.setCharAt(5, 1, 'Z');
		ct.setCharAt(5, 2, 'A');
		ct.setCharAt(5, 3, 'B');
		ct.setCharAt(5, 4, 'C');
		ct.setCharAt(5, 5, 'D');
		ct.setCharAt(5, 6, 'E');
		ct.setCharAt(5, 7, 'F');
		ct.setCharAt(5, 8, 'G');
		ct.setCharAt(5, 9, 'H');
		ct.setCharAt(6, 0, 'I');
		ct.setCharAt(6, 1, 'J');
		ct.setCharAt(6, 2, 'K');
		ct.setCharAt(6, 3, 'L');
		ct.setCharAt(6, 4, 'M');
		ct.setCharAt(6, 5, 'N');
		ct.setCharAt(6, 6, 'O');
		ct.setCharAt(6, 7, 'P');
		ct.setCharAt(6, 8, 'Q');
		ct.setCharAt(6, 9, 'R');
		ct.setCharAt(7, 0, 'S');
		ct.setCharAt(7, 1, 'T');
		ct.setCharAt(7, 2, 'U');
		ct.setCharAt(7, 3, 'V');
		ct.setCharAt(7, 4, 'W');
		ct.setCharAt(7, 5, 'X');
		ct.setCharAt(7, 6, 'Y');
		ct.setCharAt(7, 7, 'Z');
		ct.setCharAt(7, 8, 'A');
		ct.setCharAt(7, 9, 'B');
		ct.setCharAt(8, 0, 'C');
		ct.setCharAt(8, 1, 'D');
		ct.setCharAt(8, 2, 'E');
		ct.setCharAt(8, 3, 'F');
		ct.setCharAt(8, 4, 'G');
		ct.setCharAt(8, 5, 'H');
		ct.setCharAt(8, 6, 'I');
		ct.setCharAt(8, 7, 'J');
		ct.setCharAt(8, 8, 'K');
		ct.setCharAt(8, 9, 'L');
		ct.setCharAt(9, 0, 'M');
		ct.setCharAt(9, 1, 'N');
		ct.setCharAt(9, 2, 'O');
		ct.setCharAt(9, 3, 'P');
		ct.setCharAt(9, 4, 'Q');
		ct.setCharAt(9, 5, 'R');
		ct.setCharAt(9, 6, 'S');
		ct."
