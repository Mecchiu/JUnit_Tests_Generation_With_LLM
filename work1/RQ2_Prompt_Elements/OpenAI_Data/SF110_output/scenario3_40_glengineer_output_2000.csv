ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wieyMir8pyg1Y61JacrO9ucGT6dM,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer0.java,58.45635724067688,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis layout direction
     * @param componentName the name of the component to be found
     * @return an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineerTest {

	/**
	 * Test case 1.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component with the specified name.
	 */
	@Test
	void testGetComponent1() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.HORIZONTAL, ""FINDLABEL"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JLabel(""Find What:""));
		
		foc = gle.getComponent(Axis.HORIZONTAL, ""TEXTFIELD"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JTextField());
		
		foc = gle.getComponent(Axis.HORIZONTAL, ""FINDBUTTON"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JButton(""Find""));
		
		foc = gle.getComponent(Axis.HORIZONTAL, ""CB11"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Match Case""));
		
		foc = gle.getComponent(Axis.HORIZONTAL, ""CB12"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Wrap Around""));
		
		foc = gle.getComponent(Axis.HORIZONTAL, ""CB21"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Whole Words""));
		
		foc = gle.getComponent(Axis.HORIZONTAL, ""CB22"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Search Backwards""));
		
		foc = gle.getComponent(Axis.HORIZONTAL, ""CANSELBUTTON"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JButton(""Cancel""));
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component with the specified name.
	 */
	@Test
	void testGetComponent2() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
			""          --------------+             "",
			""           CB11   CB12  | CANSELBUTTON"",
			""                        |             "",
			""           CB21   CB22  |             "");
		
		gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
		gle.associate(""TEXTFIELD"", new JTextField());
		gle.associate(""FINDBUTTON"", new JButton(""Find""));
		gle.associate(""CB11"", new JCheckBox(""Match Case""));
		gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
		gle.associate(""CB21"", new JCheckBox(""Whole Words""));
		gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
		gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
		
		gle.engineer();
		
		FunctionsOnComponent foc = gle.getComponent(Axis.VERTICAL, ""FINDLABEL"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JLabel(""Find What:""));
		
		foc = gle.getComponent(Axis.VERTICAL, ""TEXTFIELD"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JTextField());
		
		foc = gle.getComponent(Axis.VERTICAL, ""FINDBUTTON"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JButton(""Find""));
		
		foc = gle.getComponent(Axis.VERTICAL, ""CB11"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Match Case""));
		
		foc = gle.getComponent(Axis.VERTICAL, ""CB12"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Wrap Around""));
		
		foc = gle.getComponent(Axis.VERTICAL, ""CB21"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Whole Words""));
		
		foc = gle.getComponent(Axis.VERTICAL, ""CB22"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JCheckBox(""Search Backwards""));
		
		foc = gle.getComponent(Axis.VERTICAL, ""CANSELBUTTON"");
		assertTrue(foc instanceof ComponentAgent);
		assertEquals(((ComponentAgent)foc).getComponent(), new JButton(""Cancel""));
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The test case checks that the method
	 * {@link GroupLayoutEngineer#getComponent(Axis, String)}
	 * returns the correct agent of the component
	 * with the specified name.
	 * <p>
	 * The test case is passed if the method returns
	 * the correct agent of the component with the specified name.
	 */
	@Test
	void testGetComponent3() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""FINDLABEL  TEX"
cmpl-6wig1xgR3ibja36fwRBpQhhLRM4mS,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer1.java,57.08322858810425,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis layout direction
     * @param firstName the name of the first component in the group
     * @param lastName the name of the last component in the group
     * @return an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

	/**
	 * Test case 1.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 */
	@Test
	void test1() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.associate(""D"", new JLabel(""D""));
		gle.associate(""E"", new JLabel(""E""));
		gle.associate(""F"", new JLabel(""F""));
		gle.associate(""G"", new JLabel(""G""));
		gle.associate(""H"", new JLabel(""H""));
		gle.associate(""I"", new JLabel(""I""));
		gle.associate(""J"", new JLabel(""J""));
		gle.associate(""K"", new JLabel(""K""));
		gle.associate(""L"", new JLabel(""L""));
		gle.associate(""M"", new JLabel(""M""));
		gle.associate(""N"", new JLabel(""N""));
		gle.associate(""O"", new JLabel(""O""));
		gle.associate(""P"", new JLabel(""P""));
		gle.associate(""Q"", new JLabel(""Q""));
		gle.associate(""R"", new JLabel(""R""));
		gle.associate(""S"", new JLabel(""S""));
		gle.associate(""T"", new JLabel(""T""));
		gle.associate(""U"", new JLabel(""U""));
		gle.associate(""V"", new JLabel(""V""));
		gle.associate(""W"", new JLabel(""W""));
		gle.associate(""X"", new JLabel(""X""));
		gle.associate(""Y"", new JLabel(""Y""));
		gle.associate(""Z"", new JLabel(""Z""));
		gle.engineer();
		
		FunctionsOnGroup fog = gle.getGroup(Axis.HORIZONTAL, ""A"", ""Z"");
		assertEquals(fog.getFirstName(), ""A"");
		assertEquals(fog.getLastName(), ""Z"");
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 */
	@Test
	void test2() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.associate(""D"", new JLabel(""D""));
		gle.associate(""E"", new JLabel(""E""));
		gle.associate(""F"", new JLabel(""F""));
		gle.associate(""G"", new JLabel(""G""));
		gle.associate(""H"", new JLabel(""H""));
		gle.associate(""I"", new JLabel(""I""));
		gle.associate(""J"", new JLabel(""J""));
		gle.associate(""K"", new JLabel(""K""));
		gle.associate(""L"", new JLabel(""L""));
		gle.associate(""M"", new JLabel(""M""));
		gle.associate(""N"", new JLabel(""N""));
		gle.associate(""O"", new JLabel(""O""));
		gle.associate(""P"", new JLabel(""P""));
		gle.associate(""Q"", new JLabel(""Q""));
		gle.associate(""R"", new JLabel(""R""));
		gle.associate(""S"", new JLabel(""S""));
		gle.associate(""T"", new JLabel(""T""));
		gle.associate(""U"", new JLabel(""U""));
		gle.associate(""V"", new JLabel(""V""));
		gle.associate(""W"", new JLabel(""W""));
		gle.associate(""X"", new JLabel(""X""));
		gle.associate(""Y"", new JLabel(""Y""));
		gle.associate(""Z"", new JLabel(""Z""));
		gle.engineer();
		
		FunctionsOnGroup fog = gle.getGroup(Axis.HORIZONTAL, ""A"", ""Z"");
		assertEquals(fog.getFirstName(), ""A"");
		assertEquals(fog.getLastName(), ""Z"");
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z""
	 * </pre>
	 */
	@Test
	void test3() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.associate(""D"", new JLabel(""D""));
		gle.associate(""E"", new JLabel(""E""));
		gle.associate(""F"", new JLabel(""F""));
		gle.associate(""G"", new JLabel(""G""));
		gle.associate(""H"", new JLabel(""H""));
		gle.associate(""I"", new JLabel(""I""));
		gle.associate(""J"", new JLabel(""J""));
		gle.associate(""K"", new JLabel(""K""));
		gle.associate(""L"", new JLabel(""L""));
		gle.associate(""M"", new JLabel(""M""));
		gle.associate(""N"", new JLabel(""N""));
		gle.associate(""O"", new JLabel(""O""));
		gle.associate(""P"", new JLabel(""P""));
		gle.associate(""Q"", new JLabel(""Q""));
		gle.associate(""R"", new JLabel(""R"
cmpl-6wih4uuyWO2DTPtykVbJN351ndD6G,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer2.java,58.86709117889404,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis layout direction
     * @param firstName the name of the first component in the group
     * @param lastName the name of the last component in the group
     * @return an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

	/**
	 * Test case 1.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void test1() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""A"", ""C"");
		assertEquals(fopg.getGroup().getElements().size(), 3);
		assertEquals(fopg.getGroup().getElements().get(0).getComponent().getName(), ""A"");
		assertEquals(fopg.getGroup().getElements().get(1).getComponent().getName(), ""B"");
		assertEquals(fopg.getGroup().getElements().get(2).getComponent().getName(), ""C"");
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void test2() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""B"", ""B"");
		assertEquals(fopg.getGroup().getElements().size(), 1);
		assertEquals(fopg.getGroup().getElements().get(0).getComponent().getName(), ""B"");
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void test3() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""A"", ""B"");
		assertEquals(fopg.getGroup().getElements().size(), 2);
		assertEquals(fopg.getGroup().getElements().get(0).getComponent().getName(), ""A"");
		assertEquals(fopg.getGroup().getElements().get(1).getComponent().getName(), ""B"");
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void test4() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""B"", ""C"");
		assertEquals(fopg.getGroup().getElements().size(), 2);
		assertEquals(fopg.getGroup().getElements().get(0).getComponent().getName(), ""B"");
		assertEquals(fopg.getGroup().getElements().get(1).getComponent().getName(), ""C"");
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void test5() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""C"", ""A"");
		assertEquals(fopg.getGroup().getElements().size(), 3);
		assertEquals(fopg.getGroup().getElements().get(0).getComponent().getName(), ""A"");
		assertEquals(fopg.getGroup().getElements().get(1).getComponent().getName(), ""B"");
		assertEquals(fopg.getGroup().getElements().get(2).getComponent().getName(), ""C"");
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void test6() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnParallelGroup fopg = gle.getParallelGroup(Axis.HORIZONTAL, ""B"", ""A"");
		assertEquals(fopg.getGroup().getElements().size(), 2);
		assertEquals(fopg.getGroup().getElements().get(0).getComponent().getName(), ""A"");
		assertEquals(fopg.getGroup().getElements().get(1).getComponent().getName(), ""B"");
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>"
cmpl-6wii760kiWQICFT88cwVHzX0TiDNn,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer3.java,67.72392153739929,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis layout direction
     * @param firstName the name of the first component in the group
     * @param lastName the name of the last component in the group
     * @return an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineerTest {

	/**
	 * Test case 1.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup1() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""A"", ""C"");
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""C"");
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup2() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""B"", ""B"");
		assertEquals(fosg.getFirstName(), ""B"");
		assertEquals(fosg.getLastName(), ""B"");
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup3() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""C"", ""A"");
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""C"");
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup4() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""A"", ""B"");
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""B"");
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup5() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""B"", ""C"");
		assertEquals(fosg.getFirstName(), ""B"");
		assertEquals(fosg.getLastName(), ""C"");
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup6() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""A"", ""A"");
		assertEquals(fosg.getFirstName(), ""A"");
		assertEquals(fosg.getLastName(), ""A"");
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup7() {
		GroupLayoutEngineer gle = new GroupLayoutEngineer(
			new JPanel(),
			""A B C"");
		gle.associate(""A"", new JLabel(""A""));
		gle.associate(""B"", new JLabel(""B""));
		gle.associate(""C"", new JLabel(""C""));
		gle.engineer();
		
		FunctionsOnSequentialGroup fosg = gle.getSequentialGroup(Axis.HORIZONTAL, ""C"", ""C"");
		assertEquals(fosg.getFirstName(), ""C"");
		assertEquals(fosg.getLastName(), ""C"");
	}
	
	/**
	 * Test case 8.
	 * <p>
	 * The scheme:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 * <p>
	 * The expected result:
	 * <pre>
	 * 	""A B C""
	 * </pre>
	 */
	@Test
	void testGetSequentialGroup8() {
		GroupLayoutEngine"
cmpl-6wijCzjFIpeX5tgp6nT4XAYhtvNg3,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer4.java,69.89136457443237,length,"// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis layout direction
     * @return the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis);
}
","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {","// GroupLayoutEngineerTest.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineerTest {

		/**
		* Test case 1.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase1() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						getContentPane(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				
				gle.engineer();
				
				assertEquals(gle.getTopSequentialGroup(Axis.HORIZONTAL).toString(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "");
				assertEquals(gle.getTopSequentialGroup(Axis.VERTICAL).toString(),
						""          --------------+             "" +
						""           CB11   CB12  | CANSELBUTTON"" +
						""                        |             "" +
						""           CB21   CB22  |             "");
		}
		
		/**
		* Test case 2.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase2() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						getContentPane(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
				
				gle.engineer();
				
				assertEquals(gle.getTopSequentialGroup(Axis.HORIZONTAL).toString(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "");
				assertEquals(gle.getTopSequentialGroup(Axis.VERTICAL).toString(),
						""          --------------+             "" +
						""           CB11   CB12  | CANSELBUTTON"" +
						""                        |             "" +
						""           CB21   CB22  |             "");
		}
		
		/**
		* Test case 3.
		* <p>
		* The scheme:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		* <p>
		* The expected result:
		* <pre>
		* ""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
		* ""          --------------+             "",
		* ""           CB11   CB12  | CANSELBUTTON"",
		* ""                        |             "",
		* ""           CB21   CB22  |             "");
		* </pre>
		*/
		@Test
		void testCase3() {
				GroupLayoutEngineer gle = new GroupLayoutEngineer(
						getContentPane(),
						""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
						""          --------------+             "",
						""           CB11   CB12  | CANSELBUTTON"",
						""                        |             "",
						""           CB21   CB22  |             "");
				
				gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
				gle.associate(""TEXTFIELD"", new JTextField());
				gle.associate(""FINDBUTTON"", new JButton(""Find""));
				gle.associate(""CB11"", new JCheckBox(""Match Case""));
				gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
				gle.associate(""CB21"", new JCheckBox(""Whole Words""));
				gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
				g"
cmpl-6wikKmQF6uEodpCDZ8pBJxIBDOdYr,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent0.java,48.640525579452515,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly();
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgentTest {

	/**
	 * Test case 1.
	 * The parallel group agent contains gaps only.
	 */
	@Test
	void testContainsGapsOnly1() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		assertTrue(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 2.
	 * The parallel group agent contains gaps and elements.
	 */
	@Test
	void testContainsGapsOnly2() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addElement(new ElementAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 3.
	 * The parallel group agent contains gaps and parallel groups.
	 */
	@Test
	void testContainsGapsOnly3() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addParallelGroup(new ParallelGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 4.
	 * The parallel group agent contains gaps and sequential groups.
	 */
	@Test
	void testContainsGapsOnly4() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addSequentialGroup(new SequentialGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 5.
	 * The parallel group agent contains gaps and elements and parallel groups.
	 */
	@Test
	void testContainsGapsOnly5() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addElement(new ElementAgent());
		agent.addParallelGroup(new ParallelGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 6.
	 * The parallel group agent contains gaps and elements and sequential groups.
	 */
	@Test
	void testContainsGapsOnly6() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addElement(new ElementAgent());
		agent.addSequentialGroup(new SequentialGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 7.
	 * The parallel group agent contains gaps and parallel groups and sequential groups.
	 */
	@Test
	void testContainsGapsOnly7() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addParallelGroup(new ParallelGroupAgent());
		agent.addSequentialGroup(new SequentialGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 8.
	 * The parallel group agent contains gaps and elements and parallel groups and sequential groups.
	 */
	@Test
	void testContainsGapsOnly8() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addGap(10);
		agent.addGap(20);
		agent.addGap(30);
		agent.addElement(new ElementAgent());
		agent.addParallelGroup(new ParallelGroupAgent());
		agent.addSequentialGroup(new SequentialGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 9.
	 * The parallel group agent contains elements only.
	 */
	@Test
	void testContainsGapsOnly9() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addElement(new ElementAgent());
		agent.addElement(new ElementAgent());
		agent.addElement(new ElementAgent());
		assertFalse(agent.containsGapsOnly());
	}
	
	/**
	 * Test case 10.
	 * The parallel group agent contains parallel groups only.
	 */
	@Test
	void testContainsGapsOnly10() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.addParallelGroup(new ParallelGroupAgent());
		agent.addParallelGroup(new ParallelGroupAgent());
		agent.addParallelGroup(new ParallelGroupAgent());
		assertFalse(agent.containsGapsOnly());
	}
}

// ParallelGroupSettings.java
package glengineer.agents.settings;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupSettings {

    /**
     * The alignment of this parallel group.
     */
    public Alignment alignment;

    /**
     * The resizable property of this parallel group.
     */
    public boolean resizable;

    /**
     * The preferred size of this parallel group.
     */
    public int preferredSize;

    /**
     * The minimum size of this parallel group.
     */
    public int minimumSize;

    /**
     * The maximum size of this parallel group.
     */
    public int maximumSize;

    /**
     * The default settings of a parallel group.
     */
    public static final ParallelGroupSettings DEFAULT_SETTINGS = new ParallelGroupSettings();

    /**
     * Creates a new instance of {@link ParallelGroupSettings} with default settings.
     */
    public ParallelGroupSettings() {
        this.alignment = Alignment.LEADING;
        this.resizable = true;
        this.preferredSize = GroupLayout.DEFAULT_SIZE;
        this.minimumSize = GroupLayout.DEFAULT_SIZE;
        this.maximumSize = GroupLayout.DEFAULT_SIZE;
    }

    /**
     * Creates a new instance of {@link ParallelGroupSettings} with the specified settings.
     *
     * @param alignment the alignment of this parallel group
     * @param resizable the resizable property of this parallel group
     * @param preferredSize the preferred size of this parallel group
     * @param minimumSize the minimum size of this parallel group
     * @param maximumSize the maximum size of this parallel group
     */
    public ParallelGroupSettings(Alignment alignment, boolean resizable, int preferredSize, int minimumSize, int maximumSize) {
        this.alignment = alignment;
        this.resizable = resizable;
        this.preferredSize = preferredSize;
        this.minimumSize = minimumSize;
        this.maximumSize = maximumSize;
    }

    /**
     * Creates a new instance of {@link ParallelGroupSettings} with the specified settings.
     *
     * @param alignment the alignment of this parallel group
     * @param resizable the resizable property of this parallel group
     * @param preferredSize the preferred size of this parallel group
     * @param minimumSize the minimum size of this parallel group
     * @param maximumSize the maximum size of this parallel group
     */
    public ParallelGroupSettings(Alignment alignment, boolean resizable, int preferredSize, int minimumSize, int maximumSize) {
        this.alignment = alignment;
        this.resizable = resizable;
        this.preferredSize = preferredSize;"
cmpl-6wilNGEdXsUF6RtclFf5p5IcsQZmw,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent1.java,66.74062514305115,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    /**
     *       
     *   .
     *
     * @param creatorAndAdder    
     * 							    
     * @return ,   
     * 							.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);
}
","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {","// ParallelGroupAgentTest.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgentTest {

	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code null}.
	 */
	@Test
	void testGroupContent_NullAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return null;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(ParallelGroup group) {
				return group;
			}
		});
		assertNull(group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code Alignment.LEADING}.
	 */
	@Test
	void testGroupContent_LeadingAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return Alignment.LEADING;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(ParallelGroup group) {
				return group;
			}
		});
		assertEquals(Alignment.LEADING, group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code Alignment.TRAILING}.
	 */
	@Test
	void testGroupContent_TrailingAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return Alignment.TRAILING;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(ParallelGroup group) {
				return group;
			}
		});
		assertEquals(Alignment.TRAILING, group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code Alignment.CENTER}.
	 */
	@Test
	void testGroupContent_CenterAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return Alignment.CENTER;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(ParallelGroup group) {
				return group;
			}
		});
		assertEquals(Alignment.CENTER, group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getAlignment()} method returns {@code Alignment.BASELINE}.
	 */
	@Test
	void testGroupContent_BaselineAlignment() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Alignment getAlignment() {
				return Alignment.BASELINE;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(ParallelGroup group) {
				return group;
			}
		});
		assertEquals(Alignment.BASELINE, group.getAlignment());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getResizable()} method returns {@code true}.
	 */
	@Test
	void testGroupContent_ResizableTrue() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public boolean getResizable() {
				return true;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(ParallelGroup group) {
				return group;
			}
		});
		assertTrue(group.isResizable());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getResizable()} method returns {@code false}.
	 */
	@Test
	void testGroupContent_ResizableFalse() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public boolean getResizable() {
				return false;
			}
		});
		ParallelGroup group = agent.groupContent(new GroupCreatorAndElementAdder() {
			@Override
			public void addElement(ParallelGroup group, Object element) {
				// do nothing
			}
			@Override
			public ParallelGroup createGroup(ParallelGroup group) {
				return group;
			}
		});
		assertFalse(group.isResizable());
	}
	
	/**
	 * Test case for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the {@link ParallelGroupSettings#getElements()} method returns {@code null}.
	 */
	@Test
	void testGroupContent_NullElements() {
		ParallelGroupAgent agent = new ParallelGroupAgent();
		agent.setSettings(new ParallelGroupSettings() {
			@Override
			public Iterator<Object> getElements() {
				return"
cmpl-6wimSW5Xa76KNlGQsXI0qwIW8Ra46,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java,69.24164581298828,length,"// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * ,   .
 */
public class SequentialGroupAgent extends GroupAgent {

    /**
     *       
     *   .
     *
     * @param creatorAndAdder    
     * 							    
     * @return ,   
     * 							.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);
}
","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {

	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called once.
	*/
	@Test
	void testGroupContent_1() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new GroupLayout(null).createSequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called twice.
	*/
	@Test
	void testGroupContent_2() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new GroupLayout(null).createSequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called three times.
	*/
	@Test
	void testGroupContent_3() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new GroupLayout(null).createSequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called four times.
	*/
	@Test
	void testGroupContent_4() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new GroupLayout(null).createSequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	* is called five times.
	*/
	@Test
	void testGroupContent_5() {
		SequentialGroupAgent agent = new SequentialGroupAgent();
		GroupCreatorAndElementAdder creatorAndAdder = new GroupCreatorAndElementAdder() {
			@Override
			public SequentialGroup createGroup() {
				return new GroupLayout(null).createSequentialGroup();
			}
			@Override
			public void addComponent(javax.swing.JComponent component) {
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
				group.addComponent(component);
			}
		};
		SequentialGroup group = agent.groupContent(creatorAndAdder);
		ListIterator<Group> iterator = group.getElements();
		assertTrue(iterator.hasNext());
		Group next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertTrue(iterator.hasNext());
		next = iterator.next();
		assertTrue(next instanceof ParallelGroup);
		assertFalse(iterator.hasNext());
	}
	
	/**
	* Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	* It tests the case when the {@link GroupCreatorAndElementAdder#addComponent(javax.swing.JComponent)} method
	*"
cmpl-6winZ8ovgRs9530zy4yTmsaWOuvDl,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java,55.220027446746826,length,"// TopSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * ,     .
 * <p>
 *   {@code FunctionsOnTopSequentialGroup}
 *    
 *         .
 */
public class TopSequentialGroupAgent extends SequentialGroupAgent {

    /**
     *       ,
     * ,  ,       ,
     *    .
     * <p>
     *   {@code TopSequentialGroupAgent.groupContent()},
     *     .
     *
     * @param creatorAndAdder    
     * 							    
     * @return ,   
     * 							.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder);
}
","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {

	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreatorAndElementAdder() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(null);
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreator() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullElementAdder() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(() -> null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreatorAndElementAdder_NullGroupCreator() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreatorAndElementAdder_NullElementAdder() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(() -> null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreatorAndElementAdder_NullGroupCreatorAndElementAdder() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreatorAndElementAdder_NullGroupCreatorAndElementAdder_NullGroupCreator() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreatorAndElementAdder_NullGroupCreatorAndElementAdder_NullElementAdder() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(() -> null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreatorAndElementAdder_NullGroupCreatorAndElementAdder_NullGroupCreatorAndElementAdder() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreatorAndElementAdder_NullGroupCreatorAndElementAdder_NullGroupCreatorAndElementAdder_NullGroupCreator() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreatorAndElementAdder}
	 * is {@code null}.
	 * <p>
	 * Expected result: {@code NullPointerException} is thrown.
	 */
	@Test
	void testGroupContent_NullGroupCreatorAndElementAdder_NullGroupCreatorAndElementAdder_NullGroupCreatorAndElementAdder_NullElementAdder() {
		assertThrows(NullPointerException.class, () -> {
			new TopSequentialGroupAgent().groupContent(new GroupCreatorAndElementAdder(() -> null, null));
		});
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * Test case for the case when the {@code GroupCreat"
cmpl-6wioc0GedVICFQV5xz7B2vVBVigZX,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock0.java,63.4057080745697,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlockTest {

	/**
	 * Test case 1.
	 * The block is empty.
	 */
	@Test
	void testExtractSequentialSubblocks1() {
		HorizontalBlock block = new HorizontalBlock();
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(0, subblocks.size());
	}
	
	/**
	 * Test case 2.
	 * The block contains one position.
	 */
	@Test
	void testExtractSequentialSubblocks2() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(1, subblocks.get(0).size());
	}
	
	/**
	 * Test case 3.
	 * The block contains two positions.
	 */
	@Test
	void testExtractSequentialSubblocks3() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(2, subblocks.get(0).size());
	}
	
	/**
	 * Test case 4.
	 * The block contains three positions.
	 */
	@Test
	void testExtractSequentialSubblocks4() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(3, subblocks.get(0).size());
	}
	
	/**
	 * Test case 5.
	 * The block contains four positions.
	 */
	@Test
	void testExtractSequentialSubblocks5() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(4, subblocks.get(0).size());
	}
	
	/**
	 * Test case 6.
	 * The block contains five positions.
	 */
	@Test
	void testExtractSequentialSubblocks6() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(5, subblocks.get(0).size());
	}
	
	/**
	 * Test case 7.
	 * The block contains six positions.
	 */
	@Test
	void testExtractSequentialSubblocks7() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		block.add(new Position(5, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(6, subblocks.get(0).size());
	}
	
	/**
	 * Test case 8.
	 * The block contains seven positions.
	 */
	@Test
	void testExtractSequentialSubblocks8() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		block.add(new Position(5, 0));
		block.add(new Position(6, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(7, subblocks.get(0).size());
	}
	
	/**
	 * Test case 9.
	 * The block contains eight positions.
	 */
	@Test
	void testExtractSequentialSubblocks9() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		block.add(new Position(5, 0));
		block.add(new Position(6, 0));
		block.add(new Position(7, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(8, subblocks.get(0).size());
	}
	
	/**
	 * Test case 10.
	 * The block contains nine positions.
	 */
	@Test
	void testExtractSequentialSubblocks10() {
		HorizontalBlock block = new HorizontalBlock();
		block.add(new Position(0, 0));
		block.add(new Position(1, 0));
		block.add(new Position(2, 0));
		block.add(new Position(3, 0));
		block.add(new Position(4, 0));
		block.add(new Position(5, 0));
		block.add(new Position(6, 0));
		block.add(new Position(7, 0));
		block.add(new Position(8, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(9, subblocks.get(0).size());
	}
}

// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();
}

// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {
		
	/**
	 * Test case 1.
	 * The block is empty.
	 */
	@Test
	void testExtractSequentialSubblocks1() {
		VerticalBlock block = new VerticalBlock();
		List<Block"
cmpl-6wipeRBZhNlOKVkub3PmLQya4jcpf,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock1.java,60.941630363464355,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks();
}
","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {","// HorizontalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlockTest {

	/**
	 * Test case 1.
	 * <p>
	 * The block has no horizontal lines.
	 * <p>
	 * The block is divided into two parallel subblocks.
	 */
	@Test
	void testCase1() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(1).getBottomRight());
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block has one horizontal line.
	 * <p>
	 * The block is divided into two parallel subblocks.
	 */
	@Test
	void testCase2() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(1).getBottomRight());
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block has two horizontal lines.
	 * <p>
	 * The block is divided into three parallel subblocks.
	 */
	@Test
	void testCase3() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(2).getBottomRight());
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block has three horizontal lines.
	 * <p>
	 * The block is divided into four parallel subblocks.
	 */
	@Test
	void testCase4() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		block.addHorizontalLine(9);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(3).getBottomRight());
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block has four horizontal lines.
	 * <p>
	 * The block is divided into five parallel subblocks.
	 */
	@Test
	void testCase5() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		block.addHorizontalLine(9);
		block.addHorizontalLine(11);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 11), subblocks.get(3).getBottomRight());
		assertEquals(new Position(0, 11), subblocks.get(4).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(4).getBottomRight());
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The block has five horizontal lines.
	 * <p>
	 * The block is divided into six parallel subblocks.
	 */
	@Test
	void testCase6() {
		Block block = new HorizontalBlock(
			new Position(0, 0),
			new Position(10, 10)
		);
		block.addHorizontalLine(5);
		block.addHorizontalLine(7);
		block.addHorizontalLine(9);
		block.addHorizontalLine(11);
		block.addHorizontalLine(13);
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(6, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 11), subblocks.get(3).getBottomRight());
		assertEquals(new Position(0, 11), sub"
cmpl-6wiqdA3tO8NHRefkmek2hsVl77AbF,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock0.java,66.55125784873962,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks();
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlockTest {

	/**
	 * Test case 1.
	 * The block contains only one position.
	 */
	@Test
	void testCase1() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(1, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
	}
	
	/**
	 * Test case 2.
	 * The block contains two positions.
	 */
	@Test
	void testCase2() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(2, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
	}
	
	/**
	 * Test case 3.
	 * The block contains three positions.
	 */
	@Test
	void testCase3() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(3, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
	}
	
	/**
	 * Test case 4.
	 * The block contains four positions.
	 */
	@Test
	void testCase4() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(4, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
	}
	
	/**
	 * Test case 5.
	 * The block contains five positions.
	 */
	@Test
	void testCase5() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		block.addPosition(new Position(0, 4));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(5, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
		assertEquals(new Position(0, 4), subblocks.get(0).getPositions().get(4));
	}
	
	/**
	 * Test case 6.
	 * The block contains six positions.
	 */
	@Test
	void testCase6() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		block.addPosition(new Position(0, 4));
		block.addPosition(new Position(0, 5));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(6, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
		assertEquals(new Position(0, 4), subblocks.get(0).getPositions().get(4));
		assertEquals(new Position(0, 5), subblocks.get(0).getPositions().get(5));
	}
	
	/**
	 * Test case 7.
	 * The block contains seven positions.
	 */
	@Test
	void testCase7() {
		VerticalBlock block = new VerticalBlock();
		block.addPosition(new Position(0, 0));
		block.addPosition(new Position(0, 1));
		block.addPosition(new Position(0, 2));
		block.addPosition(new Position(0, 3));
		block.addPosition(new Position(0, 4));
		block.addPosition(new Position(0, 5));
		block.addPosition(new Position(0, 6));
		List<Block> subblocks = block.extractSequentialSubblocks();
		assertEquals(1, subblocks.size());
		assertEquals(7, subblocks.get(0).getPositions().size());
		assertEquals(new Position(0, 0), subblocks.get(0).getPositions().get(0));
		assertEquals(new Position(0, 1), subblocks.get(0).getPositions().get(1));
		assertEquals(new Position(0, 2), subblocks.get(0).getPositions().get(2));
		assertEquals(new Position(0, 3), subblocks.get(0).getPositions().get(3));
		assertEquals(new Position(0, 4), subblocks.get(0).getPositions().get(4));
		assertEquals(new Position(0, 5), subblocks.get(0).getPositions().get(5));
		assertEquals(new Position(0, 6), subblocks.get(0).getPositions().get(6));
	}
	
	/**
	 * Test case 8.
	 * The block contains eight positions.
	 */
	@"
cmpl-6wirh3Bn0H7QSwxZDEHLDIY8lJotz,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock1.java,75.6081690788269,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks();
}
","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {","// VerticalBlockTest.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlockTest {

	/**
	 * Test case 1.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into two parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks1() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Line(new Position(0, 0), new Position(10, 0)));
		block.addLine(new Line(new Position(0, 10), new Position(10, 10)));
		block.addLine(new Line(new Position(0, 0), new Position(0, 10)));
		block.addLine(new Line(new Position(10, 0), new Position(10, 10)));
		block.addLine(new Line(new Position(0, 5), new Position(10, 5)));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(2, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(1).getBottomRight());
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into three parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks2() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Line(new Position(0, 0), new Position(10, 0)));
		block.addLine(new Line(new Position(0, 10), new Position(10, 10)));
		block.addLine(new Line(new Position(0, 0), new Position(0, 10)));
		block.addLine(new Line(new Position(10, 0), new Position(10, 10)));
		block.addLine(new Line(new Position(0, 5), new Position(10, 5)));
		block.addLine(new Line(new Position(0, 7), new Position(10, 7)));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(3, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(2).getBottomRight());
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into four parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks3() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Line(new Position(0, 0), new Position(10, 0)));
		block.addLine(new Line(new Position(0, 10), new Position(10, 10)));
		block.addLine(new Line(new Position(0, 0), new Position(0, 10)));
		block.addLine(new Line(new Position(10, 0), new Position(10, 10)));
		block.addLine(new Line(new Position(0, 5), new Position(10, 5)));
		block.addLine(new Line(new Position(0, 7), new Position(10, 7)));
		block.addLine(new Line(new Position(0, 9), new Position(10, 9)));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(4, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(3).getBottomRight());
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into five parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks4() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Line(new Position(0, 0), new Position(10, 0)));
		block.addLine(new Line(new Position(0, 10), new Position(10, 10)));
		block.addLine(new Line(new Position(0, 0), new Position(0, 10)));
		block.addLine(new Line(new Position(10, 0), new Position(10, 10)));
		block.addLine(new Line(new Position(0, 5), new Position(10, 5)));
		block.addLine(new Line(new Position(0, 7), new Position(10, 7)));
		block.addLine(new Line(new Position(0, 9), new Position(10, 9)));
		block.addLine(new Line(new Position(0, 2), new Position(10, 2)));
		List<Block> subblocks = block.extractParallelSubblocks();
		assertEquals(5, subblocks.size());
		assertEquals(new Position(0, 0), subblocks.get(0).getTopLeft());
		assertEquals(new Position(10, 2), subblocks.get(0).getBottomRight());
		assertEquals(new Position(0, 2), subblocks.get(1).getTopLeft());
		assertEquals(new Position(10, 5), subblocks.get(1).getBottomRight());
		assertEquals(new Position(0, 5), subblocks.get(2).getTopLeft());
		assertEquals(new Position(10, 7), subblocks.get(2).getBottomRight());
		assertEquals(new Position(0, 7), subblocks.get(3).getTopLeft());
		assertEquals(new Position(10, 9), subblocks.get(3).getBottomRight());
		assertEquals(new Position(0, 9), subblocks.get(4).getTopLeft());
		assertEquals(new Position(10, 10), subblocks.get(4).getBottomRight());
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block has no vertical lines.
	 * <p>
	 * The block is divided into six parallel subblocks.
	 */
	@Test
	void testExtractParallelSubblocks5() {
		Block block = new VerticalBlock(new Position(0, 0), new Position(10, 10));
		block.addLine(new Line(new Position(0, 0), new Position(10, 0)));
"
cmpl-6wisvrsjVjFUHyrDAp7ue6CP60b07,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/positions/HWordPosition.java,76.3740246295929,stop,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public String textAt(CharTable ct);
}
","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {","// HWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPositionTest {

	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		HWordPosition wp = new HWordPosition(0, 0, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(1, 0, 'b');
		ct.setCharAt(2, 0, 'c');
		ct.setCharAt(3, 0, 'd');
		ct.setCharAt(4, 0, 'e');
		assertEquals(""abcde"", wp.textAt(ct));
	}
}

// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public String textAt(CharTable ct);
}

// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		VWordPosition wp = new VWordPosition(0, 0, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(0, 1, 'b');
		ct.setCharAt(0, 2, 'c');
		ct.setCharAt(0, 3, 'd');
		ct.setCharAt(0, 4, 'e');
		assertEquals(""abcde"", wp.textAt(ct));
	}
}

// CharTable.java
package glengineer.blocks;

import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;

/**
 * Represents a table of characters.
 *
 * The table is represented as a two-dimensional array of characters.
 * The table is used to store the characters of the scheme.
 */
public class CharTable {

    /**
     * Returns the character at the specified position.
     *
     * @param x the x coordinate of the position.
     * @param y the y coordinate of the position.
     * @return the character at the specified position.
     */
    public char charAt(int x, int y);

    /**
     * Sets the character at the specified position.
     *
     * @param x the x coordinate of the position.
     * @param y the y coordinate of the position.
     * @param c the character to be set at the specified position.
     */
    public void setCharAt(int x, int y, char c);

    /**
     * Returns the text at the specified position.
     *
     * @param wp the word position at which the text must be read.
     * @return the text at the specified position.
     */
    public String textAt(WordPosition wp);
}

// CharTableTest.java
package glengineer.blocks;

import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CharTable}.
* It contains ten unit test cases for the {@link CharTable#textAt(WordPosition)} method.
*/
class CharTableTest {
		
	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		WordPosition wp = new HWordPosition(0, 0, 5);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(1, 0, 'b');
		ct.setCharAt(2, 0, 'c');
		ct.setCharAt(3, 0, 'd');
		ct.setCharAt(4, 0, 'e');
		assertEquals(""abcde"", ct.textAt(wp));
	}
}

// Scheme.java
package glengineer;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;

/**
 * Represents a scheme.
 *
 * The scheme is represented as a two-dimensional array of blocks.
 * The scheme is used to store the blocks of the scheme.
 */
public class Scheme {

    /**
     * Returns the block at the specified position.
     *
     * @param x the x coordinate of the position.
     * @param y the y coordinate of the position.
     * @return the block at the specified position.
     */
    public Block blockAt(int x, int y);

    /**
     * Sets the block at the specified position.
     *
     * @param x the x coordinate of the position.
     * @param y the y coordinate of the position.
     * @param b the block to be set at the specified position.
     */
    public void setBlockAt(int x, int y, Block b);

    /**
     * Returns the char table of the scheme.
     *
     * @return the char table of the scheme.
     */
    public CharTable charTable();

    /**
     * Returns the text at the specified position.
     *
     * @param wp the word position at which the text must be read.
     * @return the text at the specified position.
     */
    public String textAt(WordPosition wp);
}

// SchemeTest.java
package glengineer;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#textAt(WordPosition)} method.
*/
class SchemeTest {
		
	@Test
	void testTextAt() {
		Scheme s = new Scheme(10, 10);
		WordPosition wp = new HWordPosition(0, 0, 5);
		s.setBlockAt(0, 0, new Block('a'));
		s.setBlockAt(1, 0, new Block('b'));
		s.setBlockAt(2, 0, new Block('c'));
		s.setBlockAt(3, 0, new Block('d'));
		s.setBlockAt(4, 0, new Block('e'));
		assertEquals(""abcde"", s.textAt(wp));
	}
}"
cmpl-6wiu94UidQLpCThq78cQfDnKsee8d,/EvoSuiteBenchmark/scenario3/40_glengineer/src/main/java/glengineer/positions/VWordPosition.java,88.91769480705261,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct the char table from which the text must be read.
     * @return the text at this position on the specified char table.
     */
    public String textAt(CharTable ct);
}
","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {","// VWordPositionTest.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPositionTest {

	@Test
	void testTextAt() {
		CharTable ct = new CharTable(10, 10);
		ct.setCharAt(0, 0, 'a');
		ct.setCharAt(0, 1, 'b');
		ct.setCharAt(0, 2, 'c');
		ct.setCharAt(0, 3, 'd');
		ct.setCharAt(0, 4, 'e');
		ct.setCharAt(0, 5, 'f');
		ct.setCharAt(0, 6, 'g');
		ct.setCharAt(0, 7, 'h');
		ct.setCharAt(0, 8, 'i');
		ct.setCharAt(0, 9, 'j');
		ct.setCharAt(1, 0, 'k');
		ct.setCharAt(1, 1, 'l');
		ct.setCharAt(1, 2, 'm');
		ct.setCharAt(1, 3, 'n');
		ct.setCharAt(1, 4, 'o');
		ct.setCharAt(1, 5, 'p');
		ct.setCharAt(1, 6, 'q');
		ct.setCharAt(1, 7, 'r');
		ct.setCharAt(1, 8, 's');
		ct.setCharAt(1, 9, 't');
		ct.setCharAt(2, 0, 'u');
		ct.setCharAt(2, 1, 'v');
		ct.setCharAt(2, 2, 'w');
		ct.setCharAt(2, 3, 'x');
		ct.setCharAt(2, 4, 'y');
		ct.setCharAt(2, 5, 'z');
		ct.setCharAt(2, 6, 'a');
		ct.setCharAt(2, 7, 'b');
		ct.setCharAt(2, 8, 'c');
		ct.setCharAt(2, 9, 'd');
		ct.setCharAt(3, 0, 'e');
		ct.setCharAt(3, 1, 'f');
		ct.setCharAt(3, 2, 'g');
		ct.setCharAt(3, 3, 'h');
		ct.setCharAt(3, 4, 'i');
		ct.setCharAt(3, 5, 'j');
		ct.setCharAt(3, 6, 'k');
		ct.setCharAt(3, 7, 'l');
		ct.setCharAt(3, 8, 'm');
		ct.setCharAt(3, 9, 'n');
		ct.setCharAt(4, 0, 'o');
		ct.setCharAt(4, 1, 'p');
		ct.setCharAt(4, 2, 'q');
		ct.setCharAt(4, 3, 'r');
		ct.setCharAt(4, 4, 's');
		ct.setCharAt(4, 5, 't');
		ct.setCharAt(4, 6, 'u');
		ct.setCharAt(4, 7, 'v');
		ct.setCharAt(4, 8, 'w');
		ct.setCharAt(4, 9, 'x');
		ct.setCharAt(5, 0, 'y');
		ct.setCharAt(5, 1, 'z');
		ct.setCharAt(5, 2, 'a');
		ct.setCharAt(5, 3, 'b');
		ct.setCharAt(5, 4, 'c');
		ct.setCharAt(5, 5, 'd');
		ct.setCharAt(5, 6, 'e');
		ct.setCharAt(5, 7, 'f');
		ct.setCharAt(5, 8, 'g');
		ct.setCharAt(5, 9, 'h');
		ct.setCharAt(6, 0, 'i');
		ct.setCharAt(6, 1, 'j');
		ct.setCharAt(6, 2, 'k');
		ct.setCharAt(6, 3, 'l');
		ct.setCharAt(6, 4, 'm');
		ct.setCharAt(6, 5, 'n');
		ct.setCharAt(6, 6, 'o');
		ct.setCharAt(6, 7, 'p');
		ct.setCharAt(6, 8, 'q');
		ct.setCharAt(6, 9, 'r');
		ct.setCharAt(7, 0, 's');
		ct.setCharAt(7, 1, 't');
		ct.setCharAt(7, 2, 'u');
		ct.setCharAt(7, 3, 'v');
		ct.setCharAt(7, 4, 'w');
		ct.setCharAt(7, 5, 'x');
		ct.setCharAt(7, 6, 'y');
		ct.setCharAt(7, 7, 'z');
		ct.setCharAt(7, 8, 'a');
		ct.setCharAt(7, 9, 'b');
		ct.setCharAt(8, 0, 'c');
		ct.setCharAt(8, 1, 'd');
		ct.setCharAt(8, 2, 'e');
		ct.setCharAt(8, 3, 'f');
		ct.setCharAt(8, 4, 'g');
		ct.setCharAt(8, 5, 'h');
		ct.setCharAt(8, 6, 'i');
		ct.setCharAt(8, 7, 'j');
		ct.setCharAt(8, 8, 'k');
		ct.setCharAt(8, 9, 'l');
		ct.setCharAt(9, 0, 'm');
		ct.setCharAt(9, 1, 'n');
		ct.setCharAt(9, 2, 'o');
		ct.setCharAt(9, 3, 'p');
		ct.setCharAt(9, 4, 'q');
		ct.setCharAt(9, 5, 'r');
		ct.setCharAt(9, 6, 's');
		ct.setCharAt(9, 7, 't');
		ct.setCharAt(9, 8, 'u');
		ct.setCharAt(9, 9, 'v');
		
		VWordPosition wp = new VWordPosition(0, 0, 0, 9);
		assertEquals(""abcdefghij"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 1, 0, 9);
		assertEquals(""klmnopqrst"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 2, 0, 9);
		assertEquals(""uvwxyzabcd"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 3, 0, 9);
		assertEquals(""efghijklmn"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 4, 0, 9);
		assertEquals(""opqrstuvwx"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 5, 0, 9);
		assertEquals(""yzabcdefgh"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 6, 0, 9);
		assertEquals(""ijklmnopqr"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 7, 0, 9);
		assertEquals(""stuvwxyzab"", wp.textAt(ct));
		
		wp = new VWordPosition(0, 8, 0, 9);
		assertEquals(""c"
