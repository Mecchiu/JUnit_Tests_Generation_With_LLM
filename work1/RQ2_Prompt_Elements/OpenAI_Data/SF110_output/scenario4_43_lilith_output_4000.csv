ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6xFj9hGMeMH3MIwo8goRWvAeUSVno,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_0Test.java,103.54479122161865,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_0Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_0Test {","// MessageFormatter_0Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_0Test {

		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_0() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_1() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_2() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_3() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_4() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_5() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_6() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_7() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_8() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_9() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_10() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
}

// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_1Test {
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_0() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_1() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_2() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_3() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_4() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_5() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_6() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_7() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_8() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link MessageFormatter#format(String, String[])} method.
		* Test method for {@link MessageFormatter#format(String, String[])}
		*
		* @throws Exception
		*
		* @see MessageFormatter#format(String, String[])
		*/
		@Test
		public void testFormat_9() throws Exception {
				String messagePattern = """";
				String[] arguments = new String[] {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i""};
				String result = MessageFormatter.format(messagePattern, arguments);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link Message"
cmpl-6xFkpq2EV6HJ8aDVNCTWd4VoWbNUT,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_1Test.java,91.96375155448914,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatter_1Test {","// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatter_1Test {

		@Test
		public void testCountArgumentPlaceholders_1() {
				String messagePattern = """";
				int expected = 0;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_2() {
				String messagePattern = ""foo"";
				int expected = 0;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_3() {
				String messagePattern = ""foo {}"";
				int expected = 1;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_4() {
				String messagePattern = ""foo {0}"";
				int expected = 1;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_5() {
				String messagePattern = ""foo {1}"";
				int expected = 1;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_6() {
				String messagePattern = ""foo {1} {0}"";
				int expected = 2;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_7() {
				String messagePattern = ""foo {1} {0} {2}"";
				int expected = 3;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_8() {
				String messagePattern = ""foo {1} {0} {2} {3}"";
				int expected = 4;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_9() {
				String messagePattern = ""foo {1} {0} {2} {3} {4}"";
				int expected = 5;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testCountArgumentPlaceholders_10() {
				String messagePattern = ""foo {1} {0} {2} {3} {4} {5}"";
				int expected = 6;
				int actual = MessageFormatter.countArgumentPlaceholders(messagePattern);
				assertEquals(expected, actual);
		}
}

// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_2Test {
		
		@Test
		public void testFormat_1() {
				String messagePattern = """";
				String[] arguments = new String[] {};
				String expected = """";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testFormat_2() {
				String messagePattern = ""foo"";
				String[] arguments = new String[] {};
				String expected = ""foo"";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testFormat_3() {
				String messagePattern = ""foo {}"";
				String[] arguments = new String[] {""bar""};
				String expected = ""foo bar"";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testFormat_4() {
				String messagePattern = ""foo {0}"";
				String[] arguments = new String[] {""bar""};
				String expected = ""foo bar"";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testFormat_5() {
				String messagePattern = ""foo {1}"";
				String[] arguments = new String[] {""bar""};
				String expected = ""foo {1}"";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testFormat_6() {
				String messagePattern = ""foo {1} {0}"";
				String[] arguments = new String[] {""bar"", ""baz""};
				String expected = ""foo baz bar"";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testFormat_7() {
				String messagePattern = ""foo {1} {0} {2}"";
				String[] arguments = new String[] {""bar"", ""baz"", ""boo""};
				String expected = ""foo baz bar boo"";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testFormat_8() {
				String messagePattern = ""foo {1} {0} {2} {3}"";
				String[] arguments = new String[] {""bar"", ""baz"", ""boo"", ""bam""};
				String expected = ""foo baz bar boo bam"";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testFormat_9() {
				String messagePattern = ""foo {1} {0} {2} {3} {4}"";
				String[] arguments = new String[] {""bar"", ""baz"", ""boo"", ""bam"", ""bud""};
				String expected = ""foo baz bar boo bam bud"";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testFormat_10() {
				String messagePattern = ""foo {1} {0} {2} {3} {4} {5}"";
				String[] arguments = new String[] {""bar"", ""baz"", ""boo"", ""bam"", ""bud"", ""bae""};
				String expected = ""foo baz bar boo bam bud bae"";
				String actual = MessageFormatter.format(messagePattern, arguments);
				assertEquals(expected, actual);
		}
}

// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_3Test {
		
		@Test
		public void testEvaluateArguments_1() {
				String messagePattern = """";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_2() {
				String messagePattern = ""foo"";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_3() {
				String messagePattern = ""foo {}"";
				Object[] arguments = new Object[] {""bar""};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {""bar""}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_4() {
				String messagePattern = ""foo {0}"";
				Object[] arguments = new Object[] {""bar""};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {""bar""}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_5() {
				String messagePattern = ""foo {1}"";
				Object[] arguments = new Object[] {""bar""};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_6() {
				String messagePattern = ""foo {1} {0}"";
				Object[] arguments = new Object[] {""bar"", ""baz""};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {""baz"", ""bar""}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_7() {
				String messagePattern = ""foo {1} {0} {2}"";
				Object[] arguments = new Object[] {""bar"", ""baz"", ""boo""};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {""baz"", ""bar"", ""boo""}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_8() {
				String messagePattern = ""foo {1} {0} {2} {3}"";
				Object[] arguments = new Object[] {""bar"", ""baz"", ""boo"", ""bam""};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {""baz"", ""bar"", ""boo"", ""bam""}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_9() {
				String messagePattern = ""foo {1} {0} {2} {3} {4}"";
				Object[] arguments = new Object[] {""bar"", ""baz"", ""boo"", ""bam"", ""bud""};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {""baz"", ""bar"", ""boo"", ""bam"", ""bud""}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
		
		@Test
		public void testEvaluateArguments_10() {
				String messagePattern = ""foo {1} {0} {2} {3} {4} {5}"";
				Object[] arguments = new Object[] {""bar"", ""baz"", ""boo"", ""bam"", ""bud"", ""bae""};
				MessageFormatter.ArgumentResult expected = new MessageFormatter.ArgumentResult(new String[] {""baz"", ""bar"", ""boo"", ""bam"", ""bud"", ""bae""}, null);
				MessageFormatter.ArgumentResult actual = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertEquals(expected, actual);
		}
}

// MessageFormatter_4Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#deepToString(Object)} method.
*/
class MessageFormatter_4Test {
		
		@Test
		public void testDeepToString_1() {
				Object o = null;
				String expected = ""null"";
		"
cmpl-6xFmJnBDC2O6Jrh13TCPe7asCFG6Y,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_2Test.java,82.84176206588745,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_2Test {","// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_2Test {

		@Test
		public void testEvaluateArguments_1() {
				String messagePattern = """";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_2() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_3() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_4() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_5() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_6() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_7() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_8() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_9() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_10() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
}

// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_3Test {
		
		@Test
		public void testEvaluateArguments_1() {
				String messagePattern = """";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_2() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_3() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_4() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_5() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_6() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_7() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_8() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_9() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_10() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
}

// MessageFormatter_4Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_4Test {
		
		@Test
		public void testEvaluateArguments_1() {
				String messagePattern = """";
				Object[] arguments = new Object[] {};
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_2() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_3() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_4() {
				String messagePattern = """";
				Object[] arguments = new Object[] { new Exception(), new Exception(), new Exception() };
				MessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);
				assertNotNull(result);
				assertNull(result.getThrowable());
				assertNotNull(result.getArguments());
				assertEquals(0, result.getArguments().length);
		}
		
		@Test
		public void testEvaluateArguments_5() {
				String messagePattern = """";
				Object[] arguments = new Object[] {"
cmpl-6xFndnsZugjlL91XYsnCnO0vkc06a,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_3Test.java,87.68653607368469,length,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_3Test {","// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_3Test {

		@Test
		public void testIdentityToString() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(""test""));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new String(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern().intern()));
		}
}

// MessageFormatter_4Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_4Test {
		
		@Test
		public void testIdentityToString() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(""test""));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new String(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern().intern()));
		}
}

// MessageFormatter_5Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_5Test {
		
		@Test
		public void testIdentityToString() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(""test""));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new String(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern().intern()));
		}
}

// MessageFormatter_6Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_6Test {
		
		@Test
		public void testIdentityToString() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(""test""));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new String(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern().intern()));
		}
}

// MessageFormatter_7Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_7Test {
		
		@Test
		public void testIdentityToString() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(""test""));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new String(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern().intern()));
		}
}

// MessageFormatter_8Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_8Test {
		
		@Test
		public void testIdentityToString() {
				assertEquals(""null"", MessageFormatter.identityToString(null));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(""test""));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new String(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"")));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuffer(""test"").toString().intern()));
				assertEquals(""java.lang.String@"" + Integer.toHexString(""test"".hashCode()), MessageFormatter.identityToString(new StringBuilder(""test"").toString().intern().intern()"
cmpl-6xFp3Y25ilin1oJTyOLXnvJZZ8yUO,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/logback/classic/NDC.java,82.8202555179596,length,"// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    private static final NDCAdapter ndcAdapter;

    static {
    }

    private NDC() {
    }

    public static void push(String message);

    public static void push(String messagePattern, Object[] arguments);

    /**
     * Pops the last message from the stack.
     * <p/>
     * This method does not return the popped message to discourage it's usage in application logic.
     */
    public static void pop();

    public static int getDepth();

    public static void setMaximumDepth(int maximumDepth);

    public static boolean isEmpty();

    public static void clear();

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}
","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains ten unit test cases for the {@link NDC#getContextStack()} method.
*/
class NDCTest {

	@Test
	void testGetContextStack() {
		NDC.clear();
		Message[] contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(0, contextStack.length);
		
		NDC.push(""Message 1"");
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		
		NDC.push(""Message 2"");
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(2, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		assertEquals(""Message 2"", contextStack[1].getMessage());
		
		NDC.push(""Message 3"");
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(3, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		assertEquals(""Message 2"", contextStack[1].getMessage());
		assertEquals(""Message 3"", contextStack[2].getMessage());
		
		NDC.pop();
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(2, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		assertEquals(""Message 2"", contextStack[1].getMessage());
		
		NDC.pop();
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(1, contextStack.length);
		assertEquals(""Message 1"", contextStack[0].getMessage());
		
		NDC.pop();
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(0, contextStack.length);
		
		NDC.push(""Message 1"");
		NDC.push(""Message 2"");
		NDC.push(""Message 3"");
		NDC.clear();
		contextStack = NDC.getContextStack();
		assertNotNull(contextStack);
		assertEquals(0, contextStack.length);
	}
}
```

## Mutation Testing

Mutation testing is a technique for determining if a test suite is useful. It involves making small changes to the code under test, and then checking if the test suite can detect the changes.

### Pitest

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.

Pitest is a mutation testing tool for Java. It is free and open source.
"
28edb075-1884-4b52-9cb0-245b893dc4c8,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/AboutPanel.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9250 tokens (5250 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);

    public static final String BACKGROUND_IMAGE_RESOURCE = ""background.png"";

    public static final String ABOUT_IMAGE_RESOURCE = ""about.png"";

    public static final String TEXT_RESOURCE_PREFIX = ""about."";

    public static final String SCROLL_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + ""scroll.text"";

    public static final String VERSION_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + ""version.text"";

    public static final String VERSION_HEIGHT_RESOURCE = TEXT_RESOURCE_PREFIX + ""version.height"";

    public static final String SCROLL_AREA_RESOURCE_BASE = TEXT_RESOURCE_PREFIX + ""scroll.area."";

    public static final String SCROLL_AREA_X_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""x"";

    public static final String SCROLL_AREA_Y_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""y"";

    public static final String SCROLL_AREA_WIDTH_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""width"";

    public static final String SCROLL_AREA_HEIGHT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""height"";

    public static final String SCROLL_AREA_TOOLTIP_TEXT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""tooltip.text"";

    public static final String TEXT_RESOURCE_BUNDLE_RESOURCE = ""TextResources"";

    public static final int MOUSE_DISABLED = 0;

    public static final int MOUSE_COMPONENT = 1;

    public static final int MOUSE_SCROLLAREA = 2;

    public static final int MOUSE_BACKGROUND = 3;

    //private static final int SCROLL_SLEEP_TIME = 50;
    private static final int SCROLL_PIXELS = 1;

    private BufferedImage backgroundImage;

    private BufferedImage aboutImage;

    //private ImageIcon aboutImageIcon;
    private FontMetrics fontMetrics;

    private Insets insets;

    private Dimension size;

    private Dimension preferredSize;

    private Point offscreenOffset;

    private String[] scrollLines;

    private String versionText;

    private String scrollAreaToolTipText;

    private int versionHeight;

    private int scrollPosition;

    private int maxScrollPosition;

    private int minScrollPosition;

    private Rectangle maxScrollArea;

    private Rectangle backgroundImageArea;

    private Rectangle translatedBackgroundImageArea;

    private Rectangle translatedScrollArea;

    private Rectangle scrollArea;

    private Rectangle paintArea;

    private BufferedImage offscreenImage;

    private BufferedImage scrollImage;

    private boolean scrolling;

    //private boolean painted;
    private int mouseEventHandling = MOUSE_BACKGROUND;

    //private transient Thread scrollThread;
    private boolean debug;

    private Timer timer;

    /**
     * Creates a new <code>AboutPanel</code> initialized with the given parameters.
     *
     * @param backgroundImageUrl The URL to the Background-Image of the
     *                           AboutPanel. This parameter is mandatory.
     * @param scrollArea         The Rectangle inside the background-image where
     *                           scrolling should take place. This parameter is optional. If it's null
     *                           then the scroll-area is set to (0, 0, background.width,
     *                           background.height).
     */
    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText) throws IOException {
    }

    public boolean isDebug();

    public void setDebug(boolean debug);

    /**
     * Creates a new <code>AboutPanel</code> initialized with the given parameters.
     *
     * @param backgroundImageUrl The URL to the Background-Image of the
     *                           AboutPanel. This parameter is mandatory.
     * @param scrollArea         The Rectangle inside the background-image where
     *                           scrolling should take place. This parameter is optional. If it's null
     *                           then the scroll-area is set to (0, 0, background.width,
     *                           background.height).
     * @param versionText        The String describing the version of the program.
     *                           It is painted centered to the scroll-rectangle at the specified height.
     *                           This parameter is optional.
     * @param versionHeight      The height at which the version-string is
     *                           supposed to be painted. This parameter is optional but should be given
     *                           a correct value if versionText!=null..
     */
    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, String versionText, int versionHeight) throws IOException {
    }

    /**
     * Creates a new <code>AboutPanel</code> initialized with the given parameters.
     *
     * @param backgroundImageUrl The URL to the Background-Image of the
     *                           AboutPanel. This parameter is mandatory.
     * @param scrollArea         The Rectangle inside the background-image where
     *                           scrolling should take place. This parameter is optional. If it's null
     *                           then the scroll-area is set to (0, 0, background.width,
     *                           background.height).
     * @param imageUrl           The URL to the Image that will be painted at the
     *                           start of the scroll-area. This parameter is optional.
     * @param versionText        The String describing the version of the program.
     *                           It is painted centered to the scroll-rectangle at the specified height.
     *                           This parameter is optional.
     * @param versionHeight      The height at which the version-string is
     *                           supposed to be painted. This parameter is optional but should be given
     *                           a correct value if versionText!=null..
     */
    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException {
    }

    public AboutPanel() {
    }

    private void init(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException;

    private void initAttributes();

    public void setScrollText(String ScrollText);

    protected void setScrollLines(String[] scrollLines);

    /**
     * Sets the backgroundImage attribute of the <code>AboutPanel</code> object
     */
    public void setBackgroundImage(URL imageUrl) throws IOException;

    /**
     * Sets the backgroundImage attribute of the <code>AboutPanel</code> object
     *
     * @param BackgroundImage The new backgroundImage value
     */
    public void setBackgroundImage(BufferedImage BackgroundImage);

    public void setAboutImage(URL imageUrl) throws IOException;

    public void setAboutImage(BufferedImage AboutImage);

    /**
     * Sets the scrollArea attribute of the <code>AboutPanel</code> object
     *
     * @param ScrollArea The new scrollArea value
     */
    public void setScrollArea(Rectangle ScrollArea);

    /**
     * Description of the Method
     */
    private void flushScrollImage();

    /**
     * Description of the Method
     */
    private void flushOffscreenImage();

    /**
     * Description of the Method
     */
    private void updateBackgroundAttributes();

    /**
     * Sets the ToolTipText that will appear if the user moves the mouse over the
     * scroll-area of this component.
     *
     * @param toolTipText The new ScrollAreaToolTipText value
     */
    public void setScrollAreaToolTipText(String toolTipText);

    /**
     * Gets the ScrollAreaToolTipText attribute of the <code>AboutPanel</code>
     * object
     *
     * @return The ScrollAreaToolTipText value
     */
    public String getScrollAreaToolTipText();

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt);

    protected boolean handleMouseEvent(MouseEvent evt);

    /**
     * Increases the ScrollPosition by SCROLL_PIXELS. This method is called by the
     * scroll-thread and calls <code>setScrollPosition</code>, therefore causing a
     * repaint of the scroll-area..
     *
     * @see #setScrollPosition
     */
    protected void increaseScrollPosition();

    /**
     * Sets the scrollPosition attribute of the <code>AboutPanel</code> object. The
     * value will be corrected according Minimum- and MaximumScrollPosition.
     * Changing the scroll-position will result in a repaint of the scroll-area.
     *
     * @param scrollPosition The new scrollPosition value. This value indicates
     *                       the height-offset of the scroll-area.
     * @see #getMinimumScrollPosition
     * @see #getMaximumScrollPosition
     */
    public void setScrollPosition(int scrollPosition);

    /**
     * Gets the ScrollPosition attribute of the <code>AboutPanel</code> object
     *
     * @return this value indicates the height-offset of the scroll-area.
     */
    public int getScrollPosition();

    /**
     * Gets the MinimumScrollPosition attribute of the <code>AboutPanel</code>
     * object. It's value is the negated value of the scroll-area-height.
     *
     * @return The MinimumScrollPosition value
     */
    public int getMinimumScrollPosition();

    /**
     * Gets the MaximumScrollPosition attribute of the <code>AboutPanel</code>
     * object. It's value is the height needed for all lines of text plus (if
     * available) the height of the image with an additional empty line.
     *
     * @return The MaximumScrollPosition value
     */
    public int getMaximumScrollPosition();

    /**
     * This method creates the offscreen-image when needed (when called for the
     * first time or recreated because of a changed font) and updates it on
     * subsequent calls by calling <code>updateOffscreenImage()</code>.
     */
    private void processOffscreenImage();

    /**
     * Updates the offscreen-image to represent the current scroll-position. It
     * calls <code>initScrollImage()</code>.
     *
     * @param g <code>Graphics</code>-object
     */
    private void drawScrollArea(Graphics2D g);

    /**
     * Initializes the scroll-image if needed. The scroll-image is as high as
     * needed to contain all the scroll-lines and (if available) the image.
     */
    private void initScrollImage();

    public static ConvolveOp getGaussianBlurFilter(int radius, boolean horizontal);

    /**
     * Sets the font attribute of the <code>AboutPanel</code> object. Setting it
     * will result in the recreation of all buffers. The font can even be safely
     * changed while the component is visible. It will be used for the version- and
     * scroll-text.<p />
     * <p/>
     * If the parameter is <code>null</code> then <code>UIManager.getFont( ""Label.font"" )</code>
     * will be used.
     *
     * @param newFont The new font value.
     */
    public void setFont(Font newFont);

    /**
     * Paints this component.
     *
     * @param _g <code>Graphics</code>-object
     */
    public void paintComponent(Graphics _g);

    /**
     * Makes sure that the private attributes size, paintArea, offscreenOffset and
     * translated areas have sane values. It's called on component-resize.
     */
    private void calculateAttributes();

    /**
     * This methods takes the insets (the border) of this component into account
     * when the preferred size is calculated. Any border will work. It is called by
     * the property-change-listener if the border was changed.
     */
    protected void calculatePreferredSize();

    /**
     * This method requests a repaint of the scroll-area. The rest of the component
     * will not be repainted. It is called by <code>setScrollPosition()</code> .
     *
     * @see
     */
    private void repaintScrollArea();

    /**
     * This method calls <code>super.addNotify()</code> and notifies the
     * scroll-thread by calling <code>setScrolling(true)</code>. It also
     * (re)initializes the scroll-position to MinimumScrollPosition (this is always
     * the negative height of the scroll-rectangle) and registers tbis component at
     * the <code>ToolTipManager</code>.
     *
     * @see #setScrolling
     * @see #setScrollPosition
     * @see #getMinimumScrollPosition
     */
    public void addNotify();

    /**
     * This method calls <code>super.removeNotify()</code> and sends the
     * scroll-thread into a wait-state by calling <code>setScrolling(false)</code>
     * . It also unregisters this component from the <code>ToolTipManager</code>.
     *
     * @see #setScrolling
     */
    public void removeNotify();

    /**
     * This method is used to set the scrolling-property of this component. A value
     * of <code>true</code> will notify the scroll-thread that it has to resume
     * work. A value of <code>false</code> will send it into wait-state instead.
     *
     * @param Scrolling The new scrolling value
     */
    public void setScrolling(boolean Scrolling);

    /**
     * This method returns <code>true</code> if scrolling is currently active. If
     * it returns <code>false</code> then the scroll-thread is waiting.
     *
     * @return The scrolling value
     */
    public boolean isScrolling();

    /**
     * Description of the Class
     *
     * @author Joern Huxhorn
     */
    class AboutComponentListener extends ComponentAdapter {

        /**
         * Description of the Method
         *
         * @param e Description of the Parameter
         */
        public void componentResized(ComponentEvent e) {
            AboutPanel.this.calculateAttributes();
        }
    }

    /**
     * Description of the Class
     *
     * @author Joern Huxhorn
     */
    class AboutPropertyChangeListener implements PropertyChangeListener {

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void propertyChange(PropertyChangeEvent evt) {
            String propertyName = evt.getPropertyName();
            if (propertyName.equals(""border"")) {
                calculatePreferredSize();
            } else if (propertyName.equals(""foreground"")) {
                flushScrollImage();
            } else if (propertyName.equals(""background"")) {
                flushScrollImage();
            }
            //			else if ( propertyName.equals( ""locale"" ) )
            //			{
            //				initResources();
            //			}
        }
    }

    /**
     * This <code>MouseInputListener</code> handles the pause/resume on click as
     * well as the dragging inside the scroll-area.
     *
     * @author Joern Huxhorn
     */
    class AboutMouseInputListener extends MouseInputAdapter {

        Point lastPoint = null;

        boolean scrollingBeforePress = false;

        boolean dragged = false;

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mousePressed(MouseEvent evt) {
            if (handleMouseEvent(evt)) {
                // always stop scrolling if mouse is pressed inside
                // the scroll-area
                lastPoint = evt.getPoint();
                scrollingBeforePress = isScrolling();
                setScrolling(false);
            } else {
                lastPoint = null;
            }
            dragged = false;
        }

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mouseReleased(MouseEvent evt) {
            if (dragged) {
                // set scrolling-attribute to the value before the user dragged.
                lastPoint = null;
                setScrolling(scrollingBeforePress);
            }
        }

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mouseClicked(MouseEvent evt) {
            // this is only called after mouseReleased if no drag occurred.
            if (handleMouseEvent(evt)) {
                // toggle scrolling.
                setScrolling(!scrollingBeforePress);
            }
            dragged = false;
        }

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mouseDragged(MouseEvent evt) {
            // only drag if original press was inside scroll-rectangle
            if (lastPoint != null) {
                dragged = true;
                Point currentPoint = evt.getPoint();
                int yOffset = lastPoint.y - currentPoint.y;
                setScrollPosition(getScrollPosition() + yOffset);
                lastPoint = currentPoint;
            }
        }
    }

    private class TimerActionListener implements ActionListener {

        private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);

        private long lastRepaintStart;

        private long frequency = 25;

        public void actionPerformed(ActionEvent e) {
            long currentTime = System.nanoTime() / 1000000;
            long meanTime = currentTime - lastRepaintStart;
            if (meanTime > frequency) {
                if (logger.isDebugEnabled())
                    logger.debug(""Tick! meanTime={}"", meanTime);
                increaseScrollPosition();
                lastRepaintStart = currentTime;
            }
        }
    }
}
","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {
"
1c8a2773-f074-4d46-b730-74fc2d927bbc,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/ApplicationPreferences.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8921 tokens (4921 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ApplicationPreferences.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;

public class ApplicationPreferences {

    public static enum SourceFiltering {

        NONE, BLACKLIST, WHITELIST
    }

    private static final Preferences PREFERENCES = Preferences.userNodeForPackage(ApplicationPreferences.class);

    private static final String STATUS_COLORS_XML_FILENAME = ""statusColors.xml"";

    private static final String LEVEL_COLORS_XML_FILENAME = ""levelColors.xml"";

    private static final String DETAILS_VIEW_ROOT_FOLDER = ""detailsView"";

    public static final String DETAILS_VIEW_CSS_FILENAME = ""detailsView.css"";

    public static final String DETAILS_VIEW_GROOVY_FILENAME = ""detailsView.groovy"";

    private static final String CONDITIONS_XML_FILENAME = ""savedConditions.xml"";

    public static final String STATUS_COLORS_PROPERTY = ""statusColors"";

    public static final String LEVEL_COLORS_PROPERTY = ""levelColors"";

    public static final String LOOK_AND_FEEL_PROPERTY = ""lookAndFeel"";

    public static final String CLEANING_LOGS_ON_EXIT_PROPERTY = ""cleaningLogsOnExit"";

    public static final String COLORING_WHOLE_ROW_PROPERTY = ""coloringWholeRow"";

    public static final String SHOWING_IDENTIFIER_PROPERTY = ""showingIdentifier"";

    public static final String SHOWING_FULL_CALLSTACK_PROPERTY = ""showingFullCallstack"";

    public static final String SHOWING_STACKTRACE_PROPERTY = ""showingStackTrace"";

    public static final String CHECKING_FOR_UPDATE_PROPERTY = ""checkingForUpdate"";

    public static final String SOURCE_FILTERING_PROPERTY = ""sourceFiltering"";

    public static final String SOUND_LOCATIONS_PROPERTY = ""soundLocations"";

    public static final String MUTE_PROPERTY = ""mute"";

    public static final String USING_INTERNAL_FRAMES_PROPERTY = ""usingInternalFrames"";

    public static final String SCROLLING_TO_BOTTOM_PROPERTY = ""scrollingToBottom"";

    public static final String SOURCE_NAMES_PROPERTY = ""sourceNames"";

    public static final String APPLICATION_PATH_PROPERTY = ""applicationPath"";

    public static final String AUTO_OPENING_PROPERTY = ""autoOpening"";

    public static final String AUTO_CLOSING_PROPERTY = ""autoClosing"";

    public static final String IMAGE_PATH_PROPERTY = ""imagePath"";

    public static final String SOUND_PATH_PROPERTY = ""soundPath"";

    public static final String AUTO_FOCUSING_WINDOW_PROPERTY = ""autoFocusingWindow"";

    public static final String SOURCE_LISTS_PROPERTY = ""sourceLists"";

    public static final String BLACK_LIST_NAME_PROPERTY = ""blackListName"";

    public static final String WHITE_LIST_NAME_PROPERTY = ""whiteListName"";

    public static final String CONDITIONS_PROPERTY = ""conditions"";

    public static final String SPLASH_SCREEN_DISABLED_PROPERTY = ""splashScreenDisabled"";

    public static final String ASKING_BEFORE_QUIT_PROPERTY = ""askingBeforeQuit"";

    public static final String LOGGING_LAYOUT_GLOBAL_XML_FILENAME = ""loggingLayoutGlobal.xml"";

    public static final String LOGGING_LAYOUT_XML_FILENAME = ""loggingLayout.xml"";

    public static final String ACCESS_LAYOUT_GLOBAL_XML_FILENAME = ""accessLayoutGlobal.xml"";

    public static final String ACCESS_LAYOUT_XML_FILENAME = ""accessLayout.xml"";

    public static final String SOURCE_NAMES_XML_FILENAME = ""SourceNames.xml"";

    public static final String SOURCE_LISTS_XML_FILENAME = ""SourceLists.xml"";

    public static final String SOURCE_NAMES_PROPERTIES_FILENAME = ""SourceNames.properties"";

    public static final String SOUND_LOCATIONS_XML_FILENAME = ""SoundLocations.xml"";

    public static final String SOUND_LOCATIONS_PROPERTIES_FILENAME = ""SoundLocations.properties"";

    public static final String PREVIOUS_APPLICATION_PATH_FILENAME = "".previous.application.path"";

    private static final String OLD_LICENSED_PREFERENCES_KEY = ""licensed"";

    private static final String LICENSED_PREFERENCES_KEY = ""licensedVersion"";

    public static final String USER_HOME;

    public static final String DEFAULT_APPLICATION_PATH;

    private static final Map<String, String> DEFAULT_SOURCE_NAMES;

    private static final Map<String, String> DEFAULT_SOUND_LOCATIONS;

    private static final Map<LoggingEvent.Level, ColorScheme> DEFAULT_LEVEL_COLORS;

    private static final Map<HttpStatus.Type, ColorScheme> DEFAULT_STATUS_COLORS;

    private static final String PREVIOUS_OPEN_PATH_PROPERTY = ""previousOpenPath"";

    private static final String PREVIOUS_IMPORT_PATH_PROPERTY = ""previousImportPath"";

    public static final String STARTUP_LOOK_AND_FEEL;

    private static final long CONDITIONS_CHECK_INTERVAL = 30000;

    private static final String GROOVY_SUFFIX = "".groovy"";

    private static final String EXAMPLE_GROOVY_BASE = ""/conditions/"";

    private static final String EXAMPLE_GROOVY_LIST = ""conditions.txt"";

    static {
    }

    private final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);

    private PropertyChangeSupport propertyChangeSupport;

    private File startupApplicationPath;

    private File detailsViewRoot;

    private ArrayList<String> installedLookAndFeels;

    private String[] conditionScriptFiles;

    private long lastConditionsCheck;

    private Map<LoggingEvent.Level, ColorScheme> levelColors;

    private Map<HttpStatus.Type, ColorScheme> statusColors;

    private URL detailsViewRootUrl;

    /**
     * Identifier => Name
     */
    private Map<String, String> sourceNames;

    private long lastSourceNamesModified;

    private long lastConditionsModified;

    private Map<String, String> soundLocations;

    private long lastSoundLocationsModified;

    private Map<String, Set<String>> sourceLists;

    private long lastSourceListsModified;

    private SourceFiltering sourceFiltering;

    private Set<String> blackList;

    private Set<String> whiteList;

    private List<SavedCondition> conditions;

    private File groovyConditionsPath;

    public ApplicationPreferences() {
    }

    public File resolveConditionScriptFile(String input);

    public String[] getAllConditionScriptFiles();

    public void installExampleConditions();

    private void initLevelColors();

    private Map<LoggingEvent.Level, ColorScheme> cloneLevelColors(Map<LoggingEvent.Level, ColorScheme> input);

    public void setLevelColors(Map<LoggingEvent.Level, ColorScheme> colors);

    private void writeLevelColors(Map<LoggingEvent.Level, ColorScheme> colors);

    public Map<LoggingEvent.Level, ColorScheme> getLevelColors();

    private void initStatusColors();

    private Map<HttpStatus.Type, ColorScheme> cloneStatusColors(Map<HttpStatus.Type, ColorScheme> input);

    public void setStatusColors(Map<HttpStatus.Type, ColorScheme> colors);

    private void writeStatusColors(Map<HttpStatus.Type, ColorScheme> colors);

    public Map<HttpStatus.Type, ColorScheme> getStatusColors();

    public void setSourceFiltering(SourceFiltering sourceFiltering);

    private void initSourceLists();

    public Map<String, Set<String>> getSourceLists();

    public void setSourceLists(Map<String, Set<String>> sourceLists);

    public SourceFiltering getSourceFiltering();

    public void initDetailsViewRoot(boolean overwriteAlways);

    private void initIfNecessary(File file, String resourcePath, String historyBasePath, boolean overwriteAlways);

    private void copy(URL source, File target, boolean overwrite);

    /**
     * Returns a list of strings containing all non-empty, non-comment lines found in the given URL.
     * Commented lines start with a #.
     *
     * @param url the URL to read the lines from.
     * @return a List of type String containing all non-empty, non-comment lines.
     */
    private List<String> readLines(URL url);

    public File getDetailsViewRoot();

    public URL getDetailsViewRootUrl();

    public boolean isValidSource(String source);

    public boolean isBlackListed(String source);

    public void setBlackListName(String name);

    public String getBlackListName();

    public boolean isWhiteListed(String source);

    public void setWhiteListName(String name);

    public String getWhiteListName();

    public void setLookAndFeel(String name);

    public String getLookAndFeel();

    private void initConditions();

    public SavedCondition resolveSavedCondition(Condition condition);

    public SavedCondition resolveSavedCondition(String conditionName);

    public List<SavedCondition> getConditions();

    public void setConditions(List<SavedCondition> conditions);

    public void setAutoOpening(boolean autoOpening);

    public boolean isAutoOpening();

    public void setShowingIdentifier(boolean showingIdentifierWithName);

    public boolean isShowingIdentifier();

    public void setSplashScreenDisabled(boolean splashScreenDisabled);

    public boolean isSplashScreenDisabled();

    public void setAskingBeforeQuit(boolean askingBeforeQuit);

    public boolean isAskingBeforeQuit();

    public void setShowingFullCallstack(boolean showingFullCallstack);

    public boolean isShowingFullCallstack();

    public void setShowingStackTrace(boolean showingStackTrace);

    public boolean isShowingStackTrace();

    public void setCleaningLogsOnExit(boolean cleaningLogsOnExit);

    public boolean isCleaningLogsOnExit();

    public void setColoringWholeRow(boolean coloringWholeRow);

    public boolean isColoringWholeRow();

    public void setCheckingForUpdate(boolean checkingForUpdate);

    public boolean isCheckingForUpdate();

    public void setAutoClosing(boolean autoClosing);

    public boolean isAutoClosing();

    public File getImagePath();

    public void setImagePath(File imagePath);

    public File getPreviousOpenPath();

    public void setPreviousOpenPath(File openPath);

    public File getPreviousImportPath();

    public void setPreviousImportPath(File importPath);

    public File getSoundPath();

    public void setSoundPath(File soundPath);

    public void setMute(boolean mute);

    public boolean isMute();

    public void setLicensed(boolean licensed);

    public boolean isLicensed();

    public void setApplicationPath(File applicationPath);

    public File getApplicationPath();

    /**
     * The StartupApplicationPath is initialized on application startup via ApplicationPreferences.getApplicationPath.
     * If a part of the application needs the application path it should *always* use this method instead of
     * getApplicationPath() since the application path might change while this one will always stay
     * the same.
     * <p/>
     * A switch of the application path while the application is running isn't safe so it's changed for real
     * upon next restart.
     *
     * @return the application path at startup time.
     */
    public File getStartupApplicationPath();

    public void setUsingInternalFrames(boolean usingInternalFrames);

    public boolean isUsingInternalFrames();

    public void setAutoFocusingWindow(boolean autoFocusingWindow);

    public boolean isAutoFocusingWindow();

    public void setSourceNames(Map<String, String> sourceNames);

    public Map<String, String> getSourceNames();

    public Map<String, String> getSoundLocations();

    public void setSoundLocations(Map<String, String> soundLocations);

    public void resetSoundLocations();

    public void addPropertyChangeListener(PropertyChangeListener listener);

    public void removePropertyChangeListener(PropertyChangeListener listener);

    public void reset();

    public void setScrollingToBottom(boolean scrollingToBottom);

    public boolean isScrollingToBottom();

    private boolean loadSoundLocationsXml(File file);

    private boolean writeSoundLocations(Map<String, String> sourceNames);

    private boolean loadSourceNamesXml(File file);

    private boolean loadSourceNamesProperties(File sourceNamesFile);

    private boolean writeSourceNames(Map<String, String> sourceNames);

    private boolean writeSourceLists(Map<String, Set<String>> sourceLists);

    private boolean writeConditions(List<SavedCondition> conditions);

    /**
     * @noinspection MismatchedQueryAndUpdateOfCollection
     */
    private Map<String, String> loadPropertiesXml(File file);

    /**
     * @noinspection MismatchedQueryAndUpdateOfCollection
     */
    private boolean writePropertiesXml(File file, Map<String, String> sourceNames, String comment);

    private Map<String, String> loadProperties(File file);

    public void writeLoggingColumnLayout(boolean global, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos);

    public void writeAccessColumnLayout(boolean global, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos);

    public List<PersistentTableColumnModel.TableColumnLayoutInfo> readLoggingColumnLayout(boolean global);

    public List<PersistentTableColumnModel.TableColumnLayoutInfo> readAccessColumnLayout(boolean global);

    private boolean writeColumnLayout(File file, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos);

    private List<PersistentTableColumnModel.TableColumnLayoutInfo> readColumnLayout(File file);

    /**
     * Quick & dirty MD5 checksum function.
     * Returns null in case of error.
     *
     * @param input the input
     * @return the checksum
     */
    public static byte[] getMD5(InputStream input);

    public void flush();

    /**
     * As described in http://weblogs.java.net/blog/malenkov/archive/2006/08/how_to_encode_e.html
     */
    static class EnumPersistenceDelegate extends PersistenceDelegate {

        protected boolean mutatesTo(Object oldInstance, Object newInstance) {
            return oldInstance == newInstance;
        }

        protected Expression instantiate(Object oldInstance, Encoder out) {
            Enum e = (Enum) oldInstance;
            return new Expression(e, e.getClass(), ""valueOf"", new Object[] { e.name() });
        }
    }
}
","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {
"
cmpl-6xFsLpuuonuxhOZeIX9E49OM9yDQH,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/callables/IndexingCallable.java,112.10975337028503,length,"// IndexingCallable.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

/**
 * Should only be executed on inactive files.
 */
public class IndexingCallable extends AbstractProgressingCallable<Long> {

    private final Logger logger = LoggerFactory.getLogger(IndexingCallable.class);

    private File dataFile;

    private File indexFile;

    public IndexingCallable(File dataFile, File indexFile) {
    }

    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    public Long call() throws Exception;

    public File getDataFile();

    public File getIndexFile();

    private static void closeQuietly(RandomAccessFile file);
}
","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains ten unit test cases for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains ten unit test cases for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {

		private static final Logger logger = LoggerFactory.getLogger(IndexingCallableTest.class);
		
		private static final FileHeaderStrategy fileHeaderStrategy = new DefaultFileHeaderStrategy();
		private static final IndexStrategy indexStrategy = new DefaultIndexStrategy();
		private static final SparseDataStrategy dataStrategy = new DefaultDataStrategy();
		
		private static final File dataFile = new File(""data.dat"");
		private static final File indexFile = new File(""index.dat"");
		
		private static final int ELEMENT_COUNT = 100;
		
		private static final int ELEMENT_SIZE = 100;
		
		private static final int ELEMENT_COUNT_2 = 200;
		
		private static final int ELEMENT_SIZE_2 = 200;
		
		private static final int ELEMENT_COUNT_3 = 300;
		
		private static final int ELEMENT_SIZE_3 = 300;
		
		private static final int ELEMENT_COUNT_4 = 400;
		
		private static final int ELEMENT_SIZE_4 = 400;
		
		private static final int ELEMENT_COUNT_5 = 500;
		
		private static final int ELEMENT_SIZE_5 = 500;
		
		private static final int ELEMENT_COUNT_6 = 600;
		
		private static final int ELEMENT_SIZE_6 = 600;
		
		private static final int ELEMENT_COUNT_7 = 700;
		
		private static final int ELEMENT_SIZE_7 = 700;
		
		private static final int ELEMENT_COUNT_8 = 800;
		
		private static final int ELEMENT_SIZE_8 = 800;
		
		private static final int ELEMENT_COUNT_9 = 900;
		
		private static final int ELEMENT_SIZE_9 = 900;
		
		private static final int ELEMENT_COUNT_10 = 1000;
		
		private static final int ELEMENT_SIZE_10 = 1000;
		
		/**
		* Test case for the {@link IndexingCallable#call()} method.
		* The test case tests the {@link IndexingCallable#call()} method with the following parameters:
		* <ul>
		* <li>{@link IndexingCallable#call()}</li>
		* </ul>
		*
		* @throws Exception
		* 																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																				"
cmpl-6xFu9m5tS5sda0yIvS7UW6gL2Lmke,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/preferences/GenericSortedListModel.java,7.558368921279907,stop,"// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    private final List<T> data;

    private final Comparator<T> comparator;

    public GenericSortedListModel() {
    }

    public GenericSortedListModel(Comparator<T> comparator) {
    }

    public void setData(List<T> data);

    public List<T> getData();

    public void add(T element);

    public void remove(T element);

    /**
     * Returns the length of the list.
     *
     * @return the length of the list
     */
    public int getSize();

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index);
}
","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {

		@Test
		public void testGetElementAt() {
				List<String> data = new ArrayList<String>();
				data.add(""a"");
				data.add(""b"");
				data.add(""c"");
				data.add(""d"");
				data.add(""e"");
				data.add(""f"");
				data.add(""g"");
				data.add(""h"");
				data.add(""i"");
				data.add(""j"");
				GenericSortedListModel<String> model = new GenericSortedListModel<String>(data);
				assertEquals(""a"", model.getElementAt(0));
				assertEquals(""b"", model.getElementAt(1));
				assertEquals(""c"", model.getElementAt(2));
				assertEquals(""d"", model.getElementAt(3));
				assertEquals(""e"", model.getElementAt(4));
				assertEquals(""f"", model.getElementAt(5));
				assertEquals(""g"", model.getElementAt(6));
				assertEquals(""h"", model.getElementAt(7));
				assertEquals(""i"", model.getElementAt(8));
				assertEquals(""j"", model.getElementAt(9));
		}
}"
cmpl-6xFvCcb3FsaAdG8ahmIR58i6kQAcQ,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_0Test.java,97.42459487915039,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_0Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModel_0Test {","// PersistentTableColumnModel_0Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModel_0Test {

		/**
		* Test case for the method {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}.
		*
		* @throws Exception
		* 																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																"
cmpl-6xFwlKzLdCkreTo0HPVnvBvXWRJsf,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_1Test.java,92.97198295593262,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_1Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModel_1Test {","// PersistentTableColumnModel_1Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModel_1Test {

	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: true</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of visible columns.
	*/
	@Test
	public void testGetColumnCount_1() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(1), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(3), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(5), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(7), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(9), false);
		int result = persistentTableColumnModel.getColumnCount(true);
		assertEquals(0, result);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: false</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of columns.
	*/
	@Test
	public void testGetColumnCount_2() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(1), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(3), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(5), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(7), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(9), false);
		int result = persistentTableColumnModel.getColumnCount(false);
		assertEquals(10, result);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: true</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of visible columns.
	*/
	@Test
	public void testGetColumnCount_3() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(1), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(3), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(5), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(7), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(9), false);
		int result = persistentTableColumnModel.getColumnCount(true);
		assertEquals(0, result);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: false</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of columns.
	*/
	@Test
	public void testGetColumnCount_4() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(1), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(3), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(5), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(7), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(9), false);
		int result = persistentTableColumnModel.getColumnCount(false);
		assertEquals(10, result);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: true</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of visible columns.
	*/
	@Test
	public void testGetColumnCount_5() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(1), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(3), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(5), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(7), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(9), false);
		int result = persistentTableColumnModel.getColumnCount(true);
		assertEquals(0, result);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: false</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of columns.
	*/
	@Test
	public void testGetColumnCount_6() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(1), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(3), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(5), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(7), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(9), false);
		int result = persistentTableColumnModel.getColumnCount(false);
		assertEquals(10, result);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
	* <p>
	* This test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method
	* with the following parameters:
	* <ul>
	* <li>onlyVisible: true</li>
	* </ul>
	* <p>
	* The expected result is that the method returns the number of visible columns.
	*/
	@Test
	public void testGetColumnCount_7() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn(new TableColumn());
		persistentTableColumnModel.addColumn("
cmpl-6xFyGdiMW5eENg5SVQFCMFsv0KKJD,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_2Test.java,91.97673296928406,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_2Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModel_2Test {","// PersistentTableColumnModel_2Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModel_2Test {

	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>true</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of the visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(5, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>false</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of all columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(false);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(10, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>true</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of the visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_2() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(5, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>false</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of all columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_2() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(false);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(10, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>true</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of the visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_3() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(5, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>false</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of all columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_3() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(false);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(10, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>true</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of the visible columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_true_4() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(4), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(6), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(8), false);
		Iterator<TableColumn> iterator = persistentTableColumnModel.getColumns(true);
		int count = 0;
		while (iterator.hasNext()) {
			iterator.next();
			count++;
		}
		assertEquals(5, count);
	}
	
	/**
	* Test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
	* This test case tests the method with the parameter <code>onlyVisible</code> set to <code>false</code>.
	* The test case expects that the method returns an <code>Iterator</code> with the size of all columns.
	*/
	@Test
	public void testGetColumns_onlyVisible_false_4() {
		PersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();
		persistentTableColumnModel.addColumn(new TableColumn(0));
		persistentTableColumnModel.addColumn(new TableColumn(1));
		persistentTableColumnModel.addColumn(new TableColumn(2));
		persistentTableColumnModel.addColumn(new TableColumn(3));
		persistentTableColumnModel.addColumn(new TableColumn(4));
		persistentTableColumnModel.addColumn(new TableColumn(5));
		persistentTableColumnModel.addColumn(new TableColumn(6));
		persistentTableColumnModel.addColumn(new TableColumn(7));
		persistentTableColumnModel.addColumn(new TableColumn(8));
		persistentTableColumnModel.addColumn(new TableColumn(9));
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(0), false);
		persistentTableColumnModel.setColumnVisible(persistentTableColumnModel.getColumn(2), false);
		persistentTableColumnModel.setColumn"
cmpl-6xFzkQt298l9uH2Kplj63B6Oob8Nt,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_3Test.java,115.60732626914978,length,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_3Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModel_3Test {","// PersistentTableColumnModel_3Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModel_3Test {

	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is visible.
	* The column identifier is not null.
	* The column identifier is equal to the specified identifier.
	* The onlyVisible parameter is set to true.
	* Expected result: 0
	*/
	@Test
	public void testGetColumnIndex_1() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		columnModel.addColumn(column);
		int result = columnModel.getColumnIndex(""column"", true);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is visible.
	* The column identifier is not null.
	* The column identifier is equal to the specified identifier.
	* The onlyVisible parameter is set to false.
	* Expected result: 0
	*/
	@Test
	public void testGetColumnIndex_2() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		columnModel.addColumn(column);
		int result = columnModel.getColumnIndex(""column"", false);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is visible.
	* The column identifier is not null.
	* The column identifier is not equal to the specified identifier.
	* The onlyVisible parameter is set to true.
	* Expected result: -1
	*/
	@Test
	public void testGetColumnIndex_3() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		columnModel.addColumn(column);
		int result = columnModel.getColumnIndex(""column2"", true);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is visible.
	* The column identifier is not null.
	* The column identifier is not equal to the specified identifier.
	* The onlyVisible parameter is set to false.
	* Expected result: -1
	*/
	@Test
	public void testGetColumnIndex_4() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		columnModel.addColumn(column);
		int result = columnModel.getColumnIndex(""column2"", false);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is visible.
	* The column identifier is null.
	* The onlyVisible parameter is set to true.
	* Expected result: -1
	*/
	@Test
	public void testGetColumnIndex_5() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(null);
		columnModel.addColumn(column);
		int result = columnModel.getColumnIndex(""column"", true);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is visible.
	* The column identifier is null.
	* The onlyVisible parameter is set to false.
	* Expected result: -1
	*/
	@Test
	public void testGetColumnIndex_6() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(null);
		columnModel.addColumn(column);
		int result = columnModel.getColumnIndex(""column"", false);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is invisible.
	* The column identifier is not null.
	* The column identifier is equal to the specified identifier.
	* The onlyVisible parameter is set to true.
	* Expected result: -1
	*/
	@Test
	public void testGetColumnIndex_7() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		columnModel.addColumn(column);
		columnModel.setColumnVisible(column, false);
		int result = columnModel.getColumnIndex(""column"", true);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is invisible.
	* The column identifier is not null.
	* The column identifier is equal to the specified identifier.
	* The onlyVisible parameter is set to false.
	* Expected result: 0
	*/
	@Test
	public void testGetColumnIndex_8() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		columnModel.addColumn(column);
		columnModel.setColumnVisible(column, false);
		int result = columnModel.getColumnIndex(""column"", false);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is invisible.
	* The column identifier is not null.
	* The column identifier is not equal to the specified identifier.
	* The onlyVisible parameter is set to true.
	* Expected result: -1
	*/
	@Test
	public void testGetColumnIndex_9() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		columnModel.addColumn(column);
		columnModel.setColumnVisible(column, false);
		int result = columnModel.getColumnIndex(""column2"", true);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing one column.
	* The column is invisible.
	* The column identifier is not null.
	* The column identifier is not equal to the specified identifier.
	* The onlyVisible parameter is set to false.
	* Expected result: -1
	*/
	@Test
	public void testGetColumnIndex_10() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column = new TableColumn();
		column.setIdentifier(""column"");
		columnModel.addColumn(column);
		columnModel.setColumnVisible(column, false);
		int result = columnModel.getColumnIndex(""column2"", false);
		assertEquals(-1, result);
	}
	
}

// PersistentTableColumnModel_4Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModel_4Test {
		
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing two columns.
	* The first column is visible.
	* The first column identifier is not null.
	* The first column identifier is equal to the specified identifier.
	* The second column is visible.
	* The second column identifier is not null.
	* The second column identifier is not equal to the specified identifier.
	* The onlyVisible parameter is set to true.
	* Expected result: 0
	*/
	@Test
	public void testGetColumnIndex_1() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn();
		column1.setIdentifier(""column1"");
		columnModel.addColumn(column1);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		columnModel.addColumn(column2);
		int result = columnModel.getColumnIndex(""column1"", true);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing two columns.
	* The first column is visible.
	* The first column identifier is not null.
	* The first column identifier is equal to the specified identifier.
	* The second column is visible.
	* The second column identifier is not null.
	* The second column identifier is not equal to the specified identifier.
	* The onlyVisible parameter is set to false.
	* Expected result: 0
	*/
	@Test
	public void testGetColumnIndex_2() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn();
		column1.setIdentifier(""column1"");
		columnModel.addColumn(column1);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		columnModel.addColumn(column2);
		int result = columnModel.getColumnIndex(""column1"", false);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing two columns.
	* The first column is visible.
	* The first column identifier is not null.
	* The first column identifier is not equal to the specified identifier.
	* The second column is visible.
	* The second column identifier is not null.
	* The second column identifier is equal to the specified identifier.
	* The onlyVisible parameter is set to true.
	* Expected result: 1
	*/
	@Test
	public void testGetColumnIndex_3() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn();
		column1.setIdentifier(""column1"");
		columnModel.addColumn(column1);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		columnModel.addColumn(column2);
		int result = columnModel.getColumnIndex(""column2"", true);
		assertEquals(1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing two columns.
	* The first column is visible.
	* The first column identifier is not null.
	* The first column identifier is not equal to the specified identifier.
	* The second column is visible.
	* The second column identifier is not null.
	* The second column identifier is equal to the specified identifier.
	* The onlyVisible parameter is set to false.
	* Expected result: 1
	*/
	@Test
	public void testGetColumnIndex_4() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn();
		column1.setIdentifier(""column1"");
		columnModel.addColumn(column1);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		columnModel.addColumn(column2);
		int result = columnModel.getColumnIndex(""column2"", false);
		assertEquals(1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing two columns.
	* The first column is visible.
	* The first column identifier is not null.
	* The first column identifier is not equal to the specified identifier.
	* The second column is visible.
	* The second column identifier is not null.
	* The second column identifier is not equal to the specified identifier.
	* The onlyVisible parameter is set to true.
	* Expected result: -1
	*/
	@Test
	public void testGetColumnIndex_5() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn();
		column1.setIdentifier(""column1"");
		columnModel.addColumn(column1);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		columnModel.addColumn(column2);
		int result = columnModel.getColumnIndex(""column3"", true);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing two columns.
	* The first column is visible.
	* The first column identifier is not null.
	* The first column identifier is not equal to the specified identifier.
	* The second column is visible.
	* The second column identifier is not null.
	* The second column identifier is not equal to the specified identifier.
	* The onlyVisible parameter is set to false.
	* Expected result: -1
	*/
	@Test
	public void testGetColumnIndex_6() {
		PersistentTableColumnModel columnModel = new PersistentTableColumnModel();
		TableColumn column1 = new TableColumn();
		column1.setIdentifier(""column1"");
		columnModel.addColumn(column1);
		TableColumn column2 = new TableColumn();
		column2.setIdentifier(""column2"");
		columnModel.addColumn(column2);
		int result = columnModel.getColumnIndex(""column3"", false);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
	* Tested with a column model containing two columns.
	* The first column is visible.
	* The first column identifier is null.
	* The second column is visible.
	* The second column identifier is not null.
	* The second column identifier is equal to the specified identifier.
	* The onlyVisible parameter is set to true.
	* Expected result: 1
	*/
	@Test
	public void testGetColumnIndex_7() {
		PersistentTableColumnModel column"
cmpl-6xG1cDJO9n3sO3ozVlyNqQs9jxFEc,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_0Test.java,118.17275404930115,length,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    private static final long serialVersionUID = -2372658104457011019L;

    private int thickness;

    private int innerThickness;

    private Color borderColor;

    public ConditionalBorder(Color color) {
    }

    public ConditionalBorder(Color color, int thickness) {
    }

    public ConditionalBorder(Color color, int thickness, int innerThickness) {
    }

    /**
     * Paints the border for the specified component with the
     * specified position and size.
     *
     * @param c      the component for which this border is being painted
     * @param g      the paint graphics
     * @param x      the x position of the painted border
     * @param y      the y position of the painted border
     * @param width  the width of the painted border
     * @param height the height of the painted border
     */
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height);

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c      the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);

    /**
     * Returns the color of the border.
     *
     * @return the color of the border.
     */
    public Color getBorderColor();

    /**
     * Sets the color of the border.
     *
     * @param borderColor the color of the border.
     */
    public void setBorderColor(Color borderColor);

    /**
     * Returns the inner thickness of the border.
     *
     * @return Returns the inner thickness of the border.
     */
    public int getInnerThickness();

    /**
     * Sets the inner thickness of the border.
     *
     * @param innerThickness Returns the inner thickness of the border.
     */
    public void setInnerThickness(int innerThickness);

    /**
     * Returns the thickness of the border.
     *
     * @return Returns the thickness of the border.
     */
    public int getThickness();

    /**
     * Sets the thickness of the border.
     *
     * @param thickness the thickness of the border.
     */
    public void setThickness(int thickness);

    /**
     * Returns whether or not the border is opaque.
     */
    public boolean isBorderOpaque();
}
","// ConditionalBorder_0Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorder_0Test {","// ConditionalBorder_0Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorder_0Test {

		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of zero.
		*/
		@Test
		public void testGetBorderInsets_0() {
				// create a border with a thickness of zero
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 0);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(0, insets.top);
				assertEquals(0, insets.left);
				assertEquals(0, insets.bottom);
				assertEquals(0, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of one.
		*/
		@Test
		public void testGetBorderInsets_1() {
				// create a border with a thickness of one
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(1, insets.top);
				assertEquals(1, insets.left);
				assertEquals(1, insets.bottom);
				assertEquals(1, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of two.
		*/
		@Test
		public void testGetBorderInsets_2() {
				// create a border with a thickness of two
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 2);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(2, insets.top);
				assertEquals(2, insets.left);
				assertEquals(2, insets.bottom);
				assertEquals(2, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of three.
		*/
		@Test
		public void testGetBorderInsets_3() {
				// create a border with a thickness of three
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 3);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(3, insets.top);
				assertEquals(3, insets.left);
				assertEquals(3, insets.bottom);
				assertEquals(3, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of four.
		*/
		@Test
		public void testGetBorderInsets_4() {
				// create a border with a thickness of four
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 4);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(4, insets.top);
				assertEquals(4, insets.left);
				assertEquals(4, insets.bottom);
				assertEquals(4, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of five.
		*/
		@Test
		public void testGetBorderInsets_5() {
				// create a border with a thickness of five
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 5);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(5, insets.top);
				assertEquals(5, insets.left);
				assertEquals(5, insets.bottom);
				assertEquals(5, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of six.
		*/
		@Test
		public void testGetBorderInsets_6() {
				// create a border with a thickness of six
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 6);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(6, insets.top);
				assertEquals(6, insets.left);
				assertEquals(6, insets.bottom);
				assertEquals(6, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of seven.
		*/
		@Test
		public void testGetBorderInsets_7() {
				// create a border with a thickness of seven
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 7);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(7, insets.top);
				assertEquals(7, insets.left);
				assertEquals(7, insets.bottom);
				assertEquals(7, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of eight.
		*/
		@Test
		public void testGetBorderInsets_8() {
				// create a border with a thickness of eight
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 8);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(8, insets.top);
				assertEquals(8, insets.left);
				assertEquals(8, insets.bottom);
				assertEquals(8, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of nine.
		*/
		@Test
		public void testGetBorderInsets_9() {
				// create a border with a thickness of nine
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 9);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(9, insets.top);
				assertEquals(9, insets.left);
				assertEquals(9, insets.bottom);
				assertEquals(9, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
		* The test case tests the border insets for a border with a thickness of ten.
		*/
		@Test
		public void testGetBorderInsets_10() {
				// create a border with a thickness of ten
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 10);
				// create a component
				Component c = new Component() {
				};
				// get the border insets
				Insets insets = border.getBorderInsets(c);
				// check the border insets
				assertEquals(10, insets.top);
				assertEquals(10, insets.left);
				assertEquals(10, insets.bottom);
				assertEquals(10, insets.right);
		}
}

// ConditionalBorder_1Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_1Test {
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
		* The test case tests the border insets for a border with a thickness of zero.
		*/
		@Test
		public void testGetBorderInsets_0() {
				// create a border with a thickness of zero
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 0);
				// create a component
				Component c = new Component() {
				};
				// create an insets object
				Insets insets = new Insets(0, 0, 0, 0);
				// get the border insets
				border.getBorderInsets(c, insets);
				// check the border insets
				assertEquals(0, insets.top);
				assertEquals(0, insets.left);
				assertEquals(0, insets.bottom);
				assertEquals(0, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
		* The test case tests the border insets for a border with a thickness of one.
		*/
		@Test
		public void testGetBorderInsets_1() {
				// create a border with a thickness of one
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1);
				// create a component
				Component c = new Component() {
				};
				// create an insets object
				Insets insets = new Insets(0, 0, 0, 0);
				// get the border insets
				border.getBorderInsets(c, insets);
				// check the border insets
				assertEquals(1, insets.top);
				assertEquals(1, insets.left);
				assertEquals(1, insets.bottom);
				assertEquals(1, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
		* The test case tests the border insets for a border with a thickness of two.
		*/
		@Test
		public void testGetBorderInsets_2() {
				// create a border with a thickness of two
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 2);
				// create a component
				Component c = new Component() {
				};
				// create an insets object
				Insets insets = new Insets(0, 0, 0, 0);
				// get the border insets
				border.getBorderInsets(c, insets);
				// check the border insets
				assertEquals(2, insets.top);
				assertEquals(2, insets.left);
				assertEquals(2, insets.bottom);
				assertEquals(2, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
		* The test case tests the border insets for a border with a thickness of three.
		*/
		@Test
		public void testGetBorderInsets_3() {
				// create a border with a thickness of three
				ConditionalBorder border = new ConditionalBorder(Color.BLACK, 3);
				// create a component
				Component c = new Component() {
				};
				// create an insets object
				Insets insets = new Insets(0, 0, 0, 0);
				// get the border insets
				border.getBorderInsets(c, insets);
				// check the border insets
				assertEquals(3, insets.top);
				assertEquals(3, insets.left);
				assertEquals(3, insets.bottom);
				assertEquals(3, insets.right);
		}
		
		/**
		* Test case for the {@link ConditionalBorder"
cmpl-6xG3WHAtTefdrCAbsCgsoffjrt0FR,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_1Test.java,99.06251192092896,length,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    private static final long serialVersionUID = -2372658104457011019L;

    private int thickness;

    private int innerThickness;

    private Color borderColor;

    public ConditionalBorder(Color color) {
    }

    public ConditionalBorder(Color color, int thickness) {
    }

    public ConditionalBorder(Color color, int thickness, int innerThickness) {
    }

    /**
     * Paints the border for the specified component with the
     * specified position and size.
     *
     * @param c      the component for which this border is being painted
     * @param g      the paint graphics
     * @param x      the x position of the painted border
     * @param y      the y position of the painted border
     * @param width  the width of the painted border
     * @param height the height of the painted border
     */
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height);

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c      the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);

    /**
     * Returns the color of the border.
     *
     * @return the color of the border.
     */
    public Color getBorderColor();

    /**
     * Sets the color of the border.
     *
     * @param borderColor the color of the border.
     */
    public void setBorderColor(Color borderColor);

    /**
     * Returns the inner thickness of the border.
     *
     * @return Returns the inner thickness of the border.
     */
    public int getInnerThickness();

    /**
     * Sets the inner thickness of the border.
     *
     * @param innerThickness Returns the inner thickness of the border.
     */
    public void setInnerThickness(int innerThickness);

    /**
     * Returns the thickness of the border.
     *
     * @return Returns the thickness of the border.
     */
    public int getThickness();

    /**
     * Sets the thickness of the border.
     *
     * @param thickness the thickness of the border.
     */
    public void setThickness(int thickness);

    /**
     * Returns whether or not the border is opaque.
     */
    public boolean isBorderOpaque();
}
","// ConditionalBorder_1Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_1Test {","// ConditionalBorder_1Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_1Test {

	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_1() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_2() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_3() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_4() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_5() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_6() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_7() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_8() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_9() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_10() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
}

// ConditionalBorder_2Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_2Test {
		
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_1() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_2() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_3() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_4() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_5() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_6() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_7() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_8() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_9() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_10() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
}

// ConditionalBorder_3Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_3Test {
		
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_1() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@Test
	void testGetBorderInsets_2() {
		ConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 1);
		Insets insets = border.getBorderInsets(null, null);
		assertNotNull(insets);
		assertEquals(1, insets.top);
		assertEquals(1, insets.left);
		assertEquals(1, insets.bottom);
		assertEquals(1, insets.right);
	}
	
	/**
	 * Test case for {@link ConditionalBorder#getBorderInsets(Component, Insets)}
	 * with a null insets parameter.
	 */
	@"
