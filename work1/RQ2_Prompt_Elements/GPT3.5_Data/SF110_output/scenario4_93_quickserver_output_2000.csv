ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
chatcmpl-6yY6qGN85izdIxxv7qwyWyzKRs647,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_0Test.java,2.7434284687042236,stop,"// NonBlockingClientHandler.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;

public class NonBlockingClientHandler extends BasicClientHandler {

    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());

    //v1.4.5
    protected ClientWriteHandler clientWriteHandler;

    private SocketChannel socketChannel;

    protected ArrayList readByteBuffer = new ArrayList();

    protected ArrayList writeByteBuffer = new ArrayList();

    protected SelectionKey selectionKey;

    protected volatile int threadAccessCount = 0;

    protected volatile boolean willReturn;

    protected volatile boolean waitingForFinalWrite;

    //one for each event ACCEPT, WRITE, READ
    private static int maxThreadAccessCount = 5;

    private static boolean wakeupSelectorAfterRegisterWrite = true;

    private static boolean wakeupSelectorAfterRegisterRead = true;

    //private final SSLSession session;
    private boolean initialHandshakeStatus = false;

    private SSLEngineResult.HandshakeStatus handshakeStatus;

    private SSLEngineResult.Status status = null;

    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);

    private ByteBuffer peerNetData = null;

    private boolean sslShutdown = false;

    /**
     * Sets the flag to wakeup Selector After RegisterForWrite is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterWrite(boolean flag);

    /**
     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector
     * after RegisterForWrite is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterWrite();

    /**
     * Sets the flag to wakeup Selector After RegisterForRead is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterRead(boolean flag);

    /**
     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector
     * after RegisterForRead is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterRead();

    /**
     * Sets the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static void setMaxThreadAccessCount(int count);

    /**
     * Returns the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static int getMaxThreadAccessCount();

    //v1.4.7
    private ByteBufferOutputStream byteBufferOutputStream;

    public NonBlockingClientHandler(int instanceCount) {
    }

    public NonBlockingClientHandler() {
    }

    public void clean();

    protected void finalize() throws Throwable;

    public void handleClient(TheClient theClient) throws Exception;

    protected void setInputStream(InputStream in) throws IOException;

    public BufferedReader getBufferedReader();

    public void closeConnection();

    private void doPostCloseActivity() throws IOException;

    public boolean closeIfSSLOutboundDone();

    /**
     * waitTillFullyWritten
     * @since 1.4.7
     */
    public void waitTillFullyWritten();

    public void run();

    protected boolean checkReturnClientHandler();

    /**
     * Process read
     * @return value indicates if the thread should return form run()
     */
    private boolean processRead() throws Exception;

    private boolean doRead() throws Exception;

    /**
     * Process write
     * @return value indicates if the thread should return form run()
     */
    private boolean processWrite() throws IOException;

    private boolean doWrite() throws IOException;

    protected void returnThread();

    protected void returnClientHandler();

    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException;

    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException;

    protected byte[] readInputStream() throws IOException;

    public void updateInputOutputStreams() throws IOException;

    public boolean getBlockingMode();

    public void setSocketChannel(SocketChannel socketChannel);

    public SocketChannel getSocketChannel();

    public void setSelectionKey(SelectionKey selectionKey);

    public SelectionKey getSelectionKey();

    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException;

    public void registerForRead() throws IOException, ClosedChannelException;

    public void registerForWrite() throws IOException, ClosedChannelException;

    public void registerWrite() throws IOException;

    protected void setClientWriteHandler(ClientWriteHandler handler);

    /**
     * Returns number of thread currently in this object.
     * @since 1.4.6
     */
    public int getThreadAccessCount();

    private void doHandshake() throws Exception;

    private void doTasks();

    private void finishInitialHandshake() throws IOException;

    public boolean getInitialHandshakeStatus();

    public ByteBuffer encrypt(ByteBuffer src) throws IOException;
}
","// NonBlockingClientHandler_0Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterWrite()} method.
*/
class NonBlockingClientHandler_0Test {","I'm sorry, but the code you provided is incomplete. It seems to be missing the actual test cases for the `getWakeupSelectorAfterRegisterWrite()` method. Can you please provide the complete code so I can assist you better?"
chatcmpl-6yY7tKEclOmI8DXkLcoNIOKzXcByH,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_1Test.java,2.5160772800445557,stop,"// NonBlockingClientHandler.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;

public class NonBlockingClientHandler extends BasicClientHandler {

    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());

    //v1.4.5
    protected ClientWriteHandler clientWriteHandler;

    private SocketChannel socketChannel;

    protected ArrayList readByteBuffer = new ArrayList();

    protected ArrayList writeByteBuffer = new ArrayList();

    protected SelectionKey selectionKey;

    protected volatile int threadAccessCount = 0;

    protected volatile boolean willReturn;

    protected volatile boolean waitingForFinalWrite;

    //one for each event ACCEPT, WRITE, READ
    private static int maxThreadAccessCount = 5;

    private static boolean wakeupSelectorAfterRegisterWrite = true;

    private static boolean wakeupSelectorAfterRegisterRead = true;

    //private final SSLSession session;
    private boolean initialHandshakeStatus = false;

    private SSLEngineResult.HandshakeStatus handshakeStatus;

    private SSLEngineResult.Status status = null;

    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);

    private ByteBuffer peerNetData = null;

    private boolean sslShutdown = false;

    /**
     * Sets the flag to wakeup Selector After RegisterForWrite is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterWrite(boolean flag);

    /**
     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector
     * after RegisterForWrite is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterWrite();

    /**
     * Sets the flag to wakeup Selector After RegisterForRead is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterRead(boolean flag);

    /**
     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector
     * after RegisterForRead is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterRead();

    /**
     * Sets the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static void setMaxThreadAccessCount(int count);

    /**
     * Returns the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static int getMaxThreadAccessCount();

    //v1.4.7
    private ByteBufferOutputStream byteBufferOutputStream;

    public NonBlockingClientHandler(int instanceCount) {
    }

    public NonBlockingClientHandler() {
    }

    public void clean();

    protected void finalize() throws Throwable;

    public void handleClient(TheClient theClient) throws Exception;

    protected void setInputStream(InputStream in) throws IOException;

    public BufferedReader getBufferedReader();

    public void closeConnection();

    private void doPostCloseActivity() throws IOException;

    public boolean closeIfSSLOutboundDone();

    /**
     * waitTillFullyWritten
     * @since 1.4.7
     */
    public void waitTillFullyWritten();

    public void run();

    protected boolean checkReturnClientHandler();

    /**
     * Process read
     * @return value indicates if the thread should return form run()
     */
    private boolean processRead() throws Exception;

    private boolean doRead() throws Exception;

    /**
     * Process write
     * @return value indicates if the thread should return form run()
     */
    private boolean processWrite() throws IOException;

    private boolean doWrite() throws IOException;

    protected void returnThread();

    protected void returnClientHandler();

    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException;

    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException;

    protected byte[] readInputStream() throws IOException;

    public void updateInputOutputStreams() throws IOException;

    public boolean getBlockingMode();

    public void setSocketChannel(SocketChannel socketChannel);

    public SocketChannel getSocketChannel();

    public void setSelectionKey(SelectionKey selectionKey);

    public SelectionKey getSelectionKey();

    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException;

    public void registerForRead() throws IOException, ClosedChannelException;

    public void registerForWrite() throws IOException, ClosedChannelException;

    public void registerWrite() throws IOException;

    protected void setClientWriteHandler(ClientWriteHandler handler);

    /**
     * Returns number of thread currently in this object.
     * @since 1.4.6
     */
    public int getThreadAccessCount();

    private void doHandshake() throws Exception;

    private void doTasks();

    private void finishInitialHandshake() throws IOException;

    public boolean getInitialHandshakeStatus();

    public ByteBuffer encrypt(ByteBuffer src) throws IOException;
}
","// NonBlockingClientHandler_1Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterRead()} method.
*/
class NonBlockingClientHandler_1Test {","I'm sorry, but the code you provided is incomplete. It seems to be missing the actual test cases for the `getWakeupSelectorAfterRegisterRead()` method. Can you please provide the complete code?"
chatcmpl-6yY8wvxoDauS9iXEn7FKTTrQFS38M,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_2Test.java,1.622241497039795,stop,"// NonBlockingClientHandler.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;

public class NonBlockingClientHandler extends BasicClientHandler {

    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());

    //v1.4.5
    protected ClientWriteHandler clientWriteHandler;

    private SocketChannel socketChannel;

    protected ArrayList readByteBuffer = new ArrayList();

    protected ArrayList writeByteBuffer = new ArrayList();

    protected SelectionKey selectionKey;

    protected volatile int threadAccessCount = 0;

    protected volatile boolean willReturn;

    protected volatile boolean waitingForFinalWrite;

    //one for each event ACCEPT, WRITE, READ
    private static int maxThreadAccessCount = 5;

    private static boolean wakeupSelectorAfterRegisterWrite = true;

    private static boolean wakeupSelectorAfterRegisterRead = true;

    //private final SSLSession session;
    private boolean initialHandshakeStatus = false;

    private SSLEngineResult.HandshakeStatus handshakeStatus;

    private SSLEngineResult.Status status = null;

    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);

    private ByteBuffer peerNetData = null;

    private boolean sslShutdown = false;

    /**
     * Sets the flag to wakeup Selector After RegisterForWrite is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterWrite(boolean flag);

    /**
     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector
     * after RegisterForWrite is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterWrite();

    /**
     * Sets the flag to wakeup Selector After RegisterForRead is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterRead(boolean flag);

    /**
     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector
     * after RegisterForRead is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterRead();

    /**
     * Sets the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static void setMaxThreadAccessCount(int count);

    /**
     * Returns the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static int getMaxThreadAccessCount();

    //v1.4.7
    private ByteBufferOutputStream byteBufferOutputStream;

    public NonBlockingClientHandler(int instanceCount) {
    }

    public NonBlockingClientHandler() {
    }

    public void clean();

    protected void finalize() throws Throwable;

    public void handleClient(TheClient theClient) throws Exception;

    protected void setInputStream(InputStream in) throws IOException;

    public BufferedReader getBufferedReader();

    public void closeConnection();

    private void doPostCloseActivity() throws IOException;

    public boolean closeIfSSLOutboundDone();

    /**
     * waitTillFullyWritten
     * @since 1.4.7
     */
    public void waitTillFullyWritten();

    public void run();

    protected boolean checkReturnClientHandler();

    /**
     * Process read
     * @return value indicates if the thread should return form run()
     */
    private boolean processRead() throws Exception;

    private boolean doRead() throws Exception;

    /**
     * Process write
     * @return value indicates if the thread should return form run()
     */
    private boolean processWrite() throws IOException;

    private boolean doWrite() throws IOException;

    protected void returnThread();

    protected void returnClientHandler();

    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException;

    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException;

    protected byte[] readInputStream() throws IOException;

    public void updateInputOutputStreams() throws IOException;

    public boolean getBlockingMode();

    public void setSocketChannel(SocketChannel socketChannel);

    public SocketChannel getSocketChannel();

    public void setSelectionKey(SelectionKey selectionKey);

    public SelectionKey getSelectionKey();

    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException;

    public void registerForRead() throws IOException, ClosedChannelException;

    public void registerForWrite() throws IOException, ClosedChannelException;

    public void registerWrite() throws IOException;

    protected void setClientWriteHandler(ClientWriteHandler handler);

    /**
     * Returns number of thread currently in this object.
     * @since 1.4.6
     */
    public int getThreadAccessCount();

    private void doHandshake() throws Exception;

    private void doTasks();

    private void finishInitialHandshake() throws IOException;

    public boolean getInitialHandshakeStatus();

    public ByteBuffer encrypt(ByteBuffer src) throws IOException;
}
","// NonBlockingClientHandler_2Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getMaxThreadAccessCount()} method.
*/
class NonBlockingClientHandler_2Test {","I'm sorry, but the code you provided is incomplete and contains errors. Please provide a complete and error-free code for me to assist you better."
a1b3f6d6-b66a-4412-b2aa-8c885d260aee,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_0Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11019 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_0Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersion()} method.
*/
class QuickServer_0Test {","// QuickServer_0Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersion()} method.
*/
class QuickServer_0Test {
"
b1328fd0-24f6-4217-b7d3-635d2de0154d,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_1Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11020 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_1Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersionNo()} method.
*/
class QuickServer_1Test {","// QuickServer_1Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersionNo()} method.
*/
class QuickServer_1Test {
"
c8acb52c-9bd6-4055-aad4-86b098ce8d0d,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_2Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11020 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_2Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getNewLine()} method.
*/
class QuickServer_2Test {","// QuickServer_2Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getNewLine()} method.
*/
class QuickServer_2Test {
"
0df06635-2d17-495e-b92a-b2cd608ba7e6,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_3Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11022 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_3Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(Object[])} method.
*/
class QuickServer_3Test {","// QuickServer_3Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(Object[])} method.
*/
class QuickServer_3Test {
"
c89f9cc1-000b-472f-8f1f-12b99066a865,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_4Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11024 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_4Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(QuickServerConfig)} method.
*/
class QuickServer_4Test {","// QuickServer_4Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(QuickServerConfig)} method.
*/
class QuickServer_4Test {
"
d48b55cc-d8d6-49f3-b191-ca7f904df5cf,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_5Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11020 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_5Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#startService()} method.
*/
class QuickServer_5Test {","// QuickServer_5Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#startService()} method.
*/
class QuickServer_5Test {
"
5e485817-662e-423a-974e-9da37b621a8d,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_6Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11020 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_6Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#stopService()} method.
*/
class QuickServer_6Test {","// QuickServer_6Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#stopService()} method.
*/
class QuickServer_6Test {
"
855a6bd0-022d-4d75-a481-ffac29d4c6cd,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_7Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11020 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_7Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#suspendService()} method.
*/
class QuickServer_7Test {","// QuickServer_7Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#suspendService()} method.
*/
class QuickServer_7Test {
"
95d05415-40f7-48fa-9c0b-631600f1b88e,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_8Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11020 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_8Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#resumeService()} method.
*/
class QuickServer_8Test {","// QuickServer_8Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#resumeService()} method.
*/
class QuickServer_8Test {
"
ce7cf602-5601-4f93-83c7-bc1d778cf3dc,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_9Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11019 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_9Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#info()} method.
*/
class QuickServer_9Test {","// QuickServer_9Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#info()} method.
*/
class QuickServer_9Test {
"
dfbde8a6-fe8c-43d4-b41c-d94b0ff2dd0f,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_10Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11020 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_10Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClient()} method.
*/
class QuickServer_10Test {","// QuickServer_10Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClient()} method.
*/
class QuickServer_10Test {
"
a66bd651-7e30-45b8-8fc3-631c1bd207fa,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_11Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11021 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_11Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLContext(String)} method.
*/
class QuickServer_11Test {","// QuickServer_11Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLContext(String)} method.
*/
class QuickServer_11Test {
"
fb6c7160-4833-4ea5-a89f-af96e8d11235,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_12Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11023 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_12Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLSocketFactory(String)} method.
*/
class QuickServer_12Test {","// QuickServer_12Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLSocketFactory(String)} method.
*/
class QuickServer_12Test {
"
4aa0c747-d4d2-4b74-810f-971e0176d81f,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_13Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, your messages resulted in 11019 tokens. Please reduce the length of the messages.","// QuickServer.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 * Main class of QuickServer library. This class is used to create
 * multi client servers quickly.
 * <p>
 * Ones a client is connected, it creates {@link ClientHandler} object,
 * which is run using any thread available from the pool of threads
 * maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 * handles the client. <br/>
 * QuickServer divides the application logic of its developer over eight
 * class, <br>
 * 	<ul>
 * 	<li>ClientEventHandler<br>
 * 		   &nbsp;Handles client events [Optional Class].
 * 		<li>ClientCommandHandler [#]<br>
 * 		   &nbsp;Handles client character/string commands.
 * 		<li>ClientObjectHandler [#]<br>
 * 		   &nbsp;Handles client interaction - Object commands.
 * 	<li>ClientBinaryHandler [#]<br>
 * 		   &nbsp;Handles client interaction - binary data.
 * 	<li>ClientWriteHandler [Optional Class]<br>
 * 		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 * 		<li>ClientAuthenticationHandler [Optional Class]<br>
 * 			&nbsp;Used to Authencatet a client.
 * 		<li>ClientData [Optional Class]<br>
 * 			&nbsp;Client data carrier (support class)
 * 	<li>ClientExtendedEventHandler [Optional Class]<br>
 * 		   &nbsp;Handles extended client events.
 * 	</ul>
 *
 * [#] = Any one of these have to be set based on default DataMode for input.
 * The default DataMode for input is String so if not changes you will
 * have to set ClientCommandHandler.
 * </p>
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 * @version 1.4.8
 * @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion();

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo();

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver);

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine();

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString();

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException;

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException;

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException;

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName();

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name);

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner();

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner);

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port);

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort();

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler);

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler();

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator);

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler();

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator);

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator();

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data);

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData();

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time);

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout();

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry);

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry();

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg);

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg();

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg);

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg();

    private TheClient initTheClient();

    public void run();

    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection);

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection();

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount();

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg);

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg();

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException;

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr();

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects);

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects();

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port);

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort();

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator);

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator();

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException;

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException;

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer();

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer);

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed();

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger();

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger);

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler);

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler();

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException;

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini();

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro();

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level);

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel();

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level);

    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError();

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param);

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig);

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService();

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService();

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService();

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService();

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info();

    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException;

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException;

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState();

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state);

    private void configConsoleLoggingLevel(QuickServer qs, String temp);

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception;

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception;

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args);

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException;

    /**
     * Prints usage
     */
    private static String printUsage();

    private static void handleOptions(String[] args, QuickServer quickserver);

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception;

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception;

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception;

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool();

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool();

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config);

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig();

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception;

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool();

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil();

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig);

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception;

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id);

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient();

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern);

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key);

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern);

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted();

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation();

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation);

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging);

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging();

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass);

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass();

    public SecurityManager getSecurityManager() throws AppException;

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig);

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig();

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader);

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader();

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException;

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath);

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath();

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks);

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks();

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses();

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event);

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone();

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure);

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure();

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure();

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure);

    private File makeAbsoluteToConfig(String fileName);

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException;

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception;

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig();

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException;

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException;

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler);

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler();

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector);

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector();

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception;

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception;

    private boolean checkAccessConstraint(Socket socket);

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException;

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig);

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool();

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception;

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler);

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler();

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime();

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag);

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier();

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception;

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode();

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception;

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler);

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler();

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException;

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException;

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType);

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler);

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler();

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception;

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID();

    public boolean isRawCommunicationLogging();

    public void setRawCommunicationLogging(boolean rawCommunicationLogging);

    public int getRawCommunicationMaxLength();

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength);
}
","// QuickServer_13Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getPID()} method.
*/
class QuickServer_13Test {","// QuickServer_13Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getPID()} method.
*/
class QuickServer_13Test {
"
chatcmpl-6yYNa3dFrSWS3EbVzzPEHOkjQUCHh,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/qsadmin/QSAdminAPI.java,2.597186803817749,stop,"// QSAdminAPI.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;

/**
 * QSAdminAPI class to communicate to QsAdmin from java applications.
 * <p>
 *  Eg:
 * <code><BLOCKQUOTE><pre>
 * 	QSAdminAPI qsAdminApi = new QSAdminAPI(""127.0.0.1"", 9080);
 * 	if(qsAdminApi.logon()) {
 * 		System.out.println(""Logged in"");
 * 		String info = qsAdminApi.sendCommand(""info server"");
 * 		System.out.println(""Info on Server :\n""+info);
 * 		qsAdminApi.logoff();
 * 	} else {
 * 		System.out.println(""Bad Login"");
 * 		qsAdminApi.close();
 * 	}
 * </pre></BLOCKQUOTE></code></p>
 *
 * @see QSAdminServer
 * @since 1.4
 * @author Akshathkumar Shetty
 */
public class QSAdminAPI {

    private static final Logger logger = Logger.getLogger(QSAdminAPI.class.getName());

    private String username = ""Admin"";

    private String password = ""QsAdm1n"";

    private String host = ""localhost"";

    private int port = 9877;

    private Socket socket;

    private InputStream in;

    private OutputStream out;

    private BufferedReader br;

    private BufferedWriter bw;

    /**
     * Creates QSAdminAPI object that will communicate with the
     * passed host and port.
     */
    public QSAdminAPI(String host, int port) {
    }

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon() throws IOException;

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon(String username, String password) throws IOException;

    /**
     * Sends the given command to QSAdmin and gives the response back.
     */
    public String sendCommand(String data) throws IOException;

    private String readResponse() throws IOException;

    /**
     * Logoff the QSAdminServer and closed the socket associated.
     */
    public void logoff() throws IOException;

    /**
     * Closes the socket associated.
     */
    public void close() throws IOException;

    public static void main(String[] args) throws Exception;
}
","// QSAdminAPITest.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminAPI}.
* It contains ten unit test cases for the {@link QSAdminAPI#logon()} method.
*/
class QSAdminAPITest {","I'm sorry, but the code you provided is incomplete. It seems that the class `QSAdminAPITest` is not implemented and there are missing method implementations in the `QSAdminAPI` class. Please provide the complete code so I can assist you better."
chatcmpl-6yYOdAxX1mMI3zdiLZHS85KBJ7aFb,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_0Test.java,2.903937816619873,stop,"// PasswordField.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;

/**
 * This class prompts the user for a password and attempts to mask
 * input.
 *
 * @since 1.4
 */
public class PasswordField {

    private static Logger logger = Logger.getLogger(PasswordField.class.getName());

    /**
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(String prompt) throws IOException;

    /**
     * @param in input stream to be used (e.g. System.in)
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(InputStream in, String prompt) throws IOException;
}
","// PasswordField_0Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_0Test {","I'm sorry, but the code you provided is incomplete. The `getPassword` methods in the `PasswordField` class are declared but not implemented. Additionally, the `PasswordField_0Test` class is not complete and does not contain any test cases. Please provide the complete code so I can assist you better."
chatcmpl-6yYPg1yK7Xg0Becj9P1DwQyLz7YLj,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_1Test.java,1.794119119644165,stop,"// PasswordField.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;

/**
 * This class prompts the user for a password and attempts to mask
 * input.
 *
 * @since 1.4
 */
public class PasswordField {

    private static Logger logger = Logger.getLogger(PasswordField.class.getName());

    /**
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(String prompt) throws IOException;

    /**
     * @param in input stream to be used (e.g. System.in)
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(InputStream in, String prompt) throws IOException;
}
","// PasswordField_1Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.
*/
class PasswordField_1Test {","I'm sorry, but the code you provided is incomplete. It seems that the method getPassword(String prompt) is missing its implementation. Please provide the complete code so I can assist you better."
chatcmpl-6yYQjBPCyuBIcdSLMCqGqku9zEqCp,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/ByteBufferInputStream.java,60.18922972679138,stop,"// ByteBufferInputStream.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;

/**
 * This is an InputStream constructed from list of ByteBuffers. This is
 * used in non-blocking mode.
 *
 * @since 1.4.5
 * @author Akshathkumar Shetty
 */
public class ByteBufferInputStream extends InputStream {

    private static final Logger logger = Logger.getLogger(ByteBufferInputStream.class.getName());

    static {
    }

    /**
     * Sets the debug flag.
     */
    public static void setDebug(boolean flag);

    /**
     * @since 1.4.7
     */
    public static boolean isLoggable(Level level);

    private final ArrayList bufferList;

    private ClientHandler handler;

    private CharsetDecoder decoder;

    private CharsetEncoder encoder;

    private StringBuilder strings;

    private int pos = 0;

    private int index = -1;

    private int start = 0;

    private boolean lookingForLineFeed = false;

    public ByteBufferInputStream(ArrayList bufferList, ClientHandler handler, String charset) {
    }

    public synchronized int availableOnlyInByteBuffer();

    public synchronized int available();

    public synchronized void close() throws IOException;

    public boolean markSupported();

    public synchronized int read() throws IOException;

    public int read(byte[] b) throws IOException;

    public synchronized int read(byte[] b, int off, int len) throws IOException;

    public long skip(long n) throws IOException;

    private void addStringsBackAsBuffer();

    private void returnBufferBack();

    private void returnBufferBack(ByteBuffer byteBuffer);

    /**
     * Checks if a line of String is ready to be read.
     * @throws IOException if connection is lost or closed.
     */
    public synchronized boolean isLineReady() throws IOException;

    private boolean isLineReadyForStringBuilder();

    /**
     * Reads a line of String if ready. If line is not yet ready this will
     * block. To find out if the line is ready use <code>isLineReady()</code>
     * @see #isLineReady()
     */
    public synchronized String readLine() throws IOException;

    public void dumpContent();
}
","// ByteBufferInputStreamTest.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferInputStream}.
* It contains ten unit test cases for the {@link ByteBufferInputStream#readLine()} method.
*/
class ByteBufferInputStreamTest {","// Source code for ByteBufferInputStreamTest.java

package org.quickserver.util.io;

import org.junit.jupiter.api.Test;

import java.nio.ByteBuffer;
import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test class of {@link ByteBufferInputStream}.
 * It contains ten unit test cases for the {@link ByteBufferInputStream#readLine()} method.
 */
class ByteBufferInputStreamTest {

    @Test
    void testReadLineSingleBuffer() throws Exception {
        ByteBuffer buffer = ByteBuffer.wrap(""Hello World\n"".getBytes());
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line = stream.readLine();
        assertEquals(""Hello World"", line);
    }

    @Test
    void testReadLineMultipleBuffers() throws Exception {
        ByteBuffer buffer1 = ByteBuffer.wrap(""Hello "".getBytes());
        ByteBuffer buffer2 = ByteBuffer.wrap(""World\n"".getBytes());
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer1);
        bufferList.add(buffer2);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line = stream.readLine();
        assertEquals(""Hello World"", line);
    }

    @Test
    void testReadLineEmptyBuffer() throws Exception {
        ByteBuffer buffer1 = ByteBuffer.wrap(""Hello "".getBytes());
        ByteBuffer buffer2 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer3 = ByteBuffer.wrap(""World\n"".getBytes());
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer1);
        bufferList.add(buffer2);
        bufferList.add(buffer3);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line = stream.readLine();
        assertEquals(""Hello World"", line);
    }

    @Test
    void testReadLineEmptyBufferAtEnd() throws Exception {
        ByteBuffer buffer1 = ByteBuffer.wrap(""Hello "".getBytes());
        ByteBuffer buffer2 = ByteBuffer.wrap(""World"".getBytes());
        ByteBuffer buffer3 = ByteBuffer.wrap(new byte[0]);
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer1);
        bufferList.add(buffer2);
        bufferList.add(buffer3);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line = stream.readLine();
        assertEquals(""Hello World"", line);
    }

    @Test
    void testReadLineEmptyBufferInMiddle() throws Exception {
        ByteBuffer buffer1 = ByteBuffer.wrap(""Hello "".getBytes());
        ByteBuffer buffer2 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer3 = ByteBuffer.wrap(""World\n"".getBytes());
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer1);
        bufferList.add(buffer2);
        bufferList.add(buffer3);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line = stream.readLine();
        assertEquals(""Hello World"", line);
    }

    @Test
    void testReadLineEmptyBufferInMiddle2() throws Exception {
        ByteBuffer buffer1 = ByteBuffer.wrap(""Hello"".getBytes());
        ByteBuffer buffer2 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer3 = ByteBuffer.wrap("" World\n"".getBytes());
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer1);
        bufferList.add(buffer2);
        bufferList.add(buffer3);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line = stream.readLine();
        assertEquals(""Hello World"", line);
    }

    @Test
    void testReadLineEmptyBufferInMiddle3() throws Exception {
        ByteBuffer buffer1 = ByteBuffer.wrap(""Hello "".getBytes());
        ByteBuffer buffer2 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer3 = ByteBuffer.wrap(""World"".getBytes());
        ByteBuffer buffer4 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer5 = ByteBuffer.wrap(""\n"".getBytes());
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer1);
        bufferList.add(buffer2);
        bufferList.add(buffer3);
        bufferList.add(buffer4);
        bufferList.add(buffer5);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line = stream.readLine();
        assertEquals(""Hello World"", line);
    }

    @Test
    void testReadLineEmptyBufferInMiddle4() throws Exception {
        ByteBuffer buffer1 = ByteBuffer.wrap(""Hello "".getBytes());
        ByteBuffer buffer2 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer3 = ByteBuffer.wrap(""World"".getBytes());
        ByteBuffer buffer4 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer5 = ByteBuffer.wrap(""\n"".getBytes());
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer1);
        bufferList.add(buffer2);
        bufferList.add(buffer3);
        bufferList.add(buffer4);
        bufferList.add(buffer5);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line1 = stream.readLine();
        String line2 = stream.readLine();
        assertEquals(""Hello World"", line1);
        assertEquals(null, line2);
    }

    @Test
    void testReadLineEmptyBufferInMiddle5() throws Exception {
        ByteBuffer buffer1 = ByteBuffer.wrap(""Hello "".getBytes());
        ByteBuffer buffer2 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer3 = ByteBuffer.wrap(""World"".getBytes());
        ByteBuffer buffer4 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer5 = ByteBuffer.wrap(""\n"".getBytes());
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer1);
        bufferList.add(buffer2);
        bufferList.add(buffer3);
        bufferList.add(buffer4);
        bufferList.add(buffer5);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line1 = stream.readLine();
        String line2 = stream.readLine();
        String line3 = stream.readLine();
        assertEquals(""Hello World"", line1);
        assertEquals(null, line2);
        assertEquals(null, line3);
    }

    @Test
    void testReadLineEmptyBufferInMiddle6() throws Exception {
        ByteBuffer buffer1 = ByteBuffer.wrap(""Hello "".getBytes());
        ByteBuffer buffer2 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer3 = ByteBuffer.wrap(""World"".getBytes());
        ByteBuffer buffer4 = ByteBuffer.wrap(new byte[0]);
        ByteBuffer buffer5 = ByteBuffer.wrap(""\n"".getBytes());
        ArrayList<ByteBuffer> bufferList = new ArrayList<>();
        bufferList.add(buffer1);
        bufferList.add(buffer2);
        bufferList.add(buffer3);
        bufferList.add(buffer4);
        bufferList.add(buffer5);
        ByteBufferInputStream stream = new ByteBufferInputStream(bufferList, null, ""UTF-8"");
        String line1 = stream.readLine();
        String line2 = stream.readLine();
        String line3 = stream.readLine();
        String line4 = stream.readLine();
        assertEquals(""Hello World"", line1);
        assertEquals(null, line2);
        assertEquals(null, line3);
        assertEquals(null, line4);
    }
}"
chatcmpl-6yYRhWJFAQbo0ca3o8vpMXvtLsh43,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/ClassUtil.java,50.304452657699585,stop,"// ClassUtil.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;

/**
 * A utility class to load class.
 *
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class ClassUtil {

    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());

    /**
     * Tries to load the classes present in the array
     * passed has second parameter from
     * the ClassLoader passed has first parameter.
     * Returns the HashMap of all the classed successfully loaded.
     * @param classLoader ClassLoader used to find the class
     * @param classes[] array of classes to load.
     */
    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception;

    /**
     * Returns the ClassLoader to all the jars present in the
     * dir passed has first parameter.
     * @param jarDir path to the directory containing the jars
     */
    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception;

    /**
     * Returns the ClassLoader to a jar
     * @since 1.3.3
     */
    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception;

    /**
     * Returns the ClassLoader
     * @since 1.3.3
     */
    public static ClassLoader getClassLoader(String path) throws Exception;
}
","// ClassUtilTest.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.
*/
class ClassUtilTest {","// Here's the source code for ClassUtil.java

// ClassUtil.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;

/**
 * A utility class to load class.
 *
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class ClassUtil {

    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());

    /**
     * Tries to load the classes present in the array
     * passed has second parameter from
     * the ClassLoader passed has first parameter.
     * Returns the HashMap of all the classed successfully loaded.
     * @param classLoader ClassLoader used to find the class
     * @param classes[] array of classes to load.
     */
    public static Map<String, Class<?>> loadClass(ClassLoader classLoader, String[] classNames) throws Exception {
        Map<String, Class<?>> loadedClasses = new HashMap<String, Class<?>>();
        for (String className : classNames) {
            Class<?> loadedClass = classLoader.loadClass(className);
            loadedClasses.put(className, loadedClass);
        }
        return loadedClasses;
    }

    /**
     * Returns the ClassLoader to all the jars present in the
     * dir passed has first parameter.
     * @param jarDir path to the directory containing the jars
     */
    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception {
        File dir = new File(jarDir);
        if (!dir.isDirectory()) {
            throw new IllegalArgumentException(""The specified path is not a directory: "" + jarDir);
        }
        List<URL> urls = new ArrayList<URL>();
        for (File file : dir.listFiles()) {
            if (file.getName().endsWith("".jar"")) {
                urls.add(file.toURI().toURL());
            }
        }
        URL[] urlArray = urls.toArray(new URL[urls.size()]);
        return new URLClassLoader(urlArray);
    }

    /**
     * Returns the ClassLoader to a jar
     * @since 1.3.3
     */
    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception {
        URL url = new File(jarPath).toURI().toURL();
        return new URLClassLoader(new URL[] { url });
    }

    /**
     * Returns the ClassLoader
     * @since 1.3.3
     */
    public static ClassLoader getClassLoader(String path) throws Exception {
        File file = new File(path);
        if (file.isDirectory()) {
            return new URLClassLoader(new URL[] { file.toURI().toURL() });
        } else {
            return getClassLoaderFromJar(path);
        }
    }
}

// And here's the source code for ClassUtilTest.java

// ClassUtilTest.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.
*/
class ClassUtilTest {

    @Test
    void testGetClassLoaderFromJars() throws Exception {
        String jarDir = ""test/jars"";
        ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);
        assertNotNull(classLoader, ""ClassLoader should not be null"");
    }

    @Test
    void testGetClassLoaderFromJarsWithInvalidPath() {
        String jarDir = ""invalid/path"";
        assertThrows(IllegalArgumentException.class, () -> {
            ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);
        });
    }

    @Test
    void testGetClassLoaderFromJarsWithNoJars() throws Exception {
        String jarDir = ""test/nojars"";
        ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);
        assertNotNull(classLoader, ""ClassLoader should not be null"");
    }

    @Test
    void testGetClassLoaderFromJarsWithOneJar() throws Exception {
        String jarDir = ""test/onejar"";
        ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);
        assertNotNull(classLoader, ""ClassLoader should not be null"");
    }

    @Test
    void testGetClassLoaderFromJarsWithMultipleJars() throws Exception {
        String jarDir = ""test/multiplejars"";
        ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(jarDir);
        assertNotNull(classLoader, ""ClassLoader should not be null"");
    }

    @Test
    void testGetClassLoaderFromJar() throws Exception {
        String jarPath = ""test/jars/test.jar"";
        ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(jarPath);
        assertNotNull(classLoader, ""ClassLoader should not be null"");
    }

    @Test
    void testGetClassLoaderFromJarWithInvalidPath() {
        String jarPath = ""invalid/path/test.jar"";
        assertThrows(FileNotFoundException.class, () -> {
            ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(jarPath);
        });
    }

    @Test
    void testGetClassLoader() throws Exception {
        String jarDir = ""test/jars"";
        String jarPath = ""test/jars/test.jar"";
        String dirPath = ""test/nojars"";
        ClassLoader classLoader1 = ClassUtil.getClassLoaderFromJars(jarDir);
        ClassLoader classLoader2 = ClassUtil.getClassLoaderFromJar(jarPath);
        ClassLoader classLoader3 = ClassUtil.getClassLoader(dirPath);
        assertNotNull(classLoader1, ""ClassLoader should not be null"");
        assertNotNull(classLoader2, ""ClassLoader should not be null"");
        assertNotNull(classLoader3, ""ClassLoader should not be null"");
    }

    @Test
    void testGetClassLoaderWithInvalidPath() {
        String invalidPath = ""invalid/path"";
        assertThrows(IllegalArgumentException.class, () -> {
            ClassLoader classLoader = ClassUtil.getClassLoader(invalidPath);
        });
    }
}"
chatcmpl-6yYSldKDlZ0vWQ2OddOjE9dTAjia0,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/pool/thread/ClientPool.java,28.747854709625244,stop,"// ClientPool.java
package org.quickserver.util.pool.thread;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;

/**
 * This is a class for managing the pool of threads for
 * handling clients.
 *
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class ClientPool {

    private static final Logger logger = Logger.getLogger(ClientPool.class.getName());

    protected List clients = new ArrayList(3);

    protected ObjectPool pool;

    protected PoolConfig poolConfig;

    //v1.4.6
    private int countNioWriteThreads;

    private int maxThreadsForNioWrite = 10;

    public ClientPool(QSObjectPool objectPool, PoolConfig poolConfig) {
    }

    public ObjectPool getObjectPool();

    public void addClient(Runnable r) throws NoSuchElementException;

    public synchronized void addClient(Runnable r, boolean keepObjOnFail) throws NoSuchElementException;

    public synchronized void returnObject(Object object);

    public synchronized Runnable getClient();

    /**
     * @since 1.4.5
     */
    public boolean isClientAvailable();

    protected void finalize() throws Throwable;

    public void close() throws Exception;

    public void clear() throws Exception;

    /**
     * Return the number of instances currently borrowed from my pool.
     * @since 1.4.1
     */
    public int getNumActive();

    /**
     * Return the number of instances currently idle in my pool.
     * @since 1.4.1
     */
    public int getNumIdle();

    /**
     * Returns iterator containing all the active
     * threads i.e ClientHandler handling connected clients.
     * @since 1.3.1
     */
    public final Iterator getAllClientThread();

    public Object getObjectToSynchronize();

    /**
     * Returns PoolConfig object that configured this pool
     * @since 1.4.5
     */
    public PoolConfig getPoolConfig();

    /**
     * Sets the maximum threads allowed for nio write. If set to 0 or less no limit is
     * imposed.
     * @since 1.4.6
     */
    public void setMaxThreadsForNioWrite(int count);

    /**
     * Returns the maximum threads allowed for nio write
     * @since 1.4.6
     */
    public int getMaxThreadsForNioWrite();

    /**
     * Notifies when NIO write is complete.
     * @since 1.4.6
     */
    protected void nioWriteEnd();

    /**
     * Notifies when NIO write is about to start.
     * @since 1.4.6
     */
    protected void nioWriteStart();

    /**
     * Method to suggest if nio write should be sent for processing.
     * @since 1.4.6
     */
    public boolean shouldNioWriteHappen();
}
","// ClientPoolTest.java
package org.quickserver.util.pool.thread;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientPool}.
* It contains ten unit test cases for the {@link ClientPool#shouldNioWriteHappen()} method.
*/
class ClientPoolTest {","// Here is an example implementation of the ClientPoolTest class

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class ClientPoolTest {

    @Test
    void testShouldNioWriteHappen() {
        ClientPool clientPool = new ClientPool(null, null);
        clientPool.setMaxThreadsForNioWrite(0);
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.setMaxThreadsForNioWrite(5);
        assertTrue(clientPool.shouldNioWriteHappen());

        for (int i = 0; i < 5; i++) {
            clientPool.nioWriteStart();
        }
        assertFalse(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteEnd();
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.setMaxThreadsForNioWrite(-1);
        assertTrue(clientPool.shouldNioWriteHappen());
    }

    @Test
    void testShouldNioWriteHappenWithNoThreads() {
        ClientPool clientPool = new ClientPool(null, null);
        clientPool.setMaxThreadsForNioWrite(0);
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.setMaxThreadsForNioWrite(-1);
        assertTrue(clientPool.shouldNioWriteHappen());
    }

    @Test
    void testShouldNioWriteHappenWithMaxThreads() {
        ClientPool clientPool = new ClientPool(null, null);
        clientPool.setMaxThreadsForNioWrite(1);
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteStart();
        assertFalse(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteEnd();
        assertTrue(clientPool.shouldNioWriteHappen());
    }

    @Test
    void testShouldNioWriteHappenWithMultipleThreads() {
        ClientPool clientPool = new ClientPool(null, null);
        clientPool.setMaxThreadsForNioWrite(2);
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteStart();
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteStart();
        assertFalse(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteEnd();
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteEnd();
        assertTrue(clientPool.shouldNioWriteHappen());
    }

    @Test
    void testShouldNioWriteHappenWithMoreThreadsThanMax() {
        ClientPool clientPool = new ClientPool(null, null);
        clientPool.setMaxThreadsForNioWrite(2);
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteStart();
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteStart();
        assertFalse(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteStart();
        assertFalse(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteEnd();
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteEnd();
        assertTrue(clientPool.shouldNioWriteHappen());

        clientPool.nioWriteEnd();
        assertTrue(clientPool.shouldNioWriteHappen());
    }
}"
