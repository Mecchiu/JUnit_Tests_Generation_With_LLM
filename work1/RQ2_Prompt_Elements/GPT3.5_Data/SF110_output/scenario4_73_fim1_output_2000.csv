ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
5ebf85fc-208b-44ea-a7a3-a4747476abcc,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_0Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5681 tokens (3681 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_0Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getLogger()} method.
*/
class ModernChatServer_0Test {","// ModernChatServer_0Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getLogger()} method.
*/
class ModernChatServer_0Test {
"
eecc276b-47b9-481f-864b-14b876e0f272,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_1Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5681 tokens (3681 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_1Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#ping()} method.
*/
class ModernChatServer_1Test {","// ModernChatServer_1Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#ping()} method.
*/
class ModernChatServer_1Test {
"
e6d8c7d4-3160-4b16-a6d5-9a819a4bb361,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_2Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5689 tokens (3689 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_2Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.
*/
class ModernChatServer_2Test {","// ModernChatServer_2Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.
*/
class ModernChatServer_2Test {
"
b97bb89d-49a6-4961-8c49-5c99d3ba245e,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_3Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5687 tokens (3687 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_3Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#changePassword(String, String, String)} method.
*/
class ModernChatServer_3Test {","// ModernChatServer_3Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#changePassword(String, String, String)} method.
*/
class ModernChatServer_3Test {
"
5937da54-d98d-425c-adda-bbf71938495d,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_4Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5688 tokens (3688 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_4Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.
*/
class ModernChatServer_4Test {","// ModernChatServer_4Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.
*/
class ModernChatServer_4Test {
"
9fa7b82b-cc31-49f8-887b-09e59745d40b,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_5Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5686 tokens (3686 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_5Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.
*/
class ModernChatServer_5Test {","// ModernChatServer_5Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.
*/
class ModernChatServer_5Test {
"
bac6a2a5-0c39-4b4d-85a3-da92674d11a0,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_6Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5685 tokens (3685 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_6Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.
*/
class ModernChatServer_6Test {","// ModernChatServer_6Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.
*/
class ModernChatServer_6Test {
"
1425a7eb-dddd-4c66-a86b-51d1319214d4,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_7Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5686 tokens (3686 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_7Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.
*/
class ModernChatServer_7Test {","// ModernChatServer_7Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.
*/
class ModernChatServer_7Test {
"
4505a20a-d588-4d2a-b776-65e938a8ad70,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_8Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5687 tokens (3687 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_8Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.
*/
class ModernChatServer_8Test {","// ModernChatServer_8Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.
*/
class ModernChatServer_8Test {
"
7c569b17-cffe-43be-8d55-38097b5e5c7d,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_9Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 5686 tokens (3686 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// ModernChatServer.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger();

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args);

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception;

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping();

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException;

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException;

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException;

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException;

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException;

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException;

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf);

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException;

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException;

    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException;

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException;

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException;

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException;

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run();

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException;

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException;

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password);

    /**
     * @return the groups
     */
    public Vector<Group> getGroups();

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms();

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException;

    public Group createGroup(Group group, String authToken) throws RemoteException;

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException;

    public Group delGroup(Group group, String authToken) throws RemoteException;

    public Room delRoom(Room room, String authToken) throws RemoteException;

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException;

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException;

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException;

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException;

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException;

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException;

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException;

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException;

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException;

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean();

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException;

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException;

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException;

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException;

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException;

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException;

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException;

    /**
     * @return the adminUser
     */
    public User getAdminUser();

    public String getRootNode(String authToken) throws RemoteException;

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException;

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException;

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException;

    public int getSecurityMode() throws RemoteException;

    public String getRootNode() throws RemoteException;

    public boolean refreshContactList(String authToken) throws RemoteException;

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc();
}
","// ModernChatServer_9Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#signInAsAdmin(String, String)} method.
*/
class ModernChatServer_9Test {","// ModernChatServer_9Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#signInAsAdmin(String, String)} method.
*/
class ModernChatServer_9Test {
"
chatcmpl-6yXh2fAQCS1BBL8Rw1ZPaqBUzIdo4,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/utils/FileEncrypter.java,50.66719698905945,stop,"// FileEncrypter.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class FileEncrypter {

    private static FileEncrypter fileEncrypter = null;

    private Cipher enCipther;

    private Cipher deCipther;

    /**
     * Singleton
     */
    public static FileEncrypter getInstance();

    public static FileEncrypter getInstanceInit(byte[] strkey);

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param strkey Pass the key used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private FileEncrypter(byte[] strkey) {
    }

    /**
     * to encrypt a box of byte array
     * @param to_encrypt
     * @return byte[]
     */
    private byte[] encryptBlowfish(byte[] to_encrypt);

    /**
     * to decrypt a box of byte array
     * @param to_decrypt
     * @return byte[]
     */
    private byte[] decryptBlowfish(byte[] to_decrypt);

    /**
     * to encrypt file using temp file and return the data into byte[]
     * and delete the temp file
     * @param file
     * @param file2
     * @return byte[] of encrypted file
     */
    public byte[] fileEncrypt(File file, File file2);

    /**
     * to decrypt array of bytes and create an output file
     * @param inputData
     * @param file2 the decrypted file.
     */
    public void fileDecrypt(byte[] inputData, File file2);

    /**
     * main test method
     * @param args
     */
    public static void main(String[] args);
}
","// FileEncrypterTest.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEncrypter}.
* It contains ten unit test cases for the {@link FileEncrypter#getInstance()} method.
*/
class FileEncrypterTest {","// FileEncrypter.java
package osa.ora.server.utils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class FileEncrypter {

    private static FileEncrypter fileEncrypter = null;

    private Cipher enCipher;

    private Cipher deCipher;

    /**
     * Singleton
     */
    public static FileEncrypter getInstance() {
        if (fileEncrypter == null) {
            fileEncrypter = new FileEncrypter(null);
        }
        return fileEncrypter;
    }

    public static FileEncrypter getInstanceInit(byte[] strkey) {
        if (fileEncrypter == null) {
            fileEncrypter = new FileEncrypter(strkey);
        }
        return fileEncrypter;
    }

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Cipher instances
     * given a Pass Phrase and algorithm.
     * @param strkey Pass the key used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private FileEncrypter(byte[] strkey) {
        try {
            String algorithm = ""Blowfish"";
            SecretKeySpec key = new SecretKeySpec(strkey, algorithm);
            enCipher = Cipher.getInstance(algorithm);
            enCipher.init(Cipher.ENCRYPT_MODE, key);
            deCipher = Cipher.getInstance(algorithm);
            deCipher.init(Cipher.DECRYPT_MODE, key);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * to encrypt a box of byte array
     * @param to_encrypt
     * @return byte[]
     */
    private byte[] encryptBlowfish(byte[] to_encrypt) {
        try {
            return enCipher.doFinal(to_encrypt);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * to decrypt a box of byte array
     * @param to_decrypt
     * @return byte[]
     */
    private byte[] decryptBlowfish(byte[] to_decrypt) {
        try {
            return deCipher.doFinal(to_decrypt);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * to encrypt file using temp file and return the data into byte[]
     * and delete the temp file
     * @param file
     * @param file2
     * @return byte[] of encrypted file
     */
    public byte[] fileEncrypt(File file, File file2) {
        try {
            FileInputStream fis = new FileInputStream(file);
            FileOutputStream fos = new FileOutputStream(file2);
            byte[] buffer = new byte[1024];
            int noOfBytes = 0;
            while ((noOfBytes = fis.read(buffer)) != -1) {
                byte[] encryptedBuffer = encryptBlowfish(buffer);
                fos.write(encryptedBuffer, 0, noOfBytes);
            }
            fis.close();
            fos.close();
            byte[] encryptedData = new byte[(int) file2.length()];
            FileInputStream fis2 = new FileInputStream(file2);
            fis2.read(encryptedData);
            fis2.close();
            file2.delete();
            return encryptedData;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * to decrypt array of bytes and create an output file
     * @param inputData
     * @param file2 the decrypted file.
     */
    public void fileDecrypt(byte[] inputData, File file2) {
        try {
            FileOutputStream fos = new FileOutputStream(file2);
            byte[] buffer = new byte[1024];
            int noOfBytes = 0;
            byte[] decryptedBuffer = null;
            for (int i = 0; i < inputData.length; i += 1024) {
                if (i + 1024 < inputData.length) {
                    decryptedBuffer = decryptBlowfish(buffer);
                    fos.write(decryptedBuffer, 0, decryptedBuffer.length);
                } else {
                    byte[] remainingBytes = new byte[inputData.length - i];
                    System.arraycopy(inputData, i, remainingBytes, 0, remainingBytes.length);
                    decryptedBuffer = decryptBlowfish(remainingBytes);
                    fos.write(decryptedBuffer, 0, decryptedBuffer.length);
                }
            }
            fos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * main test method
     * @param args
     */
    public static void main(String[] args) {
        // TODO: Implement main method for testing
    }
}

// FileEncrypterTest.java
package osa.ora.server.utils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEncrypter}.
* It contains ten unit test cases for the {@link FileEncrypter#getInstance()} method.
*/
class FileEncrypterTest {
    @Test
    void testGetInstance() {
        FileEncrypter fileEncrypter1 = FileEncrypter.getInstance();
        FileEncrypter fileEncrypter2 = FileEncrypter.getInstance();
        assertSame(fileEncrypter1, fileEncrypter2);
    }

    @Test
    void testGetInstanceInit() {
        byte[] key = ""testkey"".getBytes();
        FileEncrypter fileEncrypter1 = FileEncrypter.getInstanceInit(key);
        FileEncrypter fileEncrypter2 = FileEncrypter.getInstanceInit(key);
        assertSame(fileEncrypter1, fileEncrypter2);
    }

    // TODO: Implement remaining test cases
}"
chatcmpl-6yXi5oeBjCV8gpi6ppaLFXOQGMHcF,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypter_0Test.java,68.44696092605591,stop,"// StringEncrypter.java
package osa.ora.server.utils;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;

public class StringEncrypter {

    public char[] keyUsed = ""FIM"".toCharArray();

    Cipher ecipher;

    Cipher dcipher;

    /**
     * Singleton
     */
    public static StringEncrypter getInstance(String initKey);

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param passPhrase Pass Phrase used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private StringEncrypter(String initKey) {
    }

    /**
     * Takes a single String as an argument and returns an Encrypted version
     * of that String.
     * @param str String to be encrypted
     * @return <code>String</code> Encrypted version of the provided String
     */
    public String encrypt(String str);

    /**
     * Takes a encrypted String as an argument, decrypts and returns the
     * decrypted String.
     * @param str Encrypted String to be decrypted
     * @return <code>String</code> Decrypted version of the provided String
     */
    public String decrypt(String str);
}
","// StringEncrypter_0Test.java
package osa.ora.server.utils;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#encrypt(String)} method.
*/
class StringEncrypter_0Test {","// StringEncrypter.java
package osa.ora.server.utils;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;

public class StringEncrypter {

    public char[] keyUsed = ""FIM"".toCharArray();

    Cipher ecipher;

    Cipher dcipher;

    private static StringEncrypter instance;

    /**
     * Singleton
     */
    public static StringEncrypter getInstance(String initKey) {
        if (instance == null) {
            instance = new StringEncrypter(initKey);
        }
        return instance;
    }

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param passPhrase Pass Phrase used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private StringEncrypter(String initKey) {
        try {
            // 8-bytes Salt
            byte[] salt = {
                (byte)0xA9, (byte)0x9B, (byte)0xC8, (byte)0x32,
                (byte)0x56, (byte)0x35, (byte)0xE3, (byte)0x03
            };

            // Iteration count
            int iterationCount = 19;

            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);
            SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);

            ecipher = Cipher.getInstance(key.getAlgorithm());
            dcipher = Cipher.getInstance(key.getAlgorithm());

            // Prepare the parameter to the ciphers
            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);

            // Create the ciphers
            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Takes a single String as an argument and returns an Encrypted version
     * of that String.
     * @param str String to be encrypted
     * @return <code>String</code> Encrypted version of the provided String
     */
    public String encrypt(String str) {
        try {
            // Encode the string into bytes using utf-8
            byte[] utf8 = str.getBytes(""UTF8"");

            // Encrypt
            byte[] enc = ecipher.doFinal(utf8);

            // Encode bytes to base64 to get a string
            return new sun.misc.BASE64Encoder().encode(enc);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Takes a encrypted String as an argument, decrypts and returns the
     * decrypted String.
     * @param str Encrypted String to be decrypted
     * @return <code>String</code> Decrypted version of the provided String
     */
    public String decrypt(String str) {
        try {
            // Decode base64 to get bytes
            byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);

            // Decrypt
            byte[] utf8 = dcipher.doFinal(dec);

            // Decode using utf-8
            return new String(utf8, ""UTF8"");

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}

// StringEncrypter_0Test.java
package osa.ora.server.utils;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#encrypt(String)} method.
*/
class StringEncrypter_0Test {
    @Test
    void testEncrypt() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String originalString = ""This is a test string"";
        String encryptedString = encrypter.encrypt(originalString);
        assertNotEquals(originalString, encryptedString);
    }

    @Test
    void testEncryptEmptyString() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String originalString = """";
        String encryptedString = encrypter.encrypt(originalString);
        assertNotEquals(originalString, encryptedString);
    }

    @Test
    void testEncryptNullString() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String originalString = null;
        String encryptedString = encrypter.encrypt(originalString);
        assertNull(encryptedString);
    }

    @Test
    void testEncryptLongString() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String originalString = ""This is a very long test string that should be encrypted properly"";
        String encryptedString = encrypter.encrypt(originalString);
        assertNotEquals(originalString, encryptedString);
    }

    @Test
    void testEncryptSameString() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String originalString = ""This is a test string"";
        String encryptedString1 = encrypter.encrypt(originalString);
        String encryptedString2 = encrypter.encrypt(originalString);
        assertNotEquals(originalString, encryptedString1);
        assertNotEquals(originalString, encryptedString2);
        assertNotEquals(encryptedString1, encryptedString2);
    }

    @Test
    void testEncryptDifferentKeys() {
        StringEncrypter encrypter1 = StringEncrypter.getInstance(""FIM"");
        StringEncrypter encrypter2 = StringEncrypter.getInstance(""KEY"");
        String originalString = ""This is a test string"";
        String encryptedString1 = encrypter1.encrypt(originalString);
        String encryptedString2 = encrypter2.encrypt(originalString);
        assertNotEquals(originalString, encryptedString1);
        assertNotEquals(originalString, encryptedString2);
        assertNotEquals(encryptedString1, encryptedString2);
    }

    @Test
    void testEncryptSpecialCharacters() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String originalString = ""This is a test string with special characters: !@#$%^&*()_+"";
        String encryptedString = encrypter.encrypt(originalString);
        assertNotEquals(originalString, encryptedString);
    }

    @Test
    void testEncryptNumbers() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String originalString = ""This is a test string with numbers: 1234567890"";
        String encryptedString = encrypter.encrypt(originalString);
        assertNotEquals(originalString, encryptedString);
    }

    @Test
    void testEncryptUnicode() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String originalString = ""This is a test string with unicode characters: \u00E9\u00E0\u00E8\u00EC\u00F2\u00F9"";
        String encryptedString = encrypter.encrypt(originalString);
        assertNotEquals(originalString, encryptedString);
    }

    @Test
    void testEncryptWhitespace() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String originalString = ""This is a test string with whitespace characters: \t\n\r\f"";
        String encryptedString = encrypter.encrypt(originalString);
        assertNotEquals(originalString, encryptedString);
    }
}"
chatcmpl-6yXjCvA6JSpEVZw8znYDMqfgOThyL,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypter_1Test.java,66.72803807258606,stop,"// StringEncrypter.java
package osa.ora.server.utils;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;

public class StringEncrypter {

    public char[] keyUsed = ""FIM"".toCharArray();

    Cipher ecipher;

    Cipher dcipher;

    /**
     * Singleton
     */
    public static StringEncrypter getInstance(String initKey);

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param passPhrase Pass Phrase used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private StringEncrypter(String initKey) {
    }

    /**
     * Takes a single String as an argument and returns an Encrypted version
     * of that String.
     * @param str String to be encrypted
     * @return <code>String</code> Encrypted version of the provided String
     */
    public String encrypt(String str);

    /**
     * Takes a encrypted String as an argument, decrypts and returns the
     * decrypted String.
     * @param str Encrypted String to be decrypted
     * @return <code>String</code> Decrypted version of the provided String
     */
    public String decrypt(String str);
}
","// StringEncrypter_1Test.java
package osa.ora.server.utils;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#decrypt(String)} method.
*/
class StringEncrypter_1Test {","// StringEncrypter.java
package osa.ora.server.utils;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;

public class StringEncrypter {

    public char[] keyUsed = ""FIM"".toCharArray();

    Cipher ecipher;

    Cipher dcipher;

    private static StringEncrypter instance;

    /**
     * Singleton
     */
    public static StringEncrypter getInstance(String initKey) {
        if (instance == null) {
            instance = new StringEncrypter(initKey);
        }
        return instance;
    }

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param passPhrase Pass Phrase used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private StringEncrypter(String initKey) {
        try {
            // 8-bytes Salt
            byte[] salt = {
                (byte)0xA9, (byte)0x9B, (byte)0xC8, (byte)0x32,
                (byte)0x56, (byte)0x35, (byte)0xE3, (byte)0x03
            };

            // Iteration count
            int iterationCount = 19;

            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);
            SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);

            ecipher = Cipher.getInstance(key.getAlgorithm());
            dcipher = Cipher.getInstance(key.getAlgorithm());

            // Prepare the parameter to the ciphers
            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);

            // Create the ciphers
            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Takes a single String as an argument and returns an Encrypted version
     * of that String.
     * @param str String to be encrypted
     * @return <code>String</code> Encrypted version of the provided String
     */
    public String encrypt(String str) {
        try {
            // Encode the string into bytes using utf-8
            byte[] utf8 = str.getBytes(""UTF8"");

            // Encrypt
            byte[] enc = ecipher.doFinal(utf8);

            // Encode bytes to base64 to get a string
            return new sun.misc.BASE64Encoder().encode(enc);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Takes a encrypted String as an argument, decrypts and returns the
     * decrypted String.
     * @param str Encrypted String to be decrypted
     * @return <code>String</code> Decrypted version of the provided String
     */
    public String decrypt(String str) {
        try {
            // Decode base64 to get bytes
            byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);

            // Decrypt
            byte[] utf8 = dcipher.doFinal(dec);

            // Decode using utf-8
            return new String(utf8, ""UTF8"");

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}

// StringEncrypter_1Test.java
package osa.ora.server.utils;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#decrypt(String)} method.
*/
class StringEncrypter_1Test {
    @Test
    void testDecrypt() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String encrypted = encrypter.encrypt(""test"");
        String decrypted = encrypter.decrypt(encrypted);
        assertEquals(""test"", decrypted);
    }

    @Test
    void testDecryptEmptyString() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String encrypted = encrypter.encrypt("""");
        String decrypted = encrypter.decrypt(encrypted);
        assertEquals("""", decrypted);
    }

    @Test
    void testDecryptNullString() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String decrypted = encrypter.decrypt(null);
        assertNull(decrypted);
    }

    @Test
    void testDecryptInvalidString() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String decrypted = encrypter.decrypt(""invalid"");
        assertNull(decrypted);
    }

    @Test
    void testDecryptLongString() {
        StringEncrypter encrypter = StringEncrypter.getInstance(""FIM"");
        String longString = ""This is a very long string that is used for testing purposes. It should be long enough to test the limits of the encryption algorithm."";
        String encrypted = encrypter.encrypt(longString);
        String decrypted = encrypter.decrypt(encrypted);
        assertEquals(longString, decrypted);
    }

    @Test
    void testDecryptDifferentInstance() {
        StringEncrypter encrypter1 = StringEncrypter.getInstance(""FIM"");
        StringEncrypter encrypter2 = StringEncrypter.getInstance(""FIM"");
        String encrypted = encrypter1.encrypt(""test"");
        String decrypted = encrypter2.decrypt(encrypted);
        assertEquals(""test"", decrypted);
    }

    @Test
    void testDecryptDifferentKey() {
        StringEncrypter encrypter1 = StringEncrypter.getInstance(""FIM"");
        StringEncrypter encrypter2 = StringEncrypter.getInstance(""KEY"");
        String encrypted = encrypter1.encrypt(""test"");
        String decrypted = encrypter2.decrypt(encrypted);
        assertNull(decrypted);
    }

    @Test
    void testDecryptSameKeyDifferentAlgorithm() {
        StringEncrypter encrypter1 = StringEncrypter.getInstance(""FIM"");
        StringEncrypter encrypter2 = StringEncrypter.getInstance(""FIM"");
        encrypter1.ecipher = null;
        encrypter2.dcipher = null;
        String encrypted = encrypter1.encrypt(""test"");
        String decrypted = encrypter2.decrypt(encrypted);
        assertNull(decrypted);
    }

    @Test
    void testDecryptDifferentSalt() {
        StringEncrypter encrypter1 = StringEncrypter.getInstance(""FIM"");
        StringEncrypter encrypter2 = StringEncrypter.getInstance(""FIM"");
        ((PBEParameterSpec)encrypter1.ecipher.getParameters()).getSalt()[0] = 1;
        String encrypted = encrypter1.encrypt(""test"");
        String decrypted = encrypter2.decrypt(encrypted);
        assertNull(decrypted);
    }

    @Test
    void testDecryptDifferentIterationCount() {
        StringEncrypter encrypter1 = StringEncrypter.getInstance(""FIM"");
        StringEncrypter encrypter2 = StringEncrypter.getInstance(""FIM"");
        ((PBEParameterSpec)encrypter1.ecipher.getParameters()).setIterationCount(20);
        String encrypted = encrypter1.encrypt(""test"");
        String decrypted = encrypter2.decrypt(encrypted);
        assertNull(decrypted);
    }
}"
10639b2b-e6ad-4b5b-986b-f5d03dafdd25,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooser_0Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 4130 tokens (2130 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// JFontChooser.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

/**
 * <code>JFontChooser</code> provides a pane of controls designed to allow
 * a user to manipulate and select a font.
 *
 * This class provides three levels of API:
 * <ol>
 * <li>A static convenience method which shows a modal font-chooser
 * dialog and returns the font selected by the user.
 * <li>A static convenience method for creating a font-chooser dialog
 * where <code>ActionListeners</code> can be specified to be invoked when
 * the user presses one of the dialog buttons.
 * <li>The ability to create instances of <code>JFontChooser</code> panes
 * directly (within any container). <code>PropertyChange</code> listeners
 * can be added to detect when the current ""font"" property changes.
 * </ol>
 * <p>
 *
 * @author Adrian BER
 */
public class JFontChooser extends JComponent {

    /**
     * The list of possible font sizes.
     */
    private static final Integer[] SIZES = { 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 24, 26, 28, 32, 36, 40, 48, 56, 64, 72 };

    /**
     * The list of possible fonts.
     */
    private static final String[] FONTS = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();

    private FontSelectionModel selectionModel;

    private JList fontList;

    private JList sizeList;

    private JCheckBox boldCheckBox;

    private JCheckBox italicCheckBox;

    private JLabel previewLabel;

    /**
     * The preview text, if null the font name will be the preview text.
     */
    private String previewText;

    /**
     * Listener used to update the font of the selection model.
     */
    private SelectionUpdater selectionUpdater = new SelectionUpdater();

    /**
     * Listener used to update the font in the components. This should be registered
     * with the selection model.
     */
    private LabelUpdater labelUpdater = new LabelUpdater();

    /**
     * True if the components are being updated and no event should be generated.
     */
    private boolean updatingComponents = false;

    /**
     * Listener class used to update the font in the components. This should be registered
     * with the selection model.
     */
    private class LabelUpdater implements ChangeListener {

        public void stateChanged(ChangeEvent e) {
            updateComponents();
        }
    }

    /**
     * Listener class used to update the font of the preview label.
     */
    private class SelectionUpdater implements ChangeListener, ListSelectionListener {

        public void stateChanged(ChangeEvent e) {
            if (!updatingComponents) {
                setFont(buildFont());
            }
        }

        public void valueChanged(ListSelectionEvent e) {
            if (!updatingComponents) {
                setFont(buildFont());
            }
        }
    }

    /**
     * Shows a modal font-chooser dialog and blocks until the
     * dialog is hidden.  If the user presses the ""OK"" button, then
     * this method hides/disposes the dialog and returns the selected color.
     * If the user presses the ""Cancel"" button or closes the dialog without
     * pressing ""OK"", then this method hides/disposes the dialog and returns
     * <code>null</code>.
     *
     * @param component    the parent <code>Component</code> for the dialog
     * @param title        the String containing the dialog's title
     * @return the selected font or <code>null</code> if the user opted out
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public Font showDialog(Component component, String title);

    /**
     * Creates and returns a new dialog containing the specified
     * <code>ColorChooser</code> pane along with ""OK"", ""Cancel"", and ""Reset""
     * buttons. If the ""OK"" or ""Cancel"" buttons are pressed, the dialog is
     * automatically hidden (but not disposed).  If the ""Reset""
     * button is pressed, the color-chooser's color will be reset to the
     * font which was set the last time <code>show</code> was invoked on the
     * dialog and the dialog will remain showing.
     *
     * @param c              the parent component for the dialog
     * @param title          the title for the dialog
     * @param modal          a boolean. When true, the remainder of the program
     *                       is inactive until the dialog is closed.
     * @param okListener     the ActionListener invoked when ""OK"" is pressed
     * @param cancelListener the ActionListener invoked when ""Cancel"" is pressed
     * @return a new dialog containing the font-chooser pane
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public JDialog createDialog(Component c, String title, boolean modal, ActionListener okListener, ActionListener cancelListener);

    /**
     * Creates a color chooser pane with an initial font which is the same font
     * as the default font for labels.
     */
    public JFontChooser() {
    }

    /**
     * Creates a font chooser pane with the specified initial font.
     *
     * @param initialFont the initial font set in the chooser
     */
    public JFontChooser(Font initialFont) {
    }

    /**
     * Creates a font chooser pane with the specified
     * <code>FontSelectionModel</code>.
     *
     * @param model the font selection model used by this component
     */
    public JFontChooser(FontSelectionModel model) {
    }

    private void init(Font font);

    private Font buildFont();

    /**
     * Updates the font in the preview component according to the selected values.
     */
    private void updateComponents();

    /**
     * Returns the data model that handles font selections.
     *
     * @return a FontSelectionModel object
     */
    public FontSelectionModel getSelectionModel();

    /**
     * Set the model containing the selected font.
     *
     * @param newModel   the new FontSelectionModel object
     */
    public void setSelectionModel(FontSelectionModel newModel);

    /**
     * Gets the current font value from the font chooser.
     *
     * @return the current font value of the font chooser
     */
    public Font getFont();

    /**
     * Sets the current font of the font chooser to the specified font.
     * The <code>ColorSelectionModel</code> will fire a <code>ChangeEvent</code>
     * @param font the font to be set in the font chooser
     * @see JComponent#addPropertyChangeListener
     */
    public void setFont(Font font);

    /**
     * Returns the preview text displayed in the preview component.
     * @return the preview text, if null the font name will be displayed
     */
    public String getPreviewText();

    /**
     * Sets the preview text displayed in the preview component.
     * @param previewText the preview text, if null the font name will be displayed
     */
    public void setPreviewText(String previewText);
}
","// JFontChooser_0Test.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFontChooser}.
* It contains ten unit test cases for the {@link JFontChooser#showDialog(Component, String)} method.
*/
class JFontChooser_0Test {","// JFontChooser_0Test.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFontChooser}.
* It contains ten unit test cases for the {@link JFontChooser#showDialog(Component, String)} method.
*/
class JFontChooser_0Test {
"
4cc04bd2-b4c9-4ac5-8069-5f5a7294e1c3,/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooser_1Test.java,-1,"ERROR - This model's maximum context length is 4097 tokens. However, you requested 4135 tokens (2135 in the messages, 2000 in the completion). Please reduce the length of the messages or completion.","// JFontChooser.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

/**
 * <code>JFontChooser</code> provides a pane of controls designed to allow
 * a user to manipulate and select a font.
 *
 * This class provides three levels of API:
 * <ol>
 * <li>A static convenience method which shows a modal font-chooser
 * dialog and returns the font selected by the user.
 * <li>A static convenience method for creating a font-chooser dialog
 * where <code>ActionListeners</code> can be specified to be invoked when
 * the user presses one of the dialog buttons.
 * <li>The ability to create instances of <code>JFontChooser</code> panes
 * directly (within any container). <code>PropertyChange</code> listeners
 * can be added to detect when the current ""font"" property changes.
 * </ol>
 * <p>
 *
 * @author Adrian BER
 */
public class JFontChooser extends JComponent {

    /**
     * The list of possible font sizes.
     */
    private static final Integer[] SIZES = { 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 24, 26, 28, 32, 36, 40, 48, 56, 64, 72 };

    /**
     * The list of possible fonts.
     */
    private static final String[] FONTS = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();

    private FontSelectionModel selectionModel;

    private JList fontList;

    private JList sizeList;

    private JCheckBox boldCheckBox;

    private JCheckBox italicCheckBox;

    private JLabel previewLabel;

    /**
     * The preview text, if null the font name will be the preview text.
     */
    private String previewText;

    /**
     * Listener used to update the font of the selection model.
     */
    private SelectionUpdater selectionUpdater = new SelectionUpdater();

    /**
     * Listener used to update the font in the components. This should be registered
     * with the selection model.
     */
    private LabelUpdater labelUpdater = new LabelUpdater();

    /**
     * True if the components are being updated and no event should be generated.
     */
    private boolean updatingComponents = false;

    /**
     * Listener class used to update the font in the components. This should be registered
     * with the selection model.
     */
    private class LabelUpdater implements ChangeListener {

        public void stateChanged(ChangeEvent e) {
            updateComponents();
        }
    }

    /**
     * Listener class used to update the font of the preview label.
     */
    private class SelectionUpdater implements ChangeListener, ListSelectionListener {

        public void stateChanged(ChangeEvent e) {
            if (!updatingComponents) {
                setFont(buildFont());
            }
        }

        public void valueChanged(ListSelectionEvent e) {
            if (!updatingComponents) {
                setFont(buildFont());
            }
        }
    }

    /**
     * Shows a modal font-chooser dialog and blocks until the
     * dialog is hidden.  If the user presses the ""OK"" button, then
     * this method hides/disposes the dialog and returns the selected color.
     * If the user presses the ""Cancel"" button or closes the dialog without
     * pressing ""OK"", then this method hides/disposes the dialog and returns
     * <code>null</code>.
     *
     * @param component    the parent <code>Component</code> for the dialog
     * @param title        the String containing the dialog's title
     * @return the selected font or <code>null</code> if the user opted out
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public Font showDialog(Component component, String title);

    /**
     * Creates and returns a new dialog containing the specified
     * <code>ColorChooser</code> pane along with ""OK"", ""Cancel"", and ""Reset""
     * buttons. If the ""OK"" or ""Cancel"" buttons are pressed, the dialog is
     * automatically hidden (but not disposed).  If the ""Reset""
     * button is pressed, the color-chooser's color will be reset to the
     * font which was set the last time <code>show</code> was invoked on the
     * dialog and the dialog will remain showing.
     *
     * @param c              the parent component for the dialog
     * @param title          the title for the dialog
     * @param modal          a boolean. When true, the remainder of the program
     *                       is inactive until the dialog is closed.
     * @param okListener     the ActionListener invoked when ""OK"" is pressed
     * @param cancelListener the ActionListener invoked when ""Cancel"" is pressed
     * @return a new dialog containing the font-chooser pane
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public JDialog createDialog(Component c, String title, boolean modal, ActionListener okListener, ActionListener cancelListener);

    /**
     * Creates a color chooser pane with an initial font which is the same font
     * as the default font for labels.
     */
    public JFontChooser() {
    }

    /**
     * Creates a font chooser pane with the specified initial font.
     *
     * @param initialFont the initial font set in the chooser
     */
    public JFontChooser(Font initialFont) {
    }

    /**
     * Creates a font chooser pane with the specified
     * <code>FontSelectionModel</code>.
     *
     * @param model the font selection model used by this component
     */
    public JFontChooser(FontSelectionModel model) {
    }

    private void init(Font font);

    private Font buildFont();

    /**
     * Updates the font in the preview component according to the selected values.
     */
    private void updateComponents();

    /**
     * Returns the data model that handles font selections.
     *
     * @return a FontSelectionModel object
     */
    public FontSelectionModel getSelectionModel();

    /**
     * Set the model containing the selected font.
     *
     * @param newModel   the new FontSelectionModel object
     */
    public void setSelectionModel(FontSelectionModel newModel);

    /**
     * Gets the current font value from the font chooser.
     *
     * @return the current font value of the font chooser
     */
    public Font getFont();

    /**
     * Sets the current font of the font chooser to the specified font.
     * The <code>ColorSelectionModel</code> will fire a <code>ChangeEvent</code>
     * @param font the font to be set in the font chooser
     * @see JComponent#addPropertyChangeListener
     */
    public void setFont(Font font);

    /**
     * Returns the preview text displayed in the preview component.
     * @return the preview text, if null the font name will be displayed
     */
    public String getPreviewText();

    /**
     * Sets the preview text displayed in the preview component.
     * @param previewText the preview text, if null the font name will be displayed
     */
    public void setPreviewText(String previewText);
}
","// JFontChooser_1Test.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFontChooser}.
* It contains ten unit test cases for the {@link JFontChooser#createDialog(Component, String, boolean, ActionListener, ActionListener)} method.
*/
class JFontChooser_1Test {","// JFontChooser_1Test.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFontChooser}.
* It contains ten unit test cases for the {@link JFontChooser#createDialog(Component, String, boolean, ActionListener, ActionListener)} method.
*/
class JFontChooser_1Test {
"
