ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
chatcmpl-6yTv4LVwyk1ZrcQOaEMYkwDff4MPv,/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_0Test.java,65.95248770713806,length,"// BinaryCalculate.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;

public class BinaryCalculate {

    boolean isIPv4 = false;

    boolean isIPv6 = false;

    String currentIP = """";

    String fullReassembler = """";

    String DELIMITER = """";

    int lengthOfToken = 0;

    String IPRangeAddress = """";

    String usableRange = """";

    int semiCol = 0;

    String prefix = """";

    BigInteger totalIPAddresses;

    int MAXPREFIX = 0;

    /**
     *  Calculates the sum of two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be added to the starting binary
     *  @return      The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2);

    /**
     *  Subtracts two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be subtracted from the
     *                       starting binary
     *  @return      The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored into an <code>string</code> to be
     *  returned to the method that called it.
     *
     *  @param      IP          The starting IP address (subnet) in binary
     *  @param      IPPrefix    Number of IP addresses in binary
     *  @return     Results string
     */
    public String IPCalculate(String IP, String IPPrefix);

    /**
     *  Adds delimiters back into a given IP address
     *
     *  @param      binaryIP     binary IP address with no delimiters
     *  @return     binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP);

    /**
     *  Gets the netmask from a binary representation of number of IP addresses
     *
     *  @param      binaryIP     binary representation of number of IP addresses
     *  @return     netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored as declared global variables for many
     *  other methods to manipulate or use.
     *  <br>This method also detects if the provided of number of IP addresses
     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and
     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds
     *  the IP addressing bounds.
     *  <br>This method also calculates the prefix size needed to accomodate all
     *  the IP Addresses to be listed and stores it as a global variable for use
     *  in other methods.
     *
     *  @param       subnet              The starting IP address (subnet)
     *  @param       noOfIPAddresses     Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses from the smaller prefix. The results are stored into an array
     *  to be printed using <code><b>Output.java</b></code>.
     *
     *  @param       IP          The starting IP address (subnet)
     *  @param       IPPrefix    Number of IP addresses for smaller prefix
     *  @param       noPrefix    Number of smaller prefixes within the total
     *                           prefix
     *  @param       endPrefix   Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);

    /**
     *  Determines whether an IP Address provided in binary form is an IPv4 or
     *  an IPv6 by the length of the binary string.
     *
     *  @param       size1    Length of binary string
     */
    private void checkIPType(int size1);

    /**
     *  Reconstructs the dotted-decimal or hexidecimal IP address with
     *  seperators from an given binary IP Address. The reconstructed IP address
     *  is stored as a global declared variable, <code>currentIP</code>.
     *
     *  @param   IP  An binary IP Address to be converted back into
     *               dotted-decimal or hexidecimal format
     */
    private String convert(String binaryIP);

    /**
     *  Converts an given IPv4 or IPv6 address into binary format.
     *
     *  @param   IP  An IP Address to be converted back into binary format
     *  @return  Binary representation of given IP Address.
     */
    private String convertToBinary(String IP);

    /**
     *  Gets the starting IP of an IP range.
     *
     *  @return     Starting IP of IP range
     */
    private String getStartIP();
}
","// BinaryCalculate_0Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.
*/
class BinaryCalculate_0Test {","// BinaryCalculate.java
package ipac;

import java.math.BigInteger;

public class BinaryCalculate {

    private boolean isIPv4 = false;
    private boolean isIPv6 = false;
    private String currentIP = """";
    private String fullReassembler = """";
    private String DELIMITER = """";
    private int lengthOfToken = 0;
    private String IPRangeAddress = """";
    private String usableRange = """";
    private int semiCol = 0;
    private String prefix = """";
    private BigInteger totalIPAddresses;
    private int MAXPREFIX = 0;

    /**
     * Calculates the sum of two binary numbers.
     *
     * @param num1 The starting binary number
     * @param num2 The binary number to be added to the starting binary
     * @return The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2) {
        BigInteger b1 = new BigInteger(num1, 2);
        BigInteger b2 = new BigInteger(num2, 2);
        BigInteger sum = b1.add(b2);
        return sum.toString(2);
    }

    /**
     * Subtracts two binary numbers.
     *
     * @param num1 The starting binary number
     * @param num2 The binary number to be subtracted from the starting binary
     * @return The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2) {
        BigInteger b1 = new BigInteger(num1, 2);
        BigInteger b2 = new BigInteger(num2, 2);
        BigInteger diff = b1.subtract(b2);
        return diff.toString(2);
    }

    /**
     * Calculates the IP Range from the provided IP address and number of IP addresses.
     * The results are stored into an <code>string</code> to be returned to the method that called it.
     *
     * @param IP The starting IP address (subnet) in binary
     * @param IPPrefix Number of IP addresses in binary
     * @return Results string
     */
    public String IPCalculate(String IP, String IPPrefix) {
        calculate(IP, IPPrefix);
        return getStartIP() + "" - "" + IPRangeAddress;
    }

    /**
     * Adds delimiters back into a given IP address
     *
     * @param binaryIP binary IP address with no delimiters
     * @return binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP) {
        StringBuilder sb = new StringBuilder(binaryIP);
        for (int i = lengthOfToken; i < sb.length(); i += lengthOfToken + 1) {
            sb.insert(i, DELIMITER);
        }
        return sb.toString();
    }

    /**
     * Gets the netmask from a binary representation of number of IP addresses
     *
     * @param binaryIP binary representation of number of IP addresses
     * @return netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP) {
        BigInteger b = new BigInteger(binaryIP, 2);
        int prefixLength = b.bitLength();
        return new BigInteger(""FFFFFFFF"", 16).shiftRight(32 - prefixLength).toString(16);
    }

    /**
     * Calculates the IP Range from the provided IP address and number of IP addresses.
     * The results are stored as declared global variables for many other methods to manipulate or use.
     * <br>This method also detects if the provided of number of IP addresses to be calculate exceeds past these IP addresses:
     * 255.255.255.255 and FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds the IP addressing bounds.
     * <br>This method also calculates the prefix size needed to accommodate all the IP Addresses to be listed and stores it as a global variable for use in other methods.
     *
     * @param subnet The starting IP address (subnet)
     * @param noOfIPAddresses Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses) {
        int size1 = subnet.length();
        checkIPType(size1);
        BigInteger b1 = new BigInteger(subnet, 2);
        BigInteger b2 = new BigInteger(noOfIPAddresses, 2);
        totalIPAddresses = b2.add(BigInteger.ONE);
        BigInteger b3 = b1.add(totalIPAddresses).subtract(BigInteger.ONE);
        String endIP = b3.toString(2);
        if (isIPv4) {
            endIP = String.format(""%32s"", endIP).replace(' ', '0');
            IPRangeAddress = convert(getBinaryIP(subnet)) + "" - "" + convert(getBinaryIP(endIP));
            usableRange = convert(getBinaryIP(subBinary(endIP, ""00000001""))) + "" - "" + convert(getBinaryIP(subBinary(subnet, ""00000001"")));
            semiCol = 3;
            prefix = getNetmask(noOfIPAddresses);
            MAXPREFIX = 32;
        } else if (isIPv6) {
            endIP = String.format(""%128s"", endIP).replace(' ', '0');
            IPRangeAddress = convert(getBinaryIP(subnet)) + "" - "" + convert(getBinaryIP(endIP));
            usableRange = convert(getBinaryIP(subBinary(endIP, ""00000000000000000000000000000001""))) + "" - "" + convert(getBinaryIP(subBinary(subnet, ""00000000000000000000000000000001"")));
            semiCol = 7;
            prefix = getNetmask(noOfIPAddresses);
            MAXPREFIX = 128;
        }
    }

    /**
     * Calculates the IP Range from the provided IP address and number of IP addresses from the smaller prefix.
     * The results are stored into an array to be printed using <code><b>Output.java</b></code>.
     *
     * @param IP The starting IP address (subnet)
     * @param IPPrefix Number of IP addresses for smaller prefix
     * @param noPrefix Number of smaller prefixes within the total prefix
     * @param endPrefix Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix) {
        BigInteger b1 = new BigInteger(IP, 2);
        BigInteger b2 = new BigInteger(IPPrefix, 2);
        BigInteger b3 = b1.add(b2).subtract(BigInteger.ONE);
        String endIP = b3.toString(2);
        if (isIPv4) {
            endIP = String.format(""%32s"", endIP).replace(' ', '0');
            String startIP = convert(getBinaryIP(IP));
            String endIPStr = convert(getBinaryIP(endIP));
            String[] startIPArr = startIP.split(""\\."");
            String[] endIPArr = endIPStr.split(""\\."");
            int[] startIPIntArr = new int[4];
            int[] endIPIntArr = new int[4];
            for (int i = 0; i < 4; i++) {
                startIPIntArr[i] = Integer.parseInt(startIPArr[i]);
                endIPIntArr[i] = Integer.parseInt(endIPArr[i]);
            }
            int[] prefixArr = new int[4];
            int[] prefixSizeArr = new int[4];
            int prefixSize = Integer.parseInt(endPrefix);
            int prefixSizeLeft = prefixSize;
            int i = 0;
            while (prefixSizeLeft > 0) {
                if (prefixSizeLeft >= 8) {
                    prefixArr[i] = 255;
                    prefixSizeArr[i] = 8;
                    prefixSizeLeft -= 8;
                } else {
                    prefixArr[i] = 256 - (int) Math.pow(2, 8 - prefixSizeLeft);
                    prefixSizeArr[i] = prefixSizeLeft;
                    prefixSizeLeft = 0;
                }
                i++;
            }
            String[][] resultArr = new String[noPrefix][2];
            for (int j = 0; j < noPrefix; j++) {
                int[] startIPIntArrCopy = startIPIntArr.clone();
                int[] endIPIntArrCopy = endIPIntArr.clone();
                int[] prefixArrCopy = prefixArr.clone();
                int[] prefixSizeArrCopy = prefixSizeArr.clone();
                int prefixSizeLeftCopy = prefixSize;
                int k = 0;
                while (prefixSizeLeftCopy > 0) {
                    if (prefixSizeLeftCopy >= 8) {
                        prefixArrCopy[k] = startIPIntArrCopy[k];
                        prefixSizeArrCopy[k] = 8;
                        prefixSizeLeftCopy -= 8;
                    } else {
                        int mask = 256 - (int) Math.pow(2, 8 - prefixSizeLeftCopy);
                        prefixArrCopy[k] = startIPIntArrCopy[k] & mask;
                        prefixSizeArrCopy[k] = prefixSizeLeftCopy;
                        prefixSizeLeftCopy = 0;
                    }
                    k++;
                }
                String prefixStr = prefixArrCopy[0] + ""."" + prefixArrCopy[1] + ""."" + prefixArrCopy[2] + ""."" + prefixArrCopy[3];
                String startIPStr = startIPIntArrCopy[0] + ""."" + startIPIntArrCopy[1] + ""."" + startIPIntArrCopy[2] + ""."" + startIPIntArrCopy[3];
                String endIPStr2 = endIPIntArrCopy[0] +"
chatcmpl-6yTw8iW65MHoHa9E7kP0ReBShWApr,/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_1Test.java,17.078696250915527,stop,"// BinaryCalculate.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;

public class BinaryCalculate {

    boolean isIPv4 = false;

    boolean isIPv6 = false;

    String currentIP = """";

    String fullReassembler = """";

    String DELIMITER = """";

    int lengthOfToken = 0;

    String IPRangeAddress = """";

    String usableRange = """";

    int semiCol = 0;

    String prefix = """";

    BigInteger totalIPAddresses;

    int MAXPREFIX = 0;

    /**
     *  Calculates the sum of two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be added to the starting binary
     *  @return      The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2);

    /**
     *  Subtracts two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be subtracted from the
     *                       starting binary
     *  @return      The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored into an <code>string</code> to be
     *  returned to the method that called it.
     *
     *  @param      IP          The starting IP address (subnet) in binary
     *  @param      IPPrefix    Number of IP addresses in binary
     *  @return     Results string
     */
    public String IPCalculate(String IP, String IPPrefix);

    /**
     *  Adds delimiters back into a given IP address
     *
     *  @param      binaryIP     binary IP address with no delimiters
     *  @return     binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP);

    /**
     *  Gets the netmask from a binary representation of number of IP addresses
     *
     *  @param      binaryIP     binary representation of number of IP addresses
     *  @return     netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored as declared global variables for many
     *  other methods to manipulate or use.
     *  <br>This method also detects if the provided of number of IP addresses
     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and
     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds
     *  the IP addressing bounds.
     *  <br>This method also calculates the prefix size needed to accomodate all
     *  the IP Addresses to be listed and stores it as a global variable for use
     *  in other methods.
     *
     *  @param       subnet              The starting IP address (subnet)
     *  @param       noOfIPAddresses     Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses from the smaller prefix. The results are stored into an array
     *  to be printed using <code><b>Output.java</b></code>.
     *
     *  @param       IP          The starting IP address (subnet)
     *  @param       IPPrefix    Number of IP addresses for smaller prefix
     *  @param       noPrefix    Number of smaller prefixes within the total
     *                           prefix
     *  @param       endPrefix   Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);

    /**
     *  Determines whether an IP Address provided in binary form is an IPv4 or
     *  an IPv6 by the length of the binary string.
     *
     *  @param       size1    Length of binary string
     */
    private void checkIPType(int size1);

    /**
     *  Reconstructs the dotted-decimal or hexidecimal IP address with
     *  seperators from an given binary IP Address. The reconstructed IP address
     *  is stored as a global declared variable, <code>currentIP</code>.
     *
     *  @param   IP  An binary IP Address to be converted back into
     *               dotted-decimal or hexidecimal format
     */
    private String convert(String binaryIP);

    /**
     *  Converts an given IPv4 or IPv6 address into binary format.
     *
     *  @param   IP  An IP Address to be converted back into binary format
     *  @return  Binary representation of given IP Address.
     */
    private String convertToBinary(String IP);

    /**
     *  Gets the starting IP of an IP range.
     *
     *  @return     Starting IP of IP range
     */
    private String getStartIP();
}
","// BinaryCalculate_1Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.
*/
class BinaryCalculate_1Test {","// BinaryCalculate_1Test.java
package ipac;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Test class of {@link BinaryCalculate}.
 * It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.
 */
class BinaryCalculate_1Test {

    @Test
    void testSubBinary1() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""1010"", ""0011"");
        assertEquals(""1001"", result);
    }

    @Test
    void testSubBinary2() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""1111"", ""0001"");
        assertEquals(""1110"", result);
    }

    @Test
    void testSubBinary3() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""1100"", ""0101"");
        assertEquals(""0111"", result);
    }

    @Test
    void testSubBinary4() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""1001"", ""0110"");
        assertEquals(""0011"", result);
    }

    @Test
    void testSubBinary5() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""101010"", ""010101"");
        assertEquals(""010101"", result);
    }

    @Test
    void testSubBinary6() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""111111"", ""111111"");
        assertEquals(""000000"", result);
    }

    @Test
    void testSubBinary7() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""100000"", ""000001"");
        assertEquals(""011111"", result);
    }

    @Test
    void testSubBinary8() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""111000"", ""001111"");
        assertEquals(""101001"", result);
    }

    @Test
    void testSubBinary9() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""110011"", ""001100"");
        assertEquals(""100111"", result);
    }

    @Test
    void testSubBinary10() {
        BinaryCalculate bc = new BinaryCalculate();
        String result = bc.subBinary(""1111111111"", ""0000000001"");
        assertEquals(""1111111110"", result);
    }
}"
chatcmpl-6yTxBa7mYBQHdL6H0ehy4njyBEiGY,/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_2Test.java,59.84811544418335,length,"// BinaryCalculate.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;

public class BinaryCalculate {

    boolean isIPv4 = false;

    boolean isIPv6 = false;

    String currentIP = """";

    String fullReassembler = """";

    String DELIMITER = """";

    int lengthOfToken = 0;

    String IPRangeAddress = """";

    String usableRange = """";

    int semiCol = 0;

    String prefix = """";

    BigInteger totalIPAddresses;

    int MAXPREFIX = 0;

    /**
     *  Calculates the sum of two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be added to the starting binary
     *  @return      The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2);

    /**
     *  Subtracts two binary numbers.
     *
     *  @param       num1    The starting binary number
     *  @param       num2    The binary number to be subtracted from the
     *                       starting binary
     *  @return      The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored into an <code>string</code> to be
     *  returned to the method that called it.
     *
     *  @param      IP          The starting IP address (subnet) in binary
     *  @param      IPPrefix    Number of IP addresses in binary
     *  @return     Results string
     */
    public String IPCalculate(String IP, String IPPrefix);

    /**
     *  Adds delimiters back into a given IP address
     *
     *  @param      binaryIP     binary IP address with no delimiters
     *  @return     binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP);

    /**
     *  Gets the netmask from a binary representation of number of IP addresses
     *
     *  @param      binaryIP     binary representation of number of IP addresses
     *  @return     netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses. The results are stored as declared global variables for many
     *  other methods to manipulate or use.
     *  <br>This method also detects if the provided of number of IP addresses
     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and
     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds
     *  the IP addressing bounds.
     *  <br>This method also calculates the prefix size needed to accomodate all
     *  the IP Addresses to be listed and stores it as a global variable for use
     *  in other methods.
     *
     *  @param       subnet              The starting IP address (subnet)
     *  @param       noOfIPAddresses     Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses);

    /**
     *  Calculates the IP Range from the provided IP address and number of IP
     *  addresses from the smaller prefix. The results are stored into an array
     *  to be printed using <code><b>Output.java</b></code>.
     *
     *  @param       IP          The starting IP address (subnet)
     *  @param       IPPrefix    Number of IP addresses for smaller prefix
     *  @param       noPrefix    Number of smaller prefixes within the total
     *                           prefix
     *  @param       endPrefix   Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix);

    /**
     *  Determines whether an IP Address provided in binary form is an IPv4 or
     *  an IPv6 by the length of the binary string.
     *
     *  @param       size1    Length of binary string
     */
    private void checkIPType(int size1);

    /**
     *  Reconstructs the dotted-decimal or hexidecimal IP address with
     *  seperators from an given binary IP Address. The reconstructed IP address
     *  is stored as a global declared variable, <code>currentIP</code>.
     *
     *  @param   IP  An binary IP Address to be converted back into
     *               dotted-decimal or hexidecimal format
     */
    private String convert(String binaryIP);

    /**
     *  Converts an given IPv4 or IPv6 address into binary format.
     *
     *  @param   IP  An IP Address to be converted back into binary format
     *  @return  Binary representation of given IP Address.
     */
    private String convertToBinary(String IP);

    /**
     *  Gets the starting IP of an IP range.
     *
     *  @return     Starting IP of IP range
     */
    private String getStartIP();
}
","// BinaryCalculate_2Test.java
package ipac;

import java.text.*;
import java.util.*;
import java.math.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BinaryCalculate}.
* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.
*/
class BinaryCalculate_2Test {","// Here's an example implementation of the BinaryCalculate class and its test class:

// BinaryCalculate.java
package ipac;

import java.math.BigInteger;

public class BinaryCalculate {

    private static final int MAX_PREFIX = 128;

    private boolean isIPv4 = false;
    private boolean isIPv6 = false;
    private String currentIP = """";
    private String fullReassembler = """";
    private String delimiter = """";
    private int lengthOfToken = 0;
    private String ipRangeAddress = """";
    private String usableRange = """";
    private int semiCol = 0;
    private String prefix = """";
    private BigInteger totalIPAddresses;

    /**
     * Calculates the sum of two binary numbers.
     *
     * @param num1 The starting binary number
     * @param num2 The binary number to be added to the starting binary
     * @return The sum of two binary numbers.
     */
    public String addBinary(String num1, String num2) {
        BigInteger b1 = new BigInteger(num1, 2);
        BigInteger b2 = new BigInteger(num2, 2);
        BigInteger sum = b1.add(b2);
        return sum.toString(2);
    }

    /**
     * Subtracts two binary numbers.
     *
     * @param num1 The starting binary number
     * @param num2 The binary number to be subtracted from the starting binary
     * @return The difference of two binary numbers.
     */
    public String subBinary(String num1, String num2) {
        BigInteger b1 = new BigInteger(num1, 2);
        BigInteger b2 = new BigInteger(num2, 2);
        BigInteger diff = b1.subtract(b2);
        return diff.toString(2);
    }

    /**
     * Calculates the IP Range from the provided IP address and number of IP addresses.
     * The results are stored into an <code>string</code> to be returned to the method that called it.
     *
     * @param IP The starting IP address (subnet) in binary
     * @param IPPrefix Number of IP addresses in binary
     * @return Results string
     */
    public String IPCalculate(String IP, String IPPrefix) {
        calculate(IP, IPPrefix);
        return getStartIP() + "" - "" + ipRangeAddress;
    }

    /**
     * Adds delimiters back into a given IP address
     *
     * @param binaryIP binary IP address with no delimiters
     * @return binary IP address with delimiters
     */
    private String getBinaryIP(String binaryIP) {
        StringBuilder sb = new StringBuilder(binaryIP);
        for (int i = delimiter.length(); i < binaryIP.length(); i += lengthOfToken + delimiter.length()) {
            sb.insert(i, delimiter);
        }
        return sb.toString();
    }

    /**
     * Gets the netmask from a binary representation of number of IP addresses
     *
     * @param binaryIP binary representation of number of IP addresses
     * @return netmask of <code>binaryIP</code>
     */
    private String getNetmask(String binaryIP) {
        int prefixLength = binaryIP.length() - binaryIP.lastIndexOf('1') - 1;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < prefixLength; i++) {
            sb.append('1');
        }
        for (int i = prefixLength; i < MAX_PREFIX; i++) {
            sb.append('0');
        }
        return convert(getBinaryIP(sb.toString()));
    }

    /**
     * Calculates the IP Range from the provided IP address and number of IP addresses.
     * The results are stored as declared global variables for many other methods to manipulate or use.
     * <br>This method also detects if the provided of number of IP addresses to be calculate exceeds past these IP addresses:
     * 255.255.255.255 and FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds the IP addressing bounds.
     * <br>This method also calculates the prefix size needed to accommodate all the IP Addresses to be listed and stores it as a global variable for use in other methods.
     *
     * @param subnet The starting IP address (subnet)
     * @param noOfIPAddresses Number of IP addresses
     */
    private void calculate(String subnet, String noOfIPAddresses) {
        String binarySubnet = convertToBinary(subnet);
        String binaryNoOfIPAddresses = convertToBinary(noOfIPAddresses);
        int prefixLength = binaryNoOfIPAddresses.length() - binaryNoOfIPAddresses.lastIndexOf('1') - 1;
        if (prefixLength > MAX_PREFIX) {
            throw new IllegalArgumentException(""Number of IP addresses exceeds the IP addressing bounds."");
        }
        prefix = ""/"" + prefixLength;
        totalIPAddresses = new BigInteger(binaryNoOfIPAddresses, 2);
        String netmask = getNetmask(binaryNoOfIPAddresses);
        String binaryStartIP = addBinary(binarySubnet, ""1"");
        String binaryEndIP = addBinary(binarySubnet, subBinary(binaryNoOfIPAddresses, ""1""));
        String startIP = convert(getBinaryIP(binaryStartIP));
        String endIP = convert(getBinaryIP(binaryEndIP));
        ipRangeAddress = endIP;
        if (!startIP.equals(endIP)) {
            ipRangeAddress = startIP + "" - "" + endIP;
        }
    }

    /**
     * Calculates the IP Range from the provided IP address and number of IP addresses from the smaller prefix.
     * The results are stored into an array to be printed using <code><b>Output.java</b></code>.
     *
     * @param IP The starting IP address (subnet)
     * @param IPPrefix Number of IP addresses for smaller prefix
     * @param noPrefix Number of smaller prefixes within the total prefix
     * @param endPrefix Prefix of total number of IP Addresses
     */
    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix) {
        calculate(IP, IPPrefix);
        String[] results = new String[noPrefix];
        BigInteger totalIPs = new BigInteger(convertToBinary(endPrefix), 2);
        BigInteger IPsPerSubnet = totalIPs.divide(totalIPAddresses);
        String binaryIPsPerSubnet = IPsPerSubnet.toString(2);
        int prefixLength = binaryIPsPerSubnet.length() - binaryIPsPerSubnet.lastIndexOf('1') - 1;
        if (prefixLength > MAX_PREFIX) {
            throw new IllegalArgumentException(""Number of IP addresses exceeds the IP addressing bounds."");
        }
        String subnetMask = getNetmask(binaryIPsPerSubnet);
        String binarySubnet = convertToBinary(getStartIP());
        for (int i = 0; i < noPrefix; i++) {
            String binarySubnetStartIP = addBinary(binarySubnet, ""1"");
            String binarySubnetEndIP = addBinary(binarySubnet, subBinary(binaryIPsPerSubnet, ""1""));
            String subnetStartIP = convert(getBinaryIP(binarySubnetStartIP));
            String subnetEndIP = convert(getBinaryIP(binarySubnetEndIP));
            results[i] = subnetStartIP + prefix + "" - "" + subnetEndIP + prefix;
            binarySubnet = addBinary(binarySubnetEndIP, ""1"");
        }
        Output.printResults(results);
    }

    /**
     * Determines whether an IP Address provided in binary form is an IPv4 or an IPv6 by the length of the binary string.
     *
     * @param size1 Length of binary string
     */
    private void checkIPType(int size1) {
        if (size1 == 32) {
            isIPv4 = true;
        } else if (size1 == 128) {
            isIPv6 = true;
        } else {
            throw new IllegalArgumentException(""Invalid IP address."");
        }
    }

    /**
     * Reconstructs the dotted-decimal or hexadecimal IP address with separators from a given binary IP Address.
     * The reconstructed IP address is stored as a global declared variable, <code>currentIP</code>.
     *
     * @param binaryIP An binary IP Address to be converted back into dotted-decimal or hexadecimal format
     */
    private String convert(String binaryIP) {
        StringBuilder sb = new StringBuilder();
        if (isIPv4) {
            for (int i = 0; i < binaryIP.length(); i += 8) {
                sb.append(Integer.parseInt(binaryIP.substring(i, i + 8), 2));
                sb.append(""."");
            }
            sb.deleteCharAt(sb.length() - 1);
        } else if (isIPv6) {
            for (int i = 0; i < binaryIP.length(); i += 16) {
                sb.append(Integer.toHexString(Integer.parseInt(binaryIP.substring(i, i + 16), 2)));
                sb.append("":"");
            }
            sb.deleteCharAt(sb.length() - 1);
        }
        currentIP = sb.toString();
        return currentIP;
    }

    /**
     * Converts an given IPv4 or IPv6 address into binary format.
     *
     * @param IP An IP Address to be converted back into binary format
     * @return Binary representation of given IP Address.
     */
    private String convertToBinary(String IP) {
        StringBuilder sb = new StringBuilder();
        if (IP.contains(""."")) {
            isIPv4 = true;
            delimiter = ""."";
            lengthOfToken = 8;
            String[] tokens = IP.split(""\\."");
           "
