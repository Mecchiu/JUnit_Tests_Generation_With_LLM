[
  {
    "numberTests": "ten",
    "original_code": "// HorizontalBlock.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * An implementation of the abstract class {@code Block}\n * used for horizontal layouting.\n */\npublic class HorizontalBlock extends Block {\n\n    public List\u003cBlock\u003e extractSequentialSubblocks() {\n        this.optimize();\n        if (isTrivial())\n            return new LinkedList\u003cBlock\u003e();\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\n        Block firstBlock;\n        HorizontalBlock theRest \u003d this;\n        do {\n            firstBlock \u003d theRest.extractFirstSequentialSubblock();\n            theRest \u003d theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\n            firstBlock.optimize();\n            if (!firstBlock.isTrivial())\n                result.add(firstBlock);\n            theRest.optimize();\n        } while (!theRest.isTrivial());\n        return result;\n    }\n}\n",
    "package": "glengineer.blocks",
    "classname": "HorizontalBlock",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_0Test.java",
    "test_prompt": "// HorizontalBlock_0Test.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HorizontalBlock}.\n* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.\n*/\nclass HorizontalBlock_0Test {",
    "method_signature": "extractSequentialSubblocks()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// HorizontalBlock.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * An implementation of the abstract class {@code Block}\n * used for horizontal layouting.\n */\npublic class HorizontalBlock extends Block {\n\n    public List\u003cBlock\u003e extractParallelSubblocks() {\n        this.optimize();\n        if (isTrivial())\n            return new LinkedList\u003cBlock\u003e();\n        Set\u003cHWordPosition\u003e hLines \u003d getIntersectingHLines();\n        if (hLines.size() \u003e 0)\n            return extractParallelSubblocksSeparatedByLines(hLines);\n        else\n            return extractParallelSubblocksWithoutLines();\n    }\n}\n",
    "package": "glengineer.blocks",
    "classname": "HorizontalBlock",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_1Test.java",
    "test_prompt": "// HorizontalBlock_1Test.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HorizontalBlock}.\n* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.\n*/\nclass HorizontalBlock_1Test {",
    "method_signature": "extractParallelSubblocks()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// VerticalBlock.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * An implementation of the abstract class {@code Block}\n * used for vertical layouting.\n */\npublic class VerticalBlock extends Block {\n\n    public List\u003cBlock\u003e extractSequentialSubblocks() {\n        this.optimize();\n        if (isTrivial())\n            return new LinkedList\u003cBlock\u003e();\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\n        VerticalBlock firstBlock;\n        VerticalBlock theRest \u003d this;\n        do {\n            firstBlock \u003d theRest.extractFirstSequentialSubblock();\n            theRest \u003d theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));\n            firstBlock.optimize();\n            if (!firstBlock.isTrivial())\n                result.add(firstBlock);\n            theRest.optimize();\n        } while (!theRest.isTrivial());\n        return result;\n    }\n}\n",
    "package": "glengineer.blocks",
    "classname": "VerticalBlock",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_0Test.java",
    "test_prompt": "// VerticalBlock_0Test.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VerticalBlock}.\n* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.\n*/\nclass VerticalBlock_0Test {",
    "method_signature": "extractSequentialSubblocks()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// VerticalBlock.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * An implementation of the abstract class {@code Block}\n * used for vertical layouting.\n */\npublic class VerticalBlock extends Block {\n\n    public List\u003cBlock\u003e extractParallelSubblocks() {\n        this.optimize();\n        if (isTrivial())\n            return new LinkedList\u003cBlock\u003e();\n        Set\u003cVWordPosition\u003e vLines \u003d getIntersectingVLines();\n        if (vLines.size() \u003e 0)\n            return extractParallelSubblocksSeparatedByLines(vLines);\n        else\n            return extractParallelSubblocksWithoutLines();\n    }\n}\n",
    "package": "glengineer.blocks",
    "classname": "VerticalBlock",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_1Test.java",
    "test_prompt": "// VerticalBlock_1Test.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VerticalBlock}.\n* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.\n*/\nclass VerticalBlock_1Test {",
    "method_signature": "extractParallelSubblocks()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    public FunctionsOnComponent getComponent(Axis axis, String componentName) {\n        Agent agent \u003d getAgent(axis, componentName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such component found: \" + componentName);\n        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_0Test.java",
    "test_prompt": "// GroupLayoutEngineer_0Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.\n*/\nclass GroupLayoutEngineer_0Test {",
    "method_signature": "getComponent(Axis, String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null || !(agent instanceof GroupAgent))\n            throw new IllegalArgumentException(\"no such group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_1Test.java",
    "test_prompt": "// GroupLayoutEngineer_1Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.\n*/\nclass GroupLayoutEngineer_1Test {",
    "method_signature": "getGroup(Axis, String, String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getParallelGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such parallel group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_2Test.java",
    "test_prompt": "// GroupLayoutEngineer_2Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.\n*/\nclass GroupLayoutEngineer_2Test {",
    "method_signature": "getParallelGroup(Axis, String, String)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getSequentialGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"No such sequential group found: \u003c\" + firstName + \",\" + lastName + \"\u003e.\");\n        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_3Test.java",
    "test_prompt": "// GroupLayoutEngineer_3Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.\n*/\nclass GroupLayoutEngineer_3Test {",
    "method_signature": "getSequentialGroup(Axis, String, String)",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {\n        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_4Test.java",
    "test_prompt": "// GroupLayoutEngineer_4Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.\n*/\nclass GroupLayoutEngineer_4Test {",
    "method_signature": "getTopSequentialGroup(Axis)",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// ParallelGroupAgent.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\nimport glengineer.agents.settings.ParallelGroupSettings;\nimport java.util.Iterator;\nimport javax.swing.GroupLayout.Alignment;\nimport javax.swing.GroupLayout.ParallelGroup;\n\n/**\n * �����, �������������� ������������ ������.\n */\npublic class ParallelGroupAgent extends GroupAgent {\n\n    public boolean containsGapsOnly() {\n        for (Agent child : childrenAgents) if (!child.isGap())\n            return false;\n        return true;\n    }\n}\n",
    "package": "glengineer.agents",
    "classname": "ParallelGroupAgent",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_0Test.java",
    "test_prompt": "// ParallelGroupAgent_0Test.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\nimport glengineer.agents.settings.ParallelGroupSettings;\nimport java.util.Iterator;\nimport javax.swing.GroupLayout.Alignment;\nimport javax.swing.GroupLayout.ParallelGroup;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParallelGroupAgent}.\n* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.\n*/\nclass ParallelGroupAgent_0Test {",
    "method_signature": "containsGapsOnly()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// ParallelGroupAgent.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\nimport glengineer.agents.settings.ParallelGroupSettings;\nimport java.util.Iterator;\nimport javax.swing.GroupLayout.Alignment;\nimport javax.swing.GroupLayout.ParallelGroup;\n\n/**\n * �����, �������������� ������������ ������.\n */\npublic class ParallelGroupAgent extends GroupAgent {\n\n    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\n        ParallelGroup result \u003d creatorAndAdder.createParallelGroup(getSettings());\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\n        return result;\n    }\n}\n",
    "package": "glengineer.agents",
    "classname": "ParallelGroupAgent",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_1Test.java",
    "test_prompt": "// ParallelGroupAgent_1Test.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\nimport glengineer.agents.settings.ParallelGroupSettings;\nimport java.util.Iterator;\nimport javax.swing.GroupLayout.Alignment;\nimport javax.swing.GroupLayout.ParallelGroup;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParallelGroupAgent}.\n* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.\n*/\nclass ParallelGroupAgent_1Test {",
    "method_signature": "groupContent(GroupCreatorAndElementAdder)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// SequentialGroupAgent.java\npackage glengineer.agents;\n\nimport java.util.ListIterator;\nimport glengineer.agents.setters.*;\nimport javax.swing.GroupLayout;\nimport javax.swing.LayoutStyle;\nimport javax.swing.GroupLayout.*;\n\n/**\n * �����, �������������� ���������������� ������.\n */\npublic class SequentialGroupAgent extends GroupAgent {\n\n    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\n        SequentialGroup result \u003d creatorAndAdder.createSequentialGroup();\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\n        return result;\n    }\n}\n",
    "package": "glengineer.agents",
    "classname": "SequentialGroupAgent",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java",
    "test_prompt": "// SequentialGroupAgentTest.java\npackage glengineer.agents;\n\nimport java.util.ListIterator;\nimport glengineer.agents.setters.*;\nimport javax.swing.GroupLayout;\nimport javax.swing.LayoutStyle;\nimport javax.swing.GroupLayout.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SequentialGroupAgent}.\n* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.\n*/\nclass SequentialGroupAgentTest {",
    "method_signature": "groupContent(GroupCreatorAndElementAdder)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// TopSequentialGroupAgent.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.SequentialGroup;\nimport glengineer.agents.setters.*;\n\n/**\n * �����, �������������� ���������������� ������ �������� ������.\n * \u003cp\u003e\n * ��������� ��������� {@code FunctionsOnTopSequentialGroup}\n * ���������� �������������� ������������ �����������\n * � ������ � � ����� ���������������� ������ �������� ������.\n */\npublic class TopSequentialGroupAgent extends SequentialGroupAgent {\n\n    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\n        SequentialGroup result \u003d creatorAndAdder.createSequentialGroup();\n        if (precedingContainerGap !\u003d null)\n            precedingContainerGap.addOneselfToGroup(result);\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\n        if (followingContainerGap !\u003d null)\n            followingContainerGap.addOneselfToGroup(result);\n        return result;\n    }\n}\n",
    "package": "glengineer.agents",
    "classname": "TopSequentialGroupAgent",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java",
    "test_prompt": "// TopSequentialGroupAgentTest.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.SequentialGroup;\nimport glengineer.agents.setters.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TopSequentialGroupAgent}.\n* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.\n*/\nclass TopSequentialGroupAgentTest {",
    "method_signature": "groupContent(GroupCreatorAndElementAdder)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// VWordPosition.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\n\n/**\n * Encapsulates the position (start and end coordinates)\n * of a word lying vertically on the scheme.\n */\npublic class VWordPosition extends WordPosition implements Comparable\u003cVWordPosition\u003e {\n\n    public String textAt(CharTable ct) {\n        return ct.textAt(this);\n    }\n}\n",
    "package": "glengineer.positions",
    "classname": "VWordPosition",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/positions/VWordPosition.java",
    "test_prompt": "// VWordPositionTest.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VWordPosition}.\n* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.\n*/\nclass VWordPositionTest {",
    "method_signature": "textAt(CharTable)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// HWordPosition.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\n\n/**\n * Encapsulates the position (start and end coordinates)\n * of a word lying horizontally on the scheme.\n */\npublic class HWordPosition extends WordPosition {\n\n    public String textAt(CharTable ct) {\n        return ct.textAt(this);\n    }\n}\n",
    "package": "glengineer.positions",
    "classname": "HWordPosition",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/positions/HWordPosition.java",
    "test_prompt": "// HWordPositionTest.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HWordPosition}.\n* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.\n*/\nclass HWordPositionTest {",
    "method_signature": "textAt(CharTable)",
    "suffix": ""
  }
]