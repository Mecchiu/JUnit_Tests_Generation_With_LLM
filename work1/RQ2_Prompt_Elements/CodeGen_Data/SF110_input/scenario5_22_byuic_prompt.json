[
  {
    "numberTests": "ten",
    "original_code": "// Decompiler.java\npackage org.mozilla.javascript;\n\n/**\n * The following class save decompilation information about the source.\n * Source information is returned from the parser as a String\n * associated with function nodes and with the toplevel script.  When\n * saved in the constant pool of a class, this string will be UTF-8\n * encoded, and token values will occupy a single byte.\n *\n * Source is saved (mostly) as token numbers.  The tokens saved pretty\n * much correspond to the token stream of a \u0027canonical\u0027 representation\n * of the input program, as directed by the parser.  (There were a few\n * cases where tokens could have been left out where decompiler could\n * easily reconstruct them, but I left them in for clarity).  (I also\n * looked adding source collection to TokenStream instead, where I\n * could have limited the changes to a few lines in getToken... but\n * this wouldn\u0027t have saved any space in the resulting source\n * representation, and would have meant that I\u0027d have to duplicate\n * parser logic in the decompiler to disambiguate situations where\n * newlines are important.)  The function decompile expands the\n * tokens back into their string representations, using simple\n * lookahead to correct spacing and indentation.\n *\n * Assignments are saved as two-token pairs (Token.ASSIGN, op). Number tokens\n * are stored inline, as a NUMBER token, a character representing the type, and\n * either 1 or 4 characters representing the bit-encoding of the number.  String\n * types NAME, STRING and OBJECT are currently stored as a token type,\n * followed by a character giving the length of the string (assumed to\n * be less than 2^16), followed by the characters of the string\n * inlined into the source string.  Changing this to some reference to\n * to the string in the compiled class\u0027 constant pool would probably\n * save a lot of space... but would require some method of deriving\n * the final constant pool entry from information available at parse\n * time.\n */\npublic class Decompiler {\n\n    /**\n     * Decompile the source information associated with this js\n     * function/script back into a string.  For the most part, this\n     * just means translating tokens back to their string\n     * representations; there\u0027s a little bit of lookahead logic to\n     * decide the proper spacing/indentation.  Most of the work in\n     * mapping the original source to the prettyprinted decompiled\n     * version is done by the parser.\n     *\n     * @param source encoded source tree presentation\n     * @param flags flags to select output format\n     * @param properties indentation properties\n     */\n    public static String decompile(String source, int flags, UintMap properties) {\n        int length \u003d source.length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int indent \u003d properties.getInt(INITIAL_INDENT_PROP, 0);\n        if (indent \u003c 0)\n            throw new IllegalArgumentException();\n        int indentGap \u003d properties.getInt(INDENT_GAP_PROP, 4);\n        if (indentGap \u003c 0)\n            throw new IllegalArgumentException();\n        int caseGap \u003d properties.getInt(CASE_GAP_PROP, 2);\n        if (caseGap \u003c 0)\n            throw new IllegalArgumentException();\n        StringBuffer result \u003d new StringBuffer();\n        boolean justFunctionBody \u003d (0 !\u003d (flags \u0026 Decompiler.ONLY_BODY_FLAG));\n        boolean toSource \u003d (0 !\u003d (flags \u0026 Decompiler.TO_SOURCE_FLAG));\n        // Spew tokens in source, for debugging.\n        // as TYPE number char\n        if (printSource) {\n            System.err.println(\"length:\" + length);\n            for (int i \u003d 0; i \u003c length; ++i) {\n                // Note that tokenToName will fail unless Context.printTrees\n                // is true.\n                String tokenname \u003d null;\n                if (Token.printNames) {\n                    tokenname \u003d Token.name(source.charAt(i));\n                }\n                if (tokenname \u003d\u003d null) {\n                    tokenname \u003d \"---\";\n                }\n                String pad \u003d tokenname.length() \u003e 7 ? \"\\t\" : \"\\t\\t\";\n                System.err.println(tokenname + pad + (int) source.charAt(i) + \"\\t\u0027\" + ScriptRuntime.escapeString(source.substring(i, i + 1)) + \"\u0027\");\n            }\n            System.err.println();\n        }\n        int braceNesting \u003d 0;\n        boolean afterFirstEOL \u003d false;\n        int i \u003d 0;\n        int topFunctionType;\n        if (source.charAt(i) \u003d\u003d Token.SCRIPT) {\n            ++i;\n            topFunctionType \u003d -1;\n        } else {\n            topFunctionType \u003d source.charAt(i + 1);\n        }\n        if (!toSource) {\n            // add an initial newline to exactly match js.\n            result.append(\u0027\\n\u0027);\n            for (int j \u003d 0; j \u003c indent; j++) result.append(\u0027 \u0027);\n        } else {\n            if (topFunctionType \u003d\u003d FunctionNode.FUNCTION_EXPRESSION) {\n                result.append(\u0027(\u0027);\n            }\n        }\n        while (i \u003c length) {\n            switch(source.charAt(i)) {\n                case Token.GET:\n                case Token.SET:\n                    result.append(source.charAt(i) \u003d\u003d Token.GET ? \"get \" : \"set \");\n                    ++i;\n                    i \u003d printSourceString(source, i + 1, false, result);\n                    // Now increment one more to get past the FUNCTION token\n                    ++i;\n                    break;\n                case Token.NAME:\n                case // re-wrapped in \u0027/\u0027s in parser...\n                Token.REGEXP:\n                    i \u003d printSourceString(source, i + 1, false, result);\n                    continue;\n                case Token.STRING:\n                    i \u003d printSourceString(source, i + 1, true, result);\n                    continue;\n                case Token.NUMBER:\n                    i \u003d printSourceNumber(source, i + 1, result);\n                    continue;\n                case Token.TRUE:\n                    result.append(\"true\");\n                    break;\n                case Token.FALSE:\n                    result.append(\"false\");\n                    break;\n                case Token.NULL:\n                    result.append(\"null\");\n                    break;\n                case Token.THIS:\n                    result.append(\"this\");\n                    break;\n                case Token.FUNCTION:\n                    // skip function type\n                    ++i;\n                    result.append(\"function \");\n                    break;\n                case FUNCTION_END:\n                    // Do nothing\n                    break;\n                case Token.COMMA:\n                    result.append(\", \");\n                    break;\n                case Token.LC:\n                    ++braceNesting;\n                    if (Token.EOL \u003d\u003d getNext(source, length, i))\n                        indent +\u003d indentGap;\n                    result.append(\u0027{\u0027);\n                    break;\n                case Token.RC:\n                    {\n                        --braceNesting;\n                        /* don\u0027t print the closing RC if it closes the\n                 * toplevel function and we\u0027re called from\n                 * decompileFunctionBody.\n                 */\n                        if (justFunctionBody \u0026\u0026 braceNesting \u003d\u003d 0)\n                            break;\n                        result.append(\u0027}\u0027);\n                        switch(getNext(source, length, i)) {\n                            case Token.EOL:\n                            case FUNCTION_END:\n                                indent -\u003d indentGap;\n                                break;\n                            case Token.WHILE:\n                            case Token.ELSE:\n                                indent -\u003d indentGap;\n                                result.append(\u0027 \u0027);\n                                break;\n                        }\n                        break;\n                    }\n                case Token.LP:\n                    result.append(\u0027(\u0027);\n                    break;\n                case Token.RP:\n                    result.append(\u0027)\u0027);\n                    if (Token.LC \u003d\u003d getNext(source, length, i))\n                        result.append(\u0027 \u0027);\n                    break;\n                case Token.LB:\n                    result.append(\u0027[\u0027);\n                    break;\n                case Token.RB:\n                    result.append(\u0027]\u0027);\n                    break;\n                case Token.EOL:\n                    {\n                        if (toSource)\n                            break;\n                        boolean newLine \u003d true;\n                        if (!afterFirstEOL) {\n                            afterFirstEOL \u003d true;\n                            if (justFunctionBody) {\n                                /* throw away just added \u0027function name(...) {\u0027\n                         * and restore the original indent\n                         */\n                                result.setLength(0);\n                                indent -\u003d indentGap;\n                                newLine \u003d false;\n                            }\n                        }\n                        if (newLine) {\n                            result.append(\u0027\\n\u0027);\n                        }\n                        /* add indent if any tokens remain,\n                 * less setback if next token is\n                 * a label, case or default.\n                 */\n                        if (i + 1 \u003c length) {\n                            int less \u003d 0;\n                            int nextToken \u003d source.charAt(i + 1);\n                            if (nextToken \u003d\u003d Token.CASE || nextToken \u003d\u003d Token.DEFAULT) {\n                                less \u003d indentGap - caseGap;\n                            } else if (nextToken \u003d\u003d Token.RC) {\n                                less \u003d indentGap;\n                            } else /* elaborate check against label... skip past a\n                     * following inlined NAME and look for a COLON.\n                     */\n                            if (nextToken \u003d\u003d Token.NAME) {\n                                int afterName \u003d getSourceStringEnd(source, i + 2);\n                                if (source.charAt(afterName) \u003d\u003d Token.COLON)\n                                    less \u003d indentGap;\n                            }\n                            for (; less \u003c indent; less++) result.append(\u0027 \u0027);\n                        }\n                        break;\n                    }\n                case Token.DOT:\n                    result.append(\u0027.\u0027);\n                    break;\n                case Token.NEW:\n                    result.append(\"new \");\n                    break;\n                case Token.DELPROP:\n                    result.append(\"delete \");\n                    break;\n                case Token.IF:\n                    result.append(\"if \");\n                    break;\n                case Token.ELSE:\n                    result.append(\"else \");\n                    break;\n                case Token.FOR:\n                    result.append(\"for \");\n                    break;\n                case Token.IN:\n                    result.append(\" in \");\n                    break;\n                case Token.WITH:\n                    result.append(\"with \");\n                    break;\n                case Token.WHILE:\n                    result.append(\"while \");\n                    break;\n                case Token.DO:\n                    result.append(\"do \");\n                    break;\n                case Token.TRY:\n                    result.append(\"try \");\n                    break;\n                case Token.CATCH:\n                    result.append(\"catch \");\n                    break;\n                case Token.FINALLY:\n                    result.append(\"finally \");\n                    break;\n                case Token.THROW:\n                    result.append(\"throw \");\n                    break;\n                case Token.SWITCH:\n                    result.append(\"switch \");\n                    break;\n                case Token.BREAK:\n                    result.append(\"break\");\n                    if (Token.NAME \u003d\u003d getNext(source, length, i))\n                        result.append(\u0027 \u0027);\n                    break;\n                case Token.CONTINUE:\n                    result.append(\"continue\");\n                    if (Token.NAME \u003d\u003d getNext(source, length, i))\n                        result.append(\u0027 \u0027);\n                    break;\n                case Token.CASE:\n                    result.append(\"case \");\n                    break;\n                case Token.DEFAULT:\n                    result.append(\"default\");\n                    break;\n                case Token.RETURN:\n                    result.append(\"return\");\n                    if (Token.SEMI !\u003d getNext(source, length, i))\n                        result.append(\u0027 \u0027);\n                    break;\n                case Token.VAR:\n                    result.append(\"var \");\n                    break;\n                case Token.LET:\n                    result.append(\"let \");\n                    break;\n                case Token.SEMI:\n                    result.append(\u0027;\u0027);\n                    if (Token.EOL !\u003d getNext(source, length, i)) {\n                        // separators in FOR\n                        result.append(\u0027 \u0027);\n                    }\n                    break;\n                case Token.ASSIGN:\n                    result.append(\" \u003d \");\n                    break;\n                case Token.ASSIGN_ADD:\n                    result.append(\" +\u003d \");\n                    break;\n                case Token.ASSIGN_SUB:\n                    result.append(\" -\u003d \");\n                    break;\n                case Token.ASSIGN_MUL:\n                    result.append(\" *\u003d \");\n                    break;\n                case Token.ASSIGN_DIV:\n                    result.append(\" /\u003d \");\n                    break;\n                case Token.ASSIGN_MOD:\n                    result.append(\" %\u003d \");\n                    break;\n                case Token.ASSIGN_BITOR:\n                    result.append(\" |\u003d \");\n                    break;\n                case Token.ASSIGN_BITXOR:\n                    result.append(\" ^\u003d \");\n                    break;\n                case Token.ASSIGN_BITAND:\n                    result.append(\" \u0026\u003d \");\n                    break;\n                case Token.ASSIGN_LSH:\n                    result.append(\" \u003c\u003c\u003d \");\n                    break;\n                case Token.ASSIGN_RSH:\n                    result.append(\" \u003e\u003e\u003d \");\n                    break;\n                case Token.ASSIGN_URSH:\n                    result.append(\" \u003e\u003e\u003e\u003d \");\n                    break;\n                case Token.HOOK:\n                    result.append(\" ? \");\n                    break;\n                case Token.OBJECTLIT:\n                    // pun OBJECTLIT to mean colon in objlit property\n                    // initialization.\n                    // This needs to be distinct from COLON in the general case\n                    // to distinguish from the colon in a ternary... which needs\n                    // different spacing.\n                    result.append(\u0027:\u0027);\n                    break;\n                case Token.COLON:\n                    if (Token.EOL \u003d\u003d getNext(source, length, i))\n                        // it\u0027s the end of a label\n                        result.append(\u0027:\u0027);\n                    else\n                        // it\u0027s the middle part of a ternary\n                        result.append(\" : \");\n                    break;\n                case Token.OR:\n                    result.append(\" || \");\n                    break;\n                case Token.AND:\n                    result.append(\" \u0026\u0026 \");\n                    break;\n                case Token.BITOR:\n                    result.append(\" | \");\n                    break;\n                case Token.BITXOR:\n                    result.append(\" ^ \");\n                    break;\n                case Token.BITAND:\n                    result.append(\" \u0026 \");\n                    break;\n                case Token.SHEQ:\n                    result.append(\" \u003d\u003d\u003d \");\n                    break;\n                case Token.SHNE:\n                    result.append(\" !\u003d\u003d \");\n                    break;\n                case Token.EQ:\n                    result.append(\" \u003d\u003d \");\n                    break;\n                case Token.NE:\n                    result.append(\" !\u003d \");\n                    break;\n                case Token.LE:\n                    result.append(\" \u003c\u003d \");\n                    break;\n                case Token.LT:\n                    result.append(\" \u003c \");\n                    break;\n                case Token.GE:\n                    result.append(\" \u003e\u003d \");\n                    break;\n                case Token.GT:\n                    result.append(\" \u003e \");\n                    break;\n                case Token.INSTANCEOF:\n                    result.append(\" instanceof \");\n                    break;\n                case Token.LSH:\n                    result.append(\" \u003c\u003c \");\n                    break;\n                case Token.RSH:\n                    result.append(\" \u003e\u003e \");\n                    break;\n                case Token.URSH:\n                    result.append(\" \u003e\u003e\u003e \");\n                    break;\n                case Token.TYPEOF:\n                    result.append(\"typeof \");\n                    break;\n                case Token.VOID:\n                    result.append(\"void \");\n                    break;\n                case Token.CONST:\n                    result.append(\"const \");\n                    break;\n                case Token.YIELD:\n                    result.append(\"yield \");\n                    break;\n                case Token.NOT:\n                    result.append(\u0027!\u0027);\n                    break;\n                case Token.BITNOT:\n                    result.append(\u0027~\u0027);\n                    break;\n                case Token.POS:\n                    result.append(\u0027+\u0027);\n                    break;\n                case Token.NEG:\n                    result.append(\u0027-\u0027);\n                    break;\n                case Token.INC:\n                    result.append(\"++\");\n                    break;\n                case Token.DEC:\n                    result.append(\"--\");\n                    break;\n                case Token.ADD:\n                    result.append(\" + \");\n                    break;\n                case Token.SUB:\n                    result.append(\" - \");\n                    break;\n                case Token.MUL:\n                    result.append(\" * \");\n                    break;\n                case Token.DIV:\n                    result.append(\" / \");\n                    break;\n                case Token.MOD:\n                    result.append(\" % \");\n                    break;\n                case Token.COLONCOLON:\n                    result.append(\"::\");\n                    break;\n                case Token.DOTDOT:\n                    result.append(\"..\");\n                    break;\n                case Token.DOTQUERY:\n                    result.append(\".(\");\n                    break;\n                case Token.XMLATTR:\n                    result.append(\u0027@\u0027);\n                    break;\n                default:\n                    // If we don\u0027t know how to decompile it, raise an exception.\n                    throw new RuntimeException(\"Token: \" + Token.name(source.charAt(i)));\n            }\n            ++i;\n        }\n        if (!toSource) {\n            // add that trailing newline if it\u0027s an outermost function.\n            if (!justFunctionBody)\n                result.append(\u0027\\n\u0027);\n        } else {\n            if (topFunctionType \u003d\u003d FunctionNode.FUNCTION_EXPRESSION) {\n                result.append(\u0027)\u0027);\n            }\n        }\n        return result.toString();\n    }\n\n    private static int printSourceString(String source, int offset, boolean asQuotedString, StringBuffer sb);\n\n    private static int printSourceNumber(String source, int offset, StringBuffer sb);\n\n    private static int getNext(String source, int length, int i);\n\n    private static int getSourceStringEnd(String source, int offset);\n}\n\npublic class Token {\n\n    public static String name(int token);\n}\n",
    "package": "org.mozilla.javascript",
    "classname": "Decompiler",
    "id": "/EvoSuiteBenchmark/original/22_byuic/src/main/java/org/mozilla/javascript/Decompiler.java",
    "test_prompt": "// DecompilerTest.java\npackage org.mozilla.javascript;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Decompiler}.\n* It contains ten unit test cases for the {@link Decompiler#decompile(String, int, UintMap)} method.\n*/\nclass DecompilerTest {",
    "method_signature": "decompile(String, int, UintMap)",
    "suffix": ""
  }
]