[
  {
    "numberTests": "ten",
    "original_code": "// Decompiler.java\npackage org.mozilla.javascript;\n\n/**\n * The following class save decompilation information about the source.\n * Source information is returned from the parser as a String\n * associated with function nodes and with the toplevel script.  When\n * saved in the constant pool of a class, this string will be UTF-8\n * encoded, and token values will occupy a single byte.\n *\n * Source is saved (mostly) as token numbers.  The tokens saved pretty\n * much correspond to the token stream of a \u0027canonical\u0027 representation\n * of the input program, as directed by the parser.  (There were a few\n * cases where tokens could have been left out where decompiler could\n * easily reconstruct them, but I left them in for clarity).  (I also\n * looked adding source collection to TokenStream instead, where I\n * could have limited the changes to a few lines in getToken... but\n * this wouldn\u0027t have saved any space in the resulting source\n * representation, and would have meant that I\u0027d have to duplicate\n * parser logic in the decompiler to disambiguate situations where\n * newlines are important.)  The function decompile expands the\n * tokens back into their string representations, using simple\n * lookahead to correct spacing and indentation.\n *\n * Assignments are saved as two-token pairs (Token.ASSIGN, op). Number tokens\n * are stored inline, as a NUMBER token, a character representing the type, and\n * either 1 or 4 characters representing the bit-encoding of the number.  String\n * types NAME, STRING and OBJECT are currently stored as a token type,\n * followed by a character giving the length of the string (assumed to\n * be less than 2^16), followed by the characters of the string\n * inlined into the source string.  Changing this to some reference to\n * to the string in the compiled class\u0027 constant pool would probably\n * save a lot of space... but would require some method of deriving\n * the final constant pool entry from information available at parse\n * time.\n */\npublic class Decompiler {\n\n    /**\n     * Decompile the source information associated with this js\n     * function/script back into a string.  For the most part, this\n     * just means translating tokens back to their string\n     * representations; there\u0027s a little bit of lookahead logic to\n     * decide the proper spacing/indentation.  Most of the work in\n     * mapping the original source to the prettyprinted decompiled\n     * version is done by the parser.\n     *\n     * @param source encoded source tree presentation\n     * @param flags flags to select output format\n     * @param properties indentation properties\n     */\n    public static String decompile(String source, int flags, UintMap properties);\n}\n",
    "package": "org.mozilla.javascript",
    "classname": "Decompiler",
    "id": "/EvoSuiteBenchmark/original/22_byuic/src/main/java/org/mozilla/javascript/Decompiler.java",
    "test_prompt": "// DecompilerTest.java\npackage org.mozilla.javascript;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Decompiler}.\n* It contains ten unit test cases for the {@link Decompiler#decompile(String, int, UintMap)} method.\n*/\nclass DecompilerTest {",
    "method_signature": "decompile(String, int, UintMap)",
    "suffix": ""
  }
]