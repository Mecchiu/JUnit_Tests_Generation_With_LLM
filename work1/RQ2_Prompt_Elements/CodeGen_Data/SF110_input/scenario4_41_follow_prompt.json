[
  {
    "numberTests": "ten",
    "original_code": "// EnumeratedProperties.java\npackage ghm.follow.config;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Extension of {@link java.util.Properties} which allows one to specify property values which are\n * Lists of Strings.\n *\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class EnumeratedProperties extends Properties {\n\n    /**\n     * Returns the List value of the property with the supplied key. Note that one can call\n     * getEnumeratedProperty() for a given key successfully if and only if setEnumeratedProperty()\n     * for that key was called some time beforehand. All members of the list returned will be\n     * Strings.\n     *\n     * @param key\n     *            lookup of the enumerated property to be retrieved.\n     * @return list containing String values\n     */\n    public List\u003cString\u003e getEnumeratedProperty(String key);\n\n    /**\n     * Assigns the supplied array of String values to the supplied key.\n     *\n     * @param key\n     *            property lookup\n     * @param values\n     *            values to be associated with the property lookup\n     */\n    public void setEnumeratedProperty(String key, List\u003cString\u003e values);\n\n    /**\n     * Delimiter between property name \u0026 list member index\n     */\n    protected static char delimiter \u003d \u0027.\u0027;\n}\n",
    "package": "ghm.follow.config",
    "classname": "EnumeratedProperties",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/config/EnumeratedProperties.java",
    "test_prompt": "// EnumeratedPropertiesTest.java\npackage ghm.follow.config;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EnumeratedProperties}.\n* It contains ten unit test cases for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.\n*/\nclass EnumeratedPropertiesTest {",
    "method_signature": "getEnumeratedProperty(String)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// JTextPaneDestination.java\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextPane;\nimport javax.swing.text.BadLocationException;\n\n/**\n * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextPane}.\n *\n * @see OutputDestination\n * @see JTextPane\n * @author \u003ca href\u003d\"mailto:carl.hall@gmail.com\"\u003eCarl Hall\u003c/a\u003e\n */\npublic class JTextPaneDestination implements OutputDestination {\n\n    private Logger log \u003d Logger.getLogger(JTextPaneDestination.class.getName());\n\n    protected JTextPane jTextPane;\n\n    protected boolean autoPositionCaret;\n\n    /**\n     * Construct a new JTextPaneDestination.\n     *\n     * @param jTextPane\n     *            text will be appended to this text area\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public JTextPaneDestination(JTextPane jTextPane, boolean autoPositionCaret) {\n    }\n\n    public JTextPane getJTextPane();\n\n    public void setJTextArea(JTextPane jTextPane);\n\n    /**\n     * Add a filtered view to this destination. Filtered views show only a subset of the total\n     * output based on filter conditions.\n     *\n     * @since 1.8.0\n     */\n    public void addFilteredView();\n\n    /**\n     * Remove a filtered view\n     *\n     * @since 1.8.0\n     */\n    public void removeFilteredView();\n\n    /**\n     * @return whether caret will be automatically moved to the bottom of the text area when text is\n     *         appended\n     */\n    public boolean autoPositionCaret();\n\n    /**\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public void setAutoPositionCaret(boolean autoPositionCaret);\n\n    public void print(String s);\n\n    public void clear();\n}\n",
    "package": "ghm.follow.io",
    "classname": "JTextPaneDestination",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextPaneDestination.java",
    "test_prompt": "// JTextPaneDestinationTest.java\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextPane;\nimport javax.swing.text.BadLocationException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JTextPaneDestination}.\n* It contains ten unit test cases for the {@link JTextPaneDestination#autoPositionCaret()} method.\n*/\nclass JTextPaneDestinationTest {",
    "method_signature": "autoPositionCaret()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// JTextComponentDestination.java\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.JTextComponent;\n\n/**\n * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextComponent}.\n *\n * @see OutputDestination\n * @see JTextCompnent\n * @author \u003ca href\u003d\"mailto:carl.hall@gmail.com\"\u003eCarl Hall\u003c/a\u003e\n */\npublic class JTextComponentDestination extends FilterableOutputDestination {\n\n    private static final Logger LOG \u003d Logger.getLogger(JTextComponentDestination.class.getName());\n\n    protected JTextComponent comp;\n\n    protected boolean autoPositionCaret;\n\n    /**\n     * Construct a new JTextCompnentDestination.\n     *\n     * @param jTextPane\n     *            text will be appended to this text area\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public JTextComponentDestination(JTextComponent comp, boolean autoPositionCaret) {\n    }\n\n    public JTextComponent getJTextComponent();\n\n    public void setJTextComponent(JTextComponent comp);\n\n    /**\n     * Add a filtered view to this destination. Filtered views show only a subset of the total\n     * output based on filter conditions.\n     *\n     * @since 1.8.0\n     */\n    public void addFilteredView();\n\n    /**\n     * Remove a filtered view\n     *\n     * @since 1.8.0\n     */\n    public void removeFilteredView();\n\n    /**\n     * @return whether caret will be automatically moved to the bottom of the text area when text is\n     *         appended\n     */\n    public boolean autoPositionCaret();\n\n    /**\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public void setAutoPositionCaret(boolean autoPositionCaret);\n\n    public void handlePrint(String s);\n\n    public void clear();\n}\n",
    "package": "ghm.follow.io",
    "classname": "JTextComponentDestination",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextComponentDestination.java",
    "test_prompt": "// JTextComponentDestinationTest.java\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.JTextComponent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JTextComponentDestination}.\n* It contains ten unit test cases for the {@link JTextComponentDestination#autoPositionCaret()} method.\n*/\nclass JTextComponentDestinationTest {",
    "method_signature": "autoPositionCaret()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// SearchableTextPane.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\n\npublic class SearchableTextPane extends JTextArea {\n\n    private Logger log \u003d Logger.getLogger(SearchableTextPane.class.getName());\n\n    private int lastSearchPos \u003d -1;\n\n    private String lastSearchTerm;\n\n    private final DefaultHighlightPainter wordPainter \u003d new DefaultHighlightPainter(Color.YELLOW);\n\n    public SearchableTextPane(Font font, int tabSize) {\n    }\n\n    /**\n     * Override this to keep the text from wrapping and to make the viewable area as wide as the\n     * tabbed pane\n     */\n    public boolean getScrollableTracksViewportWidth();\n\n    /**\n     * Highlight \u003ccode\u003eterm\u003c/code\u003e wherever it is found in the view. Also highlights the entire\n     * line on which the term is found.\n     *\n     * @param term\n     * @param caseSensitive\n     * @param useRegularExpression\n     * @return\n     */\n    public List\u003cLineResult\u003e highlight(String term, int flags);\n\n    /**\n     * Highlight a piece of text in the document\n     *\n     * @param start\n     * @param wordEnd\n     * @param highlighter\n     */\n    private void addHighlight(int start, int length) throws BadLocationException;\n\n    /**\n     * Removes highlights from text area\n     */\n    public void removeHighlights();\n\n    /**\n     * Searches for a term. If the term provided matches the last searched term, the last found\n     * position is used as a starting point.\u003cbr\u003e\n     * \u003cbr\u003e\n     * Developer note: this method isn\u0027t currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @return The position where the term was found.\u003cbr\u003e\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term);\n\n    /**\n     * Searches for a term at the given starting position.\u003cbr\u003e\n     * \u003cbr\u003e\n     * Developer note: this method isn\u0027t currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @param startPos\n     *            Where to start.\n     * @return The position where the term was found.\u003cbr\u003e\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term, int startPos);\n\n    /**\n     * Converts word results from search into line results\n     *\n     * @param words\n     * @return\n     */\n    private List\u003cLineResult\u003e convertWords2Lines(List\u003cWordResult\u003e words) throws BadLocationException;\n\n    /**\n     * Adds word result to line result and updates line information\n     *\n     * @param wordResult\n     * @param lineResult\n     */\n    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException;\n}\n",
    "package": "ghm.follow.search",
    "classname": "SearchableTextPane",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_0Test.java",
    "test_prompt": "// SearchableTextPane_0Test.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchableTextPane}.\n* It contains ten unit test cases for the {@link SearchableTextPane#search(String)} method.\n*/\nclass SearchableTextPane_0Test {",
    "method_signature": "search(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// SearchableTextPane.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\n\npublic class SearchableTextPane extends JTextArea {\n\n    private Logger log \u003d Logger.getLogger(SearchableTextPane.class.getName());\n\n    private int lastSearchPos \u003d -1;\n\n    private String lastSearchTerm;\n\n    private final DefaultHighlightPainter wordPainter \u003d new DefaultHighlightPainter(Color.YELLOW);\n\n    public SearchableTextPane(Font font, int tabSize) {\n    }\n\n    /**\n     * Override this to keep the text from wrapping and to make the viewable area as wide as the\n     * tabbed pane\n     */\n    public boolean getScrollableTracksViewportWidth();\n\n    /**\n     * Highlight \u003ccode\u003eterm\u003c/code\u003e wherever it is found in the view. Also highlights the entire\n     * line on which the term is found.\n     *\n     * @param term\n     * @param caseSensitive\n     * @param useRegularExpression\n     * @return\n     */\n    public List\u003cLineResult\u003e highlight(String term, int flags);\n\n    /**\n     * Highlight a piece of text in the document\n     *\n     * @param start\n     * @param wordEnd\n     * @param highlighter\n     */\n    private void addHighlight(int start, int length) throws BadLocationException;\n\n    /**\n     * Removes highlights from text area\n     */\n    public void removeHighlights();\n\n    /**\n     * Searches for a term. If the term provided matches the last searched term, the last found\n     * position is used as a starting point.\u003cbr\u003e\n     * \u003cbr\u003e\n     * Developer note: this method isn\u0027t currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @return The position where the term was found.\u003cbr\u003e\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term);\n\n    /**\n     * Searches for a term at the given starting position.\u003cbr\u003e\n     * \u003cbr\u003e\n     * Developer note: this method isn\u0027t currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @param startPos\n     *            Where to start.\n     * @return The position where the term was found.\u003cbr\u003e\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term, int startPos);\n\n    /**\n     * Converts word results from search into line results\n     *\n     * @param words\n     * @return\n     */\n    private List\u003cLineResult\u003e convertWords2Lines(List\u003cWordResult\u003e words) throws BadLocationException;\n\n    /**\n     * Adds word result to line result and updates line information\n     *\n     * @param wordResult\n     * @param lineResult\n     */\n    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException;\n}\n",
    "package": "ghm.follow.search",
    "classname": "SearchableTextPane",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_1Test.java",
    "test_prompt": "// SearchableTextPane_1Test.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchableTextPane}.\n* It contains ten unit test cases for the {@link SearchableTextPane#search(String, int)} method.\n*/\nclass SearchableTextPane_1Test {",
    "method_signature": "search(String, int)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// FileFollowingPane.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\n\n/**\n * A component which allows one to view a text file to which information is being asynchronously\n * appended.\n *\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class FileFollowingPane extends JScrollPane {\n\n    private Logger log \u003d Logger.getLogger(FileFollowingPane.class.getName());\n\n    /**\n     * FileFollower used to print to this component\n     */\n    protected FileFollower fileFollower;\n\n    /**\n     * Text area into which followed file\u0027s contents are printed\n     */\n    protected SearchableTextPane textArea;\n\n    /**\n     * OutputDestination used w/FileFollower\n     */\n    protected JTextComponentDestination destination;\n\n    /**\n     * @param file\n     *            text file to be followed\n     * @param bufferSize\n     *            size of the character buffer inside the FileFollower used to follow the supplied\n     *            file\n     * @param latency\n     *            latency of the FileFollower used to follow the supplied file\n     */\n    public FileFollowingPane(File file, int bufferSize, int latency, boolean autoPositionCaret, Font font, int tabSize) {\n    }\n\n    /**\n     * Returns the text area to which the followed file\u0027s contents are being printed.\n     *\n     * @return text area containing followed file\u0027s contents\n     */\n    public SearchableTextPane getTextPane();\n\n    /**\n     * Returns whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @return whether caret is automatically repositioned on append\n     */\n    public boolean autoPositionCaret();\n\n    /**\n     * Sets whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @param value\n     *            whether caret is automatically repositioned on append\n     */\n    public void setAutoPositionCaret(boolean value);\n\n    /**\n     * Returns the FileFollower which is being used to print information in this component.\n     *\n     * @return FileFollower used by this component\n     */\n    public FileFollower getFileFollower();\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().getFollowedFile()\n     */\n    public File getFollowedFile();\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().start()\n     */\n    public void startFollowing();\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stop()\n     */\n    public void stopFollowing();\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().restart()\n     */\n    public void restartFollowing();\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().pause()\n     */\n    public void pauseFollowing();\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().unpause()\n     */\n    public void unpauseFollowing();\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().isPaused()\n     *\n     * @return\n     */\n    public boolean isFollowingPaused();\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stopAndWait()\n     */\n    public void stopFollowingAndWait() throws InterruptedException;\n\n    /**\n     * Convenience method; equivalent to called getFileFollower().isBeingFollowed()\n     *\n     * @return\n     */\n    public boolean isFollowing();\n\n    /**\n     * Clears the contents of this FileFollowingPane synchronously.\n     */\n    public void clear() throws IOException;\n}\n",
    "package": "ghm.follow.gui",
    "classname": "FileFollowingPane",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/gui/FileFollowingPane.java",
    "test_prompt": "// FileFollowingPaneTest.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollowingPane}.\n* It contains ten unit test cases for the {@link FileFollowingPane#autoPositionCaret()} method.\n*/\nclass FileFollowingPaneTest {",
    "method_signature": "autoPositionCaret()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// FileFollower.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Instances of this class \u0027follow\u0027 a particular text file, assmebling that\n * file\u0027s characters into Strings and sending them to instances of\n * {@link OutputDestination}. The name and behavior of this class are inspired\n * by the \u0027-f\u0027 (follow) flag of the UNIX command \u0027tail\u0027.\n *\n * @see OutputDestination\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class FileFollower {\n\n    /**\n     * Constructs a new FileFollower; invoking this constructor does\n     * \u003cem\u003enot\u003c/em\u003e cause the new object to begin following the supplied file.\n     * In order to begin following, one must call {@link #start()}.\n     *\n     * @param file\n     *            file to be followed\n     * @param bufferSize\n     *            number of chars to be read each time the file is accessed\n     * @param latency\n     *            each time a FileFollower\u0027s running thread encounters the end\n     *            of the file in its stream, it will rest for this many\n     *            milliseconds before checking to see if there are any more\n     *            bytes in the file\n     * @param initialOutputDestinations\n     *            an initial array of OutputDestinations which will be used when\n     *            printing the contents of the file (this array may be\n     *            \u003ctt\u003enull\u003c/tt\u003e)\n     */\n    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {\n    }\n\n    /**\n     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},\n     * except that a default buffer size (32,768 characters) and latency (1000\n     * milliseconds) are used.\n     *\n     * @see #FileFollower(File, int, int, OutputDestination[])\n     */\n    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {\n    }\n\n    /**\n     * Cause this FileFollower to spawn a thread which will follow the file\n     * supplied in the constructor and send its contents to all of the\n     * FileFollower\u0027s OutputDestinations.\u003cbr\u003e\n     * \u003cbr\u003e\n     * If this FileFollower is running but paused, this method equates to\n     * calling unpause().\n     */\n    public synchronized void start();\n\n    public synchronized void pause();\n\n    public synchronized void unpause();\n\n    public synchronized void restart();\n\n    /**\n     * Cause this FileFollower to stop following the file supplied in the\n     * constructor after it flushes the characters it\u0027s currently reading to all\n     * its OutputDestinations.\n     */\n    public synchronized void stop();\n\n    /**\n     * Like {@link #stop()}, but this method will not exit until the thread\n     * which is following the file has finished executing (i.e., stop\n     * synchronously).\n     */\n    public synchronized void stopAndWait() throws InterruptedException;\n\n    /**\n     * Send the supplied string to all OutputDestinations\n     *\n     * @param s\n     */\n    private synchronized void print(String s);\n\n    /**\n     * Clear all OutputDestinations\n     */\n    private synchronized void clear();\n\n    /**\n     * Add another OutputDestination to which the followed file\u0027s contents\n     * should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be added\n     */\n    public boolean addOutputDestination(OutputDestination outputDestination);\n\n    /**\n     * Remove the supplied OutputDestination from the list of OutputDestinations\n     * to which the followed file\u0027s contents should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be removed\n     */\n    public boolean removeOutputDestination(OutputDestination outputDestination);\n\n    /**\n     * Returns the List which maintains all OutputDestinations for this\n     * FileFollower.\n     *\n     * @return contains all OutputDestinations for this FileFollower\n     */\n    public List\u003cOutputDestination\u003e getOutputDestinations();\n\n    /**\n     * Returns the file which is being followed by this FileFollower\n     *\n     * @return file being followed\n     */\n    public File getFollowedFile();\n\n    /**\n     * Returns the following state of a file\n     *\n     * @return true if being followed, false if not being followed\n     */\n    public boolean isBeingFollowed();\n\n    /**\n     * Returns the pause state of the follower.\n     *\n     * @return true if paused, false otherwise\n     */\n    public boolean isPaused();\n\n    /**\n     * Returns the size of the character buffer used to read characters from the\n     * followed file. Each time the file is accessed, this buffer is filled.\n     *\n     * @return size of the character buffer\n     */\n    public int getBufferSize();\n\n    /**\n     * Sets the size of the character buffer used to read characters from the\n     * followed file. Increasing buffer size will improve efficiency but\n     * increase the amount of memory used by the FileFollower.\u003cbr\u003e\n     * \u003cem\u003eNOTE:\u003c/em\u003e Setting this value will \u003cem\u003enot\u003c/em\u003e cause a running\n     * FileFollower to immediately begin reading characters into a buffer of the\n     * newly specified size. You must stop \u0026 restart the FileFollower in order\n     * for changes to take effect.\n     *\n     * @param bufferSize\n     *            size of the character buffer\n     */\n    public void setBufferSize(int bufferSize);\n\n    /**\n     * Returns the time (in milliseconds) which a FileFollower spends sleeping\n     * each time it encounters the end of the followed file.\n     *\n     * @return latency, in milliseconds\n     */\n    public int getLatency();\n\n    /**\n     * Sets the time (in milliseconds) which a FileFollower spends sleeping each\n     * time it encounters the end of the followed file. Note that extremely low\n     * latency values may cause thrashing between the FileFollower\u0027s running\n     * thread and other threads in an application. A change in this value will\n     * be reflected the next time the FileFollower\u0027s running thread sleeps.\n     *\n     * @param latency\n     *            latency, in milliseconds\n     */\n    public void setLatency(int latency);\n\n    protected int bufferSize;\n\n    protected int latency;\n\n    protected File file;\n\n    protected List\u003cOutputDestination\u003e outputDestinations;\n\n    protected boolean continueRunning;\n\n    protected boolean needsRestart;\n\n    protected Thread runnerThread;\n\n    protected boolean paused;\n\n    /**\n     * Instances of this class are used to run a thread which follows a\n     * FileFollower\u0027s file and sends prints its contents to OutputDestinations.\n     * This class should only handle the gathering of data from the followed\n     * file. Actually writing to the output destinations is handled by the outer\n     * class (FileFollower).\n     */\n    class Runner implements Runnable {\n\n        private Logger log \u003d Logger.getLogger(Runner.class.getName());\n\n        public void run() {\n            log.finer(\"entering FileFollower.run()\");\n            while (continueRunning) {\n                runAction();\n            }\n            log.finer(\"exiting FileFollower.run()\");\n        }\n\n        protected void runAction() {\n            try {\n                clear();\n                long fileSize \u003d file.length();\n                byte[] byteArray \u003d new byte[bufferSize];\n                int numBytesRead;\n                long lastActivityTime \u003d file.lastModified();\n                // create some stream readers to handle the file\n                FileInputStream fis \u003d new FileInputStream(file);\n                BufferedInputStream bis \u003d new BufferedInputStream(fis);\n                // start at the beginning of the file\n                long startingPoint \u003d 0;\n                // if the file size is bigger than the buffer size, skip to the\n                // end of the file if not performing a restart\n                if (fileSize \u003e bufferSize) {\n                    startingPoint \u003d fileSize - bufferSize;\n                }\n                // reset the restart flag\n                needsRestart \u003d false;\n                log.finer(\"Starting point: \" + startingPoint + \"; Last activity: \" + lastActivityTime);\n                bis.skip(startingPoint);\n                while (continueRunning \u0026\u0026 !needsRestart) {\n                    if (!paused) {\n                        lastActivityTime \u003d System.currentTimeMillis();\n                        numBytesRead \u003d bis.read(byteArray, 0, byteArray.length);\n                        boolean dataWasFound \u003d (numBytesRead \u003e 0);\n                        log.finer(\"Bytes read: \" + numBytesRead + \"; dataWasFound: \" + dataWasFound);\n                        // if data was found, print it and log activity time\n                        if (dataWasFound) {\n                            String output \u003d new String(byteArray, 0, numBytesRead);\n                            // print the output to the listeners\n                            print(output);\n                        } else // no data found so check the file and restart if needed\n                        {\n                            // check if the file handle has become stale (file\n                            // was modified, but no data was read).\n                            boolean fileExists \u003d file.exists();\n                            // removed check for 0 length because a file could\n                            // change by being cleared out\n                            // \u0026\u0026 (file_.length() \u003e 0);\n                            boolean fileHasChanged \u003d file.lastModified() \u003e lastActivityTime;\n                            if (fileExists \u0026\u0026 fileHasChanged) {\n                                log.finer(\"Needs restart [fileExists\u003d\" + fileExists + \"; fileHasChanged\u003d\" + fileHasChanged + \"]\");\n                                needsRestart \u003d true;\n                            }\n                        }\n                        boolean allDataRead \u003d (numBytesRead \u003c byteArray.length);\n                        if (allDataRead \u0026\u0026 !needsRestart) {\n                            log.finer(\"Sleeping for \" + latency + \"ms [allDataRead:\" + allDataRead + \"; needsRestart:\" + needsRestart + \"]\");\n                            sleep();\n                        }\n                    } else {\n                        log.finer(\"Runner paused.\");\n                        sleep();\n                    }\n                }\n                log.finer(\"exiting Runner.runAction [continueRunning\u003d\" + continueRunning + \"; needsRestart\u003d\" + needsRestart + \"]\");\n                bis.close();\n                fis.close();\n            } catch (IOException e) {\n                log.log(Level.SEVERE, \"IOException while following file\", e);\n            }\n        }\n\n        private void sleep() {\n            try {\n                Thread.sleep(latency);\n            } catch (InterruptedException e) {\n                // Interrupt may be thrown manually by stop()\n                log.finer(\"DIED IN MY SLEEP\");\n            }\n        }\n    }\n\n    /**\n     * Line separator, retrieved from System properties \u0026 stored statically.\n     */\n    protected static final String lineSeparator \u003d System.getProperty(\"line.separator\");\n}\n",
    "package": "ghm.follow",
    "classname": "FileFollower",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_0Test.java",
    "test_prompt": "// FileFollower_0Test.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollower}.\n* It contains ten unit test cases for the {@link FileFollower#addOutputDestination(OutputDestination)} method.\n*/\nclass FileFollower_0Test {",
    "method_signature": "addOutputDestination(OutputDestination)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// FileFollower.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Instances of this class \u0027follow\u0027 a particular text file, assmebling that\n * file\u0027s characters into Strings and sending them to instances of\n * {@link OutputDestination}. The name and behavior of this class are inspired\n * by the \u0027-f\u0027 (follow) flag of the UNIX command \u0027tail\u0027.\n *\n * @see OutputDestination\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class FileFollower {\n\n    /**\n     * Constructs a new FileFollower; invoking this constructor does\n     * \u003cem\u003enot\u003c/em\u003e cause the new object to begin following the supplied file.\n     * In order to begin following, one must call {@link #start()}.\n     *\n     * @param file\n     *            file to be followed\n     * @param bufferSize\n     *            number of chars to be read each time the file is accessed\n     * @param latency\n     *            each time a FileFollower\u0027s running thread encounters the end\n     *            of the file in its stream, it will rest for this many\n     *            milliseconds before checking to see if there are any more\n     *            bytes in the file\n     * @param initialOutputDestinations\n     *            an initial array of OutputDestinations which will be used when\n     *            printing the contents of the file (this array may be\n     *            \u003ctt\u003enull\u003c/tt\u003e)\n     */\n    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {\n    }\n\n    /**\n     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},\n     * except that a default buffer size (32,768 characters) and latency (1000\n     * milliseconds) are used.\n     *\n     * @see #FileFollower(File, int, int, OutputDestination[])\n     */\n    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {\n    }\n\n    /**\n     * Cause this FileFollower to spawn a thread which will follow the file\n     * supplied in the constructor and send its contents to all of the\n     * FileFollower\u0027s OutputDestinations.\u003cbr\u003e\n     * \u003cbr\u003e\n     * If this FileFollower is running but paused, this method equates to\n     * calling unpause().\n     */\n    public synchronized void start();\n\n    public synchronized void pause();\n\n    public synchronized void unpause();\n\n    public synchronized void restart();\n\n    /**\n     * Cause this FileFollower to stop following the file supplied in the\n     * constructor after it flushes the characters it\u0027s currently reading to all\n     * its OutputDestinations.\n     */\n    public synchronized void stop();\n\n    /**\n     * Like {@link #stop()}, but this method will not exit until the thread\n     * which is following the file has finished executing (i.e., stop\n     * synchronously).\n     */\n    public synchronized void stopAndWait() throws InterruptedException;\n\n    /**\n     * Send the supplied string to all OutputDestinations\n     *\n     * @param s\n     */\n    private synchronized void print(String s);\n\n    /**\n     * Clear all OutputDestinations\n     */\n    private synchronized void clear();\n\n    /**\n     * Add another OutputDestination to which the followed file\u0027s contents\n     * should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be added\n     */\n    public boolean addOutputDestination(OutputDestination outputDestination);\n\n    /**\n     * Remove the supplied OutputDestination from the list of OutputDestinations\n     * to which the followed file\u0027s contents should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be removed\n     */\n    public boolean removeOutputDestination(OutputDestination outputDestination);\n\n    /**\n     * Returns the List which maintains all OutputDestinations for this\n     * FileFollower.\n     *\n     * @return contains all OutputDestinations for this FileFollower\n     */\n    public List\u003cOutputDestination\u003e getOutputDestinations();\n\n    /**\n     * Returns the file which is being followed by this FileFollower\n     *\n     * @return file being followed\n     */\n    public File getFollowedFile();\n\n    /**\n     * Returns the following state of a file\n     *\n     * @return true if being followed, false if not being followed\n     */\n    public boolean isBeingFollowed();\n\n    /**\n     * Returns the pause state of the follower.\n     *\n     * @return true if paused, false otherwise\n     */\n    public boolean isPaused();\n\n    /**\n     * Returns the size of the character buffer used to read characters from the\n     * followed file. Each time the file is accessed, this buffer is filled.\n     *\n     * @return size of the character buffer\n     */\n    public int getBufferSize();\n\n    /**\n     * Sets the size of the character buffer used to read characters from the\n     * followed file. Increasing buffer size will improve efficiency but\n     * increase the amount of memory used by the FileFollower.\u003cbr\u003e\n     * \u003cem\u003eNOTE:\u003c/em\u003e Setting this value will \u003cem\u003enot\u003c/em\u003e cause a running\n     * FileFollower to immediately begin reading characters into a buffer of the\n     * newly specified size. You must stop \u0026 restart the FileFollower in order\n     * for changes to take effect.\n     *\n     * @param bufferSize\n     *            size of the character buffer\n     */\n    public void setBufferSize(int bufferSize);\n\n    /**\n     * Returns the time (in milliseconds) which a FileFollower spends sleeping\n     * each time it encounters the end of the followed file.\n     *\n     * @return latency, in milliseconds\n     */\n    public int getLatency();\n\n    /**\n     * Sets the time (in milliseconds) which a FileFollower spends sleeping each\n     * time it encounters the end of the followed file. Note that extremely low\n     * latency values may cause thrashing between the FileFollower\u0027s running\n     * thread and other threads in an application. A change in this value will\n     * be reflected the next time the FileFollower\u0027s running thread sleeps.\n     *\n     * @param latency\n     *            latency, in milliseconds\n     */\n    public void setLatency(int latency);\n\n    protected int bufferSize;\n\n    protected int latency;\n\n    protected File file;\n\n    protected List\u003cOutputDestination\u003e outputDestinations;\n\n    protected boolean continueRunning;\n\n    protected boolean needsRestart;\n\n    protected Thread runnerThread;\n\n    protected boolean paused;\n\n    /**\n     * Instances of this class are used to run a thread which follows a\n     * FileFollower\u0027s file and sends prints its contents to OutputDestinations.\n     * This class should only handle the gathering of data from the followed\n     * file. Actually writing to the output destinations is handled by the outer\n     * class (FileFollower).\n     */\n    class Runner implements Runnable {\n\n        private Logger log \u003d Logger.getLogger(Runner.class.getName());\n\n        public void run() {\n            log.finer(\"entering FileFollower.run()\");\n            while (continueRunning) {\n                runAction();\n            }\n            log.finer(\"exiting FileFollower.run()\");\n        }\n\n        protected void runAction() {\n            try {\n                clear();\n                long fileSize \u003d file.length();\n                byte[] byteArray \u003d new byte[bufferSize];\n                int numBytesRead;\n                long lastActivityTime \u003d file.lastModified();\n                // create some stream readers to handle the file\n                FileInputStream fis \u003d new FileInputStream(file);\n                BufferedInputStream bis \u003d new BufferedInputStream(fis);\n                // start at the beginning of the file\n                long startingPoint \u003d 0;\n                // if the file size is bigger than the buffer size, skip to the\n                // end of the file if not performing a restart\n                if (fileSize \u003e bufferSize) {\n                    startingPoint \u003d fileSize - bufferSize;\n                }\n                // reset the restart flag\n                needsRestart \u003d false;\n                log.finer(\"Starting point: \" + startingPoint + \"; Last activity: \" + lastActivityTime);\n                bis.skip(startingPoint);\n                while (continueRunning \u0026\u0026 !needsRestart) {\n                    if (!paused) {\n                        lastActivityTime \u003d System.currentTimeMillis();\n                        numBytesRead \u003d bis.read(byteArray, 0, byteArray.length);\n                        boolean dataWasFound \u003d (numBytesRead \u003e 0);\n                        log.finer(\"Bytes read: \" + numBytesRead + \"; dataWasFound: \" + dataWasFound);\n                        // if data was found, print it and log activity time\n                        if (dataWasFound) {\n                            String output \u003d new String(byteArray, 0, numBytesRead);\n                            // print the output to the listeners\n                            print(output);\n                        } else // no data found so check the file and restart if needed\n                        {\n                            // check if the file handle has become stale (file\n                            // was modified, but no data was read).\n                            boolean fileExists \u003d file.exists();\n                            // removed check for 0 length because a file could\n                            // change by being cleared out\n                            // \u0026\u0026 (file_.length() \u003e 0);\n                            boolean fileHasChanged \u003d file.lastModified() \u003e lastActivityTime;\n                            if (fileExists \u0026\u0026 fileHasChanged) {\n                                log.finer(\"Needs restart [fileExists\u003d\" + fileExists + \"; fileHasChanged\u003d\" + fileHasChanged + \"]\");\n                                needsRestart \u003d true;\n                            }\n                        }\n                        boolean allDataRead \u003d (numBytesRead \u003c byteArray.length);\n                        if (allDataRead \u0026\u0026 !needsRestart) {\n                            log.finer(\"Sleeping for \" + latency + \"ms [allDataRead:\" + allDataRead + \"; needsRestart:\" + needsRestart + \"]\");\n                            sleep();\n                        }\n                    } else {\n                        log.finer(\"Runner paused.\");\n                        sleep();\n                    }\n                }\n                log.finer(\"exiting Runner.runAction [continueRunning\u003d\" + continueRunning + \"; needsRestart\u003d\" + needsRestart + \"]\");\n                bis.close();\n                fis.close();\n            } catch (IOException e) {\n                log.log(Level.SEVERE, \"IOException while following file\", e);\n            }\n        }\n\n        private void sleep() {\n            try {\n                Thread.sleep(latency);\n            } catch (InterruptedException e) {\n                // Interrupt may be thrown manually by stop()\n                log.finer(\"DIED IN MY SLEEP\");\n            }\n        }\n    }\n\n    /**\n     * Line separator, retrieved from System properties \u0026 stored statically.\n     */\n    protected static final String lineSeparator \u003d System.getProperty(\"line.separator\");\n}\n",
    "package": "ghm.follow",
    "classname": "FileFollower",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_1Test.java",
    "test_prompt": "// FileFollower_1Test.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollower}.\n* It contains ten unit test cases for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.\n*/\nclass FileFollower_1Test {",
    "method_signature": "removeOutputDestination(OutputDestination)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// FollowApp.java\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This class\u0027 main() method is the entry point into the Follow application.\n *\n * @see #main(String[])\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class FollowApp {\n\n    public static final String FILE_SEPARATOR \u003d System.getProperty(\"file.separator\");\n\n    public static final String MESSAGE_LINE_SEPARATOR \u003d \"\\n\";\n\n    public static final boolean DEBUG \u003d Boolean.getBoolean(\"follow.debug\");\n\n    public static boolean HAS_SOLARIS_BUG \u003d false;\n\n    private static Logger LOG \u003d Logger.getLogger(FollowApp.class.getName());\n\n    private int currentCursor \u003d Cursor.DEFAULT_CURSOR;\n\n    private Cursor defaultCursor;\n\n    private Cursor waitCursor;\n\n    private Map\u003cFile, FileFollowingPane\u003e fileToFollowingPaneMap \u003d new HashMap\u003cFile, FileFollowingPane\u003e();\n\n    private JTabbedPane tabbedPane;\n\n    private ToolBar toolBar;\n\n    private PopupMenu popupMenu;\n\n    private Menu recentFilesMenu;\n\n    private MouseListener rightClickListener;\n\n    private HashMap\u003cString, FollowAppAction\u003e actions \u003d new HashMap\u003cString, FollowAppAction\u003e();\n\n    private SystemInterface systemInterface;\n\n    private StartupStatus startupStatus;\n\n    private FollowAppAttributes attributes;\n\n    private static FollowApp instance;\n\n    private static ResourceBundle resources \u003d ResourceBundle.getBundle(\"ghm.follow.FollowAppResourceBundle\");\n\n    private JFrame frame;\n\n    // We should remove this hack once JDK 1.4 gets wide adoption on Solaris.\n    static {\n    }\n\n    /**\n     * @param fileNames\n     *            names of files to be opened\n     */\n    FollowApp(List\u003cString\u003e fileNames) throws IOException, InterruptedException, InvocationTargetException {\n    }\n\n    FollowApp(List\u003cString\u003e filenames, File propertyFile) throws IOException, InterruptedException, InvocationTargetException {\n    }\n\n    /**\n     * Close the current tab\n     */\n    public void closeFile();\n\n    /**\n     * Get a string from the resource bundle. Convenience method to shorten and\n     * centralize this common call\n     *\n     * @param key\n     * @return The value of key in the resource bundle. null if the key is not\n     *         found.\n     */\n    public static String getResourceString(String key);\n\n    /**\n     * Gets an image icon from the resource path.\n     *\n     * @param clazz\n     *            The class to use as an entry point to the resource path. Image\n     *            path should be relative to this class.\n     * @param iconNameKey\n     *            The resource key name where the image is defined.\n     * @return An image icon based on the URL generated from the value of\n     *         iconNameKey. null if no URL can be found.\n     */\n    public static ImageIcon getIcon(Class\u003c?\u003e clazz, String iconNameKey);\n\n    /**\n     * Loads the actions used in the application\n     *\n     * @throws IOException\n     */\n    private void loadActions() throws IOException;\n\n    /**\n     * @param jMenuBar\n     */\n    private void initFrame(JMenuBar jMenuBar);\n\n    public void show();\n\n    public FollowAppAction getAction(String name);\n\n    /**\n     * Get all actions associated to the application\n     *\n     * @return\n     */\n    public HashMap\u003cString, FollowAppAction\u003e getActions();\n\n    /**\n     * Set an action to the action map of the application.\n     *\n     * @param name\n     *            The key to set the action to.\n     * @param action\n     *            The action to create an association for.\n     */\n    public void putAction(String name, FollowAppAction action);\n\n    public void openFile(File file) throws FileNotFoundException;\n\n    /**\n     * Warning: This method should be called only from (1) the FollowApp\n     * initializer (before any components are realized) or (2) from the event\n     * dispatching thread.\n     */\n    void openFile(File file, boolean startFollowing) throws FileNotFoundException;\n\n    private void updateActions();\n\n    /**\n     * Warning: This method should be called only from the event dispatching\n     * thread.\n     *\n     * @param cursorType\n     *            may be Cursor.DEFAULT_CURSOR or Cursor.WAIT_CURSOR\n     */\n    public void setCursor(int cursorType);\n\n    // Lazy initializer for the right-click listener which invokes a popup menu\n    private MouseListener getRightClickListener();\n\n    public void enableDragAndDrop(Component c);\n\n    public void disableDragAndDrop(Component c);\n\n    public FileFollowingPane getSelectedFileFollowingPane();\n\n    public List\u003cFileFollowingPane\u003e getAllFileFollowingPanes();\n\n    public FollowAppAttributes getAttributes();\n\n    public Map\u003cFile, FileFollowingPane\u003e getFileToFollowingPaneMap();\n\n    public JFrame getFrame();\n\n    public static FollowApp getInstance();\n\n    public SystemInterface getSystemInterface();\n\n    public void setSystemInterface(SystemInterface systemInterface);\n\n    public JTabbedPane getTabbedPane();\n\n    public static void centerWindowInScreen(Window window);\n\n    /**\n     * Invoke this method to start the Follow application. If any command-line\n     * arguments are passed in, they are assume to be filenames and are opened\n     * in the Follow application\n     *\n     * @param args\n     *            files to be opened\n     */\n    public static void main(String[] args);\n\n    private class RecentFileListener implements PropertyChangeListener {\n\n        public void propertyChange(PropertyChangeEvent evt) {\n            if (recentFilesMenu !\u003d null) {\n                recentFilesMenu.removeAll();\n                List\u003cFile\u003e recentFiles \u003d attributes.getRecentFiles();\n                // descend down the list to order files by last opened\n                for (int i \u003d recentFiles.size() - 1; i \u003e\u003d 0; i--) {\n                    // have to use FollowApp.this because \u0027this\u0027 is now the\n                    // context of\n                    // the inner class\n                    recentFilesMenu.add(new Open(FollowApp.this, recentFiles.get(i)));\n                }\n            }\n        }\n    }\n}\n",
    "package": "ghm.follow",
    "classname": "FollowApp",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FollowApp.java",
    "test_prompt": "// FollowAppTest.java\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowApp}.\n* It contains ten unit test cases for the {@link FollowApp#getIcon(Class, String)} method.\n*/\nclass FollowAppTest {",
    "method_signature": "getIcon(Class, String)",
    "suffix": ""
  }
]