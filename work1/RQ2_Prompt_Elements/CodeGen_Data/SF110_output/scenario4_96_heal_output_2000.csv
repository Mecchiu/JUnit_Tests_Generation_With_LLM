ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
920b8775-2bb7-4871-bc2d-27067883c118,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/approver/ModifyApprovalQueueEntryAction.java,57.2208788394928,length,"// ModifyApprovalQueueEntryAction.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Modifies an approval queue entry.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
public class ModifyApprovalQueueEntryAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ModifyApprovalQueueEntryActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyApprovalQueueEntryAction}.
* It contains one unit test case for the {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyApprovalQueueEntryActionTest {","// ModifyApprovalQueueEntryActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyApprovalQueueEntryAction}.
* It contains one unit test case for the {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyApprovalQueueEntryActionTest {
private final String APPROVE = ""Approval/ApplicationQueue/Queue"";

		/**
		 * Test method for {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()}.
		 */
		@Test
public void test() {
		if (!AuthTools.authorizeApproverOrNonApprover(request(), response(), (String)null)) {
			fail(""Should authorize access for modification of approval queue entries"");
		}
	}

    /**
     * Tests modification of approval queue entry
     */
    @Test
    public void testApprovalQueueEntry() throws IOException, ServletException, Exception {
        HttpServletRequest request = new ModifyApprovalQueueEntryAction.ModifyApprovalQueueEntryRequest(true, APPROVE, ""SomeApplicationQueue/QueueName"", QueueDAO.TABLE);
        HttpServletResponse response = new ModifyApprovalQueueEntryAction.ModifyApprovalQueueEntryResponse(true, APPROVE, false, QueuedRecordBean.TABLE, """");
        final ModifyApprovalQueueEntryAction action = new ModifyApprovalQueueEntryAction();
        assertNotNull(action);
        assertFalse(action.actionRequiresLogin());
        
        final QueuedRecordBean queuedRecord = new QueuedRecordBean();
        request.setParameter(""queueName"", queuedRecord);
        request.setParameter(QueueDAO.FIELD_FIELD_QUEUE_NAME, queuedRecord.getQueueName());
        request.setParameter(""queueFields"", QueuedRecordBean.TABLE);
        request.setParameter((String)null, QueuedRecordBean.FIELD_FIELD_QUEUE_ADDED, queuedRecord.getQueueAddDate());
        final String result = action.perform(request, response);
        assertTrue(""Check number of records added"", queuedRecord.getQueueAddedCount() >= 1);
        queuedRecord.setQueueAddedCount(queuedRecord.getQueueAddedCount() - 1);
        request.setParameter(QueueDAO.FIELD_FIELD_QUEUE_ADDED, queuedRecord.getQueueAddDate());
        final String responseString = action.perform(request, response);
        assertEquals(""Check queue updated"", queuedRecord.getQueueUpdatedDate(), new Date());
        queuedRecord = QueuedRecordBean.loadById(queuedRecord.getQueueAddDate());
        assertNotNull(""Check queue record found"", queuedRecord);
        request.setParameter((String)null, QueuedRecordBean.FIELD_FIELD_QUEUE_UPDATE_DATE, queuedRecord.getQueueUpdateDate());
        final String result2 = action.perform(request, response);
        assertComparing(""Check queue updated"", result, result2);
        
        // clean queue
        request.setParameter(QueueDAO.FIELD_FIELD_QUEUE_REQUEST, request.getParameter(QueueDAO.FIELD_FIELD_QUEUE_REQUEST));
        request.setParameter(QueueDAO.FIELD_FIELD_QUEUE_REQUEST_ID, """");
        final String responseString2 = action.perform(request, response);
        assertEquals(""Check queue request removed"", queuedRecord.getQueueRequest(), """");
    }

	/**
	 * Test set of non-applicable parameters.
	 * @throws ServletException
     */
    @Test
    public void testNonApplicableApprovalQueueValues() throws ServletException {
        HttpServletRequest request = new ModifyApprovalQueueEntryAction.ModifyApprovalQueueEntryRequest(true, APPROVE, ""SampleQueue/QueueName"", QueueDAO.TABLE);
        String[] notApplicableFields = new String[QueueDAO.NUM_FIELDS];
        for (int i=0; i<QueueDAO.NUM_FIELDS; i++) {
            notApplicableFields[i] = QueuedRecordBean.FIELD_FIELD_QUEUE_ADDED;
        }
        HttpServletResponse response = new ModifyApprovalQueueEntryAction.ModifyApprovalQueueEntryResponse((String[])null, 0, true, QueuedRecordBean.TABLE, notApplicableFields);
        final ModifyApprovalQueueEntryAction action = new ModifyApprovalQueueEntryAction();
        assertNotNull(action);
        assertFalse(action.actionRequiresLogin());
        
        final QueuedRecordBean queuedRecord = new QueuedRecordBean();
        request.setParameter(""queueName"", queuedRecord);
        request.setParameter(QueueDAO.FIELD_FIELD_QUEUE_REQUEST_ID, 0);
        final String responseString = action.perform(request, response);
        assertTrue(""Check number of records removed"", queuedRecord.getQueueRequest() == 0);
    }
	/**
	 * Test set of application and non-applicable parameters.
	 * @throws ServletException
     */
    @Test
    public void testApprovalQueueValues() throws ServletException {
        HttpServletRequest request = new ModifyApprovalQueueEntryAction.ModifyApprovalQueueEntryRequest(true, APPROVE, ""SampleQueue/QueueName"", QueueDAO.TABLE);
        String[] availableFields = new String[QueueDAO.NUM_FIELDS];
        for (int i=0; i<QueueDAO.NUM_FIELDS; i++) {
            availableFields[i] = QueuedRecordBean.FIELD_FIELD_QUEUE_ADDED;
            availableFields[i] = QueuedRecordBean.FIELD_FIELD_QUEUE_REQUEST_ID;
        }
        HttpServletResponse response = new ModifyApprovalQueueEntryAction.ModifyApprovalQueueEntryResponse((String[])null, 0, true, QueuedRecordBean.TABLE, availableFields);
        final ModifyApprovalQueueEntryAction action = new ModifyApprovalQueueEntryAction();
        assertNotNull(action);
        assertFalse(action.actionRequiresLogin());
        
        final QueuedRecordBean queuedRecord = new QueuedRecordBean();
        request.setParameter(""queueName"", queuedRecord);
        request.setParameter(QueueDAO.FIELD_FIELD_QUEUE_REQUEST_ID, 0);
        final String responseString = action.perform(request, response);
        assertTrue(""Check number of records removed"", queuedRecord.getQueue"
af34f502-798a-4da7-8b97-c46de4140238,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/approver/ShowApprovalQueueAction.java,54.901922941207886,stop,"// ShowApprovalQueueAction.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * An {@link org.heal.servlet.Action} which fetches the information needed to
 * display the approval queue.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
public class ShowApprovalQueueAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ShowApprovalQueueActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowApprovalQueueAction}.
* It contains one unit test case for the {@link ShowApprovalQueueAction#actionRequiresLogin()} method.
*/
class ShowApprovalQueueActionTest {","// ShowApprovalQueueActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowApprovalQueueAction}.
* It contains one unit test case for the {@link ShowApprovalQueueAction#actionRequiresLogin()} method.
*/
class ShowApprovalQueueActionTest {
@javax.inject.Inject
		QueueDAO dao;
		
	
		RequestDispatcher dispatch;
		@Test
		public void test_actionRequiresLogin() {
			// setup
			// setup expected action result
			String q_id = ""P001"";
			List<ApprovalQueue> approvalQueueList = dao.queryByQueueId(q_id);
			assertEquals(""Unexpected approved queue list"", 1, approvalQueueList.size());
			ApprovalQueue approvalQueue = approvalQueueList.get(0);
			assertEquals(""Unexpected id"", q_id, approvalQueue.getId());
			assertEquals(""Unexpected name"", ""p001"", approvalQueue.getDescription());
			assertNotNull(""Non-null approval queue"", approvalQueue);
			assertFalse(""Null approval queue"", approvalQueue.getName().equals(""p001""));
			assertString(""Unexpected title"", ""P001"", approvalQueue.getHeaderName());
			assertEquals(""Unexpected description"", ""Approval queue name"", approvalQueue.getHeaderDescription());
			assertString(""Unexpected location"", """", approvalQueue.getLocation());
			assertTrue(""Unexpected approval type"", approvalQueue.isApproval());
			Action result = this.actionRequiresLogin();
			List<String> expectedActions = 
			this.dao.queryByName("""");
			assertNotNull(""Unexpected actions"", expectedActions);
			assertFalse(""Unexpected list"", expectedActions.isEmpty());
			
			assertFalse(""Unexpected action result"", result.actionRequiresLogin());
			assertNotNull(""Non-null action results"", result.getActions());
			assertFalse(""Unexpected number of actions"", result.getActions().isEmpty());
		}
		
		/**
		 * Test that the view displays actions based on an approved queue, as expected.
		 */
		private Action actionRequiresLogin() {
			// setup
			AuthenticationTools auth = new AuthenticationTools();
			String admin = ""admin"";
			String name = ""name"";
			String q_name = ""p001"";
			String auth_id = ""123"";
			String description = ""description"";
			String location = ""location"";
			String location_sublocation = ""location sublocation"";
			List<ApprovalQueue> approvalQueueList = dao.queryByQueueId(q_id);

			return new ShowApprovalQueueAction(
				auth.getAuthorization(admin, name, auth_id),
				location,
				location_sublocation,
				q_name
			) {
				
				List<Approval> approvalList = new java.util.AbstractList().toList();
				List<String> expectedActions = 
					this.dao.queryByName("""");
				// query actions for approved queue
				expectedActions = this.dao.queryAllButNot(this.dao.queryAllButByNameAndStatus(this.dao.queryAllButNot(this.dao.queryAllButByNameAndStatus(this.dao.queryByName(this.dao.queryAllButByNameAndStatus(this.dao.queryByDescriptionAndLocation(q_name, location_sublocation), this.dao.queryAllNot(this.dao.queryAllNotAndDescriptionAndLocationNot(this.dao.queryAllByAuthorizationNot(this.dao.queryAllByName(name)), this.dao.queryAllByDescriptionNot(description)))))))).toList();
				
				assertEquals(""Unexpected actions list"", 1, approvalQueueList.size());
				ApprovalQueue approvalQueue = approvalQueueList.get(0);
				assertEquals(""Unexpected name"", q_name, approvalQueue.getHeaderName());
				assertEquals(""Unexpected location"", location, approvalQueue.getHeaderLocation());
				assertEquals(""Unexpected auth type"", this.dao.queryById(auth_id), approvalQueue.getHeaderAuthorization());
				assertEquals(""Unexpected description"", description, approvalQueue.getHeaderDescription());

				if (expectedActions.isEmpty()) {
					fail(""Unexpected actions from result."");
				}

				return (Action) this.dao.queryByName(expectedActions.toArray());
			};
		}
}
"
7a998cd9-2aa8-4bca-98f7-fed343ea51f0,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditContextURLAction.java,55.35481095314026,stop,"// EditContextURLAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Context URL.  If
 * there isn't an existing Context URL which can be found to edit,
 * we assume that a new Context URL should be edited.
 */
public class EditContextURLAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditContextURLActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContextURLAction}.
* It contains one unit test case for the {@link EditContextURLAction#actionRequiresLogin()} method.
*/
class EditContextURLActionTest {","// EditContextURLActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContextURLAction}.
* It contains one unit test case for the {@link EditContextURLAction#actionRequiresLogin()} method.
*/
class EditContextURLActionTest {

	// edit the context URL in the context URL beanutil and make sure it should work
	@Test
	public void testContextURLWithEditPermission() throws IOException, ServletException {
		CompleteMetadataBean completeBean = new CompleteMetadataBean();
		ContextURLBean ctxURLBean = new ContextURLBean(); ctxURLBean.setSiteUrl(""http://curl.com"");
		CompleteMetadataBean completeBean2 = new CompleteMetadataBean();
		CompleteMetadataBean completeBean3 = new CompleteMetadataBean();
		CompleteMetadataBean completeBean4 = new CompleteMetadataBean();
		CompleteMetadataBean completeBean5 = new CompleteMetadataBean();
		CompleteMetadataBean completeBean6 = new CompleteMetadataBean();
		CompleteMetadataBean completeBean7 = new CompleteMetadataBean();
		
		Iterator<MetadataBean> iter = completeBean.iterator();
		Iterator<MetadataBean> iter2 = completeBean2.iterator();
		Iterator<MetadataBean> iter3 = completeBean3.iterator();
		Iterator<MetadataBean> iter4 = completeBean4.iterator();
		Iterator<MetadataBean> iter5 = completeBean5.iterator();
		Iterator<MetadataBean> iter6 = completeBean6.iterator();
		Iterator<MetadataBean> iter7 = completeBean7.iterator();
		
		Action action = new EditContextURLAction();
		
		@SuppressWarnings(""resource"")
		RequestDispatcher mockREQUEST = mock(RequestDispatcher.class);
		
		// Mock requests
		when(mockREQUEST.getContextPath()).thenReturn("""");
		when(mockREQUEST.getPathInfo())
				.thenReturn(""contexturl"");
		when(mockREQUEST.getMatchedURI())
				.thenReturn("""");
		when(mockREQUEST.getQueryString()).thenReturn("""");
		when(mockREQUEST.getQueryString(String.class)).thenReturn("""");
		when(mockREQUEST.getRequestURI())
				.thenReturn(""/contexturl?user=albert"");
		when(mockREQUEST.getServletPath()).thenReturn(""/contexturl"");
		when(mockREQUEST.getAttribute(""ContextPath"")).thenReturn("""");
		when(mockREQUEST.getAttribute(""PathInfo"")).thenReturn("""");
		when(mockREQUEST.getAttribute(""QueryString"")).thenReturn("""");
		when(mockREQUEST.getAttribute(""RequestURI"")).thenReturn("""");
		when(mockREQUEST.getAttribute(""ServletPath"")).thenReturn("""");
		when(mockREQUEST.getAttribute(""RequestURI"")).thenReturn("""");
		when(mockREQUEST.getAttribute(""Path"")).thenReturn(""/contexturl"");
		when(mockREQUEST.getAttribute(String.class)).thenReturn(""Context"");
		when(mockREQUEST.getAttribute(""UserPrincipal"")).thenReturn(""albert"");
		
		int rc=-1;
		
		rc = action.doActionRequest(mockREQUEST, completeBean);
		
		assertEquals(""Expected status "" + rc + "", but got response code "" + rc, rc, rc);
		
		assertEquals(ctxURLBean.getSiteUrl(), completeBean2.getSiteUrl());
		assertEquals(ctxURLBean.getSiteUrl(), completeBean3.getSiteUrl());
		assertTrue(""Expected SiteUrl not equal"", ctxURLBean.getSiteUrl().equals(completeBean_.getSiteUrl()));
		assertEquals(""SiteUrl not equal"", ctxURLBean.getSiteUrl(), ctxURLBean.getSiteUrl2());
		assertEquals(""Expected SiteUrl2 not equal"", ctxURLBean.getSiteUrl(), ctxURLBean.getSiteUrl3());
		
		assertEquals(""Non context URL should be not be equal"",
				!iter == iter2 || 
				!iter!= iter2 || 
				!iter!= iter2 || 
				iter2!= iter3 ||
				!iter2!= iter3 ||
				iter!= iter.next() || 
				iter.hasNext(),
				true);
		
		assertEquals(""Non context URL should be not be equal"",
				!iter2 == iter3 || 
				!iter3!= iter3 || 
				!iter3!= iter5 || 
				iter3.hasNext(),
				true);
		
		assertEquals(""Non context URL should be not be equal"",
				!iter5 == iter4 || 
				!iter4!= iter4 || 
				!iter4!= iter.next() || 
				!iter4.hasNext(),
				false);
		
		assertEquals(""Non context URL should be not be equal"",
				!iter5 == iter.next() || 
				!iter.hasNext(),
				false);
		
		assertEquals(""Non context URL should be not be equal"",
				iter2.hasNext(), true);
		
		assertEquals(""Non context URL should be not be equal"",
				iter3.hasNext(), true);
		
		assertEquals(""Non context URL should be not be equal"",
				iter.hasNext(), true);
		
		assertTrue(""Non context URL should contain 2 contexts"", iter.hasNext());
		assertEquals(""Non context URL should contain a context"",
				iter.next().getPath(), ""/contexturl"");
		
		assertTrue(""Non context URL should contain a context"", iter.hasNext());
		assertEquals(""Non context URL should contain a context2"",
				iter.next().getPath(), ""/contexturl2"");
		
		assertFalse(""Non context URL should be null"", null == iter);
	}
}
"
cc2ea48b-a9c9-419f-bb70-dc78d5c4faa6,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyMetadataAction.java,44.28734540939331,stop,"// ModifyMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>An {@link Action} that saves the metadata from a form into
 * the session's {@link CompleteMetadataBean} by mapping {@link MetadataModifier}s
 * to forms.  The {@link MetadataModifier} which matches the form determines
 * the next {@link Action} to execute.</p>
 *
 * <p>The mapping is currently defined as:</p>
 *
 * <ul><li>'metadata' : {@link MetadataRecordModifier}
 * <li>'contextURL' : {@link ContextURLRecordModifier}
 * <li>'contributor' : {@link ContributorRecordModifier}
 * <li>'copyrightHolder' : {@link CopyrightHolderRecordModifier}
 * <li>'controlledVocabulary' : {@link ControlledVocabularyRecordModifier}
 * <li>'requirement' : {@link RequirementRecordModifier}
 * </ul>
 */
public class ModifyMetadataAction implements Action {

    private final Map modifierMap;

    public ModifyMetadataAction() {
    }

    /**
     * <p>This perform method uses the <code>""type""</code> parameter to save the
     * metadata modifications from the <code>request</code> in the
     * {@link CompleteMetadataBean} that is in the session.  If the type or
     * <code>CompleteMetadataBean</code> doesn't exist, the <code>response</code> is
     * redirected to an error page.</o>
     *
     * <p>When a valid type and a <code>CompleteMetadataBean</code> is available
     * in the session, this method uses the appropriate {@link MetadataModifier}
     * to save the motifications to the metadata and to perform the subsequent
     * {@link Action}.</p>
     */
    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ModifyMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyMetadataAction}.
* It contains one unit test case for the {@link ModifyMetadataAction#actionRequiresLogin()} method.
*/
class ModifyMetadataActionTest {","// ModifyMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyMetadataAction}.
* It contains one unit test case for the {@link ModifyMetadataAction#actionRequiresLogin()} method.
*/
class ModifyMetadataActionTest {
/**
	 * <p>Constructs a {@link ModifyMetadataAction} instance.</p>
	 */
    public ModifyMetadataActionTest() {
    }

	/**
	 * <p>Tests if a {@link ModifyMetadataAction} can be found in the 
	 * {@link javax.servlet.ServletContext}.</p>
	 */
	@Test
	void testModuleIsInTheServletContext() {
		assertNotNull(ModifyMetadataAction.class.getClassFile());
	}

		/**
	 * <p>Tests if the {@link CompleteMetadataBean} can be retrieved in
	 * the request.</p>
	 */
    public void testCompletEmptiness() {
		assertNotNull(""CompleteMetadataBean not found (id=100)"", CompleteMetadataBean.createCompleteMetadataBean(100));
    }
	/**
	 * <p>Tests if a {@link CompleteMetadataBean} can be retrieved in
	 * the request.</p>
	 */
	@Test
	void testCompletEMBWhenModifierAlreadySavedInRequest() {
		Map<String, Object> attributes = Collections.singletonMap(""type"", ""contextURL"");
		String modifiedMetadataBean = CompleteMetadataBean.createCompleteMetadataBean(100).saveMetadataForModifier(new MetadataModifier(""100""));

		CompleteMetadataBean modifiedMetadataBeanRead = CompleteMetadataBean.createCompleteMetadataBean(100).mapFromOriginalMetadata(modifiedMetadataBean);

		assertNotNull(""Should have been able to get CompleteMetadataBean for ID="" + 100, modifiedMetadataBeanRead);
	}
	/**
	 * <p>Tests if a {@link CompleteMetadataBean} can be retrieved in
	 * the request and is changed.</p>
	 */
	@Test
	void testCompletEMB() {
		Map<String, Object> attributes = Collections.singletonMap(""type"", ""contextURL"");

		CompleteMetadataBean modifiedMetadataBean = CompleteMetadataBean.createCompleteMetadataBean(100).mapFromOriginalMetadata(CompleteMetadataBean.createCompleteMetadataBean(100).saveMetadataForModifier(new MetadataModifier(""100"")));
		CompleteMetadataBean modifiedMetadataBeanRead = CompleteMetadataBean.createCompleteMetadataBean(100).mapFromOriginalMetadata(modifiedMetadataBean.saveMetadataForModifier(new MetadataModifier(""600"")));

		assertNotNull(""Should have been able to get CompleteMetadataBean for ID=100"", modifiedMetadataBeanRead);
	}
}

"
155e484b-3c8e-4a8b-a671-efa486062d4c,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/SaveMetadataAction.java,42.60609817504883,length,"// SaveMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Iterator;

/**
 * An {@link org.heal.servlet.Action Action} used to save metadata
 * records.
 */
public class SaveMetadataAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * Since we have been using negative numbers to give unique id's to
     * complicated metadata information, this method will turn all those
     * negative ids back to <code>null</code> values so that the metadata
     * gets saved correctly.
     *
     * @param cmb The {@link CompleteMetadataBean} to scrub.
     */
    private void scrubMetadata(CompleteMetadataBean cmb);

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// SaveMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SaveMetadataAction}.
* It contains one unit test case for the {@link SaveMetadataAction#actionRequiresLogin()} method.
*/
class SaveMetadataActionTest {","// SaveMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SaveMetadataAction}.
* It contains one unit test case for the {@link SaveMetadataAction#actionRequiresLogin()} method.
*/
class SaveMetadataActionTest {

	/**
	 * @return <code>true</code>
	 */
	@Test
	public void actionRequiresLogin_mustReturnTrue_false_ifUserDoesNotHaveSystemAccess() throws PermissionException {
		saveMetadata(null, null, null, null);
		assertFalse(actionRequiresLogin());
	}

	/**
	 * @return <code>true</code>
	 */
	@Test
	public void actionRequiresLogin_mustReturnTrue_false_ifUserDoesNotHaveSystemAccess() throws PermissionException {
		saveMetadata(new MetametadataIdentifierBean(""metametadataID"", ""metametadata"", """", """"));
		assertFalse(actionRequiresLogin());
	}

	/**
	 * @return <code>true</code>
	 */
	@Test
	public void actionRequiresLogin_mustReturnTrue_false_ifUserDoesNotHaveSystemAccess() throws PermissionException {
		saveMetadata(new MetametadataIdentifierBean(""metametadataID"", ""metametadata"", """", """"));
		assertFalse(actionRequiresLogin());
	}

	/**
	 * @return <code>true</code>
	 */
	@Test
	public void actionRequiresLogin_mustReturnTrue_false_ifUserDoesNotHaveSystemAccess_andHasCustomAuthorization() throws SQLException, PermissionException, IOException {
		MetametadataBean mb = new MetametadataContributorBean(""mbeanID"", ""mbean"", """", null);
		mb.setIdentifier(new MetametadataIdentifierBean(mb.getIdentifierType(), ""mbeanid"", """", """"));
		mb.setAuthorizable(false);
		mb.setAuthorization(Authorization.COPY_TO_ALL);
		mb = new MetametadataIdentifierBean(mb.getIdentifierType(), ""mbeanID"", """", """");
		
		// First, remove all the authorization
		// If the user has ""Custom"" authorization, we can't save
		// mb because that would be the only way to make it ""copied"" and
		// get more authorizable metadata
		//assertAuthorizationNotAppearingForAnyMbean(mb);
		
		String mb_id = mb.getIdentifier().getID();
		RequestDispatcher rd_mbean = request.createDispatch(""javax.sql.DataSource"", ""GET_ALL_METADATA"", rd_);
		rd_mbean.forward(request, response);
		
		CompleteMetadataBean mmb = new CompleteMetadataBean(); 
		mmb.setMetametadata(mb);
		saveMetadata(mmb);
		checkMetadataContainsAllMbeans(mb.getMetametadata());
		
		// Now make sure the old authorizer cannot copy mbeans
		assertThrowAuthorization(mb.getIdentifier(), Authorization.COPY_TO_ALL);
		
		// First, remove it
		Iterator<Iterable<MetametadataIdentifierBean>> itrs = mb.getMetametadata().iterator();
		while (itrs.hasNext()) {
			itrs.next();
			itrs.remove();
		}
		
		assertThrowAuthorization(mb.getIdentifier(), Authorization.COPY_TO_ALL);
		
		System.out.println(""Copied metadata for mbean "" + mb_id + ""."");
		mmb.setIdentifier(mb.getIdentifier());
		saveMetadata(mmb);
		checkMetadataContainsAllMbeans(mb.getMetametadata());
		
	}
	
	/**
	 * @return <code>true</code>
	 */
	private boolean assertAuthorizationNotAppearingForAnyMbean(CompleteMetadataBean mbe) {
		boolean found = false;
		Iterator<Iterable<MetametadataIdentifierBean>> itrs = mbe.getMetametadata().iterator();
		while (!found && itrs.hasNext()) {
			itrs.next();
			itrs.remove();
		}
		return found;
	}

	/**
	 * Check if the given metadata container also contains <code>'Metametadata.containsMetadata(Metametadata.IDENTIFIER)'</code> method
	 *
	 * @param mb the complete metadata
	 * @throws PermissionException if the metadata container doesn't contain metadata of identifier 'Identifier'
	 * @throws SQLException
	 * @throws ClassCast"
f967adb2-a388-43ec-bdcf-49678f95807d,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/CreateMetadataAction.java,46.00742506980896,length,"// CreateMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * An {@link Action} which creates a new metadata record to edit,
 * puts it into the session, and then directs the user to the editing
 * page.
 */
public class CreateMetadataAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * Since this {@link Action} creates <em>new</em> metadata records, we
     * must clear the ids from an existing {@link CompleteMetadataBean} that
     * this new record is based on.
     *
     * @param cmb
     */
    private static void clearIds(CompleteMetadataBean cmb) throws ServletException;

    private static void clearIdsFromList(List objects) throws ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// CreateMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CreateMetadataAction}.
* It contains one unit test case for the {@link CreateMetadataAction#actionRequiresLogin()} method.
*/
class CreateMetadataActionTest {","// CreateMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CreateMetadataAction}.
* It contains one unit test case for the {@link CreateMetadataAction#actionRequiresLogin()} method.
*/
class CreateMetadataActionTest {

	private static void createCompleteMetadataBean(String name) {
		CompleteMetadataBean completeMetadataBean = new CompleteMetadataBean();
		CompleteMetadataBean toBeDeletedCompleteMetadataBean = new CompleteMetadataBean();
		Map<String, Object> completeMetadataBeanAndProperties = new HashMap<>();
		completeMetadataBeanAndProperties.put(""id"", name);
		completeMetadataBeanAndProperties.put(""created"", String.format(""2013-06-08T12:52:57.000""));
		completeMetadataBeanAndProperties.put(""category"", name);
		completeMetadataBean.setCompleteMetadataBeanAndProperties(completeMetadataBeanAndProperties);
		completeMetadataBeanAndProperties.clear();
		completeMetadataBeanAndProperties.put(MetadataDAO.FULLMATCH, new Integer(1));
		completeMetadataBeanAndProperties.put(MetadataDAO.SUMMATCH, new Integer(1));
		completeMetadataBeanAndProperties.put(MetadataDAO.LATESTVERSION, new Integer(1));
		completeMetadataBean.setCompleteMetadataBeanAndProperties(completeMetadataBeanAndProperties);
		CompleteMetadataBean completeMetadataBeanFromServer = new CompleteMetadataBean();
		Map<String, Object> completeMetadataBeanAndPropertiesFromServer = completeMetadataBeanFromServer.getCompleteMetadataBeanAndProperties();
		completeMetadataBeanAndPropertiesFromServer.put(MetadataDAO.FULLMATCH, new Integer(3));
		completeMetadataBeanAndPropertiesFromServer.put(MetadataDAO.LATESTVERSION, new Integer(3));
		completeMetadataBeanAndPropertiesFromServer.put(MetadataDAO.SUMMATCH, new Integer(5));
		completeMetadataBeanAndPropertiesFromServer.put(MetadataDAO.NODECOUNT, 1009);
		completeMetadataBeanAndPropertiesFromServer.put(MetadataDAO.UNKNOWN1, new Integer(50000));
		completeMetadataBeanAndPropertiesFromServer.put(MetadataDAO.UNKNOWN2, new Integer(20000));
		completeMetadataBeanAndPropertiesFromServer.put(MetadataDAO.UNKNOWN3, new Integer(20001));
		completeMetadataBeanAndProperties.putAll(completeMetadataBeanAndPropertiesFromServer);
		completeMetadataBean.setCompleteMetadataBeanAndProperties(completeMetadataBeanAndProperties);
		List<Map<String, Object>> completeMetadataBeansList = new ArrayList<>();
		completeMetadataBeansList.add(completeMetadataBean.getCompleteMetadataBeanAndProperties());
		createCompleteMetadataBean(name);
		completeMetadataBeanAndProperties.remove(MetadataDAO.FULLMATCH);
		completeMetadataBeanAndProperties.remove(MetadataDAO.LATESTVERSION);
		completeMetadataBeanAndProperties.remove(MetadataDAO.SUMMATCH);
		completeMetadataBeanAndProperties.remove(MetadataDAO.NODECOUNT);
		completeMetadataBeanAndProperties.remove(MetadataDAO.UNKNOWN1);
		completeMetadataBeanAndProperties.remove(MetadataDAO.UNKNOWN2);
		completeMetadataBeanAndProperties.remove(MetadataDAO.UNKNOWN3);
		Map<String, Object> toBeDeletedCompleteMetadataBeanAndProperties = completeMetadataBeanAndProperties.get(MetadataDAO.toBeDeletedCompleteMetadataBean);
		toBeDeletedCompleteMetadataBeanAndProperties.remove(MetadataDAO.FULLMATCH);
		toBeDeletedCompleteMetadataBeanAndProperties.remove(MetadataDAO.TZID);
		completeMetadataBeanAndProperties.remove(MetadataDAO.FULLMATCH);
		completeMetadataBeanAndPropertiesAndServer.put(MetadataDAO.toBeDeletedCompleteMetadataBean, toBeDeletedCompleteMetadataBean);
		createCompleteMetadataBean(name);	
		System.out.println(""Totally processed "" + completeMetadataBeansList.size() + "" complete metadata beans"");
		List<String> nonDeletedCompleteMetadataBeans = completeMetadataBeansList.stream()
				.filter(completeMetadataBean ->!completeMetadataBean.getCompleteMetadataBeanServer().getCompleteMetadataBeanAndProperties().containsKey(MetadataDAO.toBeDeletedCompleteMetadataBean.getCompleteMetadataBeanAndProperties().get(MetadataDAO.FULLMATCH)))
				.map(CompleteMetadataBeanDAO::getIncompleteMetadataBeanAndName)
				.filter(x ->!x.getCompleteMetadataBeanServer().getCompleteMetadataBe"
cea43e55-8ded-4dec-93d9-6c0c9e9735b1,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyCatalogQueueEntryAction.java,47.2856879234314,length,"// ModifyCatalogQueueEntryAction.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.FileLocator;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.sql.SQLException;

/**
 * An {@link org.heal.servlet.Action Action} which is called in order to edit a metadata item which is in
 * the catalog queue.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @version 1.0
 */
public class ModifyCatalogQueueEntryAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * Copies a file from a sourceLocation to a destinationLocation.
     *
     * @param sourceLocation
     * @param destinationLocation
     */
    private static void copyFile(String sourceLocation, String destinationLocation);

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ModifyCatalogQueueEntryActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.FileLocator;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.sql.SQLException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyCatalogQueueEntryAction}.
* It contains one unit test case for the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyCatalogQueueEntryActionTest {","// ModifyCatalogQueueEntryActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.FileLocator;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.sql.SQLException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyCatalogQueueEntryAction}.
* It contains one unit test case for the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyCatalogQueueEntryActionTest {

	/**
	 * @exclude
	 * @description Tests method {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()}.
	 */
	@org.junit.jupiter.api.Disabled
	@Test
	public void testActionRequiresLogin() throws SQLException, IOException, ServletException {

    
		QueueDAO queueDAO = new QueueDAO();
		
		String metadataFileBaseLocation = FileLocator.getFileFolder_AbsolutePath() + ""/metadata/"";
		String catalogFileBaseLocation = FileLocator.getFileFolder_AbsolutePath() + ""/files/"";
		File metadataBase = FileLocator.getFile(FileLocator.getMetadataDirectory() + FileLocator.metadataFilename);
		File catalogBase = FileLocator.getFile(FileLocator.getCatalogDirectory() + FileLocator.catalogFilename);

		// initialize queue with one queue record
		QueuedRecordBean record = new QueuedRecordBean();
		QueuedRecordBean newRecord = new QueuedRecordBean();
		
		newRecord.setRecordLocation(metadataFileBaseLocation);
		newRecord.setQueueLocation(catalogFileBaseLocation);
		
		//set the short metadata.  Note that this is how we set the queue
		String metadataString =  ""<short>"" + 
    			                        ""<string>"" + 
    			                        ""<value>"" + 
    			                        ""<long>"" + 
    			                        ""<long>"" + 
    			                        ""<reference-id>"" + // reference Id
    			                        ""<string-id>"" + // string Id
    			                        ""<long>"" + 
    			                        ""</string></short>"" + 
    			                        ""</string></short>"" + 

    			    		""</short>"";
    		newRecord.setShortMetadata(datatypeToShort( metadataString ));
    		record.addRecord(newShortMetadataRecordBean(newRecord.getShortMetadata()), newRecord);
    		
    		record.setQueueLocation(catalogFileBaseLocation + catalogFileBaseLocation);
    		
    		// Add a new record with a new short Metadata.
    		newRecord.setQueueLocation(catalogFileBaseLocation + catalogFileBaseLocation + ""/"" + catalogFileBaseLocation + ""/test1x.txt"");
    		record.addRecord(newRecord.getShortMetadata(), newRecord);
    		
    		record.setQueueLocation(catalogFileBaseLocation + catalogFileBaseLocation + ""/"" + catalogFileBaseLocation + ""/"" + catalogFileBaseLocation + ""/test1x"");
    		
    		// Add the same long id to the record for this shortMetadataItem.
    		newRecord.setQueueLocation(catalogFileBaseLocation + catalogFileBaseLocation
    		                                  + catalogFileBaseLocation + ""/""
    		                                  + catalogFileBaseLocation + ""/""
    		                                  + catalogFileBaseLocation + ""/test1x"");
    		
    		// Add the same short id to the record for this shortMetadataItem.
    		newRecord.setQueueLocation(catalogFileBaseLocation + catalogFileBaseLocation
    		                                  + catalogFileBaseLocation + ""/""
    		                                  + catalogFileBaseLocation + ""/""
    		                                  + catalogFileBaseLocation + ""/""
    		                                  + catalogFileBaseLocation
    		                                  + catalogFileBaseLocation + ""/test1x"");
    		
    		//Add a new record with a new short Metadata.
    		record.setQueueLocation(catalogFileBaseLocation + catalogFileBaseLocation
    		                                  + catalogFileBaseLocation + ""/""
    		                                  + catalogFileBaseLocation + ""/""
    		                                  + catalogFileBaseLocation + ""/""
    		                                  + catalogFileBaseLocation + ""/test1x"");

        try {
	
        	// Create test file and write some metadata records
	        File tempFile = File.createTempFile(""metadatatest"", null);
	        FileOutputStream fos = new FileOutputStream(tempFile);
	        fos.write(metadataString.getBytes());
	        fos.close();
	        FileChannel channel = new FileInputStream(tempFile).getChannel();
	        fos = new FileOutputStream(metadataBase +""/"" + catalogFileBaseLocation + ""/test1x.txt"");
	        channel.transferFrom(fos, channel.size());
	
            // Delete this test file
            fos.close();

        	fos = new FileOutputStream(metadataBase +""/"" + catalogFileBaseLocation + ""/"" + catalogFileBaseLocation + ""/"" + catalogFileBaseLocation + ""/"" + catalogFileBaseLocation + ""/test1x"").getChannel();
	        channel.transferFrom(fos, channel.size());

        	// Copy the file to a test file and delete.
        	//Copy the file to a test file and delete.
	        FileSource src = new FileSource(tempFile);
	        CopySource source = new CopySource(src);
	        FileTarget target = new FileTarget(tempFile);
	        CopymapSource.copyMappings(target);
	        
		
	    	Thread.sleep(1000);
	        "
15b4cbd4-6c8c-4a61-b5c4-b38a791d41b4,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/RelationRecordModifier.java,51.51597452163696,length,"// RelationRecordModifier.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.CompleteMetadataBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;

/**
 * Saves changes to a {@link RelationBean} and acts as
 * an {@link Action} which is called to edit a Relation.  If
 * there isn't an existing Relation which can be found to edit,
 * we assume that a new Relation should be edited.
 */
public class RelationRecordModifier implements Action, MetadataModifier {

    private static Action NEXT_ACTION = new EditMetadataAction();

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();

    public void updateMetadata(CompleteMetadataBean cmb, ServletRequest request);

    public Action getNextAction(ServletRequest request);

    private RelationBean findRelationBean(final List relations, final String relationId);
}
","// RelationRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.CompleteMetadataBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RelationRecordModifier}.
* It contains one unit test case for the {@link RelationRecordModifier#actionRequiresLogin()} method.
*/
class RelationRecordModifierTest {","// RelationRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.CompleteMetadataBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RelationRecordModifier}.
* It contains one unit test case for the {@link RelationRecordModifier#actionRequiresLogin()} method.
*/
class RelationRecordModifierTest {

  /**
  * Asserts that nothing is added or removed
  * than ""this is a comment"".
  */
  @Test
  void testRemoveAndAdd() {
      RelationBean br = new RelationBean();
      br.setId(""1"");


      List records = new List();
      List r = new List();
      r = new List();
      br.records.add(records);
      br.records.add(r);
      br.records.add(records);

      br.updated = 7;
      br.changes.add(""this is a comment"");

      List expected = new List();
      expected.add(""-11"");
      expected.add(""-10"");
      expected.add(""-9"");
      expected.add(""-8"");
      expected.add(""-7"");
      expected.add(""-6"");
      expected.add(""-5"");      
      expected.add(""-4"");
      expected.add(""-3"");
      expected.add(""-2"");
      expected.add(""-1"");
      expected.add(""1"");      

      RelationBean result = new RelationBean();
      result.records = br.records;
      result.updated = br.updated;
      result.changes = br.changes;
      expected.iterator().next();
      assertEquals(expected, result.records);
      assertEquals(expected.size(), result.records.size());
  }

  /**
  * Asserts that only the changes are added
  */
  @Test
  void testSaveAndRollback() {
      RelationBean br = new RelationBean();
      br.setId(""1"");


      List records = new List();
      List r = new List();
      r = new List();
      br.records.add(records);
      br.records.add(r);
      br.records.add(records);

      br.changes.add(""a=b"");

      List expected = new List();
      expected.add(""a=b"");

      RelationBean result = new RelationBean();
      result.records = br.records;
      result.changes = br.changes;
      expected.iterator().next();
      assertEquals(expected, result.records);
      assertEquals(expected.size(), result.records.size());
      br.updated = 7;
      br.changes.clear();
      RelationBean result1 = new RelationBean();
      result.changes = br.changes;
      assertEquals(expected.size(), result.changes.size());      
  }

  /**
  * Asserts that only the changes are added
  * than the new one.
  */
  @Test
  void testRollbackAndAdd() {
      RelationBean br = new RelationBean();
      br.setId(""1"");


      List records = new List();
      List r = new List();
      r = new List();
      br.records.add(records);
      br.records.add(r);
      br.records.add(records);

      br.changes.add(""a=b"");


      List expected = new List();
      expected.add(""a=b"");

      RelationBean result = new RelationBean();
      result.records = br.records;
      result.changes = br.changes;
      expected.iterator().next();
      assertEquals(expected, result.records);
      assertEquals(expected.size(), br.records.size());      
  }

  /**
  * Asserts that only the changes are added
  */
  @Test
  void testCreateAndRollback() {
      RelationBean br = new RelationBean();
      br.setId(""1"");


      List records = new List();
      List r = new List();
      r = new List();
      br.records.add(records);
      br.records.add(r);
      br.records.add(records);

      br.changes.add(""a=b"");


  	final CompleteMetadataBean cb = new CompleteMetadataBean();
	  cb.setId(""a"");
	  cb.setName(""b"");
	  cb.setDescription(""c"");
	  cb.setUnit(1D);
	  cb.setDefaultValue(""d"");

	  br.changes.add(cb);
      br.updated = 7;
      br.changes.remove(""a=b*"");

      
      List expected = new List();
      expected.add(""-a=b"");
      expected.add(""-d=c"");

      
      RelationBean result = new RelationBean();
      result.records = br.records;
      result.changes = br.changes;
      expected.iterator().next();
      assertEquals(expected, result.records);
      assertEquals(expected.size(), result.records.size());      

  }

  
  /**
  * Asserts that the old relation doesn't exist
  */
  @Test
  void testCreateNewOldRecord() throws Exception {
      
      RelationBean br = new RelationBean();
      br.setId(""1"");

      List records = new List();
      List r = new List();
      r = new List();
      br.records.add(records);
      br.records.add(r);
      br.records.add(records);

      br.changes.add(""a=b"");

      final CompleteMetadataBean cb = new CompleteMetadataBean();
      cb.setId(""b"");
      cb.setName(""c"");
      cb.setDescription(""d"");"
43584b53-69fa-4dc4-87ab-97d30dd16e31,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/CancelEditMetadataAction.java,56.69854164123535,stop,"// CancelEditMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;

/**
 * A simple {@link Action} which clears the session variable used
 * for editing metadata.
 */
public class CancelEditMetadataAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>false</code>
     */
    public boolean actionRequiresLogin();
}
","// CancelEditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CancelEditMetadataAction}.
* It contains one unit test case for the {@link CancelEditMetadataAction#actionRequiresLogin()} method.
*/
class CancelEditMetadataActionTest {","// CancelEditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CancelEditMetadataAction}.
* It contains one unit test case for the {@link CancelEditMetadataAction#actionRequiresLogin()} method.
*/
class CancelEditMetadataActionTest {

    @Test
    public void testIsRunThrough() throws Exception {							
        Auths auths = AuthenticationTools.runAsyncAndGetAuthorization(
				      this.getClass().getResource(""/../Auths.properties""));
		Auths.AuthorizationRequest authReq = Auths.getAuthorizationRequest(auths);
		CancelEditMetadataAction authAction = CancelEditMetadataAction.class;
		boolean result = authAction.actionRequiresLogin() && (authReq == authAction.getAuthRequest());
		assertTrue(result);
    }
}
"
4f3f00ff-9237-41f4-b342-a63ecabf6b3b,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditControlledVocabularyAction.java,53.84510540962219,stop,"// EditControlledVocabularyAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Controlled Vocabulary item.  If
 * there isn't an existing Controlled Vocabulary item which can be found to edit,
 * we assume that a new Controlled Vocabulary entry should be edited.
 */
public class EditControlledVocabularyAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditControlledVocabularyActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditControlledVocabularyAction}.
* It contains one unit test case for the {@link EditControlledVocabularyAction#actionRequiresLogin()} method.
*/
class EditControlledVocabularyActionTest {","// EditControlledVocabularyActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditControlledVocabularyAction}.
* It contains one unit test case for the {@link EditControlledVocabularyAction#actionRequiresLogin()} method.
*/
class EditControlledVocabularyActionTest {

    /**
     * Unit test case for {@link EditControlledVocabularyAction#actionRequiresLogin()}.
     * Makes sure that we are getting an error when we have no item on a page which can be edited.
     */
	@Test
	public void getNoItem() {
					
		// This should fail as the user has no edit rights for this item
		HttpServletRequest currentRequest = new HttpServletRequest(""GET"", ""/home"");
		EditorResponse response = new EditorResponse();
		Iterator<CompleteMetadataBean> it = BookCatalogs.getBookCatalogs().getCompleteMetadataBeans();
		assertFalse(it.hasNext());
		response.renderEditor(currentRequest, null);
		assertNotNull(response.getErrorMessage());
	}
	
	/**
     * Unit test case for {@link EditControlledVocabularyAction#actionRequiresLogin()}.
     * Makes sure that we are getting an error when the user cannot edit a Controlled Vocabulary item.
     */
	@Test
	public void notEditable() {
		
		// This should fail as the user cannot edit any item on a page which can be edited
        HttpServletRequest currentRequest = new HttpServletRequest(""GET"", ""/home"");
        EditorResponse response = new EditorResponse();
        Iterator<CompleteMetadataBean> it = BookCatalogs.getBookCatalogs().getCompleteMetadataBeans();
		assertTrue(it.hasNext());
		response.renderEditor(currentRequest, null);
		boolean isItemEditable = response.getMetadataItemByPath(""name"").canEdit();
		assertTrue(!isItemEditable);
		response.renderEditor(currentRequest, null);
		assertTrue(isItemEditable);
		response.renderEditor(currentRequest, null);
		isItemEditable = response.getTaxon().canEdit();
		assertFalse(!isItemEditable);
	}
	
	/**
     * Unit test case for {@link EditControlledVocabularyAction#isLoginAuthorized()}.
     * Makes sure that we are getting an error when the user isn't logind on the page.
	 */
	@Test
	public void nonLoginPageError() {
		
		// This should fail as the user isn't on the edit page
		HttpServletRequest currentRequest = new HttpServletRequest(""GET"", ""/edit"");
		EditorResponse response = new EditorResponse();
        Iterator<CompleteMetadataBean> it = BookCatalogs.getBookCatalogs().getCompleteMetadataBeans();
		assertFalse(it.hasNext());
		response.renderEditor(currentRequest, null);
		boolean isItemEditable = response.getMetadataItemByPath(""name"").canEdit();
		boolean isTaxonEditable = response.getTaxon().canEdit();
		boolean statusCode = response.getStatusCode();
		assertTrue(!isItemEditable);
		assertTrue(!isTaxonEditable);
		assertTrue(!statusCode);
		response.renderLoginPage(currentRequest, null);
		response.renderLoginPage(currentRequest, null);
		assertTrue(isItemEditable);
		assertTrue(isTaxonEditable);
		assertTrue(!statusCode);
		response.renderLoginPage(currentRequest, null);
		assertTrue(isItemEditable);
		response.renderLoginPage(currentRequest, null);
		assertFalse(isItemEditable);
		response.renderLoginPage(currentRequest, null);
		assertTrue(isItemEditable);
		assertTrue(!isTaxonEditable);
		response.renderLoginPage(currentRequest, null);
		assertTrue(isItemEditable);
		assertTrue(isTaxonEditable);
		assertTrue(!statusCode);
		response.renderLoginPage(currentRequest, null);
		assertTrue(!isItemEditable);
		assertTrue(!isTaxonEditable);
		assertTrue(!statusCode);
		response.renderLoginPage(currentRequest, null);
		assertTrue(isItemEditable);
	}
	
}"
7caa60ef-68e5-4793-8d61-20f1ef00a80a,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/MetadataRecordModifier.java,35.05446648597717,length,"// MetadataRecordModifier.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.CopyrightTextBean;
import org.heal.module.metadata.DiseaseDiagnosisBean;
import org.heal.module.metadata.FormatBean;
import org.heal.module.metadata.KeywordBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.ThumbnailBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.servlet.Action;
import org.heal.util.DateTools;
import javax.servlet.ServletRequest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * <p>A {@link MetadataModifier} which fills the basic metadata information
 * from a <code>ServletRequest</code> into a {@link CompleteMetadataBean}.</p>
 */
public class MetadataRecordModifier implements MetadataModifier {

    private static final Map nextActionMap;

    private static final Action NEXT_ACTION_DEFAULT = new EditMetadataAction();

    static {
    }

    public MetadataRecordModifier() {
    }

    public void updateMetadata(CompleteMetadataBean cmb, ServletRequest request);

    /**
     * @param request Used to get the parameter <code>""nextAction""</code>, which
     * 		determines what the next {@link Action} to take will be.  If no
     * 		<code>""nextAction""</code> exists, a valid {@link Action} will still
     * 		be returned.
     * @return The next {@link Action} to take after saving the metadata from
     * 		the form.
     */
    public Action getNextAction(ServletRequest request);
}
","// MetadataRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.CopyrightTextBean;
import org.heal.module.metadata.DiseaseDiagnosisBean;
import org.heal.module.metadata.FormatBean;
import org.heal.module.metadata.KeywordBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.ThumbnailBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.servlet.Action;
import org.heal.util.DateTools;
import javax.servlet.ServletRequest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MetadataRecordModifier}.
* It contains one unit test case for the {@link MetadataRecordModifier#getNextAction(ServletRequest)} method.
*/
class MetadataRecordModifierTest {","// MetadataRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.CopyrightTextBean;
import org.heal.module.metadata.DiseaseDiagnosisBean;
import org.heal.module.metadata.FormatBean;
import org.heal.module.metadata.KeywordBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.ThumbnailBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.servlet.Action;
import org.heal.util.DateTools;
import javax.servlet.ServletRequest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MetadataRecordModifier}.
* It contains one unit test case for the {@link MetadataRecordModifier#getNextAction(ServletRequest)} method.
*/
class MetadataRecordModifierTest {
/**
     * Set up a unit test.
     */
    @Test
    public void test() {
        final MetadataRecordModifier.MetadataRecordBean mrb = new MetadataRecordModifier.MetadataRecordBean(
                ""name"", ""desc"", ""http://example.ch"",
                false, DateTools.getNextYearMonthDay(""2014-01""), ""2007/06"");
        final List<CompleteMetadataBean> cbs = new ArrayList<CompleteMetadataBean>(10);
        cbs.add(new CompleteMetadataBean(
                ""Contrib1"",
                ""Contrib Name1"",
                null));
        cbs.add(new CompleteMetadataBean(
                ""Contrib2"",
                ""Contrib Name 2"",
                null));
        final List<TaxonPathBean> tpb = new ArrayList<TaxonPathBean>(3);
        tpb.add(new TaxonPathBean(
                             ""Taxon Name1"",
                             ""Taxon Name 2"",
                             null));
        tpb.add(new TaxonPathBean(
                             ""Taxon Name2"",
                             ""Taxon Name 3"",
                             null));
        final List<ThumbnailBean> tb = new ArrayList<ThumbnailBean>(2);
        tb.add(new ThumbnailBean(
                             ""Image URL1"",
                             ""SVG"",
                             150));
        tb.add(new ThumbnailBean(
                             ""Image URL2"",
                             ""SVG"",
                             100));
        final List<String> cts = new ArrayList<String>(2);
        cts.add(""Author Name"");
        cts.add(null);
        final SortedSet<Source> ss = new TreeSet<Source>();
        ss.add(new Source(""Author URL"", ""Image URL1"", 30.0));
        ss.add(new Source(""Author URL"", ""Image URL2"", -20.0));
        ss.add(new Source(""Original"", ""Original URL"", 25.0));
        tpb.add(new TaxonPathBean(
                             ""Taxon Name2"",
                             """",
                             Collections.singleton(MetametadataIdentifierBean.TAXON_PATH_URL_SENTIR)));
        final List<SortedSet<TargetUserGroupBean>> ass = new ArrayList<SortedSet<TargetUserGroupBean>>(3);
        final SortedSet<TargetUserGroupBean> ags1 = new TreeSet<TargetUserGroupBean>();
        ags1.add(new TargetUserGroupBean(
                             ""TG1"",
                             ""TG Name 1"",
                             ""TG Group 1""));
        ags1.add(new TargetUserGroupBean(
                             ""TG1"",
                             ""TG Name 1"",
                             ""TG Group 2""));
        ags1.add(new TargetUserGroupBean(
                             ""TG1"",
                             ""TG Name 1"",
                             ""TG Group A""));
        final SortedSet<TargetUserGroupBean> ags2 = new TreeSet<TargetUserGroupBean>();
        ags2.add(new TargetUserGroupBean(
                             ""TG2"",
                             ""TG Name 2"",
                             ""TG Group 1""));
        ags2.add(new TargetUserGroupBean(
                             ""TG2"",
                             ""TG Name 2"",
                             ""TG Group 2""));
        final SortedSet<TargetUserGroupBean> ags3 = new TreeSet<TargetUserGroupBean>();
        ags3.add(new TargetUserGroupBean(
                             ""TG"
2cc6e20c-effd-4be8-b11b-9aa7cc283157,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditMetadataAction.java,48.14547896385193,stop,"// EditMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.VCardBean;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

/**
 * An {@link org.heal.servlet.Action Action} used to edit metadata
 * records.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @version 1.0
 */
public class EditMetadataAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.VCardBean;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditMetadataAction}.
* It contains one unit test case for the {@link EditMetadataAction#actionRequiresLogin()} method.
*/
class EditMetadataActionTest {","// EditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.VCardBean;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditMetadataAction}.
* It contains one unit test case for the {@link EditMetadataAction#actionRequiresLogin()} method.
*/
class EditMetadataActionTest {
public static class TestAction extends AbstractAction implements Action{
			public TestAction() {
				super();
			}

			public void perform(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
			  request.getRequestDispatcher(""index.jsp"").forward(request, response);
			}		

			public boolean actionRequiresLogin() {
				return true;
			}		
		}
		
		@Test
		public void testPost() throws Exception {
				TestAction tester = new TestAction();
				ServletRequestAdapter adapter = new ServletRequestAdapter(request, response, tester);	    	
				Map attributes = new HashMap();
				attributes.put(""firstname"",""John"");
				attributes.put(""lastname"",""McDonald"");
				Map responseMap =  AdmTools.buildAttributes(request, response, attributes);
					assertEquals(""javax.servlet.http.HttpServletResponse#write(int) return"", HTTP_OK, responseMap.get(HttpServletResponse.class).
							getResponseCode());
					System.out.println(""Successfully tested the EditMetadataAction with valid values"");
		}



}
"
e9e34888-e5be-4fa9-9fb5-1fffd6423672,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditContributorAction.java,55.36470293998718,stop,"// EditContributorAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContributorBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Contributor.  If
 * there isn't an existing Contributor which can be found to edit,
 * we assume that a new Contributor should be edited.
 */
public class EditContributorAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditContributorActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContributorBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContributorAction}.
* It contains one unit test case for the {@link EditContributorAction#actionRequiresLogin()} method.
*/
class EditContributorActionTest {","// EditContributorActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContributorBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContributorAction}.
* It contains one unit test case for the {@link EditContributorAction#actionRequiresLogin()} method.
*/
class EditContributorActionTest {
/**
		* Test method for {@link EditContributorAction#actionRequiresLogin()}.
		*/
	@Test
	public void testActionRequiresLogin() {
		assertEquals(false, EditContributorAction.actionRequiresLogin());
	}

	/**
	 * Test method for {@link EditContributorAction#perform(HttpServlet, HttpServletRequest, HttpServletResponse)}.
	 * @throws javax.servlet.ServletException
	 */
	@Test
	public void testPerform() throws ServletException {
		// setup
		ContributorBean beanA;
		CompleteMetadataBean metadata;
		Action.ErrorResponse res;
		Iterator<ContributorBean> i;
		Iterator<CompleteMetadataBean> j;
		// perform
		i = EditContributorAction.perform(EditContributorAction.class, request, response);
		// assert
		assertNotNull(i);
		assertTrue(i.hasNext());
		beanA = i.next();
		metadata = EditContributorAction.metadataService.save(beanA, true);
		res = EditContributorAction.errorResponseService.saveBeanContent(beanA);	
		// assert
		assertNotNull(metadata);
		assertNotNull(res);
		assertEquals(EditContributorAction.errorResponseService.errorSaved, res);	
		// test for a success condition
		i.next();
		j = EditContributorAction.metadataService.findAll();
		assertEquals(EditContributorAction.metadataService.count(), EditContributorAction.errorResponseService.errorCount, EditContributorAction.errorResponseService.errorCount);
		// the error should NOT be set
		assertTrue(EditContributorAction.errorResponseService.getError()==null);
		EditContributorAction.dataService.getMetaData(EditContributorAction.dataName, beanA, true);	
		// test for a successful condition
		i.next();
		j = EditContributorAction.metadataService.findAll();
		assertFalse(EditContributorAction.metadataService.hasData(EditContributorAction.dataName));
		assertEquals(EditContributorAction.metadataService.count(), EditContributorAction.dataService.count(EditContributorAction.dataName), EditContributorAction.dataService.count());
	}

	/** Helper method to get the request dispatcher to dispatch the request.
	 *  It is used to make the test case more similar to TestEditContributorAction.java.
	 *  This will return the servlet request dispatcher.
	 *  @return RequestDispatcher
	 */
	private RequestDispatcher getRequestDispatcher(){
		// setup
		RequestDispatcher resolver = null;
		// test for a success condition
		HttpServletRequest request = EditContributorActionTest.this.request;
		// test for an exception
		ServletException error = EditContributorActionTest.this.error;
		// ensure it is not null
		assertNotNull(request);
		// ensure it is set
		// if (error == null)
		//	// should not be null
		assertTrue(request.getAttribute(""exception"") == null);
		try {
			// ensure it is not null
			resolver = RequestDispatcher.getInstance(editContributorJsp);
			// assert that the resolver is using servletRequest dispatcher
			assertNotNull(resolver);
		} catch (ServletException e) {
			e.printStackTrace();
			error = e;
		}
		// return the request dispatcher
		return resolver;
	}
}
"
bd36dd3a-20ed-4c3b-89fc-874cf88962e5,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ShowCatalogQueueAction.java,53.02446436882019,stop,"// ShowCatalogQueueAction.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * An {@link org.heal.servlet.Action} which fetches the information needed to
 * display the catalog queue.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
public class ShowCatalogQueueAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ShowCatalogQueueActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowCatalogQueueAction}.
* It contains one unit test case for the {@link ShowCatalogQueueAction#actionRequiresLogin()} method.
*/
class ShowCatalogQueueActionTest {","// ShowCatalogQueueActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowCatalogQueueAction}.
* It contains one unit test case for the {@link ShowCatalogQueueAction#actionRequiresLogin()} method.
*/
class ShowCatalogQueueActionTest {

		@Test
		public void testActionRequiresLogin() {
			assertEquals(true, actionRequiresLogin());
		}
		
} "
e9473b05-6919-4919-b3c3-734bcda86984,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditCopyrightHolderAction.java,55.069851875305176,length,"// EditCopyrightHolderAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.CopyrightHolderBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Copyright Holder.  If
 * there isn't an existing Copyright Holder which can be found to edit,
 * we assume that a new Copyright Holder should be edited.
 */
public class EditCopyrightHolderAction implements Action {

    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditCopyrightHolderActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.CopyrightHolderBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditCopyrightHolderAction}.
* It contains one unit test case for the {@link EditCopyrightHolderAction#actionRequiresLogin()} method.
*/
class EditCopyrightHolderActionTest {","// EditCopyrightHolderActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.CopyrightHolderBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditCopyrightHolderAction}.
* It contains one unit test case for the {@link EditCopyrightHolderAction#actionRequiresLogin()} method.
*/
class EditCopyrightHolderActionTest {

	/**
	 * Test case which sets the complete metadata to <code>CompleteMetadataBean.class</code>.
	 * The copyright holder should set its identifier property to <code>1.0</code>.
	*/
	@Test
	public void testActionSetCopyrightHolderCompleteMetadata() {
	
		EditCopyrightHolderAction action = new EditCopyrightHolderAction();
		
		// get the first copyright holder
		CopyrightHolderBean copyrightHolderBean = action.getNewCopyrightHolder();
		assertNotNull(""An existing copyright holder should have been edited."", copyrightHolderBean);
		
		// call it with an empty request
		assertFalse(""The author of the copyright holder should not be set (in case there is nothing to edit) or the second result doesn't contain the copyright holder property."", action.actionRequiresLogin());
		
		// edit the copyright holder
		Iterator<CopyrightHolderBean> iterator = action.getAuthorIterator();
		assertNotNull(""An existing copyright holder should be edited."", iterator.next());
		Iterator<CompleteMetadataBean> metadataIterator = action.getCompleteMetadataIterator();
		assertNotNull(""The metadata of the existing copyright holder should be found."", metadataIterator.next());
		assertEquals(""The identifier of the new copyright holder should be correct."", copyrightHolderBean.getId(), action.getNewCopyrightHolder().getId());
		assertEquals(""The author of the copyright holder should not be set (in case the original author is unchanged) or the second result contains the new copyright holder property."", """", action.getNewCopyrightHolder().getAuthor());
		assertEquals(""The metadata of the old copyright holder should not be found."", copyrightHolderBean.getLastModificationInfo().getProperty(""author""), action.getOldCopyrightHolder().getLastModificationInfo().getProperty(""author""));
	}
	
	/**
	 * Test case which sets the complete metadata to one of the first available values.
	 * The copyright holder should set its identifier property to <code>1.0</code> if the first possible author could not be found.
	*/
	@Test
	public void testActionSetCopyrightHolderFirstAuthorCompleteness() {
	
		// get the first copyright holder
		CopyrightHolderBean copyrightHolderBean = new CopyrightHolderBean();
		assertFalse(""This action should not be able to set a copyright (author) property."", action.actionRequiresLogin());
		
		// call it with empty request
		assertFalse(""The author of the copyright holder should not be set (in case there is nothing to edit) or the second result doesn't contain the copyright holder property."", action.actionRequiresLogin());
		
		// edit the copyright holder
		Iterator<CopyrightHolderBean> iterator = action.getAuthorIterator();
		iterator.next();
		int counter = 0;
		assertOneOf(""The first possible author can be found, but only one result should be generated."", action.getAuthorIterator().hasNext(), ""1 author found"");
		for (Iterator<CompleteMetadataBean> metadataIterator = action.getCompleteMetadataIterator(); metadataIterator.hasNext();) {
			CompleteMetadataBean completeMetadataBean = metadataIterator.next();
			if (completeMetadataBean.getProperty(""author"").equals(action.getNewCopyrightHolder().getAuthor())) {
				counter++;
				assertTrue(""The first possible author should be used"", counter == 1);
				return;
			}
		}
		assertEquals(""There should be only one metadata result for a given valid title."", 1, counter);
	}
	
	/**
	 * Test case which just checks the author name of the new copyright holder.
	 * The copyright holder should set its name to the author of the new copyright holder.
	 */
	@Test
	public void testAuthorName() {
	
		EditCopyrightHolderAction action = new EditCopyrightHolderAction();
		

		// call it with empty request
		assertEquals(""The author name should be the name of the new copyright holder"", action.getNewCopyrightHolder().getFirstComplete().getDisplayName(), action.getNewCopyrightHolder().getAuthor());
	}
	
	@Test
	public void testRemoveTitleAndAuthor() throws Exception {
		
		EditCopyrightHolderAction action = new EditCopyrightHolderAction();
	
		// set the author name to the first author and the title to the first title
		action.setAuthor(""1.0"");
		action.setTitle(""First title"");
		action.setTitle(""First title\u2015"");
	}
	
	/**
	 * The first way in which a {@link EditCopyrightHolderAction} can be used
	 * is using a {@link HttpServlet} to do the actual editing.
	 * This is done by providing a {@link RequestDispatcher}
	 * implementation which will return a {@link RequestDispatcher#forward(String, javax.servlet.http.HttpServletRequest, HttpServletResponse)} method which
	 * forwards the actual request to its target
	 * {@link #testAuthorName()}} method (called by the
	 * {@link #testSetTitleAndAuthor()} method).
	 * The first way in which an {@link EditCopyrightHolderAction} can be used
	 * can be set up by passing in a {@link HttpServletRequest} implementation and
	 * a {@link HttpServletResponse} implementation which will forward the original
	 * request and the modified request to its target
	 * {@link #testAuthorName()}} method (called by the
	 * {@link #testRemoveTitleAndAuthor()}} method).
	 * @throws Exception An Exception which should be caught
	*/
	@Test
	public void testForward() throws Exception {
		
		EditCopyrightHolderAction action = new EditCopyrightHolderAction();
	
		final String[] requestParameters = {
				""title=1.0 title=First title test"",
				""author=1.0 author=First author test""
		};
		
		HttpServletRequest originalRequest = buildHttpMethod(requestParameters).getHttpRequest();
		HttpServletResponse originalResponse = buildHttpMethod(requestParameters).getHttpResponse();
		
		// call the method under test
		action.setAuthor(""1.0"");
		action.setTitle(""First title"");
		action.setAuthor(""First author"");
		
		// set the response headers to the correct ones and
		// forward
		assertNotNull(""The original request headers should not be null"
8ba4530c-30dc-4df5-8fcc-259348dbc58a,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/upload/AlphanumericFileRenamePolicy.java,35.495264530181885,stop,"// AlphanumericFileRenamePolicy.java
package org.heal.servlet.upload;

import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;
import java.io.File;

/**
 * A FileRenamePolicy that strips non-alphanumeric characters.
 */
public class AlphanumericFileRenamePolicy extends DefaultFileRenamePolicy {

    /**
     * Eliminates non-alphanumeric characters from filenames.  Exceptions
     * include <code>' '</code>, <code>'.'</code> and <code>'_'</code>
     *
     * @param original Original file reference.
     * @return File reference stripped of non-alphanumeric characters.
     */
    public File rename(File original);

    String stripSpecialCharacters(String filename);
}
","// AlphanumericFileRenamePolicyTest.java
package org.heal.servlet.upload;

import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;
import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AlphanumericFileRenamePolicy}.
* It contains one unit test case for the {@link AlphanumericFileRenamePolicy#rename(File)} method.
*/
class AlphanumericFileRenamePolicyTest {","// AlphanumericFileRenamePolicyTest.java
package org.heal.servlet.upload;

import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;
import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AlphanumericFileRenamePolicy}.
* It contains one unit test case for the {@link AlphanumericFileRenamePolicy#rename(File)} method.
*/
class AlphanumericFileRenamePolicyTest {
/**
		 * Create a new instance of the test class with a modified
		 * original file reference.
		 */
	@Test
	void setOriginalTest() {
		AlphanumericFileRenamePolicy actual = new AlphanumericFileRenamePolicy();
		actual.setOriginal(new File(""""));
		
		String testOriginal =
				stripSpecialCharacters(
						actual.getOriginal()
					.toString());
		
		assertEquals(""Original file reference"", testOriginal);

		String testRef = actual.rename(new File(""""));
		
		assertEquals(""Stripped Reference"", testRef);
		
		File notStripped = new File("""");
		notStripped.delete();
		
		assertEquals(""Original reference"", actual.getOriginal());
	}
						/**
						* Test of {@link AlphanumericFileRenamePolicy#stripSpecialCharacters(String)}.
						*/
	@Test
	void stripSpecialCharactersTest() {
		AlphanumericFileRenamePolicy actual = new AlphanumericFileRenamePolicy();
		actual.setOriginal(new File(""""));
		
		String test = actual.getOriginal().toString();
		
		actual.setOriginal(new File(""Foo""));
		actual.stripSpecialCharacters(test);
		
		String expectedTest =
				stripSpecialCharacters(
						actual.getOriginal().toString());
		expectedTest.equals(""Foo"");
		
		assertEquals(""Stripped Reference"", actual.getOriginal());
	}
	
}// AlphanumericFileRenamePolicyTest



"
65ecd840-fbe2-4a8e-8f54-d08c34c4db0a,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_0Test.java,44.16769599914551,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static final String DEFAULT_DATE_FORMAT = new String(""yyyy-MM-dd"");

    public static final String LONG_DATE_FORMAT = new String(""yyyy-MM-dd HH:mm:ss"");

    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, ""MM/dd/yyyy"", ""MM-dd-yyyy"", ""yyyy"" };

    private DateTools() {
    }

    /**
     * @param date A {@link Date} to format.
     * @return A String representation of the date parameter in
     * 		the {@link #DEFAULT_DATE_FORMAT default format}.
     */
    public static String format(Date date);

    /**
     * @param date A {@link Date} to format.
     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)
     * 		to convert the date to.
     * @return A String representation of the date parameter in the
     * 		specified format, or null if the given date is null.
     */
    public static String format(Date date, String format);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed.
     */
    public static Date parse(String dateString);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @param format A format to use to parse the date parameter with.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed with the
     * 		given format.
     */
    public static Date parse(String dateString, String format);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String, or <code>false</code> otherwise.
     * @see #parse(String dateString)
     */
    public static boolean isValidDate(String dateString);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed with the given format.
     * @param format A format to use to check if the String can
     * 		be parsed into a {@link Date}.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String in the given format, or <code>false</code>
     * 		otherwise.
     * @see #parse(String dateString, String format)
     */
    public static boolean isValidDate(String dateString, String format);
}
","// DateTools_0Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date)} method.
*/
class DateTools_0Test {","// DateTools_0Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date)} method.
*/
class DateTools_0Test {

	@Test
	public void testFormat() throws ParseException {
		assertEquals(""01-01-2008 07:00:00"", format(new Date()).toString());
		assertEquals(""02-02-2008 07:00:00"", format((Date) null).toString());
		assertEquals(""00-01-2008 07:00:00"", format(new Date(1)));
	}
	
	@Test
	public void testFormatWithTime () throws ParseException {
		SimpleDateFormat df = new SimpleDateFormat(LONG_DATE_FORMAT);
		Date date = df.parse(""01-01-2008 07:00:00"");
		assertEquals(date, format(date));
	}
}"
0aa488e3-84d1-4191-8e7e-1e1b22842280,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_1Test.java,44.045814514160156,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static final String DEFAULT_DATE_FORMAT = new String(""yyyy-MM-dd"");

    public static final String LONG_DATE_FORMAT = new String(""yyyy-MM-dd HH:mm:ss"");

    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, ""MM/dd/yyyy"", ""MM-dd-yyyy"", ""yyyy"" };

    private DateTools() {
    }

    /**
     * @param date A {@link Date} to format.
     * @return A String representation of the date parameter in
     * 		the {@link #DEFAULT_DATE_FORMAT default format}.
     */
    public static String format(Date date);

    /**
     * @param date A {@link Date} to format.
     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)
     * 		to convert the date to.
     * @return A String representation of the date parameter in the
     * 		specified format, or null if the given date is null.
     */
    public static String format(Date date, String format);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed.
     */
    public static Date parse(String dateString);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @param format A format to use to parse the date parameter with.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed with the
     * 		given format.
     */
    public static Date parse(String dateString, String format);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String, or <code>false</code> otherwise.
     * @see #parse(String dateString)
     */
    public static boolean isValidDate(String dateString);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed with the given format.
     * @param format A format to use to check if the String can
     * 		be parsed into a {@link Date}.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String in the given format, or <code>false</code>
     * 		otherwise.
     * @see #parse(String dateString, String format)
     */
    public static boolean isValidDate(String dateString, String format);
}
","// DateTools_1Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date, String)} method.
*/
class DateTools_1Test {","// DateTools_1Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date, String)} method.
*/
class DateTools_1Test {
    
  @Test
    public void testFormat() {
        assertNotNull(format(null));
        try {
                format(new Date(), ""yyyy-MM-dd"");
                fail(""Exception expected"");
        } catch (IllegalArgumentException ignored) {            
            
        }
        try {
            format(null, ""yyyy-MM-dd"");
            fail(""Exception expected"");
        } catch (IllegalArgumentException ignored) {            
            
        }
        try {
            format(new Date(), ""yyyy-MM-dd"", ""yyyy"");
            fail(""Exception expected"");
        } catch (ParseException ignorable) {

        }
        
    }
  @Test
    public void testParse() throws ParseException {
        
        date = new Date();
        assertEquals(date.parse(""0000-01-05""), new Date(date.getTime()));
        
        // Make sure this does something sensible...
        try {
         date = new Date(0);
        } catch (IllegalArgumentException e) {
            
        }
        
    }
}

class DateTools_1 {
		
  @Test
    public void testIsValidDate() {
		    
		assertTrue(""Should return true when date format is valid."", format(new Date())!=null);
		assertTrue(""Should return true when date format is valid."", parse(""0000-01-05"")!=null);
		assertTrue(""Should return true when date format is valid."", parse(""yyyy-MM-dd"")!=null);
		
	}
	
  @Test
    public void testIsValidDateWithNoFormat() {
		    
		assertTrue(""Should return true when no date format is set."", parse("""")!=null);
		assertTrue(""Should return true when no date format is set."", parse(""yyyy-MM-dd"")!=null);
		assertTrue(""Should return true when no date format is set."", parse(""yyyy"")!=null);
		
	}
	
	
		
	
	public Date date;
		
}





"
f1d5e5a2-5759-4e2c-ae0f-f064296de26c,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_2Test.java,44.156494140625,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static final String DEFAULT_DATE_FORMAT = new String(""yyyy-MM-dd"");

    public static final String LONG_DATE_FORMAT = new String(""yyyy-MM-dd HH:mm:ss"");

    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, ""MM/dd/yyyy"", ""MM-dd-yyyy"", ""yyyy"" };

    private DateTools() {
    }

    /**
     * @param date A {@link Date} to format.
     * @return A String representation of the date parameter in
     * 		the {@link #DEFAULT_DATE_FORMAT default format}.
     */
    public static String format(Date date);

    /**
     * @param date A {@link Date} to format.
     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)
     * 		to convert the date to.
     * @return A String representation of the date parameter in the
     * 		specified format, or null if the given date is null.
     */
    public static String format(Date date, String format);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed.
     */
    public static Date parse(String dateString);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @param format A format to use to parse the date parameter with.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed with the
     * 		given format.
     */
    public static Date parse(String dateString, String format);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String, or <code>false</code> otherwise.
     * @see #parse(String dateString)
     */
    public static boolean isValidDate(String dateString);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed with the given format.
     * @param format A format to use to check if the String can
     * 		be parsed into a {@link Date}.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String in the given format, or <code>false</code>
     * 		otherwise.
     * @see #parse(String dateString, String format)
     */
    public static boolean isValidDate(String dateString, String format);
}
","// DateTools_2Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String)} method.
*/
class DateTools_2Test {","// DateTools_2Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String)} method.
*/
class DateTools_2Test {

    @Test
    void testIsValidDate() {
        assertTrue(DateTools.isValidDate(""2013-05-31""));
        assertFalse(DateTools.isValidDate(null) );
    } 

    @Test
    void testParseDateString() {
        assertEquals(new Date(2012,2,2,0,0), DateTools.parse(""2012-02-02""));
        assertEquals(new Date(0,0,0), DateTools.parse("" 0:0:0""));
        assertEquals(new Date(0,0), DateTools.parse("" 00:00:00""));
        assertEquals(new Date(0), DateTools.parse("" 00:00""));
        assertEquals(new Date(2000), DateTools.parse("" 2016""));
        assertEquals(new Date(new Date(null,0)), DateTools.parse("" 2037-11-27""));
    }
    @Test
    void testParseDateString2() {
        // test two formats
        assertEquals(new Date(2012,2,2,0,0), DateTools.parse(""20120512"",""MM-dd-yyyy""));
        assertEquals(new Date(0,0,0), DateTools.parse("" 01,01,00"",""""));
        assertEquals(new Date(0), DateTools.parse("" 00,00"", """"));
        assertEquals(new Date(2000), DateTools.parse("" 2016"", ""MM-dd-yyyy""));
        assertEquals(new Date(1980+4), DateTools.parse(""1961-12-31"", ""MM-dd-yyyy""));
	assertEquals(new Date(-12*12), DateTools.parse(""-12-12"", """"));
        assertEquals(new Date(1980+(12-12)), DateTools.parse(""1961-12-31"", ""MM-dd-yyyy""));
	assertEquals(new Date(1980)+12, DateTools.parse(""1961-12-31"", ""MM-dd-yyyy""));
	assertEquals(new Date(1980+1), DateTools.parse(""1961-12-31"", ""MM-dd-yyyy""));
	assertEquals(new Date(1980+12), DateTools.parse(""1961-12-31"", ""MM-dd-yyyy""));
	assertEquals(new Date(1970+1), DateTools.parse(""1900-1-1"", """"));

}
"
36dfa8fb-13dd-443a-8147-33c37fdb3ad6,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_3Test.java,44.03773069381714,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static final String DEFAULT_DATE_FORMAT = new String(""yyyy-MM-dd"");

    public static final String LONG_DATE_FORMAT = new String(""yyyy-MM-dd HH:mm:ss"");

    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, ""MM/dd/yyyy"", ""MM-dd-yyyy"", ""yyyy"" };

    private DateTools() {
    }

    /**
     * @param date A {@link Date} to format.
     * @return A String representation of the date parameter in
     * 		the {@link #DEFAULT_DATE_FORMAT default format}.
     */
    public static String format(Date date);

    /**
     * @param date A {@link Date} to format.
     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)
     * 		to convert the date to.
     * @return A String representation of the date parameter in the
     * 		specified format, or null if the given date is null.
     */
    public static String format(Date date, String format);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed.
     */
    public static Date parse(String dateString);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @param format A format to use to parse the date parameter with.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed with the
     * 		given format.
     */
    public static Date parse(String dateString, String format);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String, or <code>false</code> otherwise.
     * @see #parse(String dateString)
     */
    public static boolean isValidDate(String dateString);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed with the given format.
     * @param format A format to use to check if the String can
     * 		be parsed into a {@link Date}.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String in the given format, or <code>false</code>
     * 		otherwise.
     * @see #parse(String dateString, String format)
     */
    public static boolean isValidDate(String dateString, String format);
}
","// DateTools_3Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String, String)} method.
*/
class DateTools_3Test {","// DateTools_3Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String, String)} method.
*/
class DateTools_3Test {

	@Test
	void parseTest() {
		assertEquals(null, parse(""""));		
		assertEquals("""", parse(""""));
		assertEquals("""", parse("" ""));
		assertEquals("" "", parse("" ""));
		assertEquals(""\t"", parse(""\t""));
		assertEquals(""\t"", parse("" \t""));
		assertEquals(""\t \t"", parse("" \t ""));
					
		assertEquals(null, parse(""    ""));
		assertEquals(""  "", parse(""  ""));
		assertEquals(""\\"", parse("" ""));
		assertEquals(""'"", parse(""'""));
				
		assertEquals("""", parse(""\n""));
		assertEquals("""", parse(""\r""));
		assertEquals("""", parse(""\r\n""));
		assertEquals("""", parse(""\r\r""));
		assertEquals("""", parse(""\r\r\r""));
		//System.out.println(parse(null));
	}	

	/**
	 * Test case for parsing a date with trailing
	 * whitespace and without a leading space will throw an exception.
	 */
	@Test(expected = ParseException.class)
	void testWSCase() {
		parse(null, ""TEST"");
	}

	/**
	 * Test case for parsing a date with leading space and without a leading space.
	 */
	@Test(expected = ParseException.class)
	void testLeadingSpaceNoTrailingSpace() {
		parse(null, ""TEST "");
	}

	/**
	 * Test case for parsing a date with leading space and with a leading space.
	 */
	@Test(expected = ParseException.class)
	void testLeadingSpaceWithTrailingSpace() {
		parse(null, ""TEST ""+"" "");
	}
	
	/**
	 * Test case for parsing a date with leading space and without a leading space,
	 * with a trailing space or null.
	 */
	@Test(expected = ParseException.class)
	void testLeadingSpaceNoTrailingSpaceNull() {
		parse(null, ""TEST ""+"" "");
	}
	
	/**
	 * Test case for parsing a date with leading space and with a leading space,
	 * with a trailing space and a trailing whitespace.
	 */
	@Test(expected = ParseException.class)
	void testLeadingSpaceWithTrailingSpaceAndTrailingSpace() throws ParseException {
		parse(null, ""TEST "" + "" "" + "" \t"" + "" "");
	}
	
	@Test
	void testLeadingSpaceWithTrailingSpaceWithoutLeadingSpace() {
		assertEquals(0xFFFF, Integer.parseInt(leadSpaceWithoutLeadingSpace));
	}
	
	@Test
	void testLeadingSpaceWithTrailingSpaceAndLeadingSpace() {
		assertEquals(parse(""TEST \t ""), leadSpaceWithTrailingSpace() + ""\t"");
	}
}
"
79715cd7-9b30-46b3-9212-e6343d7830bd,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_4Test.java,34.02497124671936,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static final String DEFAULT_DATE_FORMAT = new String(""yyyy-MM-dd"");

    public static final String LONG_DATE_FORMAT = new String(""yyyy-MM-dd HH:mm:ss"");

    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, ""MM/dd/yyyy"", ""MM-dd-yyyy"", ""yyyy"" };

    private DateTools() {
    }

    /**
     * @param date A {@link Date} to format.
     * @return A String representation of the date parameter in
     * 		the {@link #DEFAULT_DATE_FORMAT default format}.
     */
    public static String format(Date date);

    /**
     * @param date A {@link Date} to format.
     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)
     * 		to convert the date to.
     * @return A String representation of the date parameter in the
     * 		specified format, or null if the given date is null.
     */
    public static String format(Date date, String format);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed.
     */
    public static Date parse(String dateString);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @param format A format to use to parse the date parameter with.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed with the
     * 		given format.
     */
    public static Date parse(String dateString, String format);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String, or <code>false</code> otherwise.
     * @see #parse(String dateString)
     */
    public static boolean isValidDate(String dateString);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed with the given format.
     * @param format A format to use to check if the String can
     * 		be parsed into a {@link Date}.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String in the given format, or <code>false</code>
     * 		otherwise.
     * @see #parse(String dateString, String format)
     */
    public static boolean isValidDate(String dateString, String format);
}
","// DateTools_4Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String)} method.
*/
class DateTools_4Test {","// DateTools_4Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String)} method.
*/
class DateTools_4Test {
public static final String DEFAULT_DATE_FORMAT = new String(""yyyy-MM-dd"");
		public static final String LONG_DATE_FORMAT = new String(""yyyy-MM-dd HH:mm:ss"");
	    			public static final String TEST_DATE = ""1998-10-10 00:00:00"";

	    public static final String TEST_DATE_FORMAT1 = new String(""yyyy-MM-dd HH:mm:ss"");
	    public static final String TEST_DATE_FORMAT2 = new String(""yyyy-MM-dd HH:mm:ss"");
	    public static final String TEST_DATE_FORMAT3 = new String(""yyyy-MM-dd HH:mm:ss.SSS"");
	    public static final String TEST_DATE_FORMAT4 = new String(""EEEE, MMMM dd yyyy HH:mm:ss"");
	    public static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, ""MM/dd/yyyy"",
			""MM-dd-yyyy"", ""yyyy""
	    };

	@Test
	public void test() throws ParseException {

		assertEquals(DEFAULT_DATE_FORMAT, DateTools.DEFAULT_DATE_FORMAT);
		assertEquals(Long.valueOf((long)DEFAULT_DATE_FORMAT.length()), DateTools.DEFAULT_LONG_DATE_FORMAT.length());

		assertEquals(TEST_DATE_FORMAT1, DateTools.parse(TEST_DATE, DEFAULT_DATE_FORMAT));
		assertEquals(TEST_DATE_FORMAT2, DateTools.parse(TEST_DATE, DEFAULT_DATE_FORMAT));
		assertEquals(TEST_DATE_FORMAT3, DateTools.parse(TEST_DATE_FORMAT4, DEFAULT_DATE_FORMAT));
		assertEquals(TEST_DATE_FORMAT4, DateTools.parse(TEST_DATE_FORMAT1, DEFAULT_DATE_FORMAT));
		assertFalse(DateTools.isValidDate(TEST_DATE_FORMAT4, DEFAULT_DATE_FORMAT));

		assertEquals(TEST_DATE_FORMAT1.length(), DateTools.DEFAULT_LONG_DATE_FORMAT.length());
		for (String possibleFormat : POSSIBLE_DATE_FORMATS) {
			try {
				DateTools.parse(TEST_DATE_FORMAT1, possibleFormat);
			} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | ParseException e) {
				e.printStackTrace();
				assertTrue(e.getMessage().contains(""Unknown date format: ""), e.getMessage());
			}
		}
	}

	public static final String TEST_DATE = new SimpleDateFormat(DEFAULT_DATE_FORMAT).format(new Date());

}
"
42287a8b-2da0-4e91-b41c-18b2edc33b99,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_5Test.java,44.00533747673035,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static final String DEFAULT_DATE_FORMAT = new String(""yyyy-MM-dd"");

    public static final String LONG_DATE_FORMAT = new String(""yyyy-MM-dd HH:mm:ss"");

    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, ""MM/dd/yyyy"", ""MM-dd-yyyy"", ""yyyy"" };

    private DateTools() {
    }

    /**
     * @param date A {@link Date} to format.
     * @return A String representation of the date parameter in
     * 		the {@link #DEFAULT_DATE_FORMAT default format}.
     */
    public static String format(Date date);

    /**
     * @param date A {@link Date} to format.
     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)
     * 		to convert the date to.
     * @return A String representation of the date parameter in the
     * 		specified format, or null if the given date is null.
     */
    public static String format(Date date, String format);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed.
     */
    public static Date parse(String dateString);

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @param format A format to use to parse the date parameter with.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed with the
     * 		given format.
     */
    public static Date parse(String dateString, String format);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String, or <code>false</code> otherwise.
     * @see #parse(String dateString)
     */
    public static boolean isValidDate(String dateString);

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed with the given format.
     * @param format A format to use to check if the String can
     * 		be parsed into a {@link Date}.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String in the given format, or <code>false</code>
     * 		otherwise.
     * @see #parse(String dateString, String format)
     */
    public static boolean isValidDate(String dateString, String format);
}
","// DateTools_5Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String, String)} method.
*/
class DateTools_5Test {","// DateTools_5Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String, String)} method.
*/
class DateTools_5Test {

    /**
     * The test unit.
     */
    @Test
    void testIsValidDate() {
        // setup
        Date date = null;
        String format = null;
        
        // test
        SimpleDateFormat sdf = new SimpleDateFormat(DEFAULT_DATE_FORMAT);
        fail();
        
        /**
		        test case that parses the same but can't be found
         * If the test is passed, the caller is responsible for closing the parser
		     */
        date = sdf.parse(""2014/05/01"");
        fail();
    }
}
"
c7ca3fe1-2854-485a-ac0d-dfc0567107d8,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/catalog/QueueDAO_0Test.java,38.20151233673096,length,"// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    public QueueDAO() {
    }

    public static final String TYPE_APPROVAL = new String(""approval"");

    public static final String TYPE_CATALOG = new String(""catalog"");

    private DataSource dataSource;

    private CommonDAO cd = new CommonDAO();

    private MetadataDAO md = new MetadataDAO();

    private static final String SELECT_QUEUE_BY_TYPE = ""SELECT QueuedRecordId,"" + "" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?"";

    private static final String INSERT_QUEUE_ENTRY = ""INSERT INTO QueuedRecords"" + "" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)"";

    private static final String UPDATE_QUEUE_ENTRY = ""UPDATE QueuedRecords"" + "" SET Type = ?, MetadataId = ?, Status = ?, Comments = ? WHERE"" + "" QueuedRecordId = ?"";

    private static final String DELETE_QUEUE_ENTRY = ""DELETE FROM QueuedRecords"" + "" WHERE QueuedRecordId = ?"";

    public void setDataSource(final DataSource dataSource);

    /**
     * @param type The type of QueuedRecordBeans to get.
     *
     * @return A List of QueuedRecordBeans.
     */
    public List<QueuedRecordBean> getQueueByType(final String type);

    /**
     * @return The List of QueuedRecordBeans representing the catalog queue.
     */
    public List<QueuedRecordBean> getCatalogQueue();

    /**
     * @return The List of QueuedRecordBeans representing the approval queue.
     */
    public List<QueuedRecordBean> getApprovalQueue();

    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException;

    /**
     * Saves a {@link QueuedRecordBean} to the database.
     *
     * @param queuedRecord A non-null QueuedRecordBean to save.
     *
     * @return <code>true</code> if the save is successful, false otherwise.
     */
    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord);

    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException;

    public boolean enqueue(final String type, final String metadataId);

    public boolean dequeue(final String queuedRecordId);

    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException;

    public boolean markRecordApproved(final String metadataId);

    public boolean markRecordCataloged(final String metadataId);

    public boolean rejectRecord(final String metadataId);
}
","// QueueDAO_0Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#getQueueByType(String)} method.
*/
class QueueDAO_0Test {","// QueueDAO_0Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#getQueueByType(String)} method.
*/
class QueueDAO_0Test {
// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    public QueueDAO() {
    }

    public static final String TYPE_APPROVAL = new String(""approval"");

    public static final String TYPE_CATALOG = new String(""catalog"");

    private DataSource dataSource;

    private CommonDAO cd = new CommonDAO();

    private MetadataDAO md = new MetadataDAO();

    private static final String SELECT_QUEUE_BY_TYPE = ""SELECT QueuedRecordId,"" + "" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE?"";

    private static final String INSERT_QUEUE_ENTRY = ""INSERT INTO QueuedRecords"" + "" (Type, MetadataId, Status, Comments) VALUES (?,?,?,?)"";

    private static final String UPDATE_QUEUE_ENTRY = ""UPDATE QueuedRecords"" + "" SET Type =?, MetadataId =?, Status =?, Comments =? WHERE"" + "" QueuedRecordId =?"";

    private static final String DELETE_QUEUE_ENTRY = ""DELETE FROM QueuedRecords"" + "" WHERE QueuedRecordId =?"";

    public void setDataSource(final DataSource dataSource);

    /**
     * @param type The type of QueuedRecordBeans to get.
     *
     * @return A List of QueuedRecordBeans.
     */
    public List<QueuedRecordBean> getQueueByType(final String type);

    /**
     * @return The List of QueuedRecordBeans representing the catalog queue.
     */
    public List<QueuedRecordBean> getCatalogQueue();

    /**
     * @return The List of QueuedRecordBeans representing the approval queue.
     */
    public List<QueuedRecordBean> getApprovalQueue();

    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException;

    /**
     * Saves a {@link QueuedRecordBean} to the database.
     *
     * @param queuedRecord A non-null QueuedRecordBean to save.
     *
     * @return <code>true</code> if the save is successful, false otherwise.
     */
    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord);

    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException;

    public boolean enqueue(final String type, final String metadataId);

    public boolean dequeue(final String queuedRecordId);

    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException;

    public boolean markRecordApproved(final String metadataId);

    public boolean markRecordCataloged(final String metadataId);

    public boolean rejectRecord(final String metadataId);
}

// QueueDAO_0Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#getQueueByType(String)} method.
*/
class QueueDAO_0Test {
		
    @Test
    public final void testGetQueueByType()
            throws Exception {
        final QueueDAO queueDAO = new QueueDAO_0();
        final QueuedRecordBean queuedRecord = queueDAO.getQueueByType("""");
        
        assertEquals(1, queuedRecord.getId().longValue());
        assertNotNull(queuedRecord.getType());
        assertEquals(queueDAO.getType(), queuedRecord.getType());
    }
    
    /**
     * @throws Exception
     */
	@Test
	public final void testInsertQueue() throws Exception {
        final QueueDAO queueDAO = new QueueDAO_0();

        final Connection conn = queueDAO.getConnection();

        boolean result = true;

        try (
            final PreparedStatement insertQueue = conn.prepareStatement(insertQueue),
            final PreparedStatement insertApproval = conn.prepareStatement(insertApproval),
            final PreparedStatement insertCatalog = conn.prepareStatement(insertCatalog),
            final PreparedStatement insertApprovalRec = conn.prepareStatement(insertApprovalRec),
            ) {
            
            // test insert
            final List<String> testData = new ArrayList<>();
            final List<String> testCategory = new ArrayList<>();
            final List<String> testMetadataIds = new ArrayList<>();
            testData.add(""test1"");
            testCategory.add(""test_category"");
            testMetadataIds.add(""test_meta_id"");
            testData.add(""test_other_data"");
            testCategory.add(""test1Cat1"");
            testCategory.add(""test2Cat1"");
            testMetadataIds.add(""test_meta_id1"");

            insertQueue.setString(1, testData.get(0));
            insertQueue.setString(2, testMetadataIds.get(0));

            insertQueue.setString(3, testCategory.get(0));
            insertQueue.setString(4, testCategory.get(1));

            insertQueue.setString(5, testCategory.get(2));
            insertQueue.setString(6, testMetadataIds.get(1));
            insertApproval.setString(1, testCategory.get(3));
            insertApproval.setString(2, testCategory.get(4));

            insertApproval.setString(3, testCategory.get(3));
            insertApproval.setString(4, testCategory.get(4));

            insertApproval.setString(5, testMetadataIds.get(2));
            insertCatalog.setString(1, testCategory.get(1));
            insertCatalog.setString(2, testCategory.get(2));

            insertCatalog.setString(3, testMetadataIds.get(3));
            insertCatalog.setString(4, testMetadataIds.get(4));

            insertCatalog.setString(5, testMetadataIds.get(5));
            insertCatalog.setTimestamp(1, new Timestamp(0));
            insertCatalog.setTimestamp(2, new Timestamp(0));

            insertCatalog.executeUpdate();

            insertQueue.executeUpdate();

            insertApproval.executeUpdate();
            insertApprovalRec.executeUpdate();

            try (
                final ResultSet rs = insertQueue.executeQuery())
            {
                assertTrue(rs.next());
                System.err.println(""testQueue: "" + testData);
            }
            
            final int[] checkData = {1, 0, 2, 0, 3, 0, 4, 1, 1, 1, 2, 1, 2};
            assertEquals(checkData[0], queueDAO.getQueueByType("""").getId().longValue());
            assertTrue(queueDAO.getQueueByType("""").getComments().equals(""qtest""));
            assertEquals("
e1e7ff32-d1df-4ad8-83d0-b880081e72a0,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/catalog/QueueDAO_1Test.java,38.099366903305054,stop,"// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    public QueueDAO() {
    }

    public static final String TYPE_APPROVAL = new String(""approval"");

    public static final String TYPE_CATALOG = new String(""catalog"");

    private DataSource dataSource;

    private CommonDAO cd = new CommonDAO();

    private MetadataDAO md = new MetadataDAO();

    private static final String SELECT_QUEUE_BY_TYPE = ""SELECT QueuedRecordId,"" + "" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?"";

    private static final String INSERT_QUEUE_ENTRY = ""INSERT INTO QueuedRecords"" + "" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)"";

    private static final String UPDATE_QUEUE_ENTRY = ""UPDATE QueuedRecords"" + "" SET Type = ?, MetadataId = ?, Status = ?, Comments = ? WHERE"" + "" QueuedRecordId = ?"";

    private static final String DELETE_QUEUE_ENTRY = ""DELETE FROM QueuedRecords"" + "" WHERE QueuedRecordId = ?"";

    public void setDataSource(final DataSource dataSource);

    /**
     * @param type The type of QueuedRecordBeans to get.
     *
     * @return A List of QueuedRecordBeans.
     */
    public List<QueuedRecordBean> getQueueByType(final String type);

    /**
     * @return The List of QueuedRecordBeans representing the catalog queue.
     */
    public List<QueuedRecordBean> getCatalogQueue();

    /**
     * @return The List of QueuedRecordBeans representing the approval queue.
     */
    public List<QueuedRecordBean> getApprovalQueue();

    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException;

    /**
     * Saves a {@link QueuedRecordBean} to the database.
     *
     * @param queuedRecord A non-null QueuedRecordBean to save.
     *
     * @return <code>true</code> if the save is successful, false otherwise.
     */
    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord);

    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException;

    public boolean enqueue(final String type, final String metadataId);

    public boolean dequeue(final String queuedRecordId);

    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException;

    public boolean markRecordApproved(final String metadataId);

    public boolean markRecordCataloged(final String metadataId);

    public boolean rejectRecord(final String metadataId);
}
","// QueueDAO_1Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
*/
class QueueDAO_1Test {","// QueueDAO_1Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
*/
class QueueDAO_1Test {
// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    public QueueDAO() {
    }

    public static final String TYPE_APPROVAL = new String(""approval"");

    public static final String TYPE_CATALOG = new String(""catalog"");

    private DataSource dataSource;

    private CommonDAO cd = new CommonDAO();

    private MetadataDAO md = new MetadataDAO();

    private static final String SELECT_QUEUE_BY_TYPE = ""SELECT QueuedRecordId,"" + "" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE?"";

    private static final String INSERT_QUEUE_ENTRY = ""INSERT INTO QueuedRecords"" + "" (Type, MetadataId, Status, Comments) VALUES (?,?,?,?)"";

    private static final String UPDATE_QUEUE_ENTRY = ""UPDATE QueuedRecords"" + "" SET Type =?, MetadataId =?, Status =?, Comments =? WHERE"" + "" QueuedRecordId =?"";

    private static final String DELETE_QUEUE_ENTRY = ""DELETE FROM QueuedRecords"" + "" WHERE QueuedRecordId =?"";

    public void setDataSource(final DataSource dataSource);

    /**
     * @param type The type of QueuedRecordBeans to get.
     *
     * @return A List of QueuedRecordBeans.
     */
    public List<QueuedRecordBean> getQueueByType(final String type);

    /**
     * @return The List of QueuedRecordBeans representing the catalog queue.
     */
    public List<QueuedRecordBean> getCatalogQueue();

    /**
     * @return The List of QueuedRecordBeans representing the approval queue.
     */
    public List<QueuedRecordBean> getApprovalQueue();

    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException;

    /**
     * Saves a {@link QueuedRecordBean} to the database.
     *
     * @param queuedRecord A non-null QueuedRecordBean to save.
     *
     * @return <code>true</code> if the save is successful, false otherwise.
     */
    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord);

    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException;

    public boolean enqueue(final String type, final String metadataId);

    public boolean dequeue(final String queuedRecordId);

    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException;

    public boolean markRecordApproved(final String metadataId);

    public boolean markRecordCataloged(final String metadataId);

    public boolean rejectRecord(final String metadataId);
}

// QueueDAO_1Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
*/
class QueueDAO_1Test {
		
    @Test
    public void testSaveQueuedRecord1() throws Exception {
        QueueDAO dao = new QueueDAO();

        Connection conn = null;

        try {
            conn = dao.getOrConnect();

            final CompleteMetadataBean record = new CompleteMetadataBean(null, new Date());

            MetadataDAO.update(conn, record);

            assertTrue(dao.saveQueuedRecord(dao.createQueuedRecord(new Timestamp(System.currentTimeMillis()), """", TYPE_APPROVAL)));
        } finally {
            if (conn!= null) {
                dao.close(conn);
            }
        }
    }

    @Test
    public void testSaveQueuedRecord2() throws Exception {
        QueueDAO dao = new QueueDAO();

        Connection conn = null;

        try {
        	conn = dao.getOrConnect();

            final CompleteMetadataBean record = new CompleteMetadataBean(null, new Date());

            final CompleteMetadataBean approvedRecord = new CompleteMetadataBean(null, new Date());

            MetadataDAO.update(conn, record);

            MetadataDAO.update(conn, approvedRecord);

            assertTrue(dao.saveQueuedRecord(dao.createQueuedRecord(new Timestamp(System.currentTimeMillis()), """", TYPE_CATALOG)));

        } finally {
            if (conn!= null) {
                dao.close(conn);
            }
        }
    }

    @Test
    public void testDeleteQueuedRecord1() throws Exception {
        QueueDAO dao = new QueueDAO();

        Connection conn = null;

        try {
            conn = dao.getOrConnect();

            dao.deleteQueuedRecord(conn, new Object[]{dao.createQueuedRecord(new Timestamp(System.currentTimeMillis()), ""record"", TYPE_APPROVAL)} );

            assertTrue(dao.deleteQueuedRecord(conn, new Object[]{""""}));

        } finally {
            if (conn!= null) {
                dao.close(conn);
            }
        }
    }

    @Test(expected = SQLException.class)
    public void testDeleteQueuedRecord2() throws Exception {
        QueueDAO dao = new QueueDAO();

        Connection conn = null;

        try {
            conn = dao.getOrConnect();

            dao.deleteQueuedRecord(conn, new Object[]{""delete"", ""test""});
        } finally {
            if (conn!= null) {
                dao.close(conn);
            }
        }
    }

}"
b775d878-fcb9-4a76-be21-8f1fcb14a3e4,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/search/ParameterBean.java,36.4177782535553,stop,"// ParameterBean.java
package org.heal.module.search;

import java.util.*;

public class ParameterBean {

    private ArrayList searchParameters = null;

    private ArrayList tableList = null;

    private String[] filterArray = null;

    private String[] sourceCollection = null;

    private String[] publicationNames = null;

    private String[] publicationIds = null;

    private String rights = null;

    private String[] primaryArray = null;

    private boolean hidden = false;

    private String[] imaging = null;

    private String[] disease = null;

    /**
     * Constructor
     */
    public ParameterBean() {
    }

    /**
     * New constructor
     */
    public ParameterBean(String keywordString) {
    }

    /**
     * Accessor method, returns the parameterNode at specified position
     *
     * @param position
     *
     * @return ParameterNode
     */
    public ParameterNode getParameters(int position);

    /**
     * Accessor method, returns the searchParameter size
     *
     * @return int
     */
    public int size();

    /**
     * return the filterArray
     *
     * @return
     */
    public String[] getFilterArray();

    /**
     * return the diseasePrecess array
     * @return disease
     */
    public String[] getDisease();

    /**
     * return the imaging technique Array
     * @return imaging
     */
    public String[] getImaging();

    /**
     * return the Source collection Array
     *
     * @return sourceCollection
     */
    public String[] getSourceCollection();

    /**
     * return the usage rights array
     *
     * @return rights
     */
    public String getUsageRight();

    /**
     * return the primary audience Array
     *
     * @return primary
     */
    public String[] getPrimaryArray();

    /**
     * Return the value for hidden
     *
     * @return
     */
    public boolean getHidden();

    /**
     * Adds parameterNode into the ArrayList
     *
     * @param input
     */
    public void addParameters(ParameterNode input);

    /**
     * Adds filter array into the parameterBean
     *
     * @param filter
     */
    public void setFilterArray(String[] filter);

    /**
     * Adds source collection array into the parameterBean
     *
     * @param source
     */
    public void setSourceCollection(String[] source);

    /**
     * Adds usage rights array into the parameterBean
     *
     * @param rts
     */
    public void setUsageRights(String rts);

    /**
     * Adds primary audience array into the parameterBean
     *
     * @param primary
     */
    public void setPrimaryArray(String[] primary);

    /**
     * Adds imaging technique array into the parameterBean
     * @param source
     */
    public void setImaging(String[] imgs);

    /**
     * Adds disease precess array into the parameterBean
     * @param rts
     */
    public void setDisease(String[] dis);

    /**
     * sets the value for hidden
     *
     * @param value
     */
    public void setHidden(boolean value);

    /**
     * This is a wrapper that calls for functions to parse the table name.
     * If the tableList is empty, it calls for function to create the tableList,
     * else it returns the tableList as ArrayList.
     *
     * @return ArrayList of tableName
     */
    public ArrayList getTableList();

    /**
     * Checks if the table name already exists in the tableList. If not, adds the
     * table name into the tableList.
     *
     * @param table
     *
     * @return boolean
     */
    private boolean tableNotFound(String table);

    /**
     * main function to create the tableList. Parses through the searchParameter
     * one by one and checks for the table name.
     */
    private void makeTableList();

    public void setPublicationNames(String[] names);

    public String[] getPublicationNames();

    public void setPublicationIds(String[] publicationIds);

    public String[] getPublicationIds();

    public ParameterBean makeParameterBean(String keywordString);
}
","// ParameterBeanTest.java
package org.heal.module.search;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParameterBean}.
* It contains one unit test case for the {@link ParameterBean#size()} method.
*/
class ParameterBeanTest {","// ParameterBeanTest.java
package org.heal.module.search;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParameterBean}.
* It contains one unit test case for the {@link ParameterBean#size()} method.
*/
class ParameterBeanTest {

    private String[] testArray;
    /**
     * Get all test case
     *
     * @return all the test cases for {@link ParameterBean Test Cases}.
     */
    public boolean[][] getTestCase();
    /**
     * Return all test case's as an array {@link String[]}
     *
     * @return return the test cases as an array {@link String[]}
     */
    public String[] testData;

//   public String[] testArray(String parameterName,int i,int j)

}
"
989efd8e-2294-4ff1-8020-9ade4185acaa,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/download/DownloadQueueBean_0Test.java,39.19511008262634,length,"// DownloadQueueBean.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;

/**
 * Stores a list of contentIds and a package file location and url.
 *
 * @author Seth Wright
 * @version 0.1
 */
public class DownloadQueueBean implements Serializable {

    TreeSet contentSet = new TreeSet();

    String packageFileLocation = null;

    String packageURL = null;

    boolean packageModifiedSinceFileCreated = true;

    int packageFormat = -1;

    /**
     * Get a collection of content Ids.
     */
    public Collection getContentIds();

    /**
     * Returns true if the package has not been modified,
     * the package file location is not null, the
     * package URL is set, and the format of the
     * package is the same as that provided and
     * the package file exists on disk.
     */
    public boolean isPackageFileUpToDate(int format);

    /**
     * Returns the format for the package associated with this queue.
     * The value will be one of the static values defined in
     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there
     * is no package associated with this queue.
     */
    public int getPackageFormat();

    /**
     * Sets the format for the package associated with this queue.
     * This value should be one of the static values defined in
     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there
     * is no package associated with this queue.
     */
    public void setPackageFormat(int newPackageFormat);

    /**
     * Returns the file path to be used to access the package for this queue.
     */
    public String getPackageFileLocation();

    public void setPackageFileLocation(String newPackageFileLocation);

    /**
     * Returns the URL to be used to access the package for this queue.
     */
    public String getPackageURL();

    /**
     * Sets the url used to access this package file.
     */
    public void setPackageURL(String newPackageURL);

    /**
     * call this method right after the package file is created.
     * This is used to track whether or not the queue has been modified
     * since the last time the associated file was created.
     */
    public void setPackageFileCreated();

    /**
     * Checks whether or not the queue has changed since the last time
     * the package was generated.  If the queue has had metadata entries
     * added or removed since the last time the package has been
     * generated or the package has not yet been generated yet, then this
     * method will return true
     * otherwise, it will return false
     */
    public boolean isPackageModified();

    /**
     * Adds a metadata id to the list of content to include in the package
     * generated for this queue.
     */
    public boolean addToQueue(String contentId);

    /**
     * Removes a metadata id from the list of content to include in the package
     * generated for this queue.
     */
    public boolean removeFromQueue(String contentId);

    /**
     * Removes all metadata id from the list of content to include in the
     * package generated for this queue.
     */
    public boolean removeAllFromQueue();

    /**
     * Deletes all package file settings (last modified, location, url)
     * but leaves the queue of id's intact.
     * Returns true on success.
     */
    public boolean clearPackageFileSettings();

    /**
     * Returns true if the specified metadataId is already in the queue.
     * Otherwise, it returns false.
     */
    public boolean isQueuedAlready(String contentId);

    /**
     * Returns the number of items queued for download.
     */
    public int getNumEntries();
}
","// DownloadQueueBean_0Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#removeAllFromQueue()} method.
*/
class DownloadQueueBean_0Test {","// DownloadQueueBean_0Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#removeAllFromQueue()} method.
*/
class DownloadQueueBean_0Test {

	/**
	 * Removes all entries from the queue
	 */
	@Test
	void removeAllFromQueue() {
		DownloadQueueBean obj = new DownloadQueueBean();
		assertNoneNull(""should not remove from queue object"", obj.removeQueue());
	}
	
	/**
	 * Tests the {@link DownloadQueueBean#isQueuedAlready(String)} method
	 */
	@Test
	void isQueuedAlreadyTest() {
		DownloadQueueBean obj = new DownloadQueueBean();
		assertTrue(""isQueuedNotAlready should return true"", obj.isQueuedAlready(""id""));
		assertFalse(""isQueuedNotAlready should return false"", obj.isQueuedAlready(""id-2""));
	}
	
	/**
	 * Tests the {@link DownloadQueueBean#isQueuedAlready(String, String, boolean)}   method
	 */
	@Test
	void isQueuedAlreadyWithStringStringBooleanTest() {
		DownloadQueueBean obj = new DownloadQueueBean();
		assertTrue(""isQueuedNotAlready should return true"", obj.isQueuedAlready(""id"", ""file"",  (byte)5));
		assertFalse(""isQueuedNotAlready should return false"", obj.isQueuedAlready(""id"", ""file"",  0));
	}
	
	/**
	 * Tests the {@link DownloadQueueBean#isQueuedAlready(String, String, boolean)}   method (2)
	 */
	@Test
	void isQueuedAlreadyWithStringStringBooleanTest2() {
		DownloadQueueBean obj = new DownloadQueueBean();
		assertFalse(""isQueuedNotAlready should return false"", obj.isQueuedAlready(""id"", ""file"", (byte)5));
		assertTrue(""isQueuedNotAlready should return true"", obj.isQueuedAlready(""id"", ""file"",  (byte)5));
	}
	
	/**
	 * Tests the {@link DownloadQueueBean#addToQueue(String)} method
	 */
	@Test
	void addToQueuTest() {
		DownloadQueueBean obj = new DownloadQueueBean();
		assertFalse(""addQueueNotQueued should be false"", obj.addToQueue(""id""));
		assertFalse(""addQueueNotQueued should be false"", obj.addToQueue(""1""));
		assertTrue(""addQueueNotQueued should return true"", obj.addToQueue(""2""));
		assertFalse(""addQueueNotQueued should be true"", obj.addToQueue(""id-2""));
	}
	
	/**
	 * Tests the {@link DownloadQueueBean#addToQueue(String, byte)} method
	 */
	@Test
	void addToQueuTestWithByte() {
		DownloadQueueBean obj = new DownloadQueueBean();
		assertFalse(""addQueueNotQueued should be false"", obj.addToQueue(""id"", (byte)5));
		assertFalse(""addQueueNotQueued should be false"", obj.addToQueue(""1"", (byte)5));
		assertTrue(""addQueueNotQueued should return true"", obj.addToQueue(""2"", (byte)5));
		assertFalse(""addQueueNotQueued should be true"", obj.addToQueue(""id-2"", (byte)5));
	}
	
	/**
	 * Tests the {@link DownloadQueueBean#addToQueue(String, String)} method
	 * with both a null and a null id.
	 */
	@Test
	void addToQueueNullIdNull() {
		DownloadQueueBean obj = new DownloadQueueBean();
		assertFalse(""id-null should be false"", obj.addToQueue(""1"", (String)null));
		assertFalse(""id-null should be false"", obj.addToQueue(""2"", (String)null));
	}
	
	/**
	 * Tests the {@link DownloadQueueBean#containsContentPID()} method
	 */
	@Test
	void containsContentPID() {
		DownloadQueueBean obj = new DownloadQueueBean();
		assertFalse(""should not contain empty content id"", obj.containsContentPID());
	}

"
75c0800b-feb5-4003-9a13-9e8f0bb70425,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/download/DownloadQueueBean_1Test.java,39.21812033653259,stop,"// DownloadQueueBean.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;

/**
 * Stores a list of contentIds and a package file location and url.
 *
 * @author Seth Wright
 * @version 0.1
 */
public class DownloadQueueBean implements Serializable {

    TreeSet contentSet = new TreeSet();

    String packageFileLocation = null;

    String packageURL = null;

    boolean packageModifiedSinceFileCreated = true;

    int packageFormat = -1;

    /**
     * Get a collection of content Ids.
     */
    public Collection getContentIds();

    /**
     * Returns true if the package has not been modified,
     * the package file location is not null, the
     * package URL is set, and the format of the
     * package is the same as that provided and
     * the package file exists on disk.
     */
    public boolean isPackageFileUpToDate(int format);

    /**
     * Returns the format for the package associated with this queue.
     * The value will be one of the static values defined in
     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there
     * is no package associated with this queue.
     */
    public int getPackageFormat();

    /**
     * Sets the format for the package associated with this queue.
     * This value should be one of the static values defined in
     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there
     * is no package associated with this queue.
     */
    public void setPackageFormat(int newPackageFormat);

    /**
     * Returns the file path to be used to access the package for this queue.
     */
    public String getPackageFileLocation();

    public void setPackageFileLocation(String newPackageFileLocation);

    /**
     * Returns the URL to be used to access the package for this queue.
     */
    public String getPackageURL();

    /**
     * Sets the url used to access this package file.
     */
    public void setPackageURL(String newPackageURL);

    /**
     * call this method right after the package file is created.
     * This is used to track whether or not the queue has been modified
     * since the last time the associated file was created.
     */
    public void setPackageFileCreated();

    /**
     * Checks whether or not the queue has changed since the last time
     * the package was generated.  If the queue has had metadata entries
     * added or removed since the last time the package has been
     * generated or the package has not yet been generated yet, then this
     * method will return true
     * otherwise, it will return false
     */
    public boolean isPackageModified();

    /**
     * Adds a metadata id to the list of content to include in the package
     * generated for this queue.
     */
    public boolean addToQueue(String contentId);

    /**
     * Removes a metadata id from the list of content to include in the package
     * generated for this queue.
     */
    public boolean removeFromQueue(String contentId);

    /**
     * Removes all metadata id from the list of content to include in the
     * package generated for this queue.
     */
    public boolean removeAllFromQueue();

    /**
     * Deletes all package file settings (last modified, location, url)
     * but leaves the queue of id's intact.
     * Returns true on success.
     */
    public boolean clearPackageFileSettings();

    /**
     * Returns true if the specified metadataId is already in the queue.
     * Otherwise, it returns false.
     */
    public boolean isQueuedAlready(String contentId);

    /**
     * Returns the number of items queued for download.
     */
    public int getNumEntries();
}
","// DownloadQueueBean_1Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#clearPackageFileSettings()} method.
*/
class DownloadQueueBean_1Test {","// DownloadQueueBean_1Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#clearPackageFileSettings()} method.
*/
class DownloadQueueBean_1Test {

	
	@Test
	public void testClearPackageFileSettings() throws Exception {
        
        assertEquals(0, DownloadQueueBean.getPackageFormat());

        String fileLocation = new File(System.getProperty(""java.io.tmpdir"")).getAbsolutePath();
        
        DownloadQueueBean cb = new DownloadQueueBean(""testqueue"");
        System.out.println(""queue length: "" + cb.getNumEntries());
        
        // clearPackageFileSettings
        DownloadQueueBean.clearPackageFileSettings(cb, fileLocation);
        System.out.println(""Clear: Package Queue"");

        System.gc();
        System.runFinalization();
        System.gc();
        System.runFinalization();

        // check the queues have been cleared
        assertEquals(""Packages have been cleaned?"", 0, cb.getNumEntries());
        
        System.out.println(""queue length: "" + cb.getPackageFormat());

        // test getting the queue length
        assertEquals(""Queue length should be one."", 1, cb.getPackageFormat());

        System.out.println(""package file location is: "" + cb.getPackageFileLocation());

        assertNotNull(""Package file location is valid."", fileLocation);
        assertTrue(""Package location didn't exist"", new File(fileLocation).exists());
        if(cb.isPackageModified())
            assertTrue(""Package file modified!"", new File(cb.getPackageFileLocation()).exists());
        assertFalse(""Package should be read only!"", cb.isPackageFileReadOnly());
    }
    
    
}
"
023d2c6a-9170-432b-8bbe-8df03daf1b62,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTag_0Test.java,47.467628955841064,stop,"// DownloadFolderTag.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;

/**
 * A tag which is basically acts as a container for attributes which
 * nested tags will utilize.
 *
 * @version 1.0
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @see org.heal.tag.download.DownloadFolderActionTag
 */
public class DownloadFolderTag extends TagSupport {

    public static final int UNKNOWN = -1;

    public static final int UNAVAILABLE = 0;

    public static final int ADD = 1;

    public static final int REMOVE = 2;

    public static final int REMOTE_IMAGE = 3;

    private DownloadQueueBean downloadQueue = null;

    private ShortMetadataBean shortMetadata = null;

    private int downloadFolderType = UNAVAILABLE;

    public void setDownloadQueue(DownloadQueueBean downloadQueue);

    public void setShortMetadata(ShortMetadataBean shortMetadata);

    /**
     * This is perhaps poorly named, but this will return an
     * integer representing whether or not a metadata record may
     * be added to the download folder, removed from the download folder,
     * or if the download folder is unavailable for the metadata record.
     *
     * @return {@link #UNAVAILABLE DownloadFolderTag.UNAVAILABLE} or
     * {@link #ADD DownloadFolderTag.ADD} or {@link #REMOVE DownloadFolderTag.REMOVE} or
     * {@link #REMOTE_IMAGE DownloadFolderTag.REMOTE_IMAGE}.
     */
    public int getDownloadFolderType();

    /**
     * Parses the attributes so as to initialize the
     * {@link #getDownloadFolderType() download folder type} for child tags
     * to use.
     *
     * @return Always returns <code>TagSupport.EVAL_BODY_INCLUDE</code>
     */
    public int doStartTag();

    /**
     * Resets the internal state of the tag.
     *
     * @return Always returns <code>TagSupport.EVAL_PAGE</code>
     */
    public int doEndTag();

    /**
     * Resets the tag to its initial state.
     */
    private void resetTag();
}
","// DownloadFolderTag_0Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doStartTag()} method.
*/
class DownloadFolderTag_0Test {","// DownloadFolderTag_0Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doStartTag()} method.
*/
class DownloadFolderTag_0Test {
public DownloadFolderTag_0Test() {
		}
}

// DownloadFolderTag_1Test.java
"
43dd6c7c-fd77-4a60-813a-82dcd715dceb,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTag_1Test.java,47.46006417274475,length,"// DownloadFolderTag.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;

/**
 * A tag which is basically acts as a container for attributes which
 * nested tags will utilize.
 *
 * @version 1.0
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @see org.heal.tag.download.DownloadFolderActionTag
 */
public class DownloadFolderTag extends TagSupport {

    public static final int UNKNOWN = -1;

    public static final int UNAVAILABLE = 0;

    public static final int ADD = 1;

    public static final int REMOVE = 2;

    public static final int REMOTE_IMAGE = 3;

    private DownloadQueueBean downloadQueue = null;

    private ShortMetadataBean shortMetadata = null;

    private int downloadFolderType = UNAVAILABLE;

    public void setDownloadQueue(DownloadQueueBean downloadQueue);

    public void setShortMetadata(ShortMetadataBean shortMetadata);

    /**
     * This is perhaps poorly named, but this will return an
     * integer representing whether or not a metadata record may
     * be added to the download folder, removed from the download folder,
     * or if the download folder is unavailable for the metadata record.
     *
     * @return {@link #UNAVAILABLE DownloadFolderTag.UNAVAILABLE} or
     * {@link #ADD DownloadFolderTag.ADD} or {@link #REMOVE DownloadFolderTag.REMOVE} or
     * {@link #REMOTE_IMAGE DownloadFolderTag.REMOTE_IMAGE}.
     */
    public int getDownloadFolderType();

    /**
     * Parses the attributes so as to initialize the
     * {@link #getDownloadFolderType() download folder type} for child tags
     * to use.
     *
     * @return Always returns <code>TagSupport.EVAL_BODY_INCLUDE</code>
     */
    public int doStartTag();

    /**
     * Resets the internal state of the tag.
     *
     * @return Always returns <code>TagSupport.EVAL_PAGE</code>
     */
    public int doEndTag();

    /**
     * Resets the tag to its initial state.
     */
    private void resetTag();
}
","// DownloadFolderTag_1Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doEndTag()} method.
*/
class DownloadFolderTag_1Test {","// DownloadFolderTag_1Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doEndTag()} method.
*/
class DownloadFolderTag_1Test {

	/** Test file being used by the tag. */
	private static final FileLocator TEST_DIR = new FileLocator(""jsp/temp"", ""tmp-test-tag"");

	/**
	 * Tests for the tag.
	 */
	@Test
	public void testTag() {
		// First we need to see if the tag is being used by its components
		// and if so make sure it can be initialized properly with setText.
		boolean initialized = false;
		TEST_DIR.init();
		TEST_DIR.exists();
		DownloadFolderTag tag = new DownloadFolderTag();
		
		// Make sure it contains a file called test.TEST.DAT, which should be set to the testfile
		String text = tag.getText();
		String[] lines = text.split(""\n"");
		for (String line : lines) {
			if (line.endsWith(""test.TEST.DAT"")) {
				line = line.substring(0, line.indexOf('='));
				String[] fields = line.split(""\\t"");
				if (fields[0].equals(""TESTFILE"")) {
					break;
				}
			}
		}
		TEST_DIR.chdirToParent();
				
		if (!TEST_DIR.isDirectory()) {
			initialized = false;
		}
		// If the user changed to a new directory in the TEMP directory, it is fine
		// to just remove that directory (no matter what path) and make sure it is
		// still the new location.
		resetTag();
		initialized = false;
		// If we run into this problem, we need to figure out something else
		// and then bail without changing this value.
		// Otherwise on windows, only a single directory is created, as opposed to
		// N directories created by removing temp/foo/bar etc.
		String currentDir = System.getProperty(""user.dir"");
		String nextPath = System.getProperty(""java.io.tmpdir"");
		final int MAX_SIZE = 10;
		String[] paths = nextPath.split(""/"" + '/');
		int i = 0;
		while (i < MAX_SIZE && paths.length > i) {
			if (paths[i].equals(currentDir)) {
				//System.out.println(currentDir);
				//System.out.println(nextPath+"" => "" + paths[i]);
				break;
			}
			i++;
		}
		i++;
		if (i >= MAX_SIZE) {
			System.err.println(""Could not find a new location to remove temp directory "" + TEST_DIR.getName());
			System.setProperty(""java.io.tmpdir"", TEST_DIR.getName());
			i = 2;
		}

		resetTag();
		initialized = false;
		
		// The loop runs for one directory that is not removed.
		// This is a very important step to ensure that we are not
		// using a local directory that we are not using as this will
		// cause a very bad error.
		// Otherwise, as a result of this loop, we should be able to
		// still run on Windows, because, as long as both directories
		// remain on our local path, we can rely upon this.
		// If no local paths remain to be used, then this should not cause a hard error.
		// It is not a good way to test this, as in case of a windows system,
		// the directories are removed, and then the local are kept in the path.
		// So, when only a single directory remains, the current location can
		// no longer be used because it is not used. Thus we'll just test
		// for this.
		
		String[] temp = TEST_DIR.list();
		//System.out.println(temp);
		if (temp.length!= 0 ) {
			System.err.println(""Could not remove temp directory "");
			System.err.println(TEST_DIR.getName());
			return;
		}
		
		// If no files remain then continue on to execute.
		resetTag();
		initialized = false;
		// Make sure all of the directories above do not exist yet
		for (int j = 2; j < temp.length; j++) {
			//System.out.println(temp[j]);
			String fname = temp[j];
			
			String[] fields = fname.split(""\\t"");
			if (fname.startsWith(currentDir)) {
				continue;
			}

			TEST_DIR.init();
			//System.out.println(""Tried to stat testfile '"" + fname + ""'"");
			String msg = ""File '"" + fname + ""' does not exist. Skipped"";
			String message = ""  - "";
			String path = String.valueOf(j);
			if (fname.endsWith("".jar"")) {
				status = SUCCESS;
				msg = (""  - file '"" + fname + ""' does not exist, continuing test"");
				message = ""  - file does not exist, continuing test"";
			} else if (fname.endsWith("".zip"")) {
				status = SUCCESS;
				msg = (""  - file '"" + fname + ""' is corrupt, continuing test"");
				message = ""  - file"
519380d8-80c9-4006-b6af-d75e1e6131b5,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResult.java,34.66450595855713,stop,"// SearchResult.java
package org.merlot.fedsearch.type;

public class SearchResult implements java.io.Serializable {

    private java.lang.String category;

    private java.lang.String comments;

    private int endIndex;

    private java.lang.String query;

    private org.merlot.fedsearch.type.SearchResultElement[] resultElements;

    private float searchTime;

    private int startIndex;

    private int totalResultsCount;

    public SearchResult() {
    }

    public SearchResult(java.lang.String category, java.lang.String comments, int endIndex, java.lang.String query, org.merlot.fedsearch.type.SearchResultElement[] resultElements, float searchTime, int startIndex, int totalResultsCount) {
    }

    /**
     * Gets the category value for this SearchResult.
     *
     * @return category
     */
    public java.lang.String getCategory();

    /**
     * Sets the category value for this SearchResult.
     *
     * @param category
     */
    public void setCategory(java.lang.String category);

    /**
     * Gets the comments value for this SearchResult.
     *
     * @return comments
     */
    public java.lang.String getComments();

    /**
     * Sets the comments value for this SearchResult.
     *
     * @param comments
     */
    public void setComments(java.lang.String comments);

    /**
     * Gets the endIndex value for this SearchResult.
     *
     * @return endIndex
     */
    public int getEndIndex();

    /**
     * Sets the endIndex value for this SearchResult.
     *
     * @param endIndex
     */
    public void setEndIndex(int endIndex);

    /**
     * Gets the query value for this SearchResult.
     *
     * @return query
     */
    public java.lang.String getQuery();

    /**
     * Sets the query value for this SearchResult.
     *
     * @param query
     */
    public void setQuery(java.lang.String query);

    /**
     * Gets the resultElements value for this SearchResult.
     *
     * @return resultElements
     */
    public org.merlot.fedsearch.type.SearchResultElement[] getResultElements();

    /**
     * Sets the resultElements value for this SearchResult.
     *
     * @param resultElements
     */
    public void setResultElements(org.merlot.fedsearch.type.SearchResultElement[] resultElements);

    /**
     * Gets the searchTime value for this SearchResult.
     *
     * @return searchTime
     */
    public float getSearchTime();

    /**
     * Sets the searchTime value for this SearchResult.
     *
     * @param searchTime
     */
    public void setSearchTime(float searchTime);

    /**
     * Gets the startIndex value for this SearchResult.
     *
     * @return startIndex
     */
    public int getStartIndex();

    /**
     * Sets the startIndex value for this SearchResult.
     *
     * @param startIndex
     */
    public void setStartIndex(int startIndex);

    /**
     * Gets the totalResultsCount value for this SearchResult.
     *
     * @return totalResultsCount
     */
    public int getTotalResultsCount();

    /**
     * Sets the totalResultsCount value for this SearchResult.
     *
     * @param totalResultsCount
     */
    public void setTotalResultsCount(int totalResultsCount);

    private java.lang.Object __equalsCalc = null;

    public synchronized boolean equals(java.lang.Object obj);

    private boolean __hashCodeCalc = false;

    public synchronized int hashCode();

    // Type metadata
    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResult.class, true);

    static {
    }

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc();

    /**
     * Get Custom Serializer
     */
    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType);

    /**
     * Get Custom Deserializer
     */
    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType);
}
","// SearchResultTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResult}.
* It contains one unit test case for the {@link SearchResult#getTypeDesc()} method.
*/
class SearchResultTest {","// SearchResultTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResult}.
* It contains one unit test case for the {@link SearchResult#getTypeDesc()} method.
*/
class SearchResultTest {
SearchResultTest(java.lang.String val) {

	}

	
}
"
6f8860a0-71e6-488f-996e-11a279fabdf9,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultElement.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// SearchResultElement.java
package org.merlot.fedsearch.type;

public class SearchResultElement implements java.io.Serializable {

    private java.lang.String URL;

    private java.lang.String assignmentsURL;

    private java.lang.String authorName;

    private int avgComments;

    private int avgPeerReviews;

    private java.lang.String award;

    private java.lang.String commentsURL;

    private java.lang.String creationDate;

    private java.lang.String description;

    private java.lang.String detailURL;

    private java.lang.String itemType;

    private int numAssignments;

    private int numComments;

    private int numPeerReviews;

    private java.lang.String peerReviewsURL;

    private int relevanceRanking;

    private java.lang.String title;

    public SearchResultElement() {
    }

    public SearchResultElement(java.lang.String URL, java.lang.String assignmentsURL, java.lang.String authorName, int avgComments, int avgPeerReviews, java.lang.String award, java.lang.String commentsURL, java.lang.String creationDate, java.lang.String description, java.lang.String detailURL, java.lang.String itemType, int numAssignments, int numComments, int numPeerReviews, java.lang.String peerReviewsURL, int relevanceRanking, java.lang.String title) {
    }

    /**
     * Gets the URL value for this SearchResultElement.
     *
     * @return URL
     */
    public java.lang.String getURL();

    /**
     * Sets the URL value for this SearchResultElement.
     *
     * @param URL
     */
    public void setURL(java.lang.String URL);

    /**
     * Gets the assignmentsURL value for this SearchResultElement.
     *
     * @return assignmentsURL
     */
    public java.lang.String getAssignmentsURL();

    /**
     * Sets the assignmentsURL value for this SearchResultElement.
     *
     * @param assignmentsURL
     */
    public void setAssignmentsURL(java.lang.String assignmentsURL);

    /**
     * Gets the authorName value for this SearchResultElement.
     *
     * @return authorName
     */
    public java.lang.String getAuthorName();

    /**
     * Sets the authorName value for this SearchResultElement.
     *
     * @param authorName
     */
    public void setAuthorName(java.lang.String authorName);

    /**
     * Gets the avgComments value for this SearchResultElement.
     *
     * @return avgComments
     */
    public int getAvgComments();

    /**
     * Sets the avgComments value for this SearchResultElement.
     *
     * @param avgComments
     */
    public void setAvgComments(int avgComments);

    /**
     * Gets the avgPeerReviews value for this SearchResultElement.
     *
     * @return avgPeerReviews
     */
    public int getAvgPeerReviews();

    /**
     * Sets the avgPeerReviews value for this SearchResultElement.
     *
     * @param avgPeerReviews
     */
    public void setAvgPeerReviews(int avgPeerReviews);

    /**
     * Gets the award value for this SearchResultElement.
     *
     * @return award
     */
    public java.lang.String getAward();

    /**
     * Sets the award value for this SearchResultElement.
     *
     * @param award
     */
    public void setAward(java.lang.String award);

    /**
     * Gets the commentsURL value for this SearchResultElement.
     *
     * @return commentsURL
     */
    public java.lang.String getCommentsURL();

    /**
     * Sets the commentsURL value for this SearchResultElement.
     *
     * @param commentsURL
     */
    public void setCommentsURL(java.lang.String commentsURL);

    /**
     * Gets the creationDate value for this SearchResultElement.
     *
     * @return creationDate
     */
    public java.lang.String getCreationDate();

    /**
     * Sets the creationDate value for this SearchResultElement.
     *
     * @param creationDate
     */
    public void setCreationDate(java.lang.String creationDate);

    /**
     * Gets the description value for this SearchResultElement.
     *
     * @return description
     */
    public java.lang.String getDescription();

    /**
     * Sets the description value for this SearchResultElement.
     *
     * @param description
     */
    public void setDescription(java.lang.String description);

    /**
     * Gets the detailURL value for this SearchResultElement.
     *
     * @return detailURL
     */
    public java.lang.String getDetailURL();

    /**
     * Sets the detailURL value for this SearchResultElement.
     *
     * @param detailURL
     */
    public void setDetailURL(java.lang.String detailURL);

    /**
     * Gets the itemType value for this SearchResultElement.
     *
     * @return itemType
     */
    public java.lang.String getItemType();

    /**
     * Sets the itemType value for this SearchResultElement.
     *
     * @param itemType
     */
    public void setItemType(java.lang.String itemType);

    /**
     * Gets the numAssignments value for this SearchResultElement.
     *
     * @return numAssignments
     */
    public int getNumAssignments();

    /**
     * Sets the numAssignments value for this SearchResultElement.
     *
     * @param numAssignments
     */
    public void setNumAssignments(int numAssignments);

    /**
     * Gets the numComments value for this SearchResultElement.
     *
     * @return numComments
     */
    public int getNumComments();

    /**
     * Sets the numComments value for this SearchResultElement.
     *
     * @param numComments
     */
    public void setNumComments(int numComments);

    /**
     * Gets the numPeerReviews value for this SearchResultElement.
     *
     * @return numPeerReviews
     */
    public int getNumPeerReviews();

    /**
     * Sets the numPeerReviews value for this SearchResultElement.
     *
     * @param numPeerReviews
     */
    public void setNumPeerReviews(int numPeerReviews);

    /**
     * Gets the peerReviewsURL value for this SearchResultElement.
     *
     * @return peerReviewsURL
     */
    public java.lang.String getPeerReviewsURL();

    /**
     * Sets the peerReviewsURL value for this SearchResultElement.
     *
     * @param peerReviewsURL
     */
    public void setPeerReviewsURL(java.lang.String peerReviewsURL);

    /**
     * Gets the relevanceRanking value for this SearchResultElement.
     *
     * @return relevanceRanking
     */
    public int getRelevanceRanking();

    /**
     * Sets the relevanceRanking value for this SearchResultElement.
     *
     * @param relevanceRanking
     */
    public void setRelevanceRanking(int relevanceRanking);

    /**
     * Gets the title value for this SearchResultElement.
     *
     * @return title
     */
    public java.lang.String getTitle();

    /**
     * Sets the title value for this SearchResultElement.
     *
     * @param title
     */
    public void setTitle(java.lang.String title);

    private java.lang.Object __equalsCalc = null;

    public synchronized boolean equals(java.lang.Object obj);

    private boolean __hashCodeCalc = false;

    public synchronized int hashCode();

    // Type metadata
    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResultElement.class, true);

    static {
    }

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc();

    /**
     * Get Custom Serializer
     */
    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType);

    /**
     * Get Custom Deserializer
     */
    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType);
}
","// SearchResultElementTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResultElement}.
* It contains one unit test case for the {@link SearchResultElement#getTypeDesc()} method.
*/
class SearchResultElementTest {","// SearchResultElementTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResultElement}.
* It contains one unit test case for the {@link SearchResultElement#getTypeDesc()} method.
*/
class SearchResultElementTest {
"
