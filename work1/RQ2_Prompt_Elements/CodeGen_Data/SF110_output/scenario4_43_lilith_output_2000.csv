ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
ccf3826a-877f-435a-ab89-c8a12c174953,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/preferences/GenericSortedListModel.java,61.2749445438385,stop,"// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    private final List<T> data;

    private final Comparator<T> comparator;

    public GenericSortedListModel() {
    }

    public GenericSortedListModel(Comparator<T> comparator) {
    }

    public void setData(List<T> data);

    public List<T> getData();

    public void add(T element);

    public void remove(T element);

    /**
     * Returns the length of the list.
     *
     * @return the length of the list
     */
    public int getSize();

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index);
}
","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains one unit test case for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains one unit test case for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {
/**
		* Test method for {@link GenericSortedListModel#getElementAt(int)}.
		*/
		@Test
		public void testGetElementAt() {
		}
}
// GenericSortedListModelTest.java"
9c26d8e5-e1f8-4347-b0cc-912a9e6e856f,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/callables/IndexingCallable.java,48.99082064628601,length,"// IndexingCallable.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

/**
 * Should only be executed on inactive files.
 */
public class IndexingCallable extends AbstractProgressingCallable<Long> {

    private final Logger logger = LoggerFactory.getLogger(IndexingCallable.class);

    private File dataFile;

    private File indexFile;

    public IndexingCallable(File dataFile, File indexFile) {
    }

    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    public Long call() throws Exception;

    public File getDataFile();

    public File getIndexFile();

    private static void closeQuietly(RandomAccessFile file);
}
","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains one unit test case for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains one unit test case for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {
private static final Logger log = LoggerFactory.getLogger(IndexingCallableTest.class);

    @Test
    public void test() throws FileNotFoundException, IOException {
         String dataFilePath = getClass().getResource(""/tmp/sulky-index-data"");
        indexFile = new File(dataFilePath);
        indexFileSize = indexFile.length();
         assertNotNull(""indexFile not yet created"", dataFile);

         openFileAndReadIndex();
         assertIndexEqual(indexFile.length(), indexFileSize/10);
         long fileOffset = 0;
         for (FileHeader header : indexFile.getFile().readFileHeader(indexFile), HeaderIterator.IteratorType.HEAD) {
            assertFileHeaderEqual(header, fileOffset, fileOffset / 10);
            fileOffset += header.getNumData();
         }
     }

    @Test
    public void canCloseIndex() throws Exception {
        final IndexStrategy strategy = new DefaultIndexStrategy();
        final SparseDataStrategy strategy2 = new SparseDataStrategy();

        call(""Data""); // close the index first

        final RandomAccessFile dataFile = new RandomAccessFile(dataFilePath, ""r"");
        if (dataFile.length()!= indexFileSize) {
            throw new Exception(""IndexFile length is not the correct size"");
        }

        int numElements = 10;
        final Long[] bytes = new Long[numElements];
        Arrays.fill(bytes, (long) numElements - 1, (long) numElements, (long) 0);
        strategy.setData(dataFile, bytes);

        assertFileHeaderEqual(indexFile.getFileHeader(), indexFile.length(), indexFile.length());

        final byte[] data = new byte[numElements * 10];
        final Long[] dataBytes = strategy.getData(dataFile);
        StringBuilder failureMessage = new StringBuilder();
        for (Long value : dataBytes) {
            if (value > 0) {
                failureMessage.append(Integer.toString((int) value));

                if (value < (long) (dataBytes.length / 2)) {
                    if (data[value - 1]!= dataBytes[value - 1]) {
                        failureMessage.append(""!= "").append((int) value);
                    }
                    else {
                        failureMessage.append(""== "").append((int) value);
                    }
                }
            }
        }
        assertTrue(failureMessage.toString(), failureMessage.length() < 100);
        strategy2.setData(dataFile, data);
        assertIndexEqual(indexFile.length(), indexFileSize);

        dataFile.close();
        dataFile.getFD().sync(); // ensure index file is removed

        indexFile.setFlag(true); // ensure that the file is in a ""valid"" state
        dataFile.close();
        dataFile.getFD().sync(); // ensure file is in a ""valid"" state
    }

    private static void assertFileHeaderEqual(FileHeader fileHeader, long dataFileOffset, long indexFileOffset) throws Exception {
        FileHeaderStrategy.assertFileHeaderEqual(new FileHeader(fileHeader), new FileHeader(dataFileHeader));

        FileHeaderStrategy.assertIndexFileHeaderEqual(fileHeader, indexFileHeader);

        assertEquals(""Data offset mismatch"", (int)fileHeader.getSize(), indexFileOffset);
        assertEquals(""Index file offset mismatch"", dataFileOffset, indexFileOffset);
        assertEquals(""Data file length mismatch"", (int)dataFileOffset, indexFileSize - indexFileOffset);
        SparseDataStrategy.assertDataFileHeaderEqual(indexFileFileHeader, fileHeader);
        assertEquals(""Index file length mismatch"", dataFileOffset, indexFileOffset);
    }

    private static void openFileAndReadIndex() throws FileNotFoundException, IOException {
        log.error(""Starting indexing file - {}"", dataFile.getName());
        dataFile.seek(0);
        if (indexFile.length() < indexFileSize) {
            throw new IOException(""IndexFile length is wrong"");
        }

        long fileOffset = 0;
        int numElements = 10;
        final Long[] bytes = new Long[numElements];
        Arrays.fill(bytes, (long) numElements - 1, (long) numElements, (long) 0);
        RandomAccessFile dataFile = new RandomAccessFile(dataFilePath, ""r"");
        strategy.setData(dataFile, bytes);
        indexFile.setFlag(false);
        indexFile.setLength(indexFileSize);
        while (indexFile.length() < fileOffset) {
            FileHeader fileHeader = new FileHeader(fileHeaderStrategy.getFile(), indexFile.getFileHeader());
            assertFileHeaderEqual(fileHeader, fileHeader.getSize(), fileOffset);
            assertTrue(""Index file length is wrong"", (int)fileFileHeaderSize > (int)fileHeader.getSize());
            int numElements = (int)(fileOffset / fileFileHeaderSize) + 30;
            fileOffset += fileHeader.getNumData();
            if (numElements > indexFileLength) {
                return;
            }
            dataFile.seek(fileOffset);
            final Long[] data ="
7d8066f0-de16-4380-bc75-94f4f4ba10f8,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/ApplicationPreferences.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// ApplicationPreferences.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;

public class ApplicationPreferences {

    public static enum SourceFiltering {

        NONE, BLACKLIST, WHITELIST
    }

    private static final Preferences PREFERENCES = Preferences.userNodeForPackage(ApplicationPreferences.class);

    private static final String STATUS_COLORS_XML_FILENAME = ""statusColors.xml"";

    private static final String LEVEL_COLORS_XML_FILENAME = ""levelColors.xml"";

    private static final String DETAILS_VIEW_ROOT_FOLDER = ""detailsView"";

    public static final String DETAILS_VIEW_CSS_FILENAME = ""detailsView.css"";

    public static final String DETAILS_VIEW_GROOVY_FILENAME = ""detailsView.groovy"";

    private static final String CONDITIONS_XML_FILENAME = ""savedConditions.xml"";

    public static final String STATUS_COLORS_PROPERTY = ""statusColors"";

    public static final String LEVEL_COLORS_PROPERTY = ""levelColors"";

    public static final String LOOK_AND_FEEL_PROPERTY = ""lookAndFeel"";

    public static final String CLEANING_LOGS_ON_EXIT_PROPERTY = ""cleaningLogsOnExit"";

    public static final String COLORING_WHOLE_ROW_PROPERTY = ""coloringWholeRow"";

    public static final String SHOWING_IDENTIFIER_PROPERTY = ""showingIdentifier"";

    public static final String SHOWING_FULL_CALLSTACK_PROPERTY = ""showingFullCallstack"";

    public static final String SHOWING_STACKTRACE_PROPERTY = ""showingStackTrace"";

    public static final String CHECKING_FOR_UPDATE_PROPERTY = ""checkingForUpdate"";

    public static final String SOURCE_FILTERING_PROPERTY = ""sourceFiltering"";

    public static final String SOUND_LOCATIONS_PROPERTY = ""soundLocations"";

    public static final String MUTE_PROPERTY = ""mute"";

    public static final String USING_INTERNAL_FRAMES_PROPERTY = ""usingInternalFrames"";

    public static final String SCROLLING_TO_BOTTOM_PROPERTY = ""scrollingToBottom"";

    public static final String SOURCE_NAMES_PROPERTY = ""sourceNames"";

    public static final String APPLICATION_PATH_PROPERTY = ""applicationPath"";

    public static final String AUTO_OPENING_PROPERTY = ""autoOpening"";

    public static final String AUTO_CLOSING_PROPERTY = ""autoClosing"";

    public static final String IMAGE_PATH_PROPERTY = ""imagePath"";

    public static final String SOUND_PATH_PROPERTY = ""soundPath"";

    public static final String AUTO_FOCUSING_WINDOW_PROPERTY = ""autoFocusingWindow"";

    public static final String SOURCE_LISTS_PROPERTY = ""sourceLists"";

    public static final String BLACK_LIST_NAME_PROPERTY = ""blackListName"";

    public static final String WHITE_LIST_NAME_PROPERTY = ""whiteListName"";

    public static final String CONDITIONS_PROPERTY = ""conditions"";

    public static final String SPLASH_SCREEN_DISABLED_PROPERTY = ""splashScreenDisabled"";

    public static final String ASKING_BEFORE_QUIT_PROPERTY = ""askingBeforeQuit"";

    public static final String LOGGING_LAYOUT_GLOBAL_XML_FILENAME = ""loggingLayoutGlobal.xml"";

    public static final String LOGGING_LAYOUT_XML_FILENAME = ""loggingLayout.xml"";

    public static final String ACCESS_LAYOUT_GLOBAL_XML_FILENAME = ""accessLayoutGlobal.xml"";

    public static final String ACCESS_LAYOUT_XML_FILENAME = ""accessLayout.xml"";

    public static final String SOURCE_NAMES_XML_FILENAME = ""SourceNames.xml"";

    public static final String SOURCE_LISTS_XML_FILENAME = ""SourceLists.xml"";

    public static final String SOURCE_NAMES_PROPERTIES_FILENAME = ""SourceNames.properties"";

    public static final String SOUND_LOCATIONS_XML_FILENAME = ""SoundLocations.xml"";

    public static final String SOUND_LOCATIONS_PROPERTIES_FILENAME = ""SoundLocations.properties"";

    public static final String PREVIOUS_APPLICATION_PATH_FILENAME = "".previous.application.path"";

    private static final String OLD_LICENSED_PREFERENCES_KEY = ""licensed"";

    private static final String LICENSED_PREFERENCES_KEY = ""licensedVersion"";

    public static final String USER_HOME;

    public static final String DEFAULT_APPLICATION_PATH;

    private static final Map<String, String> DEFAULT_SOURCE_NAMES;

    private static final Map<String, String> DEFAULT_SOUND_LOCATIONS;

    private static final Map<LoggingEvent.Level, ColorScheme> DEFAULT_LEVEL_COLORS;

    private static final Map<HttpStatus.Type, ColorScheme> DEFAULT_STATUS_COLORS;

    private static final String PREVIOUS_OPEN_PATH_PROPERTY = ""previousOpenPath"";

    private static final String PREVIOUS_IMPORT_PATH_PROPERTY = ""previousImportPath"";

    public static final String STARTUP_LOOK_AND_FEEL;

    private static final long CONDITIONS_CHECK_INTERVAL = 30000;

    private static final String GROOVY_SUFFIX = "".groovy"";

    private static final String EXAMPLE_GROOVY_BASE = ""/conditions/"";

    private static final String EXAMPLE_GROOVY_LIST = ""conditions.txt"";

    static {
    }

    private final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);

    private PropertyChangeSupport propertyChangeSupport;

    private File startupApplicationPath;

    private File detailsViewRoot;

    private ArrayList<String> installedLookAndFeels;

    private String[] conditionScriptFiles;

    private long lastConditionsCheck;

    private Map<LoggingEvent.Level, ColorScheme> levelColors;

    private Map<HttpStatus.Type, ColorScheme> statusColors;

    private URL detailsViewRootUrl;

    /**
     * Identifier => Name
     */
    private Map<String, String> sourceNames;

    private long lastSourceNamesModified;

    private long lastConditionsModified;

    private Map<String, String> soundLocations;

    private long lastSoundLocationsModified;

    private Map<String, Set<String>> sourceLists;

    private long lastSourceListsModified;

    private SourceFiltering sourceFiltering;

    private Set<String> blackList;

    private Set<String> whiteList;

    private List<SavedCondition> conditions;

    private File groovyConditionsPath;

    public ApplicationPreferences() {
    }

    public File resolveConditionScriptFile(String input);

    public String[] getAllConditionScriptFiles();

    public void installExampleConditions();

    private void initLevelColors();

    private Map<LoggingEvent.Level, ColorScheme> cloneLevelColors(Map<LoggingEvent.Level, ColorScheme> input);

    public void setLevelColors(Map<LoggingEvent.Level, ColorScheme> colors);

    private void writeLevelColors(Map<LoggingEvent.Level, ColorScheme> colors);

    public Map<LoggingEvent.Level, ColorScheme> getLevelColors();

    private void initStatusColors();

    private Map<HttpStatus.Type, ColorScheme> cloneStatusColors(Map<HttpStatus.Type, ColorScheme> input);

    public void setStatusColors(Map<HttpStatus.Type, ColorScheme> colors);

    private void writeStatusColors(Map<HttpStatus.Type, ColorScheme> colors);

    public Map<HttpStatus.Type, ColorScheme> getStatusColors();

    public void setSourceFiltering(SourceFiltering sourceFiltering);

    private void initSourceLists();

    public Map<String, Set<String>> getSourceLists();

    public void setSourceLists(Map<String, Set<String>> sourceLists);

    public SourceFiltering getSourceFiltering();

    public void initDetailsViewRoot(boolean overwriteAlways);

    private void initIfNecessary(File file, String resourcePath, String historyBasePath, boolean overwriteAlways);

    private void copy(URL source, File target, boolean overwrite);

    /**
     * Returns a list of strings containing all non-empty, non-comment lines found in the given URL.
     * Commented lines start with a #.
     *
     * @param url the URL to read the lines from.
     * @return a List of type String containing all non-empty, non-comment lines.
     */
    private List<String> readLines(URL url);

    public File getDetailsViewRoot();

    public URL getDetailsViewRootUrl();

    public boolean isValidSource(String source);

    public boolean isBlackListed(String source);

    public void setBlackListName(String name);

    public String getBlackListName();

    public boolean isWhiteListed(String source);

    public void setWhiteListName(String name);

    public String getWhiteListName();

    public void setLookAndFeel(String name);

    public String getLookAndFeel();

    private void initConditions();

    public SavedCondition resolveSavedCondition(Condition condition);

    public SavedCondition resolveSavedCondition(String conditionName);

    public List<SavedCondition> getConditions();

    public void setConditions(List<SavedCondition> conditions);

    public void setAutoOpening(boolean autoOpening);

    public boolean isAutoOpening();

    public void setShowingIdentifier(boolean showingIdentifierWithName);

    public boolean isShowingIdentifier();

    public void setSplashScreenDisabled(boolean splashScreenDisabled);

    public boolean isSplashScreenDisabled();

    public void setAskingBeforeQuit(boolean askingBeforeQuit);

    public boolean isAskingBeforeQuit();

    public void setShowingFullCallstack(boolean showingFullCallstack);

    public boolean isShowingFullCallstack();

    public void setShowingStackTrace(boolean showingStackTrace);

    public boolean isShowingStackTrace();

    public void setCleaningLogsOnExit(boolean cleaningLogsOnExit);

    public boolean isCleaningLogsOnExit();

    public void setColoringWholeRow(boolean coloringWholeRow);

    public boolean isColoringWholeRow();

    public void setCheckingForUpdate(boolean checkingForUpdate);

    public boolean isCheckingForUpdate();

    public void setAutoClosing(boolean autoClosing);

    public boolean isAutoClosing();

    public File getImagePath();

    public void setImagePath(File imagePath);

    public File getPreviousOpenPath();

    public void setPreviousOpenPath(File openPath);

    public File getPreviousImportPath();

    public void setPreviousImportPath(File importPath);

    public File getSoundPath();

    public void setSoundPath(File soundPath);

    public void setMute(boolean mute);

    public boolean isMute();

    public void setLicensed(boolean licensed);

    public boolean isLicensed();

    public void setApplicationPath(File applicationPath);

    public File getApplicationPath();

    /**
     * The StartupApplicationPath is initialized on application startup via ApplicationPreferences.getApplicationPath.
     * If a part of the application needs the application path it should *always* use this method instead of
     * getApplicationPath() since the application path might change while this one will always stay
     * the same.
     * <p/>
     * A switch of the application path while the application is running isn't safe so it's changed for real
     * upon next restart.
     *
     * @return the application path at startup time.
     */
    public File getStartupApplicationPath();

    public void setUsingInternalFrames(boolean usingInternalFrames);

    public boolean isUsingInternalFrames();

    public void setAutoFocusingWindow(boolean autoFocusingWindow);

    public boolean isAutoFocusingWindow();

    public void setSourceNames(Map<String, String> sourceNames);

    public Map<String, String> getSourceNames();

    public Map<String, String> getSoundLocations();

    public void setSoundLocations(Map<String, String> soundLocations);

    public void resetSoundLocations();

    public void addPropertyChangeListener(PropertyChangeListener listener);

    public void removePropertyChangeListener(PropertyChangeListener listener);

    public void reset();

    public void setScrollingToBottom(boolean scrollingToBottom);

    public boolean isScrollingToBottom();

    private boolean loadSoundLocationsXml(File file);

    private boolean writeSoundLocations(Map<String, String> sourceNames);

    private boolean loadSourceNamesXml(File file);

    private boolean loadSourceNamesProperties(File sourceNamesFile);

    private boolean writeSourceNames(Map<String, String> sourceNames);

    private boolean writeSourceLists(Map<String, Set<String>> sourceLists);

    private boolean writeConditions(List<SavedCondition> conditions);

    /**
     * @noinspection MismatchedQueryAndUpdateOfCollection
     */
    private Map<String, String> loadPropertiesXml(File file);

    /**
     * @noinspection MismatchedQueryAndUpdateOfCollection
     */
    private boolean writePropertiesXml(File file, Map<String, String> sourceNames, String comment);

    private Map<String, String> loadProperties(File file);

    public void writeLoggingColumnLayout(boolean global, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos);

    public void writeAccessColumnLayout(boolean global, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos);

    public List<PersistentTableColumnModel.TableColumnLayoutInfo> readLoggingColumnLayout(boolean global);

    public List<PersistentTableColumnModel.TableColumnLayoutInfo> readAccessColumnLayout(boolean global);

    private boolean writeColumnLayout(File file, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos);

    private List<PersistentTableColumnModel.TableColumnLayoutInfo> readColumnLayout(File file);

    /**
     * Quick & dirty MD5 checksum function.
     * Returns null in case of error.
     *
     * @param input the input
     * @return the checksum
     */
    public static byte[] getMD5(InputStream input);

    public void flush();

    /**
     * As described in http://weblogs.java.net/blog/malenkov/archive/2006/08/how_to_encode_e.html
     */
    static class EnumPersistenceDelegate extends PersistenceDelegate {

        protected boolean mutatesTo(Object oldInstance, Object newInstance) {
            return oldInstance == newInstance;
        }

        protected Expression instantiate(Object oldInstance, Encoder out) {
            Enum e = (Enum) oldInstance;
            return new Expression(e, e.getClass(), ""valueOf"", new Object[] { e.name() });
        }
    }
}
","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains one unit test case for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains one unit test case for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {
"
9491b8d8-4bdf-4a2a-bb15-d771b53f63d3,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    private static final long serialVersionUID = -2372658104457011019L;

    private int thickness;

    private int innerThickness;

    private Color borderColor;

    public ConditionalBorder(Color color) {
    }

    public ConditionalBorder(Color color, int thickness) {
    }

    public ConditionalBorder(Color color, int thickness, int innerThickness) {
    }

    /**
     * Paints the border for the specified component with the
     * specified position and size.
     *
     * @param c      the component for which this border is being painted
     * @param g      the paint graphics
     * @param x      the x position of the painted border
     * @param y      the y position of the painted border
     * @param width  the width of the painted border
     * @param height the height of the painted border
     */
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height);

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c      the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);

    /**
     * Returns the color of the border.
     *
     * @return the color of the border.
     */
    public Color getBorderColor();

    /**
     * Sets the color of the border.
     *
     * @param borderColor the color of the border.
     */
    public void setBorderColor(Color borderColor);

    /**
     * Returns the inner thickness of the border.
     *
     * @return Returns the inner thickness of the border.
     */
    public int getInnerThickness();

    /**
     * Sets the inner thickness of the border.
     *
     * @param innerThickness Returns the inner thickness of the border.
     */
    public void setInnerThickness(int innerThickness);

    /**
     * Returns the thickness of the border.
     *
     * @return Returns the thickness of the border.
     */
    public int getThickness();

    /**
     * Sets the thickness of the border.
     *
     * @param thickness the thickness of the border.
     */
    public void setThickness(int thickness);

    /**
     * Returns whether or not the border is opaque.
     */
    public boolean isBorderOpaque();
}
","// ConditionalBorder_0Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains one unit test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorder_0Test {","// ConditionalBorder_0Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains one unit test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorder_0Test {
"
38ab1f11-7f9b-4045-a287-30351afc01e7,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    private static final long serialVersionUID = -2372658104457011019L;

    private int thickness;

    private int innerThickness;

    private Color borderColor;

    public ConditionalBorder(Color color) {
    }

    public ConditionalBorder(Color color, int thickness) {
    }

    public ConditionalBorder(Color color, int thickness, int innerThickness) {
    }

    /**
     * Paints the border for the specified component with the
     * specified position and size.
     *
     * @param c      the component for which this border is being painted
     * @param g      the paint graphics
     * @param x      the x position of the painted border
     * @param y      the y position of the painted border
     * @param width  the width of the painted border
     * @param height the height of the painted border
     */
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height);

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c      the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);

    /**
     * Returns the color of the border.
     *
     * @return the color of the border.
     */
    public Color getBorderColor();

    /**
     * Sets the color of the border.
     *
     * @param borderColor the color of the border.
     */
    public void setBorderColor(Color borderColor);

    /**
     * Returns the inner thickness of the border.
     *
     * @return Returns the inner thickness of the border.
     */
    public int getInnerThickness();

    /**
     * Sets the inner thickness of the border.
     *
     * @param innerThickness Returns the inner thickness of the border.
     */
    public void setInnerThickness(int innerThickness);

    /**
     * Returns the thickness of the border.
     *
     * @return Returns the thickness of the border.
     */
    public int getThickness();

    /**
     * Sets the thickness of the border.
     *
     * @param thickness the thickness of the border.
     */
    public void setThickness(int thickness);

    /**
     * Returns whether or not the border is opaque.
     */
    public boolean isBorderOpaque();
}
","// ConditionalBorder_1Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains one unit test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_1Test {","// ConditionalBorder_1Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains one unit test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_1Test {
"
16dfe6d4-5db7-4378-b977-f2c1abe588f6,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_0Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModel_0Test {","// PersistentTableColumnModel_0Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModel_0Test {
"
15bae8cb-489a-454d-b67e-020aaf0ca0b4,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_1Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModel_1Test {","// PersistentTableColumnModel_1Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModel_1Test {
"
1f575afe-0949-4844-bec9-ae48e5e9e2e6,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_2Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_2Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModel_2Test {","// PersistentTableColumnModel_2Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModel_2Test {
"
9f4088df-9fb5-4918-8bbb-d81006ac579a,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_3Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();

    /**
     * Creates an extended table column model.
     */
    public PersistentTableColumnModel() {
    }

    /**
     * Should be implemented by subclasses if needed.
     */
    protected void initColumns();

    // listeners will receive columnAdded()/columnRemoved() event
    public void setColumnVisible(TableColumn column, boolean visible);

    /**
     * Makes all columns in this model visible
     */
    public void setAllColumnsVisible();

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);

    /**
     * Append <code>column</code> to the right of exisiting columns.
     * Posts <code>columnAdded</code> event.
     *
     * @param column The column to be added
     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>
     * @see #removeColumn
     */
    @Override
    public void addColumn(TableColumn column);

    /**
     * Removes <code>column</code> from this column model.
     * Posts <code>columnRemoved</code> event.
     * Will do nothing if the column is not in this model.
     *
     * @param column the column to be added
     * @see #addColumn
     */
    @Override
    public void removeColumn(TableColumn column);

    /**
     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.
     * Posts  <code>columnMoved</code> event.
     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.
     *
     * @throws IllegalArgumentException if either <code>oldIndex</code> or
     *                                  <code>newIndex</code>
     *                                  are not in [0, getColumnCount() - 1]
     * @param	oldIndex			index of column to be moved
     * @param	newIndex			new index of the column
     */
    @Override
    public void moveColumn(int oldIndex, int newIndex);

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see	#getColumns
     */
    public int getColumnCount(boolean onlyVisible);

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param	identifier the identifier object to search for
     * @param	onlyVisible if set searches only visible columns
     * @see		#getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);

    public List<TableColumnLayoutInfo> getColumnLayoutInfos();

    public static class TableColumnLayoutInfo implements Serializable {

        private String columnName;

        private int width;

        private boolean visible;

        public TableColumnLayoutInfo() {
        }

        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {
            this.columnName = columnName;
            this.width = width;
            this.visible = visible;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public String getColumnName() {
            return columnName;
        }

        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }

        @Override
        public String toString() {
            return ""TableColumnLayoutInfo[columnName="" + columnName + "", width="" + width + "", visible="" + visible + ""]"";
        }
    }
}
","// PersistentTableColumnModel_3Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModel_3Test {","// PersistentTableColumnModel_3Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModel_3Test {
"
133d8b07-fd62-4e3d-87f8-e6b0e74cf42d,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/AboutPanel.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);

    public static final String BACKGROUND_IMAGE_RESOURCE = ""background.png"";

    public static final String ABOUT_IMAGE_RESOURCE = ""about.png"";

    public static final String TEXT_RESOURCE_PREFIX = ""about."";

    public static final String SCROLL_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + ""scroll.text"";

    public static final String VERSION_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + ""version.text"";

    public static final String VERSION_HEIGHT_RESOURCE = TEXT_RESOURCE_PREFIX + ""version.height"";

    public static final String SCROLL_AREA_RESOURCE_BASE = TEXT_RESOURCE_PREFIX + ""scroll.area."";

    public static final String SCROLL_AREA_X_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""x"";

    public static final String SCROLL_AREA_Y_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""y"";

    public static final String SCROLL_AREA_WIDTH_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""width"";

    public static final String SCROLL_AREA_HEIGHT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""height"";

    public static final String SCROLL_AREA_TOOLTIP_TEXT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + ""tooltip.text"";

    public static final String TEXT_RESOURCE_BUNDLE_RESOURCE = ""TextResources"";

    public static final int MOUSE_DISABLED = 0;

    public static final int MOUSE_COMPONENT = 1;

    public static final int MOUSE_SCROLLAREA = 2;

    public static final int MOUSE_BACKGROUND = 3;

    //private static final int SCROLL_SLEEP_TIME = 50;
    private static final int SCROLL_PIXELS = 1;

    private BufferedImage backgroundImage;

    private BufferedImage aboutImage;

    //private ImageIcon aboutImageIcon;
    private FontMetrics fontMetrics;

    private Insets insets;

    private Dimension size;

    private Dimension preferredSize;

    private Point offscreenOffset;

    private String[] scrollLines;

    private String versionText;

    private String scrollAreaToolTipText;

    private int versionHeight;

    private int scrollPosition;

    private int maxScrollPosition;

    private int minScrollPosition;

    private Rectangle maxScrollArea;

    private Rectangle backgroundImageArea;

    private Rectangle translatedBackgroundImageArea;

    private Rectangle translatedScrollArea;

    private Rectangle scrollArea;

    private Rectangle paintArea;

    private BufferedImage offscreenImage;

    private BufferedImage scrollImage;

    private boolean scrolling;

    //private boolean painted;
    private int mouseEventHandling = MOUSE_BACKGROUND;

    //private transient Thread scrollThread;
    private boolean debug;

    private Timer timer;

    /**
     * Creates a new <code>AboutPanel</code> initialized with the given parameters.
     *
     * @param backgroundImageUrl The URL to the Background-Image of the
     *                           AboutPanel. This parameter is mandatory.
     * @param scrollArea         The Rectangle inside the background-image where
     *                           scrolling should take place. This parameter is optional. If it's null
     *                           then the scroll-area is set to (0, 0, background.width,
     *                           background.height).
     */
    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText) throws IOException {
    }

    public boolean isDebug();

    public void setDebug(boolean debug);

    /**
     * Creates a new <code>AboutPanel</code> initialized with the given parameters.
     *
     * @param backgroundImageUrl The URL to the Background-Image of the
     *                           AboutPanel. This parameter is mandatory.
     * @param scrollArea         The Rectangle inside the background-image where
     *                           scrolling should take place. This parameter is optional. If it's null
     *                           then the scroll-area is set to (0, 0, background.width,
     *                           background.height).
     * @param versionText        The String describing the version of the program.
     *                           It is painted centered to the scroll-rectangle at the specified height.
     *                           This parameter is optional.
     * @param versionHeight      The height at which the version-string is
     *                           supposed to be painted. This parameter is optional but should be given
     *                           a correct value if versionText!=null..
     */
    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, String versionText, int versionHeight) throws IOException {
    }

    /**
     * Creates a new <code>AboutPanel</code> initialized with the given parameters.
     *
     * @param backgroundImageUrl The URL to the Background-Image of the
     *                           AboutPanel. This parameter is mandatory.
     * @param scrollArea         The Rectangle inside the background-image where
     *                           scrolling should take place. This parameter is optional. If it's null
     *                           then the scroll-area is set to (0, 0, background.width,
     *                           background.height).
     * @param imageUrl           The URL to the Image that will be painted at the
     *                           start of the scroll-area. This parameter is optional.
     * @param versionText        The String describing the version of the program.
     *                           It is painted centered to the scroll-rectangle at the specified height.
     *                           This parameter is optional.
     * @param versionHeight      The height at which the version-string is
     *                           supposed to be painted. This parameter is optional but should be given
     *                           a correct value if versionText!=null..
     */
    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException {
    }

    public AboutPanel() {
    }

    private void init(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException;

    private void initAttributes();

    public void setScrollText(String ScrollText);

    protected void setScrollLines(String[] scrollLines);

    /**
     * Sets the backgroundImage attribute of the <code>AboutPanel</code> object
     */
    public void setBackgroundImage(URL imageUrl) throws IOException;

    /**
     * Sets the backgroundImage attribute of the <code>AboutPanel</code> object
     *
     * @param BackgroundImage The new backgroundImage value
     */
    public void setBackgroundImage(BufferedImage BackgroundImage);

    public void setAboutImage(URL imageUrl) throws IOException;

    public void setAboutImage(BufferedImage AboutImage);

    /**
     * Sets the scrollArea attribute of the <code>AboutPanel</code> object
     *
     * @param ScrollArea The new scrollArea value
     */
    public void setScrollArea(Rectangle ScrollArea);

    /**
     * Description of the Method
     */
    private void flushScrollImage();

    /**
     * Description of the Method
     */
    private void flushOffscreenImage();

    /**
     * Description of the Method
     */
    private void updateBackgroundAttributes();

    /**
     * Sets the ToolTipText that will appear if the user moves the mouse over the
     * scroll-area of this component.
     *
     * @param toolTipText The new ScrollAreaToolTipText value
     */
    public void setScrollAreaToolTipText(String toolTipText);

    /**
     * Gets the ScrollAreaToolTipText attribute of the <code>AboutPanel</code>
     * object
     *
     * @return The ScrollAreaToolTipText value
     */
    public String getScrollAreaToolTipText();

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt);

    protected boolean handleMouseEvent(MouseEvent evt);

    /**
     * Increases the ScrollPosition by SCROLL_PIXELS. This method is called by the
     * scroll-thread and calls <code>setScrollPosition</code>, therefore causing a
     * repaint of the scroll-area..
     *
     * @see #setScrollPosition
     */
    protected void increaseScrollPosition();

    /**
     * Sets the scrollPosition attribute of the <code>AboutPanel</code> object. The
     * value will be corrected according Minimum- and MaximumScrollPosition.
     * Changing the scroll-position will result in a repaint of the scroll-area.
     *
     * @param scrollPosition The new scrollPosition value. This value indicates
     *                       the height-offset of the scroll-area.
     * @see #getMinimumScrollPosition
     * @see #getMaximumScrollPosition
     */
    public void setScrollPosition(int scrollPosition);

    /**
     * Gets the ScrollPosition attribute of the <code>AboutPanel</code> object
     *
     * @return this value indicates the height-offset of the scroll-area.
     */
    public int getScrollPosition();

    /**
     * Gets the MinimumScrollPosition attribute of the <code>AboutPanel</code>
     * object. It's value is the negated value of the scroll-area-height.
     *
     * @return The MinimumScrollPosition value
     */
    public int getMinimumScrollPosition();

    /**
     * Gets the MaximumScrollPosition attribute of the <code>AboutPanel</code>
     * object. It's value is the height needed for all lines of text plus (if
     * available) the height of the image with an additional empty line.
     *
     * @return The MaximumScrollPosition value
     */
    public int getMaximumScrollPosition();

    /**
     * This method creates the offscreen-image when needed (when called for the
     * first time or recreated because of a changed font) and updates it on
     * subsequent calls by calling <code>updateOffscreenImage()</code>.
     */
    private void processOffscreenImage();

    /**
     * Updates the offscreen-image to represent the current scroll-position. It
     * calls <code>initScrollImage()</code>.
     *
     * @param g <code>Graphics</code>-object
     */
    private void drawScrollArea(Graphics2D g);

    /**
     * Initializes the scroll-image if needed. The scroll-image is as high as
     * needed to contain all the scroll-lines and (if available) the image.
     */
    private void initScrollImage();

    public static ConvolveOp getGaussianBlurFilter(int radius, boolean horizontal);

    /**
     * Sets the font attribute of the <code>AboutPanel</code> object. Setting it
     * will result in the recreation of all buffers. The font can even be safely
     * changed while the component is visible. It will be used for the version- and
     * scroll-text.<p />
     * <p/>
     * If the parameter is <code>null</code> then <code>UIManager.getFont( ""Label.font"" )</code>
     * will be used.
     *
     * @param newFont The new font value.
     */
    public void setFont(Font newFont);

    /**
     * Paints this component.
     *
     * @param _g <code>Graphics</code>-object
     */
    public void paintComponent(Graphics _g);

    /**
     * Makes sure that the private attributes size, paintArea, offscreenOffset and
     * translated areas have sane values. It's called on component-resize.
     */
    private void calculateAttributes();

    /**
     * This methods takes the insets (the border) of this component into account
     * when the preferred size is calculated. Any border will work. It is called by
     * the property-change-listener if the border was changed.
     */
    protected void calculatePreferredSize();

    /**
     * This method requests a repaint of the scroll-area. The rest of the component
     * will not be repainted. It is called by <code>setScrollPosition()</code> .
     *
     * @see
     */
    private void repaintScrollArea();

    /**
     * This method calls <code>super.addNotify()</code> and notifies the
     * scroll-thread by calling <code>setScrolling(true)</code>. It also
     * (re)initializes the scroll-position to MinimumScrollPosition (this is always
     * the negative height of the scroll-rectangle) and registers tbis component at
     * the <code>ToolTipManager</code>.
     *
     * @see #setScrolling
     * @see #setScrollPosition
     * @see #getMinimumScrollPosition
     */
    public void addNotify();

    /**
     * This method calls <code>super.removeNotify()</code> and sends the
     * scroll-thread into a wait-state by calling <code>setScrolling(false)</code>
     * . It also unregisters this component from the <code>ToolTipManager</code>.
     *
     * @see #setScrolling
     */
    public void removeNotify();

    /**
     * This method is used to set the scrolling-property of this component. A value
     * of <code>true</code> will notify the scroll-thread that it has to resume
     * work. A value of <code>false</code> will send it into wait-state instead.
     *
     * @param Scrolling The new scrolling value
     */
    public void setScrolling(boolean Scrolling);

    /**
     * This method returns <code>true</code> if scrolling is currently active. If
     * it returns <code>false</code> then the scroll-thread is waiting.
     *
     * @return The scrolling value
     */
    public boolean isScrolling();

    /**
     * Description of the Class
     *
     * @author Joern Huxhorn
     */
    class AboutComponentListener extends ComponentAdapter {

        /**
         * Description of the Method
         *
         * @param e Description of the Parameter
         */
        public void componentResized(ComponentEvent e) {
            AboutPanel.this.calculateAttributes();
        }
    }

    /**
     * Description of the Class
     *
     * @author Joern Huxhorn
     */
    class AboutPropertyChangeListener implements PropertyChangeListener {

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void propertyChange(PropertyChangeEvent evt) {
            String propertyName = evt.getPropertyName();
            if (propertyName.equals(""border"")) {
                calculatePreferredSize();
            } else if (propertyName.equals(""foreground"")) {
                flushScrollImage();
            } else if (propertyName.equals(""background"")) {
                flushScrollImage();
            }
            //			else if ( propertyName.equals( ""locale"" ) )
            //			{
            //				initResources();
            //			}
        }
    }

    /**
     * This <code>MouseInputListener</code> handles the pause/resume on click as
     * well as the dragging inside the scroll-area.
     *
     * @author Joern Huxhorn
     */
    class AboutMouseInputListener extends MouseInputAdapter {

        Point lastPoint = null;

        boolean scrollingBeforePress = false;

        boolean dragged = false;

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mousePressed(MouseEvent evt) {
            if (handleMouseEvent(evt)) {
                // always stop scrolling if mouse is pressed inside
                // the scroll-area
                lastPoint = evt.getPoint();
                scrollingBeforePress = isScrolling();
                setScrolling(false);
            } else {
                lastPoint = null;
            }
            dragged = false;
        }

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mouseReleased(MouseEvent evt) {
            if (dragged) {
                // set scrolling-attribute to the value before the user dragged.
                lastPoint = null;
                setScrolling(scrollingBeforePress);
            }
        }

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mouseClicked(MouseEvent evt) {
            // this is only called after mouseReleased if no drag occurred.
            if (handleMouseEvent(evt)) {
                // toggle scrolling.
                setScrolling(!scrollingBeforePress);
            }
            dragged = false;
        }

        /**
         * Description of the Method
         *
         * @param evt Description of the Parameter
         */
        public void mouseDragged(MouseEvent evt) {
            // only drag if original press was inside scroll-rectangle
            if (lastPoint != null) {
                dragged = true;
                Point currentPoint = evt.getPoint();
                int yOffset = lastPoint.y - currentPoint.y;
                setScrollPosition(getScrollPosition() + yOffset);
                lastPoint = currentPoint;
            }
        }
    }

    private class TimerActionListener implements ActionListener {

        private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);

        private long lastRepaintStart;

        private long frequency = 25;

        public void actionPerformed(ActionEvent e) {
            long currentTime = System.nanoTime() / 1000000;
            long meanTime = currentTime - lastRepaintStart;
            if (meanTime > frequency) {
                if (logger.isDebugEnabled())
                    logger.debug(""Tick! meanTime={}"", meanTime);
                increaseScrollPosition();
                lastRepaintStart = currentTime;
            }
        }
    }
}
","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains one unit test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains one unit test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {
"
3a8be184-2d6d-4ed4-9070-c069b7a8fcdd,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/logback/classic/NDC.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    private static final NDCAdapter ndcAdapter;

    static {
    }

    private NDC() {
    }

    public static void push(String message);

    public static void push(String messagePattern, Object[] arguments);

    /**
     * Pops the last message from the stack.
     * <p/>
     * This method does not return the popped message to discourage it's usage in application logic.
     */
    public static void pop();

    public static int getDepth();

    public static void setMaximumDepth(int maximumDepth);

    public static boolean isEmpty();

    public static void clear();

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}
","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains one unit test case for the {@link NDC#getContextStack()} method.
*/
class NDCTest {","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains one unit test case for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
"
953d2a15-33f8-4189-b1ce-a1b91bc8cc13,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_0Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_0Test {","// MessageFormatter_0Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_0Test {
"
7dc2cfba-c5bb-453a-8485-df542a9cf070,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatter_1Test {","// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatter_1Test {
"
ebad2972-beb4-48de-8d7b-e9506f4b1fc3,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_2Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_2Test {","// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_2Test {
"
76ba43dc-4318-4a73-95a0-6bf26d867987,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_3Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    private static final char DELIM_START = '{';

    private static final char DELIM_STOP = '}';

    private static final char ESCAPE_CHAR = '\\';

    public static final String RECURSION_PREFIX = ""[..."";

    public static final String RECURSION_SUFFIX = ""...]"";

    public static final String ERROR_PREFIX = ""[!!!"";

    public static final String ERROR_SEPARATOR = ""=>"";

    public static final String ERROR_MSG_SEPARATOR = "":"";

    public static final String ERROR_SUFFIX = ""!!!]"";

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments      the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments      the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);

    public static String deepToString(Object o);

    /**
     * This method performs a deep toString of the given Object.
     * Primitive arrays are converted using their respective Arrays.toString methods while
     * special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could
     * contain themselves.
     * <p/>
     * dejaVu is used in case of those container types to prevent an endless recursion.
     * <p/>
     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
     * They only check if the container is directly contained in itself, but not if a contained container contains the
     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
     * Confusing? Just read the last paragraph again and check the respective toString() implementation.
     * <p/>
     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
     * would produce a relatively hard-to-debug StackOverflowError.
     *
     * @param o      the Object to convert into a String
     * @param str    the StringBuilder that o will be appended to
     * @param dejaVu a list of container identities that were already used.
     */
    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu);

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);

    /**
     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
     * return two results, i.e. the resulting String[] and the optional Throwable.</p>
     * <p/>
     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
     * available/different in the deserializing VM.</p>
     */
    public static class ArgumentResult {

        private Throwable throwable;

        private String[] arguments;

        public ArgumentResult(String[] arguments, Throwable throwable) {
            this.throwable = throwable;
            this.arguments = arguments;
        }

        public Throwable getThrowable() {
            return throwable;
        }

        public String[] getArguments() {
            return arguments;
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append(""ArgumentResult[throwable="").append(throwable);
            result.append("", arguments="");
            if (arguments != null) {
                result.append(""["");
                boolean isFirst = true;
                for (String current : arguments) {
                    if (!isFirst) {
                        result.append("", "");
                    } else {
                        isFirst = false;
                    }
                    if (current != null) {
                        result.append(""'"").append(current).append(""'"");
                    } else {
                        result.append(""null"");
                    }
                }
                result.append(""]"");
            }
            return result.toString();
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            ArgumentResult result = (ArgumentResult) o;
            if (!Arrays.equals(arguments, result.arguments))
                return false;
            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)
                return false;
            return true;
        }

        public int hashCode() {
            int result;
            result = (throwable != null ? throwable.hashCode() : 0);
            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);
            return result;
        }
    }
}
","// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_3Test {","// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_3Test {
"
