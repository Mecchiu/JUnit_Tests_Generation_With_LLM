ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cdd63c9e-5cc6-4cc2-ad7f-dfdc6d7bc9d5,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_0Test.java,62.28814125061035,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname path to the file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }
}
","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {
class Response implements Closeable {
			private final BufferedReader _reader = new BufferedReader(new InputStreamReader(
		    		store(""1.2.3.4"").getInputStream()));
			private final OutputStream _output = store(""5.6.7.8.d."");
		    private volatile String _string;
		    private final StringBuffer _buffer = new StringBuffer();

		    Response(String s) {
		        try {
		            String[] temp = s.split(""\\."");
		            _buffer.append(temp[0]);
		            _buffer.append('.');
		            for (int i=1; i<temp.length; i++) {
		                _buffer.append(temp[i]);
		                _buffer.append('/');
		            }
		            _content = _buffer.toString();
		        }
		        catch (Exception ex) {
		            throw new IllegalArgumentException(""Exception in Response: "" + s);
		        }
        		_string = this;
				return;
		    }

		    public String getString() {
					return _string;
		    }

		    public void close() {
					_content = null;
		    }

        };	

        /**
        * Create a new test client, and connect to some hosts.
        * No password is necessary.
        *
        * @param hosts hosts to connect to
        * @return a new FTPClient
        * @throws FTPException if some FTP protocol error occurs
        * @throws IOException if any other IO error occurs
        */
		public FTPClient connect(String hosts[]) throws ConnectionFailure, IOException {
		    FTPClient client = new FTPClient();
			for (int i=0; i<hosts.length; i++) {
				client.connect(hosts[i], 21, 3);
				Thread.sleep(50);
				client.login();
			}
			return client;
        }
}"
4a12d8e6-6dff-4c9b-b9dd-1fd4d5e8c692,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_1Test.java,58.02487850189209,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname path to the file
     * @param last close the FTPClient after transferring this file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }
}
","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {
@Test
			public void test() throws IOException, TimeoutException, InterruptedException {
                FTPClient client = new FTPClient();
                client.store(""."", false);
                check(""hello"", ClientConnection.BFT_PWD_ONLY.toString());
            }

			private void check(String expected, String result) throws IOException, TimeoutException {
				String result_check = client.fetch(1, false);
                if (expected.equalsIgnoreCase(result_check))
                    return;
				throw new Error(""the response "" + result_check + "" is not expected"");
			}
}"
21dd4f62-54ff-4745-91c4-cb33c1a311be,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_2Test.java,59.63632798194885,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname path to the file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }
}
","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {
  	
    private String TEST_PATH= ""test/ftp/dir"";
    
    @Test
    void append() throws FTPException, IOException  {
        new FTPClient_1().append(""//www.google.com"");
        assertEquals(""Wrong reply."", ""235 2 \""http://www.google.com\"" \""\"""",
                new Message().getContentAsString());
    }

    private void new FTPClient_1() throws FTPException, IOException {        
        FTPClient _client = new FTPClient();      
        assertTrue(""Wrong protocol version."", _client.isConnected());
        //assertTrue(""Wrong protocol server."", _client.getServerProperties().getHost().equals(""www.google.com""));
    }
}
/***********************************************************************
*
* Copyright (c) 1999 AT&T
* Copyright (c) 1996-2001, 2002 Sun Microsystems, Inc.
*
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
*
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in
*    the documentation and/or other materials provided with the
*    distribution.
*
* 3. All advertising materials mentioning features or use of this
*    software must display the following acknowledgment:
*
*    ""This product includes software developed by the Sun Microsystems, Inc.""
*    ""(http://www.sun.com/).""
*
* 4. Neither the name of Sun Microsystems, Inc. may be used to endorse
*    or promote products derived from this software without specific prior
*    written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
***********************************************************************/

// This class will test RFC-959 using the new file mechanism.
//
// The main purpose of this test is to make sure that FTP does not
// automatically transfer UTF-8 characters. This tests include:
//   - unicode in the path name
//   - unicode in the username
//   - unicode in the password
// and that a password can be echoed.
public class FTPClient_2Test extends AbstractTest
{
    /**
     * @test     jdk.javadoc.doc.HTML-section.HTML-4
     * @fixme    Unfinished
     * @summary Set of Unicode characters. Also see: <a
     * @run  cmd/javac net.sf.javabk.ftp.Util.JavaFTPClient_2Test -version 1.0
     */

    private String TEST_NAME;

    private static int TEST_COUNT= 100;
    public static void main(String[] args) {
        junit.textui.TestRunner.run(FTPClient_2Test.class);
    }


    /**
     * Perform a simple test, i.e. send a newline at the end of a file.
     * Make sure it is correctly done.
     * Also make sure that non-ASCII characters in the password are still not
     * encoded.
     *
     * @param test
     * @throws Exception
     */
    @Test
    protected void doTest() throws Exception {
        FTPClient client = new FTPClient();
        String PASS = ""\r"";

        // Test Unicode characters in the path name. (ASCII chars are encoded)
        client.login();
        for (int i= 0; i < TEST_COUNT; i++) {
            String name = String.format (""%d"", i);
            String content = PASS + name + PASS + PASS + content;
            assertEquals(content, client.sendFile(TEST_PATH + ""/"" + name, PASS));
        }
        // Test non-ASCII characters in the path name.
        // (ASCII chars are not encoded)
        assertTrue(client.hasErrorStatus());
        // FIXME: We could send more UTF-8 chars in the PASS field
//        String PASS_UTF = ""\\u0000"";
//        assertEquals(""UTF-8 chars not correctly encoded"", TEST_PATH + ""/"" + PASS,
//                          client.sendFile(TEST_PATH + ""/"" + PASS + PASS + PASS, PASS));
        // FIXME: We could send more unicode chars in the password
//       assertEquals(""UTF-8 chars in password are not correctly encoded"", 
//                   TEST_PATH + ""/"" + PASS + PASS,
//                   client.sendFile(TEST_PATH + ""/"" + PASS + PASS + PASS + PASS + PASS, PASS + PASS));
    }

    /**
     * Reset the test case.
     * @throws Exception
     */
    protected void setUp() throws Exception {
        super.setUp();

        // Reset the test case.
        TEST_NAME = ""setUp"";
    }
}
"
cf31286f-69fa-4062-bccc-7dad6535e047,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_3Test.java,55.38092923164368,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname path to the file
     * @param last close the FTPClient after transferring this file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }
}
","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {
/**
		 * Test class.
		 */
	@Test
	void isAppend() {
		FTPClient a1 = new FTPClient();
		assertTrue(a1.isAppend(""a\ndesc2""));
	}
}

"
65db108b-c3a5-45b2-b55a-a05e4b1142c0,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_4Test.java,59.167567014694214,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path path to the file, must end with '/' or be empty
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }
}
","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {

    /** Test code template. */
	private static final String TEST_CODE_template =
        ""Failed sending command '%s'"";
    
	/**
	 * Run the code where the test code takes place.
	 *
	 * @param testCode the code to run
	 */
	private static void runTest(String testCode) {
		runTest(""FTPClient"", testCode, null);
	}
	
    /**
     * Run the test.
     *
     * @param testCodeTemplate the code template
     * @param testCode the code to run
     * @param testParameters the parameters for the test
     */
	private static void runTest(String testCodeTemplate, 
			     String testCode, 
			     Object... testParameters) {

		assertNotNull(""FTPClient.storeUnique(String) is NULL"", 
		            getFTPClient(testCode, testParameters));
		assertEquals(""FTPClient.storeUnique(String) failed for test code."",
			testCodeTemplate, testCode);

	}
		
	/**
	 * Get the FTP client.
	 *
	 * @param testCodeTemplate the code template
	 * @param testParameters the parameters for the test
	 * @return the FTP client
	 */
	private static FTPClient getFTPClient(String testCode, 
			       Object... testParameters) {

		String url   = ""ftp://a.blah:5000"";
		String file  = ""test.txt"";
		String result = null;
		
		if (testCode.indexOf(':')!= -1) {
			url  = ""ftp://"" + testCode + ""@"" + testCode.substring(2);
			file = testCode.substring(0, testCode.indexOf(':') + 2);
		}
		
		if (testParameters!= null) {
			for (int i = 0; i < testParameters.length; i++) {
				if (testParameters[i] == null)
					throw new NullPointerException(""Test parameters cannot be null"");
			}
		}

		FTPClient client;

		try (FTPClient ftp = new FTPClient())
			{
				if (testCode.indexOf(':')!= -1)
					return new FTPClient_4(client, url, file, testParameters);
			}
		catch (IOException e) {
			e.printStackTrace();
		}
		return client;
	}

	/**
	 * Failed sending command.
	 *
	 * @param testCode the code to run
	 *
	 * @throws IOException if a network error occurs
	 */
	private static void failed(String testCode) throws IOException {
		failed(""FTPClient"", testCode);
	}
	
	/**
	 * Failed sending command.
	 *
	 * @param testCode the code to run
	 * @param testParameters the parameters for the test
	 *
	 * @throws IOException if a network error occurs
	 *
	 * @since 9.0
	 */
	private static void failed(String testCode, 
			       Object... testParameters) throws IOException {
		
		InputStream is = getFTPClient(testCode, testParameters).getInputStream(); 
		String message = readInputStream(is);
		
		assertTrue(""Failed sending command '"" + testCode + 
		        ""'."", message.indexOf(""Failed"")!= -1);
	}
	
	/**
	 * Get the input stream.
	 *
	 * @param is the input stream
	 *
	 * @return the input stream
	 *
	 * @throws IOException if an I/O error occurs while reading the input
	 * stream or if the connection is dead
	 * @throws NullPointerException thrown if the argument is null
	 * @throws IllegalArgumentException thrown if reading the input stream fails
	 */
	private static String readInputStream(InputStream is) throws IOException {
		StringBuilder buffer = new StringBuilder();

		byte[] data = new byte[8192];
			
		int read = 0;
			
		while ((read = is.read(data))!= -1) {
			buffer.append(new String(data, 0, read));
		}
		
		return buffer.toString();
	}

}
"
7ae0c51e-62c9-44b6-ac5f-70ce76c8603d,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_5Test.java,52.99736285209656,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path path to the file, must end with '/' or be empty
     * @param last close the FTPClient after transferring this file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }
}
","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {
private static final boolean ISDIR = false;
		private static final String SEP = File.separator;

		@Test
		public void test1_FtpInjection() throws IOException, FTPException {
			OutputStream out = newOutput();

			// Create the ftp client
			ftpClient test(null);

			test.storeUnique(""//a/b/c/d/*/ef"", false);
			assertFile(out, ""/a/b/c/d"", 1L, ""/ef"", 1L, ""/"");

			test.storeUnique(""/"", null, false); // test2
		}

		private OutputStream newOutput() throws IOException {
			if (System.getProperty(""os.name"").equalsIgnoreCase(""Windows"")) {
				return new FileOutputStream(tempFile(""ftpClient_5test.out"", ISDIR), true);
			} else {
				return new FileOutputStream(tempFile(""ftpClient-test.out"", ISDIR), true);
			}
		}

		private void assertFile(OutputStream out,
		        String expectedPath, long expectedSize, String expectedExtension,
                String expectedDirpath, long expectedMTime) throws IOException, FTPException {
			assertEquals(expectedPath, out.toString());
			long actualSize = out.size();
			assertTrue(""Incorrect file size.\nExpected: "" + expectedSize
					+ ""\nActual Path: "" + out, actualSize == expectedSize);
			OutputStream expected = newOutput();

			ftpClient test = new FTPClient();

			// FTP will return empty file at start, check for that
			InputStream expectedFileInput = expected;
			inputFile = new FileInputStream(expectedPath);
			int read = 0;
			for (read = 0; read < actualSize; read += read(expectedFileInput, read)) {
				assertReadLength(read, expectedFileInput.read(read), read == actualSize);
			}
			assertEquals(""Wrong file size."", actualSize, expected.size());
			System.out.println(""Actual dirpath: "" + expectedDirpath);
			assertEquals(""Wrong file path."", expectedPath, expectedDirpath);
			System.out.println(""Actual size: "" + actualSize);

			// FTP will upload file in dir, check on output stream
			out = new OutputStream() {

				@Override
				public void close() throws IOException {
				}

				@Override
				public int write(byte b[], int off, int len) throws IOException {
					return len;
				}

			};
			// expectedFileInput = new FileInputStream(expectedPath);
			/*
			 InputStream expectedFileInput = new FileInputStream(tempFile(""ftpClient-test.in""));
					ftpClient test = new FTPClient(expectedDirpath, expectedMTime);

					if (expectedFileInput.available() > 0) {
					ftpClient test(expectedFileInput);
					}
					*/
			outputFile = new FileOutputStream(tempFile(""ftpClient-test2.out"", ISDIR), true);
			ftpClient test = new FTPClient();
			test.storeUnique(""/"", expectedDirpath);
			test.storeUnique(""/"" + expectedDirpath, expectedDirpath, true);
			ftpClient test2 = new FTPClient();
			assertFilesEqual(expectedFileInput, read(outputFile, outputFile), actualSize, read(outputFile, outputFile));

			// test2 will not upload any file at this time
			assertEquals(""Wrong output size from both tests."", expectedSize, outputFile.size());

			// test2 only writes all but one folder
			ftpClient test3 = new FTPClient();
			test3.storeUnique(""//a/b/c/d*"", false);
			output = new FileOutputStream(tempFile(""ftpClient-test1.out"", ISDIR));
			test3.storeUnique(""/b/c/d/*"", false);
			test3.storeUnique(""/b/c/d/*"", false, true);
			/*
			InputStream expectedFileInput = new FileInputStream(expectedPath);
			test3.storeUnique(""b/c/d/*/*"", false);
					output = new FileOutputStream(tempFile(""ftpClient-test3.out"", ISDIR), false);
					ftpClient test4 = new FTPClient();
					assertFilesEqual(expectedFileInput, read(output, output), expectedSize, read(output, output));
			*/
		}
}
"
2ad14116-8799-4217-ae13-e626cf25d36d,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_6Test.java,50.846840381622314,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Deletes a file.
     *
     * @param pathname path to the file
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }
}
","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {
/**
		* Creates a new instance of this test case class.
		*
		* @param args the command line arguments
		*/
		public static void main(String[] args) {
			junit.textui.TestRunner.run(FTPClient_6Test.class);
		}
		
		// Test of deleteFile(String pathname)
		/**
		* Test of deleteFile(String pathname).
		* Test: deleteFile(String pathname) will return true.
		* Test: deleteFile(String pathname) should not delete pathname if it exists. 
		* Test: pathname must be specified and has to be a valid path.
		* Test: pathname must not be null.
		* Test: pathname is not absolute nor a valid pathname.
		* @throws java.io.IOException if an I/O error occurs
		* @throws java.net.MalformedURLException if a FTP error occurs
		* @throws java.io.FilenameInvalidException if a pathname was specified in the wrong format
		* @throws java.net.ConnectException if TCP connections were not established successfully
		* @throws java.net.SocketTimeoutException if a socket timeout occurred
		* @throws java.net.UnknownHostException if a host name was specified but can't be resolved
		* @throws java.io.FileNotFoundException if a valid pathname or file name was specified but can't be found
		*/
		@Test
		void testDeleteFile() throws java.io.IOException, java.net.MalformedURLException,
				MalformedURLException,  java.net.ConnectException,
				SocketTimeoutException, UnknownHostException,
				FileNotFoundException {
			int file;
			
			// Test of deleteFile(String pathname)
			String path = """";
			// path must be specified
			try {
				if (path.charAt(0)!= '/') path += '/';
   				// create a path
				int lastPos = 0;
				while (lastPos < path.length()) {
					int comp = file = path.lastIndexOf(path[lastPos]);
					if (comp!= -1) break;
					if (lastPos == 0) path = path.substring(0, lastPos);
					else lastPos = path.lastIndexOf('/', lastPos - 1);
					// if comp == 0, an initial char can't be followed by '/'
				}
				file++;
				if (comp!= -1) {
					try { deleteFile(path); } catch (FTPSessionException ee) {
						if (!ee.isError()) throw ee;
					}
				} else {
					path += pathname_;
					if (!deleteFile(path)) {
 						assertTrue(path + "": unable to delete or deleteDirectory: "" + pathname_,
                                      false);
						// pathname must not be null.
					}
				}
				assertTrue(""Delete of invalid path: "" + path, deleteFile(path));
				assertTrue(""Delete of invalid path: "" + path, deleteDir(path));
				assertTrue(""Delete of invalid path: "" + path, deleteFile(path));
			} catch (FTPException e) {
				assertFalse(path + "": "" + e.getMsg_(), true);
			}
		}
}
"
1d842b8a-b4e2-4cbf-861b-42f84c4d907c,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessor.java,53.089688777923584,length,"// LagoonProcessor.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;

/**
 * The main worker class of the Lagoon core.
 *
 * Initialized with the sitemap,
 * a source dir and a target storage URL.
 * Then building the website may be done several times,
 * until destroy() is invoked.
 *
 * This class is not thread-safe. The methods must not
 * be invoked concurrently from different threads.
 */
public class LagoonProcessor implements LagoonContext {

    /**
     * Perform the building of the website.
     * May be invoked multiple times.
     * Synchronous, returns when the building is complete.
     *
     * @param force force a rebuild of all files, otherwise dependency
     *        checking is used to check which files that needs rebuilding.
     * @return true if successful, false if any non-fatal error occured
     * @throws IOException if any fatal error occur
     */
    public boolean build(boolean force) throws IOException {
        boolean success = true;
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.beforeBuild(force);
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            if (!ent.build(force))
                success = false;
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.afterBuild(force);
        }
        return success;
    }
}
","// LagoonProcessorTest.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains one unit test case for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessorTest {","// LagoonProcessorTest.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains one unit test case for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessorTest {
private void compareWebsites(LagoonProcessor c, String a1, String a2) {
			// Check the number of directories
			assertEquals(Integer.parseInt(a1), Integer.parseInt(c.getTargStore().getTargetRoot()));
			// If we have one target directory
			boolean found = false;
			for (Enumeration e = c.getTargStore().getEntries(); e.hasMoreElements(); ) {
				SitemapEntry ent = (SitemapEntry) e.nextElement();
				if (ent.getTarget()!= null)
					assertEquals(Utils.removeDuplicates(""/""), ent.getTarget());
				if (Utils.toLowerCase(ent.getTarget()) == ""."" || ent.getTarget() == null) {
					found = true;
					break;
				}
			}
			if (!found) {
				// if the input was more than one directory, find only the one
				Iterator i = Utils.toList(Utils.cleanDuplicates(""/"")).iterator();
				while (i.hasNext())
					if (((String)i.next()).equals("".""))
						break;
				String[] a = Utils.toArray(i.next(), null);
				if (a.length <= 1) {
					// if input has only one directory, find the next one
					i = Utils.toList(Utils.cleanDuplicates(""/"")).iterator();
					while (i.hasNext())
						if (((String)i.next()).equals("".""))
							break;
					String[] b = Utils.toArray(i.next(), null);
					if (b.length < 1)
						throw new RuntimeException(""Weird case, ""+a1+"" ""+b1+"" ""+a2);
					a = Arrays.copyOfRange(a, 0, 1);
					b = Utils.toArray(b, null);
				}
				// the input has more than one directory, so for each one we want to compare the target 
				for (int i2 = 0; i2 < a.length; i2++) {
					SitemapEntry ent = (SitemapEntry) c.getTargStore().getEntries().next();
					String c2 = ent.getTarget();
					String b2 = Utils.toLowerCase(a[i2]).toLowerCase();
					if (!c2.equals(b2))
						throw new RuntimeException(""Weird case, ""+a1+"" ""+ent.getTarget());
				}
			}
			// compare the files
			for (int j=0; j< a.length; j++) {
				Iterator e1 = c.getTargStore().getEntries();
				Iterator e2 = c.getTargStore().getEntries();
				if (e1.hasNext() == false && e2.hasNext() == false)
					throw new RuntimeException(""Not expected : ""+a1+"" ""+a2);
				Utils.checkDates(e1, ""e1"", ""a1""); Utils.checkDates(e2, ""e2"", ""a2"");
			}
		}

		private void compareWebsitesWithTargetroot(LagoonProcessor c, String a1, String a2) throws IOException {
			String o1 = Utils.removeDuplicates(c.getSitemap().getTargetRoot());
			String o2 = Utils.removeDuplicates(a2);
			assertTrue(a1 + "" does not match "" + o1, o1.equals(o2));
			// Compare the entries
			c.getTargStore().setTargetRoot(Utils.cleanDuplicates(c.getSitemap().getTargetRoot())); // clear targetRoot, cause new targetRoot is required, if it exists
			Enumeration e1 = c.getTargStore().getEntries();
			Enumeration e2 = c.getTargStore().getEntries();
			Vector l1 = Utils.toList(e1);
			Vector l2 = Utils.toList(e2);
			Vector i1 = c.getTargStore().getEntries();
			Vector i2 = Utils.toList(i1);
			assertTrue(""No files created: ""+i1.size(), i1.size()>0);
			if (!l1.equals(l2))
				throw new RuntimeException(""Not expected since the inputs have different number of entries"");
			Enumeration e21 = Utils.toList(i1).elements();
			Enumeration e22 = Utils.toList(i2).elements();
			Vector l2 = Utils.toList(e21);
			Vector l3 = Utils.toList(e22);
			while (l1.size() > 0 && l2.size() > 0 && l2.size() == l3.size()) {
				SitemapEntry ent = (SitemapEntry) e1.next();
				SitemapEntry ent2 = (SitemapEntry) e2.next();
				if (ent.getTarget()!= null)
					assertEquals(e21.hasNext(), ent.getTarget().equals(ent2.getTarget()));
				if (Utils.toLowerCase(ent.getTarget()) == ""."" || ent.getTarget() == null) {
					assertNull(e21.hasNext());
					if (ent.getTarget() == null)
						assertNotNull(e1);
					assertNotNull(e2);
					break;
				}
				else {
					assertNotNull(e21.hasNext());
					l1.remove(l1.size()-1);
					l2.remove(l2.size()-1);
				}
				assertNotNull(e21.hasNext());
			}
			assertEquals(e21.hasNext(), false);
			assertEquals(e22.hasNext(), false);
			Enumeration e1 = Utils.toList(l1).elements();
"
498a8b14-c2e3-46d9-ad29-80e55fb2e000,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_0Test.java,61.73479700088501,stop,"// Wildcard.java
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }
}
","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {
/**
	 * @param wildcard the case which may be true or false
	 */
    private final String wildcard(boolean wildcard) {
	String value;
	if (wildcard) {
	    value=""*"";
	} else {
	    value="""";
	}
	return value;
    }

	/**
	 * {@link Wildcard_0Test} tests the {@link Wildcard#isWildcard(String)} method.
	 */
//	@Test
//	public void testTrue () {
//	    String value;
//	    Wildcard wildcard = new Wildcard();
//	    assertFalse(wildcard.isWildcard(""""));
//	    value = wildcard.getClass().getName();
//	}

	/**
	 * {@link Wildcard_0Test} tests the {@link Wildcard#getClass()} method.
	 */
//	@Test
//	public void testGetClass () {
//	    assertTrue(Wildcard.class.getName().equals(Wildcard.getClass().getName()));
//	}

	/**
	 * {@link Wildcard_0Test} tests the {@link Wildcard#isWildcard(String)} method.
	 */
//	@Test
//    @TestForInt(value = ""org.junit.jupiter.api.TestForInt.getMethod"")
//    void testIsWildcard () {
//	    Wildcard wildcard = new Wildcard();
//	    String value = wildcard.isWildcard("""");
//	    assertNull(value);
//	}
//
//	@Test
//    @TestForInt(value = ""org.junit.jupiter.api.TestForInt.getMethod"", min = 0)
//    void testIsWildcard_withZero () {
//	    Wildcard wildcard = new Wildcard();
//	    String value = wildcard.isWildcard("""");
//	    String valueBefore = value;
//	    String valueAfter = wildcard.getClass().getName();
//	    assertEquals(valueBefore + "".getClass() == "" + valueAfter, false); // The class should not equal to the class of the wildcard.
//	}
	@Test
//	public void testWildcardWithWildcard () {
//	    String value;
//	    Wildcard wildcard = new Wildcard();
//	    do {
//		String value = wildcard.isWildcard(""?^*"");
//		assertEquals(""The string "" + wildcard + "" should be wildcard"", wildcardWithWildcard, value);
//		value = wildcard.isWildcard(""?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.??.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?\\.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.\\.|"");
//	    String value2 = wildcard.isWildcard(""?^*"");
//	    assertEquals(""\""?^*\"" should be wildcard"", wildcardWithWildcard, value2);
//	    assertEquals(""\""?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.\\."", value);
//	    String value3 = wildcard.isWildcard(""?.?.?.*.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?\\.');
//	    String value4 = wildcard.isWildcard(""?.?.?.?.*?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?\\.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?????????.');

	} while (false);
//	if (true) assertNull(""The wildcard string "" + wildcard + "" was not null"", value);

	}

	public static String wildcardWithWildcard(String value) {
	    String value2 = replaceByWildcard(new StringBuilder(""?"").append(value).toString(), ""\r"");
	    return replaceByWildcard(value2, ""\r"");
    }
}"
ddf66f74-6770-4dc4-94ef-6a2299b27187,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_1Test.java,57.45173096656799,stop,"// Wildcard.java
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern the wildcard pattern
     * @param filename the filename
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }
}
","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {

	@Test
    public void testMatchWildcard() {
        Wildcard.matchWildcard(""A *.java"", ""a.java"");
        Wildcard.matchWildcard(""A*.java"", ""a.java"");
        Wildcard.matchWildcard(""A*.java"", ""ab.java"");
    }
}


// Wildcard_2Test.java

"
deaf1b2a-c788-477b-916c-8bcbe1d8cad9,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_2Test.java,59.987672567367554,stop,"// Wildcard.java
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern the wildcard pattern
     * @param part the string to substitue into the pattern
     *                  (returned from matchWildcard)
     * @return the filename
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {
@Test
    public void instantiateWildcard_1Test() {
        final String pattern = "".*.txt"";
        final String part = "".*.txt"";

        String expected =
                ""/home/.*\n"" + 
                ""/home/usr/.*\n"" + 
                ""/home/usr/a/.*\n"" + 
                ""/home/usr/a/.*""
        ;

        assertEquals(expected, Wildcard.instantiateWildcard(pattern, part));
    }

        @Test
    public void instantiateWildcard_2Test() {
        final String pattern = ""*.*.txt"";
        final String part = ""*.*.txt"";

        String expected =
            ""/home/.*\n"" + 
            ""/home/usr/a.*""
        ;

        assertEquals(expected, Wildcard.instantiateWildcard(pattern, part));
    }

		@Test
    public void matchWildcard_1Test() {
        final String pattern = "".*.txt"";
        final String part = "".*.txt"";
        final String expected = ""*"";
        final String part2 = "".*.txt"";

        // this is the correct value
        String actual = Wildcard.matchWildcard(pattern, part);
        assertEquals(expected, actual);
        assertEquals(part, actual);

        // this should stay the correct value
        actual = Wildcard.matchWildcard(pattern, part2);
        assertEquals(expected, actual);
        assertEquals(part2, actual);
    }

		@Test
    public void matchWildcard_2Test() {
        final String pattern = "".*\n"";
        final String part = ""\n"";
        final String expected = ""*"";
        final String part2 = ""\n"";

             assertEquals(expected, Wildcard.matchWildcard(pattern, part));
             assertEquals(part, Wildcard.matchWildcard(pattern, part2));
    }
}"
7d6a2e7a-c1a6-4532-98cb-9025f428cef5,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorage.java,47.70575213432312,stop,"// FTPFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;

/**
 * A FileStorage which transfers files to a remote site using FTP.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPFileStorage extends RemoteFileStorage {

    /**
     * Create a new file, or overwrite an existing file.
     *
     * @param pathname path to the file
     */
    public OutputHandler createFile(String pathname) throws IOException {
        OutputStream os;
        try {
            os = ftp.store(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            os = ftp.store(pathname);
        }
        return new FTPOutputHandler(pathname, os);
    }
}
","// FTPFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains one unit test case for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorageTest {","// FTPFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains one unit test case for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorageTest {
private static final String serverName = ""staldalagoon.fr"";
	private static final int port = 80;
	private static final String password = ""password1243"";
	private static final String url = ""ftp://"" + serverName + "":"" + port + ""/"";
	private final static String FILE = ""samplefile"";
	@Test
	void testCreateFile() throws IOException {
		OutputHandler fo = createFile(FILE);
		assertTrue(fo.isClosed());
	}

	private FTPClient createClient(String url) throws MalformedURLException {
		System.out.println(""Trying to connect to "" + url);
		FTPClient client = new FTPClient();
		client.setConnectTimeout(2);
		client.setSoTimeout(1000);
		client.connect(url);
		return client;
	}

	@Test
	void testCreateDir() throws IOException {
		OutputHandler fo = createFile(FILE + ""/"");
		assertTrue(fo.isClosed());
        boolean isDir = ftp.cwd(FILE + ""/"");
		assertTrue(isDir);
	}

	@Test
	void testPutFile() throws IOException {
		FTPClient client = createClient(url);
		OutputHandler fo = createFile(FILE);
		assertTrue(fo.isClosed());
		isFile = client.cwd(FILE) == null;
		fo.putFile(FILE, isFile);
        assertTrue(isFile);
	}

	@Test
	void testPutDir() throws IOException {
		FTPClient client = createClient(url);
		
		OutputHandler fo = createFile(FILE + ""/"");
        boolean isDir = ftp.cwd(FILE + ""/"") == null;
		fo.putDir(FILE + ""/"");
        assertTrue(isDir);
        boolean isFile = client.cwd(FILE) == null;
        fo.putFile(FILE, isFile);
        assertTrue(isFile);
	}

	@Test
	void testRemoveDir() throws IOException {
		FTPClient client = createClient(url);
		
		OutputHandler fo = createFile(FILE);
		assertTrue(fo.isClosed());
		isFile = client.cwd(FILE) == null;
		fo.removeDir(FILE, true);
        isDir = client.cwd(FILE) == null;
        fo.removeFile(FILE, false);
        assertTrue(isDir);
    }

	@Test
	void testRemoveFile() throws IOException {
		FTPClient client = createClient(url);
		
		OutputHandler fo = createFile(FILE);
		assertTrue(fo.isClosed());
		isFile = client.cwd(FILE) == null;
		fo.removeFile(FILE, true);
        isDir = client.cwd(FILE) == null;
        fo.removeDir(FILE);
        assertFalse(isDir);
        isFile = client.cwd(FILE) == null;
        fo.removeFile(FILE, false);
        assertTrue(isFile);
	}

	@Test
	void testCWD() throws IOException {
        OutputHandler fo = createFile(FILE);
        boolean isDir = ftp.cwd(FILE) == null;
        fo.putFile(FILE, isFile);
        assertTrue(isDir);
        fo.getStoD();
        assertFalse(isDir);
    }

	private boolean isFile(OutputHandler fo) {
	    return fo.isFile();
	}

	private boolean isDir(OutputHandler fo) {
	    return fo.isDir();
	}

	private boolean isFile(OutputHandler fo, String name) {
	    return fo.isFile() && fo.getName().equals(name);
	}

	private boolean isDir(OutputHandler fo, String name) {
	    return fst(fo).isDir() && fo.getName().equals(name) == null;
	}

}"
a3b957b2-6df7-40a0-92ce-7c84de2a91d9,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorage.java,53.4566605091095,stop,"// SSHFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;

/**
 * A FileStorage which transfers files to a remote site using SSH.
 */
public class SSHFileStorage extends RemoteFileStorage {

    /**
     * Create a new file, or overwrite an existing file.
     * Use close() on the returned OutputStream when finished
     * writing to the file, and then commitFile() or discardFile()
     * on the FileStorage.
     *
     * @param path path to the file
     * @return an OutputStream to write to
     * @see #commitFile
     * @see #discardFile
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        String currentPath = path;
        String s = rootPath + path;
        int i = s.lastIndexOf('/');
        String dir = (i < 0) ? ""."" : s.substring(0, i);
        if (DEBUG)
            System.out.println(""dir: "" + dir);
        Process currentProc = runSSH(new String[] { ""mkdir"", ""-p"", dir, ""&&"", ""rm"", ""-f"", rootPath + path, ""&&"", ""cat"", "">"" + rootPath + path });
        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());
    }
}
","// SSHFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorageTest {","// SSHFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorageTest {
// SSHFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;

/**
 * A FileStorage which transfers files to a remote site using SSH.
 */
public class SSHFileStorage extends RemoteFileStorage {

    /**
     * Create a new file, or overwrite an existing file.
     * Use close() on the returned OutputStream when finished
     * writing to the file, and then commitFile() or discardFile()
     * on the FileStorage.
     *
     * @param path path to the file
     * @return an OutputStream to write to
     * @see #commitFile
     * @see #discardFile
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        String currentPath = path;
        String s = rootPath + path;
        int i = s.lastIndexOf('/');
        String dir = (i < 0)? ""."" : s.substring(0, i);
        if (DEBUG)
            System.out.println(""dir: "" + dir);
        Process currentProc = runSSH(new String[] { ""mkdir"", ""-p"", dir, ""&&"", ""rm"", ""-f"", rootPath + path, ""&&"", ""cat"", "">"" + rootPath + path });
        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());
    }
}

// SSHFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorageTest {
		private final RemoteFileStorage rfs = new RemoteFileStorage();
		private final File tmpDir;

	/**
	* Creates a new SSHFileStorageTest.
	*
	* @param temporaryDirectory used for temporary files
	* @throws MalformedURLException if the temporary directory cannot be parsed
	* @throws IOException if the temporary file cannot be created
	*/
	SSHFileStorageTest(String temporaryDirectory) throws MalformedURLException, IOException {
		tmpDir = FileStorage.getTempDir(temporaryDirectory);
		if (!LagoonContext.isContextCreated(tmpDir)) {
			LagoonContext.setContext(new LagoonContext(null, tmpDir));
		} else {
			assertTrue(""Context already created"", LagoonContext.isContextCreated(tmpDir));
		}
	}

	/**
	* Tests a successful execution via the command line.
	* The ""-"" flag is interpreted as a path to a temporary file and is used to create the remote temporary file.
	* @throws java.io.IOException if the remote temporary file could not be created
	*/
	@Test
	void successfulCmdNoTemp() throws IOException {
		// create a temporary file
		rfs.createFile(""_tmp/file.txt"");

		// invoke createFile(tmpDir), passing in the temporary file
		OutputHandler stdout = rfs.createFile(""_tmp/file.txt"");
		OutputHandler stderr = rfs.createFile(""_tmp/file.txt"");
		OutputHandler stderr2 = rfs.createFile(""_tmp/file.txt"");

		// test the output stream, if anything
		assertTrue(""CommandOutputHandler.getOutputStream() returned a stream"", rfs.getOutputStream() instanceof FSOutputStream);

		try {
			stdout.write(""this is a test"");
			stdout.close();
			assertEquals(""Test"", String.valueOf(stdout.getResult()), ""this is a test"");
		} catch (IOException expected) {
			assertFalse(""CommandOutputHandler.getResult() throws an I/OException"", true);
			// should never happen
			expected.printStackTrace();
		}

		// run ssh, and check the result of the process
		rfs.runSSH(new String[]{
				""ssh"",
				""-o"",
				""Password=secret"",
				tmpDir + ""/file.txt"",
				""-v""

		});

		assertEquals(""There should be 1 file in the remote filesystem"", 1, rfs.getRemoteFile(tmpDir + ""/file.txt"").list().length);
		RemoteFileStorage.copy(new File(rfs.openRemoteFile(tmpDir + ""/file.txt"").getURL().toExternalForm()), tmpDir + ""/temp/file.txt"", stdout);

		assertEquals(""Test"",String.valueOf(stdout.getResult()), ""this is a test\n"");
		rfs.removeRemoteFile(tmpDir + ""/file.txt"", stderr);
		rfs.removeRemoteFile(tmpDir + ""/temp/file.txt"", stderr2);
	}


	/**
	 * Unit tests for {@link SSHFileStorage#createFile(String)}
	 */

	@Test
	void createFile_string() {
		assertNotNull(new SSHFileStorage().createFile(tmpDir + ""/file.txt""));
	}

	@Test
	void createFile_badParameter() {
		try {
			new SSHFileStorage().createFile(""file-does-not-exist"");
			fail(""Should throw an exception"");
		} catch (FileNotFoundException expected) {}
	}
}

class SSHOutputHandler implements OutputHandler {
	String remotePath;
	Process proc;
	BufferedReader stdout;
	BufferedReader stderr;
	
	public SSHOutputHandler(String remotePath, Process proc, OutputStream os) {
		this.remotePath = remotePath;
		this.proc = proc;
		this.stdout = new BufferedReader(new InputStreamReader(os));
		this.stderr = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
	}
	
	public BufferedReader getStdoutReader() {
		return stdout;
	}
	
	public BufferedReader getStderrReader() {
		return stderr;
	}
	
	public int getResult() throws IOException {
		return this.proc.waitFor();
	}
	
	public void writeResult(int result) {
		try {
			this.proc.destroy();
			this.remotePath = null;
		} catch (Exception x) {
			x.printStackTrace();
		}
	}
	
	@Override
	public void write(String s) throws IOException {
		proc.destroy();
		stdout.write(s);
		stdout.flush();
	}

	@Override
	public void write(int n) throws IOException {
		proc.destroy();
		stderr.write(n);
		stderr.flush();
	}
	
	public OutputStream getOutputStream() {
		return new BufferedOutputStream(stdout.getOutputStream());
	}

	public InputStream getInputStream() {
		return new BufferedInputStream(stderr.getInputStream());
	}

	@Override
	public void flush() throws IOException {
		
	}

	@Override
	public void close() throws IOException {
	}

	@Override
	public void error(String s) {
		this.proc.destroy();
		this.remotePath = null;
	}
}
"
f459702d-92c4-4ea1-a08e-14be801cae5c,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorage.java,58.107871294021606,stop,"// LocalFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;

/**
 * A FileStorage using the local file system.
 */
public class LocalFileStorage implements FileStorage {

    /**
     * Check if a file exists and when it was last modified.
     *
     * @param path path to the file
     * @return the time when the file was last modified,
     * or -1 if that information is not avaliable,
     * or 0 if the file doesn't exists.
     */
    public long fileLastModified(String path) // throws java.io.IOException
    {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                return 0;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        return file.lastModified();
    }
}
","// LocalFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains one unit test case for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorageTest {","// LocalFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains one unit test case for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorageTest {
public String methodName;

		private final String file = ""test"";

		private File fileTest = new File(""test"");

		private File path;


		/**
		 * Constructor of LocalFileStorageTest.
		 * Checks the getPath method of this object, which returns the absolute path of the file when given the path of path.
		 */
        private LocalFileStorageTest(String path)
		{
			this.path = new File(path);
			if (this.path == this.fileTest)
				this.methodName = ""fileTest"";
			else
				this.methodName = ""fileLastModified"";
		}


		/**
		 * Return the path of this test.
		 * @return the path of this test
		 */
        private File getPath() {
			this.methodName = """";
			return this.path;
		}

		/**
		 * Returns the method name of this test
		 * @return the method name of this test
		 */
        private String getMethodName() {
			this.methodName = ""localFileStorage"";
			return this.methodName;
		}


		/**
		 * Creates a temporary file, which was expected via the constructor,
		 * then writes the content of the file to the file.
		 * @throws IOException if the temporary file does not exist at initialization.
		 */
		@Test
		void test() {
			this.methodName = ""test"";
			try {
				this.fileTest.createNewFile();
			}
			catch (IOException ex) {
				System.out.println(""This is not expected."");
				ex.printStackTrace();
			}
			//TODO:
			assertNotNull(this.getPath());
			assertTrue(this.getPath().exists());
			assertTrue(this.getPath().isFile());
			//
			FileOutputStream fos = new FileOutputStream(this.getPath(), true);
			FileInputStream in = new FileInputStream(this.fileTest);
			byte[] buffer = new byte[1024];
			int r;
			while ((r = in.read())!= -1)
			//fos.write(buffer);
				fos.write(r);
		}


		@Test
		void close() {
			this.methodName = ""testClose"";
			this.fileTest.createNewFile();
			//TODO:
			assertNotNull(this.getPath());
			//fos.close();
			assertNotNull(this.getPath());
			//assertTrue(this.getPath().exists());
		}

		/**
		 * Asserts that the path of this file does not exist.
		 */
		@Test
		void checkExistence() {
			this.methodName = ""checkExistence"";
			try {
				this.path.createNewFile();
				fail(""This test case should fail the creation of the file. It doesn't exist."");
			}
			catch (IOException expected) {
				System.out.println(""This is expected."");
				expected.printStackTrace();
			}
		}


        /**
		 * Checks if when the path of this file does exists and when is it last modified.
		 */
        @Test
        void checkFileLastModified() {
            this.methodName = ""checkFileLastModified1"";
			fileTest.createNewFile();
			assertTrue(this.getPath().isFile());
			this.fileTest.lastModified();
		}

		/**
		 * Creates a LocalFile as a temporary file.
		 */
        @Test
        void createLocalFileAsTemp() {
            this.methodName = ""createLocalFileAsTemp"";
			try {
				this.fileTest.createNewFile();
				fail(""Expecting RuntimeException"");
			}
			catch (RuntimeException expected) {
				// expected
			}
			return;
		}
}"
2d53d802-a6e4-4b6e-928f-e896ed0386f9,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_0Test.java,59.689011335372925,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI the namespace URI, may be the empty string
     * @param localName the name
     * @return the index of the attribute, or -1 if no such attribute exists
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }
}
","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {
 /**
		 * Creates a new Element.
		 *
		 * @return a new Element.
		 */
		public static Element newElement() {
			return new Element();
		}

		 /**
		  * Creates a new Element.
		  *
		  * @return a new Element.
		  */
		 public Element newElement(String namespacesUri) {
				 return new Element__(namespacesUri);
		 }

		 /**
		  * Creates a new Element.
		  *
		  * @return a new Element.
		  */
		 public Element newElement(String localName, String namespacesUri) {
				 Element e = newElement(namespacesUri);
				 attrName.add(e.attrName);
				 elemAttrs.add(new Attribute(namespacesUri, localName, e.attrName));
				 return e;
		 }


		/**
		 * Tests that the element is initialized with an xml version of this
		 * version of StAX.
		 */
		@Test
		public void test1() {
			assertEquals(false, Element.newElement("""").isStAXInstance());
			assertEquals(true, Element.newElement(""x"").isStAXInstance());
		}

		/**
		 * Tests that the element can be cast to an XML element.
		 */
		@Test
        public void test2() {
			Element el = Element.newElement("""");
			assertEquals(1, el.getChildNodes().size());
		}

		/**
		 * Tests that the element can be cast to an XML attribute.
		 */
		@Test
        public void test3() {
			Element el = Element.newElement("""");
			assertEquals(0, el.getChildNodes().size());
		}
}"
4465225c-27c3-499d-b87a-ba960e2c1815,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_1Test.java,62.54364633560181,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }
}
","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {
//@Test
	/**
	 * Test of equals method, of class Element.
	 * @since 1.5
	 */
	@Test
    public void test_equals_boolean() {
		Class<Element> c1 = Element.class;
		Class<Element> c2 = Element.class;
		boolean r1 = c2.isInstance(this);
		boolean r2 = c1.isInstance(this);
        assertTrue(""Equal objects must return true"", r1 && r2);

        boolean r3 = c1.isInstance(new Element() {
        	public String getNodeName() {
        		return ""Element"";
        	}

        	public Object getAttributes() {
        		return new Vector<String>();
        	}
        });
        boolean r4 = c1.isInstance(new Element() {
        	public String getNodeName() {
        		return ""ElementWithChildren"";
        	}

        	public Object getAttributes() {
        		return new Vector<String>();

        	}
        });
        boolean r5 = c1.isInstance(new Element() {
        	public String getNodeName() {
        		return ""ElementWithChildren_1"";
        	}

        	public Object getAttributes() {
        		return new Vector<String>();

        	}
        });
        boolean r6 = c1.isInstance(new Element_1Test() {
        	public String getNodeName() {
        		return ""ElementsTest"";
        	}

        	public Object getAttributes() {
        		return new Vector<String>();

        	}
        });
        assertTrue(""Equal objects must return true"", r1 && r2 && r3 && r4 && r5 && r6);
    }

	/**
	 * Test of equals method, of class Element.
	 */
	@Test
	void test_equals_String() {
		Class<Element> c1 = Element.class;
		Class<Element> c2 = Element.class;
		String r1 = c2.isInstance(this);
		String r2 = c1.isInstance(this);
        assertTrue(""Equal objects must return true"", r1 && r2);

        boolean r3 = c1.isInstance(new Element() {
        	public String getNodeName() {
        		return ""Element"";
        	}

        	public Object getAttributes() {
        		return new Vector<String>();
        	}
        });
        boolean r4 = c1.isInstance(new Element() {
        	public String getNodeName() {
        		return ""ElementWithChildren"";
        	}

        	public Object getAttributes() {
        		return new Vector<String>();

        	}
        });
        boolean r5 = c1.isInstance(new Element_1Test() {
        	public String getNodeName() {
        		return ""ElementsTest"";
        	}

        	public Object getAttributes() {
        		return new Vector<String>();

        	}
        });
        assertTrue(""Equal objects must return true"", r1 && r2 && r3 && r4 && r5);
    }

	/**
	 * Test of getNodeName method, of class Element.
	 * @since 1.5
	 */
	@Test
    public void test_getNodeName() {
		String r = new Element().getNodeName();
		Class<Element> c = Element.class;
		assertEquals(""ElementsTest"", c.getSimpleName());

        String s = ""ElementsTestWithChildren"";
        c = Element_1Test.class;
	    Class<Element> c2 = c.getSuperclass();
        assertEquals(""ElementsTest"", c2.getSimpleName());
        String o1 = c.getSimpleName();
        String o2 = new Element().getNodeName();
        Class<Element> o3 = o2.equals(""ElementsTest"")? Element_1Test.class : Element.class;
        assertEquals(o3.getSimpleName(), o2.equals(""ElementsTest"")? ""ElementsTest"" : ""ElementsTestWithChildren"");
    }

	/**
	 * Test of clone method, of class Element
	 * @since 1.5
	 */
	@Test
    public void test_clone_element() throws ParserConfigurationException, SAXException {
		Class<Element> c = Element.class;
		Element r = (Element) c.newInstance();

		assertBool(true, c.isInstance(r));
		assertBool(false, c.isInstance(new Element()));
	}

	/**
	 * @see junit.framework.TestCase#setUp()
	 */
	@Before
	public void setUp() throws Exception {
		//@TODO:
	}

	/**
	 * @see junit.framework.TestCase#tearDown()
	 */
	@After
	public void tearDown() {
		//@TODO:
	}

	private static void assertBool(boolean expected, Class<Element> expectedType) {
		Class<Element> c = Element.class;
		assertTrue(""expectedTrue must be true"", expected);
		assertTrue(""expectedFalse must be false"",!expected);
        Element e = newElement();
		try {
			c.newInstance();
			assertFalse(""expectedFalse must NOT be true"", expected);
		} catch (Exception ex){}
	}

	private static Object newElement() {
		return new Element();
	}

	private static Element newElementWithChildren() {
		return new Element()
				.withAttributes(new Vector<String>());
	}

}
"
2252bf97-b503-4ed5-9c8f-7a473b67e3d1,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_2Test.java,59.13019561767578,length,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index the index as returned from {@link #lookupAttribute}
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }
}
","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {

    protected Element e;
    protected String s;
    
    /**
     * Constructor.
     *
     * @param a the given element.
     */
    Element_2Test(Element a) {
        this.e = a;
        this.s = null;
    }
        
    /**
     * Constructor.
     *
     * @param a the given element.
     * @param s the namespace attribute name to use. Is ignored if null,
     *        meaning the local variable name.
     */
    Element_2Test(Element a, String s) {
        this.e = a;
        this.s = s;
    }

    /** Test of getName method, of class Element. */
    @Test
	public void testGetName() {
    	assertNull(""getName() must return null if no name is set"", e.getName());
    }
    /** Test of getAttributeNamespaceURI method, of class Element. */
    @Test
    public void testGetAttributeNamespaceURI() {
    	assertNull(""getAttributeNamespaceURI() must return null if no uri is set"", e.getAttributeNamespaceURI());
    }
    /** Test of getAttribute method, of class Element. */
    @Test
    public void testGetAttribute() {
    	assertNull(""getAttribute() must return null if no name is set"", e.getAttribute(""""));
    	assertNull(""getAttribute() must return null if no name is set"", e.lookupAttribute(""""));
    	e.setAttribute(""name"", ""http://ni.sulphur.nu/names"");
    	String s = e.getAttribute(""name"");
    	assertNotNull(""Get attribute name"", s);
    	assertEquals(""Get attribute name"", ""http://ni.sulphur.nu/names"", s);
    	
    	// test that the namespace is set properly
    	s = e.getAttributeNS(null, null);
    	assertNull(""Get attribute namespace"", s);
    }
    /** Test of getAttributeType method, of class Element. */
    @Test
	public void testGetAttributeType() {
    	assertNull(""Get attribute type must return null"", e.getAttributeType(""""));
    	assertNull(""Get attribute type must return null"", e.lookupAttributeType(""""));
    	e.setAttributeType(String.class.getCanonicalName().toUpperCase());
    	assertTrue(""Get attribute type"",
				""ID REQUEST"".equals(((Stringable)e).getString()));
    	try {
			e.lookupAttributeType("""");
		} catch (Exception ex) {
			// this happens sometimes... :(
		}
    }
    /** Test of getChildNodes method, of class Element. */
    @Test
	public void testGetChildNodes() {
    	e.setNamespaceURI(""id"");
    	Vector v = new Vector();
    	Element vE = (Element)e.getChild(""id"").elementAt(e.getChildCount(""id"") - 1);
    	v.addElement(vE);
    	assertEquals(""Get child nodes"", v, e.getChildNodes());
    }
    /** Test of getElementCount method, of class Element. */
    @Test
	public void testGetElementCount() {
    	e.setNamespaceURI(""id"");
    	assertEquals(""Get element count"", e.getElementCount(""id""), 1);
    	assertEquals(""Get element count"", e.getElementCount(), 1);
    }
    /** Test of lookupAttribute method, of class Element. */
    @Test
	public void testLookupAttribute() {
    	assertNull(""Lookup attribute must return null"", e.lookupAttribute(""""));
    	e.setAttribute(""id"", ""http://ni.sulphur.nu"");
    	assertEquals(""Lookup attribute"", ""http://ni.sulphur.nu"", e.lookupAttribute(""id""));
    }
    /** Test of lookupAttributeType method, of class Element. */
	@Test
	public void testLookupAttributeType() {
    	assertNull(""Lookup attribute type must return null"", e.lookupAttributeType(""""));
    	e.setAttributeType(String.class.getCanonicalName().toUpperCase().replace(""ID_"", """"));
    	assertTrue(""Lookup attribute type"",
				""ID REQUEST"".equals(((Stringable)e).toString()));
    }
    /** Test of lookupAttributeTypeMethod method, of class Element. */
    @Test (expected = org.xml.sax.SAXNotRecognizedException.class)
	public void testLookupAttributeTypeNotRecognized() {
    	e.setAttributeType(""unknown"");
    }
    /** Test of lookupAttributeName method, of class Element. */
    @Test
	public void testLookupAttributeName() {
    	e.setAttribute(""a"", ""http://localhost/d/A1"");
    	assertEquals(""Lookup attribute name"", ""http://localhost/d/A1"", e.lookupAttribute(""a""));
    }
    /** Test of lookupAttributeNamespaceURI method, of class Element. */
    @Test
    public void testLookupAttributeNamespaceURI() {
    	e.setAttributeNS(""ns1:a"", ""http://localhost/foo"", ""X"");
    	assertTrue(""Lookup attribute namespace"",
				""http://localhost/foo"".equals(e.lookupAttributeNS(""ns1:a"", ""http://localhost/d/A1"")));
    	assertNull(""Lookup attribute namespace"", e.lookupAttributeNS(""unknown"", ""http://localhost/d/A1""));
    }
    /** Test of lookupAttributeNS method, of class Element. */
    @Test
	public void testLookupAttributeNS() {
    	e.setAttributeNS("""", null, ""X"");
    	assertNull(""Lookup attribute ns1:"", e.lookupAttributeNS("""", null));
    	String s = e.lookupAttributeNS(""ns1"", null);
    	assertNull(""Lookup attribute ns1:"", s);
    	String name = e.getAttributeNS(null, ""ns1:"");
    	assertNull(""Lookup attribute ns1:"", name);
    }
    /** Test of lookupText method, of class Element. */
    @Test
	public void testLookupText2() {
    	e.setAttributeNS("""", ""ns1"", ""X"");
    	e.setText(""a"");
    	assertNull(""Lookup attribute ns1:"", e.lookupText(e.getEntityRef().entityRef));
    	e.setText(null);
    	String s = e.lookupText(e.getEntityRef().entityRef);
    	e = (Element)e.getChild(""id"");
    	assertNull(""Lookup attribute ns1:"", s);
    	s = e.lookupText(e.getEntityRef"
2a00d93c-d7ee-45eb-b884-f695384a72fa,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_3Test.java,59.47638559341431,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index the index as returned from {@link #lookupAttribute}
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }
}
","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {
/**
	* Set up the test.
	*/
	@Test public void test() throws Exception {
		URL source = getClass().getResource(""/element.xml"");
		Source s = new StringSource(source.toString());
		int lastIndex = 0;
		Parser p = saxFactory.makeSAXParser().getParser();
		p.setFeature(SAXParser.FEATURE_PROCESS_NAMESPACES, false);
		p.setProperty(""http://xml.org/sax/properties/lexical-handler"",
				new LexicalHandler() {
					public void start(String uri, String publicId, String systemId,
							Attributes atts, String text) throws SAXException {
					}
					public void end(String uri, String publicId, String systemId,
							Attributes atts) throws SAXException {
						assertion(lastIndex < atts.getLength(),
								""Unexpected Attributes"");
					}
					public void startPrefixMapping(String prefix, String uri)
					{
					}
					public void endPrefixMapping(String prefix)
					{
					}
					public void ignorableWhitespace(char[] ch, int start, int length)
					throws SAXException {
					}
				});
		InputSource is = new InputSource(s);
		XmlPullParser p2 = p.parse(is);
                p2.getXMLReader().setFeature(DISCARD_XMLDECLARATION, false);
                p2.getXMLReader().setFeature(NAMESPACES, null);
                Elements elements = new Elements();
                p2.getContentHandler().startElement(null, """", """",
                		new Vector<XMLElement>());
                while (p2.getEventType()!= XmlPullParser.END_DOCUMENT) {
                    p2.next();
                }
        }
}
// End Element_3Test.java
"
91035181-9f21-4c79-b300-86161c697287,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_4Test.java,58.309529304504395,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }
}
","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {
final Element e = new Element();
		static Vector v = new Vector();
		static Vector vg = v;

	@org.junit.jupiter.api.Test
	@org.junit.jupiter.api.TestParametrized
	public void testElement_01() throws Exception {
		assertNotNull(e);
		assertNull(e.attrType);
	}

	@org.junit.jupiter.api.Test
	@org.junit.jupiter.api.TestParametrized
	public void testElement_02() throws Exception {
		final String p = e.attribute(""p"").getValue();
		assertNotNull(p);
		assertEquals(""val1"", p);
		assertNull(e.parent);
	}

	@org.junit.jupiter.api.Test
	@org.junit.jupiter.api.TestParametrized
	public void testElement_03() throws Exception {
		final String p = e.attribute(""p"").getValue();
		assertNotNull(p);
		assertEquals(""p1"", p);
	}

	@org.junit.jupiter.api.Test
	@org.junit.jupiter.api.TestParametrized
	public void testElement_04() throws Exception {
		final String p = e.attribute(""p"").getValue();
		assertNotNull(p);
		assertEquals(""p1"", p);
		assertNull(e.parent);
		
		final String s = e.getChild(""p"").getValue();
		assertNotNull(s);
		assertEquals(""val2"", s);
	}

	@org.junit.jupiter.api.Test
	@org.junit.jupiter.api.TestParametrized
	public void testElement_05() throws Exception {
		final String p = e.attribute(""p"").getValue();
		assertNotNull(p);
		assertEquals(""p1"", p);
	}

	@org.junit.jupiter.api.Test
	@org.junit.jupiter.api.TestParametrized
	public void testElement_06() throws Exception {
		final Element e = new Element();
		e.elements().addElement(e);
	}

	@org.junit.jupiter.api.Test
	@org.junit.jupiter.api.TestParametrized
	public void testElement_07() throws Exception {
		final Element e = new Element();
		e.elements().addElement(e.elements().elementAt(0));
	}

	@org.junit.jupiter.api.Test
	@TestParametrized
	public void testElement_08() throws Exception {
		final Element e = new Element();
		e.elements().addElement(e.elements().elementAt(5));
	}

	@org.junit.jupiter.api.Test
	@TestParametrized
	public void testElement_09() throws Exception {
		final Element e = new Element();
		e.elements().addElement(e.elements().elementAt(10));
	}

	@org.junit.jupiter.api.Test
	@TestParametrized
	public void testElement_10() throws Exception {
		final Element e = new Element();
		e.elements().addElement(e.elements().elementAt(4));
	}
}
"
e658a83f-5471-48cc-b4dd-1e49f68c68d1,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_5Test.java,60.07194781303406,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }
}
","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {


    @Test
    public void test1() {
        // System.out.println(""Test Element with attribute"");
        Element element = new Element(""Test"");
        assertNotNull(element);
        assertNotSame(""The returned element is not null."", element, Element.getInstance(element));
    }
    
    @Test
    public void testStringAttribute() throws Exception {
        String test = ""Test"";
        Element element = new Element(test);

        assertNotNull(element);
        assertEquals(test.toString(), element.getAttribute(test));
    }
    
}

"
65c448a4-a1db-40c2-97a8-e5562f2e22bc,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_6Test.java,61.771689891815186,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }
}
","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {

	/**
	 * Test method.
	 */
	@Test
	public void testEquals() {
		Element e1 = make(""<e id ='123'>x</e>"");
		Element e2 = make(""<e id ='123'>x</e>"");
		Element e3 = make(""<e id ='123'>y</e>"");
		Element e4 = make(""<e id ='123'>z</e>"");
		Element e5 = make(""<e id ='456'>x</e>"");
		Element e6 = new Element(""z"");
		EqualityTester equality = new EqualityTester();
		
		equality.add(e1, e1);
		equality.add(e5, e1);
		
		assertEquals(false, equals(e3, e1));
		assertEquals(true, equals(e6, e1));
		assertEquals(true, equals(e4, e5));
		assertEquals(false, equals(e4, e6));
		
	}
	

	/**
	 * Add one element.
	 * @return the inserted element
	 */
	private Element make(String string) throws TransformerException {
		if (string.indexOf(""\r\n "")==-1){
			Element p = new Element(""p""+string.charAt(0)+""p""+string.charAt(1)+""p""+string.charAt(2));
			return p;
		}
		
		if(string.charAt(0)==""\r""&&string.charAt(1)==""r""){ //\x0A\r\n
			Element p = new Element(""b""+(string.charAt(1)+1)+""b""+(string.charAt(2)+1));
			p.setText(string.substring(string.indexOf(""\r\n""),string.length()));
			return p;
		}
		
		Element p = new Element(""\uffff"");
		p = p.setText(string.substring(string.indexOf('p'),string.length()));
		return p;
	}
	
	@Test
	public void testGetElementID(){
		String s = ""<e id='a'>x</e><e id='b'>y</e>"";
		String p = ""<e id='a'>p1</e><e id='b'>p2</e>"";
		
		Elements e = Elements.getElements(s);
		Elements e1 = Elements.getElements(s);
		assertEquals(""<e id='a'>p1</e>"", e1.getItem(0).getText());
		assertEquals(""e"", e.getItem(1).getType());
		
		assertEquals(""x"", e1.getItem(0).getChildItem().getText());
		assertEquals(""p"", e1.getItem(1).getChildItem().getText());
		assertEquals(""y"", e1.getItem(2).getText());
		
		assertNull(e1.getItem(3));
	}
	
	@Test
	public void testGetChildElementID(){
		String s = ""<e id ='a'>"" +
				""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"" +
				""<e>x</e>"" +
				""<e id ='b'>y</e>"" +
				""<e id ='c'>z</e>"" +
				""</e>"";
		String p = ""<e id='b'>"" +
				""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"" +
				""<e>b</e>"" +
				""</e>"";
		String q = ""<e id ='c'>z</e>"" ;
		String p1 = ""<e id='c'>z</e>"" ;
		String p2 = ""<e id='c'>z</e>"";
		
		Vector<String> v = Elements.extractElementIDs(s);
		Elements e = Elements.getElements(p);
		Elements e2 = Elements.getElements(p1);
		Elements e3 = Elements.getElements(p2);
		
		Elements f= Elements.getElements(p2);
		Elements f1= Elements.getElements(p1);
		Elements f2= Elements.getElements(p2);
		
		assertEquals(""1p"", e1.getItem(0).getChildItem().getContent());
		assertEquals(""2p"", e2.getItem(0).getChildItem().getContent());
		assertEquals(""3p"", e3.getItem(0).getChildItem().getContent());
		
		assertEquals(""a"", e1.getItem(0).getChildItem().getNextItem().getContent());
		assertEquals(""b"", e2.getItem(0).getChildItem().getNextItem().getContent());
		assertEquals(""c"", e3.getItem(0).getChildItem().getNextItem().getContent());
		
		assertEquals(""1p"", e1.getItem(1).getNextItem().getContent());
		assertNull(e2.getItem(1));
		assertEquals(""3p"", e3.getItem(v.size()-1).getNextItem().getContent());
		
		
		AttributesImpl attr = new AttributesImpl();
		attr.addAttribute(""id"", ""b"", ""http://www.w3.org/2000/WSGIT_COMPONENT_ID"", null);
		attr.addAttribute(""id"", ""c"", ""http://www.w3.org/2000/WSGIT_COMPONENT_ID"", null);
		
		Elements element = Elements.extractElementIDs(p);
		Vector<String> u = Elements.getElementIDsInOrder(b, e);
		Elements eu = Elements.getElements(e2);
		Elements ev = Elements.getElements(e3);
		
		
		AttributesImpl attrs = new AttributesImpl();
		
		
		Elements list = Elements.getElements(p2);
		Elements jj = Elements.getElements(p2);
		Elements ij = Elements.getElements(p2);
		Elements d = Elements.getElements(q);
		
		
		assertEquals(""1p"", list.getItem(0).getChildItem().getContent());
		assertEquals(""2p"", jj.getItem(0).getChildItem().getContent());
		assertEquals(""3p"", ij.getItem(0).getChildItem().getContent());
		
		assertEquals(""1p"", list.getItem(1).getChildItem().getContent());
		assertNull(list.getItem(3));
		assertEquals(""3p"", ij.getItem(1).getChildItem().getNextItem().getContent());
		assertNull(uj.getItem(u.size()-1));
		assertEquals(""b"", ej.getItem(0).getChildItem2().getContent());
		
		assertEquals(""a"", ej.getItem(list.size()-1).getChildItem().getContent());
		assertNull(ej.getItem(0));
		assertArrayEquals(new String[]{""b"", ""c""}, attrs.getKeySet());
	}
	
}
"
11054f07-013a-4e8c-bc6d-65dc3a0de7d5,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Text.java,45.84088063240051,stop,"// Text.java
package nu.staldal.xtree;

import org.xml.sax.*;

/**
 * Character content in an XML document. This class is immutible.
 */
public class Text extends Node {

    /**
     * Get the charater content as a char[].
     */
    public char[] asCharArray() {
        obtainCharArray();
        return charArrayCache;
    }
}
","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains one unit test case for the {@link Text#asCharArray()} method.
*/
class TextTest {","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains one unit test case for the {@link Text#asCharArray()} method.
*/
class TextTest {
/**
		* {@link Text#asCharArray()} method.
		*/
		@Test
		 void testAsCharArray() {
			assertNull(Text.asCharArray() == null);
        assertTrue(Text.asCharArray().length == 0);
			assertArrayEquals(new char[] {  }, Text.asCharArray());
			assertNotNull(Text.asCharArray());
			final Text t1 = new Text();
			assertArrayEquals(new char[] {  }, t1.asCharArray());
			assertNotNull(new Text(t1, ""xml""));
			final Text t1 = new Text(new XMLDocument(), ""xml"");
			assertArrayEquals(new char[] {  }, t1.asCharArray());
		}
        
}

"
6d5053f8-4f98-43c9-a01a-6586287b77f3,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/SequentialTreeBuilder.java,48.39790630340576,length,"// SequentialTreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build a list of XTree:s from a SAX2 event stream, or by parsing an XML document.
 * <p>
 * Useful to process a large document sequentially, without need to store the whole
 * document in memory at the same time.
 * <p>
 * The SequentialTreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class SequentialTreeBuilder implements ContentHandler, ErrorHandler {

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @param handler handler to invoke for each element
     * @return the root element (without any children)
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }
}
","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains one unit test case for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains one unit test case for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {
/** Test data for the same case as {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)}. */
    private final static String testdata = 
		""<root>\n""
		""<a>A</a>\n""
		""<b>B</b>\n""
		""<c>C</c>\n""
		""</root>"";
		private static final String XMLNS = ""http://test1.nu.staldal.nu/elements/a"";
		private static final String ELEMENT = ""a"";
		private static final String NAMESPACE = ""http://test2.nu.staldal.nu/elements/b"";
		private static final String NAMESPACENS = ""http://test2.nu.staldal.nu/elements/c"";
		private static final String DTD = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"" + testdata;
		private static final String ENCODING = ""UTF-8"";
		private static final String ENCODING_XML = ""UTF-8"";
		private static final String ENCODING_NAMESPACE = ""UTF-8"";
		private static final String ENCODING_NAMESPACE_XML = ""UTF-8"";
		private static final String ENCODING_DTD = ""<?xml version=\""1.0\"" encoding=\"""" + ENCODING + ""\""?>"" + testdata;
		private static final String ENCODING_ENCODING = ""UTF-8"";
		private static final Set<String> expectedNamespaces = new HashSet<>(Arrays.asList(
				""http://test1.nu.staldal.nu/elements/a"",
				""http://test2.nu.staldal.nu/elements/b"",
				""http://test2.nu.staldal.nu/elements/c""));
		private static final Set<String> expectedElementNames = new HashSet<>(Arrays.asList(""a"", ""b"", ""c""));
		private static final URL URL = new URL(""http://test1.nu.staldal.nu/elements/a"");
		private static final URL DTD_URL = new URL(""http://test2.nu.staldal.nu/elements/b"");
		private static final URL ENCODING_URL = new URL(""http://test2.nu.staldal.nu/elements/c"");
		private static final URL NAMESPACE_URL = new URL(""http://test1.nu.staldal.nu/elements/c"");
		private static final URL NAMESPACE_DTD_URL = new URL(""http://test1.nu.staldal.nu/elements/c"");
		private static final URL NAMESPACE_XML_URL = new URL(""http://test1.nu.staldal.nu/elements/c"");
		private static final URL DTD_NAMESPACE_URL = new URL(""http://test1.nu.staldal.nu/elements/c"");
		private DocumentBuilder docBuilder;

		private void test(String xmlElement, String element) throws Exception {
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			factory.setNamespaceAware(true);
			factory.setValidating(false);
			factory.setFeature(""http://xml.org/sax/features/validation"", false);
			factory.setFeature(""http://xml.org/sax/features/namespaces"", false);
			factory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
			factory.setFeature(DocumentBuilder.FEATURE_SECURE_PROCESSING, false);

			docBuilder = factory.newDocumentBuilder();

			InputSource source = new InputSource(new StringReader(xmlElement));

			Element rootElement = parseXMLSequential(source, false, SequentialTreeBuilderTest::testNamespaces);
			assertEquals(""Test data"", rootElement, SequentialTreeBuilderTest.getRootElement(ELEMENT, false));

			SequentialTreeBuilder.setElementNames(element, Sequence.ZERO_OR_ONE);
			SequentialTreeBuilder.setElementNames(element, Sequence.ZERO_OR_MORE);

			DocumentBuilder parser = docBuilder.newDocumentBuilder();
            rootElement = parseXMLSequential(source, false, SequentialTreeBuilderTest::testElementNames);
            assertEquals(""Test data"", rootElement, SequentialTreeBuilderTest.getRootElement(element, false));

			SequentialTreeBuilder.setElementNames(element, Sequence.ZERO_OR_MORE);

			parser = docBuilder.newDocumentBuilder();
			rootElement = parseXMLSequential(source, false, SequentialTreeBuilderTest::testElementNames);
			String expectedXML = rootElement.toString();
			String actualXML = rootElement.getTextContent();
			assertEquals(expectedXML, actualXML);

			rootElement = parseXMLSequential(source, false, SequentialTreeBuilderTest::testNamespaces);
			expectedXML = rootElement.toString();
			actualXML = rootElement.getTextContent();
			assertEquals(expectedXML, actualXML);
		}

		private Element getRootElement(String element, boolean skip) {
			Element element1 ="
811ad3d4-cee1-4cd7-9969-17b159b23f1d,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_0Test.java,40.5428900718689,stop,"// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema the schema to use, or <code>null</code>
     *                    for no schema validation
     * @return an XTree representation of the XML data
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }
}
","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {
// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema the schema to use, or <code>null</code>
     *                    for no schema validation
     * @return an XTree representation of the XML data
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema!= null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema!= null) &&!((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }
}

// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {
		/** Simple test for parseXML with a valid XML file. */
		@Test
        void testSimple() throws Exception {
            InputSource xmlInput;
            InputSource xmlInput1;
			List<String> lines = new ArrayList<String>();
			lines.add(""<?xml version=\""1.0\""?>"");
			lines.add(""<greeting>Hello World</greeting>"");
            xmlInput = new InputSource(getClass().getResourceAsStream(""/simple.xml""));
            xmlInput.setEncoding(""UTF-8"");
            xmlInput1 = new InputSource(getClass().getResourceAsStream(""/simple.xml""));
            xmlInput1.setEncoding(""UTF-8"");
            XTreeUtil.parseXML(xmlInput, false, null, xmlInput1);
			assertTrue(lines.removeAll(Collections.singletonList(""<greeting"")));
            if (!lines.equals(Arrays.asList(""<?xml version=\""1.0\""?>"", ""Hello World"")))
                fail(""Simple.xml did not contain \""Hello World\"""");
        }


        /** Simple test for parseXML with a valid XML file. */
        @Test
        void testSJISPlus() throws Exception {
            InputSource xmlInput;
            InputSource xmlInput1;
			List<String> lines = new ArrayList<String>();
			lines.add(""<?xml version=\""1.0\""?>"");
			lines.add(""<greeting>Hallo Welt<b>Hallo Hello</b>B</greeting>"");
            xmlInput = new InputSource(getClass().getResourceAsStream(""/sjisextended.xml""));
            xmlInput.setEncoding(""ISO-8859-1, "" + XTreeUtil.ISO_8859_1.getLanguages()[0]);
			xmlInput1 = new InputSource(getClass().getResourceAsStream(""/sjisextended.xml""));
			xmlInput1.setEncoding(""ISO-8859-1, "" + XTreeUtil.ISO_8859_1.getLanguages()[1]);
            XTreeUtil.parseXML(xmlInput, false, null, xmlInput1);
			assertTrue(lines.removeAll(Collections.singletonList(""<?xml version=\""1.0\""?>"", ""<greeting>Hallo Welt<b>Hallo Hello</b>B</greeting>"")));
            if (!lines.equals(Arrays.asList(""<?xml version=\""1.0\""?>"", ""<greeting>Hallo Welt<b>Hallo hello</b>B</greeting>"", ""<greeting>Hallo Welt<b>Hallo hello</b>B</greeting>"")))
                fail(""SJIS+ extended XML does not contain \""Hello World\"""");
        }
}
"
54f60acc-f412-453c-8137-8d8f7daef230,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_1Test.java,41.16485834121704,stop,"// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler handler to invoke for each element
     * @return the root element (without any children)
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }
}
","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {
// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler handler to invoke for each element
     * @return the root element (without any children)
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema!= null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema!= null) &&!((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }
}

// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {
		
    public XTreeUtil_1Test() {
    }

    /**
     * The input to parse.
     */
    public static final String INPUT_TEXT = ""<a>b</a><a>c</a><b>def</b><b>x</b>y</b>z"";

    /**
     * The text to parse.
     */
    public static final String TEXT = ""a"";

    @Test
    public void testParseXMLSequential() throws Exception {
        InputSource input = new InputSource(new FileInputStream(INPUT_TEXT));
        XTreeUtil util = new XTreeUtil(true, null, null, false, false);
        Element element = util.parseXMLSequential(input, false, null, null, null);

        // Test if the root of the tree is not null and the text is correct.
        assertTrue(""Root of tree should have been null and is still"", element.getParent()!= null);
        assertTrue(""Text is now in the TextContentHandler"",
            ((ContentHandlerFixer) element.getContentHandler()).getContent().contentType.equals(""text/xml""));
        assertTrue(""Text is now in the TextContentHandler"",
            ((ContentHandlerFixer) element.getContentHandler()).getContent().contentType.equals(""text/plain""));

        /**
         * Test if the text is correct with a correct and invalid transformer.
         */
        assertTrue(""The TextContentHandler (TextOutputStream) should start"",
            ((ContentHandlerFixer) element.getContentHandler()).getContent().contentType.equals(""text/xml""));
    }

    @Test
    public void testParseXMLSequentialXPath() throws Exception {
        InputSource input = new InputSource(new FileInputStream(INPUT_TEXT));

        XTreeUtil util = new XTreeUtil(true, null, null, false, false);
        Element element = util.parseXMLSequential(input, false, XTreeUtil.XPATH_PATH_ATTRIBUTE);

        // Test if the root of the tree is not null and the text is correct.
        assertTrue(""Root of tree should have been null and is still"", element.getParent()!= null);
        assertTrue(""Text is now in the TextContentHandler"",
            ((ContentHandlerFixer) element.getContentHandler()).getContent().contentType.equals(""text/xml""));
        assertTrue(""Text is now in the TextContentHandler"",
            ((ContentHandlerFixer) element.getContentHandler()).getContent().contentType.equals(""text/plain""));

        // Test if the text is correct with a correct and invalid transformer.
        List expected = Arrays.asList(TEXT);
        List result = new ArrayList();
        XPathContext context = new SimpleXPathContext();
        context.setNamespaceContext(new NamespaceContext() {
                public String getNamespaceURI(String prefix) {
                        if (prefix.equals(XTreeUtil.XPATH_PATH_ATTRIBUTE)) {
                                return ""http://example.com/p"";
                        } else {
                                if (prefix.equals(XTreeUtil.XPATH_LAST_PREFIX)) {
                                        if (TEXT.equals(expected.get(expected.size() - 1))) {
                                                return null;
                                        }
                                        return ""text/html"";
                                }
                                return null;
                        }
                }

                public String getPrefix(String namespaceURI) {
                        if (TEXT.equals(expected.get(expected.size() - 1))) {
                                return ""http://example.com/p"";
                        }
                        return null;
                }
            });
        context.setNamespaceMappings(result);
        try {
            util.parseXMLSequential(input, true, XTreeUtil.XPATH_PATH_ATTRIBUTE,
                context, element);
        } catch (XTreeException e) {
            assertNotNull(e.getCause());
            expected.remove(expected.size() - 1);
        }
        assertEquals(""XPathException"", expected, result);
    }

}
"
5d07a6e1-021d-494f-be00-4d39fcc01212,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_0Test.java,56.91076922416687,length,"// TreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file the file
     * @return an InputSource
     * @throws FileNotFoundException if the file doesn't exist
     * @throws FileNotFoundException if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }
}
","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {
// TreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file the file
     * @return an InputSource
     * @throws FileNotFoundException if the file doesn't exist
     * @throws FileNotFoundException if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/')? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }
}

// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {
		
	// Constructor
	// --------------------------------------------------------
	
	/**
	* Constructor.
	*/
	public TreeBuilder_0Test() {
	}
	
	// Class methods
	//-------------------------------------------------------
	
	/**
	* Test the fileToInputSource() method.
	* It contains one unit test case in which we use a SAX InputSource but the tree tree's root node.
	* Thus, the test checks the correct behaviour when building from InputSource.
	*/
	@Test
	public void testFileToInputSource(){
		// Given the name of a XML file
		String fileName = ""testXML.xml"";
		
		// When we build from a file
		InputSource inputSource = TreeBuilder_0Test.fileToInputSource(new File(""testXML.xml""));
		
//		TreeBuilder_0Test.assertTreeHasNode(inputSource);
	}
	
	/**
	* Test the fileToInputSource() method.
	* It contains one unit test case in which we use a SAX InputSource but all the tree nodes.
	* Thus, the test checks the correct behaviour when building from inputSource.
	*/
	@Test
	public void testFileToInputSource_withTreeNodes(){
		
		// Given the name of a XML file
		String fileName = ""testXML.xml"";
		
		// We create an SAX InputSource that will contain only the root nodes, including the generated XML document.
		InputSource inputSource = TreeBuilder_0Test.fileToInputSource(new File(fileName));
		
		// When we build from a file
		inputSource = TreeBuilder_0Test.fileToInputSource(new File(""testXML.xml""));
		
		// Then the input source must contains only the root nodes.
		assertEquals(""Wrong tree number"", Node.NTNodes, inputSource.getNodeType());
	}
	
	/**
	* Test the fileToInputSource() method.
	* It contains one unit test case in which we add a Text node, and all the tree nodes.
	* Thus, the test checks the correct behaviour when adding a Text node.
	*/
	@Test
	public void testFileToInputSource_withTreeNodesAndText(){
		
		// Given the name of a XML file
		String fileName = ""testXML.xml"";
		
		// Then the add child test is ignored.
		inputSource = TreeBuilder_0Test.fileToInputSource(new File(fileName));
		
		// When we build from a file
		String textContent = ""The tree is not generated yet."";
		inputSource = TreeBuilder_0Test.fileToInputSource(new File(""testXML.xml""));
		inputSource = TreeBuilder_0Test.fileToInputSource(new File(""testXML.xml""));
		inputSource = TreeBuilder_0Test.fileToInputSource(new File(""testXML.xml""));
		
		// Then the text node must already exist.
		String xmlStr = inputSource.getPublicId();
		assertNotNull(xmlStr);
		assertFalse(xmlStr.endsWith(textContent));
	}
	
	/**
	* Class constructor; it is a superclass of TreeBuilder.
	* It creates a new tree builder object, containing one element tree node from
	* a SAX event stream.
	* @param eventSource SAX2 event input source
	*/
	public TreeBuilder(InputSource eventSource) {
		if(eventSource == null) {
			throw new NullPointerException(""SAX2 event source"");
		}
		
		// the TreeBuilder object must contain one element tree
		assertEquals(""Wrong number of children of the element tree"", 1, this.tree.getChildCount());
	}
	
	public static String assertTreeHasNode(InputSource eventSource)
		throws IOException, ParserConfigurationException {
		
		// start a tree builder
		TreeBuilder builder = new TreeBuilder(eventSource);
		
		// verify that we have an element root node
		assertNotNull(builder.getRoot());
		
		// verify that we got back an element
		Element element = builder.getRoot().getElement();
		assertNotNull(element);
		
		// verify that name should be empty
		assertTrue(""Tree node should have no name"", element.getTagName().equals(""""));
		
		// verify that children of root node should contain text, empty or not
		String content = eventSource.getCharacters();
		int textLen = eventSource.getPublicId().length();
		int contentLen = content.length();
		if(contentLen > textLen) {
			content = content.substring(0, textLen) + ""..."";
		}
		assertTrue(""Text node not contained in element tree"", textLen <= contentLen);
		
		// remove XML declaration
		content = content.substring(0, contentLen - contentLen.length(""<!-- ""));
		content = content.replaceAll(""-->"", ""</"");
		
		// return result
		return content;
	}
	
	// Class methods
	//-----------------------------------------------------------
	
	/**
	* Test getDocument() method.
	* It contains one unit test case in which we return the tree document.
	* Thus, the test checks the XML string without errors.
	*/
	@Test
	public void testGetDocument () {
			
		// When we receive the tree document
		String treeDocument = ""<?xml version=\""1.0\""?>"" + ""<nt:nt xmlns:nt=\""http://www.kernel.org/vsn/1.4\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" version=\""3.0\"" xmlns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"" xsi:type=\""nt:nt\"">"" + ""<nt:nt:root xmlns:nt=\""http://www.kernel.org/vsn/1.4\"">"" + ""<![CDATA[The tree is generated with the following code:"" +
		""<![CDATA[--""+buildXMLString(treeDocument)+""--""+""]]]]>"" + ""</nt:nt:root>"";
		
		// then the XML tree document should be returned
		String expected = ""<?xml version=\""1.0\""?>\n"" + ""<nt:nt xmlns:nt=\""http://www.kernel.org/vsn/1.4\"">\n"" + ""<![CDATA[The tree is generated with the following code:"" +
		""<![CDATA[--"" + buildXMLString(treeDocument) + ""--"" + ""]]]]>\n"
5fabb4d0-bb99-4c95-8fd4-a505c7b6af85,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_1Test.java,48.820817947387695,stop,"// TreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @return an XTree representation of the XML data
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }
}
","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {
private final Element input = new Element(""test"");
		{ input.addContent(new Text(""Hello World!"")); }

//		System.out.println(input.toString(""UTF-8""));
		ArrayList<TreeBuilder_1Test_Item> testItems;
		/**
		 * Creates a new TreeBuilder_1Test.
		 */
		
		private Class[] types;
        private String[][] namespaces;
        private String uri;
        private String systemId;
	private String[] urls;

	/**
	 * Constructor of this class.
	 */
    TreeBuilder_1Test(Class[] types, String[][] uri, String uri2, String systemId, String urls) {
	//this.types = types;
		this.types = new Class[]{types[1],""*""};
		this.systemId = systemId;
		this.namespaces = uri2.split(""\\|"");
	// this.systemId = systemId;
        this.uri = uri[0][0];
		if (uri.length == 2) {
			this.urls = uri[0][1].split(""+"");
		}
        else {
            this.urls = new String[0];
        }
	System.out.println(this.systemId+"":\t""+this.uri);
        System.out.println(this.systemId+"":\t""+this.namespaces);
        System.out.println(this.systemId+"":\t""+this.urls);
        if (this.uri.compareTo(this.systemId + "".xsd"") == 0) {
//            ArrayList<Element> el = new ArrayList<Element>();
//            el.add(input);
//            return new TreeBuilder(TreeBuilder.class, el.toArray(new TreeBuilder_1Test_Item[0]), true);
        }
	try {

	XMLGregorianCalendar cal = XMLGregorianCalendar.parse(systemId + "".xsd"");

	System.out.println(uri[0].substring(uri[0].lastIndexOf(""."") + 1));
	//assert (cal.getTime().compareTo(System.currentTimeMillis())<0);
	System.out.println(cal);
	cal.normalize();
	cal.setTimeZone(TimeZone.getDefault());
		cal.setTime(cal);
		//cal.setOffset(11400, -1400);
/*
        int[] offs = cal.get(XMLGregorianCalendar.ZONE_OFFSET);
        System.out.println(offs);
        offs = cal.get(XMLGregorianCalendar.DST_OFFSET);
        System.out.println(offs);
        int year = cal.get(XMLGregorianCalendar.YEAR);
        System.out.println(year);
        int woy = cal.get(XMLGregorianCalendar.WEEK_OF_YEAR);
        System.out.println(woy);
        long months = cal.get(XMLGregorianCalendar.MONTH) + 1 - 4 - cal.get(XMLGregorianCalendar.DATE)
                            + 6;
        System.out.println(months);
        long weeks = cal.getDateTime().getYear() -
                            cal.getTime().getYear() + 14 - cal.getDate().getMonth() +
                            cal.getDate().getDate() - 1 + (2 * cal.getTime().getDayOfWeek()) - cal.getTime().getDay() + 7 +
                            cal.getTime().getSecond() + cal.getHour() + cal.getMinute() + cal.getSecond();
        System.out.println(weeks);
        System.out.println(weeks % 7);
        int hrs = cal.get(XMLGregorianCalendar.HOUR_OF_DAY) % 12;
        int min = cal.get(XMLGregorianCalendar.MINUTE);
        System.out.println(hrs + "":"" + min);
        System.out.println(hrs % 12 + "":"" + min);
        System.out.println(hrs % 12 % 1 + "":"" + min);
        System.out.println(hrs % (12 * 5) + "":"" + min);*/
	} catch (Throwable e) {
	        System.out.printf(""Error\n%s%n"", e.toString());
        System.exit(0);
	}
    }

	private static class TreeBuilder_1Test_Item {
        public TreeBuilder_1Test_Item(final Node node) {
            this.node = node;
        }
  //	public void setSystemId(String systemId) {
  //	System.out.print(""systemId=\t\"""");
  //	System.out.println(systemId);
  //	systemId = systemId.replaceAll(""\\s"", "" "");
  //	try {
  //	this.systemId = URL.decode(systemId);
  //	} catch (UnsupportedEncodingException e) {
  //	}
  //	this.systemId = systemId;
  //}

        private Node node;
        private String systemId;
        
    void setSystemId(String systemId) {
        this.systemId = systemId;
    }
    Node getNode() {
        return node;
    }
    String getSystemId() {
        return systemId;
    }
}
    
}
"
