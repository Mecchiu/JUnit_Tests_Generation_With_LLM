ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
37d9c1cc-ef1d-4ac7-858a-1aa848e2cf2d,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/ExplosionBounds.java,66.3472330570221,length,"// ExplosionBounds.java
package server;

import java.awt.Point;

/**
 * This class is used by the server to define the bounds of a bomb explosion.
 * It contains four integer fields indicating the min/max pixel value
 * in the given direction that is affected by the explosion. It further offers
 * a method to test if a given point lies within the defined bounds.
 *
 * @author Steffen
 */
public class ExplosionBounds {

    /**
     * Checks whether the given point lies within the bounds of the explosion.
     *
     * @param p The Point to be checked.
     * @return True if p lies within the bounds, false if not.
     */
    public boolean contain(Point p);
}
","// ExplosionBoundsTest.java
package server;

import java.awt.Point;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplosionBounds}.
* It contains one unit test case for the {@link ExplosionBounds#contain(Point)} method.
*/
class ExplosionBoundsTest {","// ExplosionBoundsTest.java
package server;

import java.awt.Point;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplosionBounds}.
* It contains one unit test case for the {@link ExplosionBounds#contain(Point)} method.
*/
class ExplosionBoundsTest {
/**
* Constructs a new test object.
* @param pTest The Point to be tested.
*/
	public ExplosionBoundsTest(Point pTest) {
		this.p = pTest;
		this.p1 = pTest;
		this.p2 = pTest;
		this.p3 = pTest;
	}

	/**
* Checks if the given point is within the bounds.
*
* @param p The Point to be checked.
* @return True if p is within the bounds, false if not.
*/
	public boolean contain(Point p) {
		return (p.x >= this.p1.x && p.y >= this.p1.y &&
				p.x <=  this.p2.x && p.y <=  this.p2.y);
	}
	/**
 * Constructs an {@link ExplosionBounds} object of specified bounds.
 * @param b The {@link ExplosionBounds} object to be used.
*/
	public static ExplosionBounds<Double> create(ExplosionBounds<Double> b) {

		/* Define the maximum and minimum coordinates */
		Point maxX = new Point(Integer.MAX_VALUE, Integer.MAX_VALUE);
		Point maxY = new Point(Integer.MAX_VALUE, Integer.MAX_VALUE);
		Point minX = new Point(Integer.MIN_VALUE, Integer.MIN_VALUE);
		Point minY = new Point(Integer.MIN_VALUE, Integer.MIN_VALUE);

		/* The coordinates of the min/max bound box */
		Point p1MinX = new Point( Integer.MAX_VALUE, Integer.MIN_VALUE);
		Point p1MinY = new Point( Integer.MIN_VALUE, Integer.MAX_VALUE);
		Point p2MinX = new Point( Integer.MIN_VALUE, Integer.MIN_VALUE);
		Point p2MinY = new Point( Integer.MAX_VALUE, Integer.MAX_VALUE);

		/* The coordinates of the maximum bound box */
		Point pMaxX = new Point( Integer.MAX_VALUE, Integer.MAX_VALUE);
		Point pMaxY = new Point( Integer.MAX_VALUE, Integer.MAX_VALUE);
		Point pMinX = new Point( Integer.MIN_VALUE, Integer.MIN_VALUE);
		Point pMinY = new Point( Integer.MIN_VALUE, Integer.MIN_VALUE);

		/* The coordinate of which p1_min/p2_min are defined */
		Point p1Min = new Point( Integer.MAX_VALUE, Integer.MAX_VALUE);
		Point p2Min = new Point( Integer.MIN_VALUE, Integer.MAX_VALUE);

		/* The coordinate of which p1_max/p2_max are defined */
		Point p1Max = new Point( Integer.MIN_VALUE, Integer.MAX_VALUE);
		Point p2Max = new Point( Integer.MAX_VALUE, Integer.MAX_VALUE);

		return new ExplosionBounds<Double>(maxX, maxY, minX, minY, p1MinX, p1MinY,
				maxX, maxY, minX, minY, p2MinX, p2MinY, maxX, maxY, minX, minY,
				p1Min.y, p1Min.x, p1Max.y, p1Max.x, p2Min.y, p2Min.x,
				p2Max.y, p2Max.x);
	}

	/**
 * Converts the given bounds into an equivalent ExplosionBounds using values
 * from the given one.
 */
	public static ExplosionBounds<Double> from(ExplosionBounds<Double> b, ExplosionBounds<Double> to) {

		/* Define bounds of to */
		Point pToMin = to.getMinX();
		Point pToMax = to.getMaxX();

		/* Create points for both bounds */
		Point p1 = new Point( Integer.MAX_VALUE, Integer.MAX_VALUE);
		Point p2 = new Point( Integer.MAX_VALUE, Integer.MAX_VALUE);
		Point p3 = new Point( Integer.MIN_VALUE, Integer.MIN_VALUE);

		/* Define range of points */
		Point pRange = new Point( Integer.MAX_VALUE - Integer.MAX_VALUE, Integer.MAX_VALUE - Integer.MAX_VALUE);

		/* Set the second point to be closest to the upper bound */
		p2.setY(pToMax.y+10);

		/* Set the range to be the distance from the upper bound to the second point */
		pRange.setY(pToMax.y - pToMin.y);

		/* Set the third point to be closest to the lower bound */
		p3.setY(pToMin.y);

		return new ExplosionBounds<Double>(p1, p2, p3, pToMin.x, pToMin.y, pToMin.y,
				pToMax.x, pToMax.y, pToMax.x, pToMax.y, pRange.x, pRange.y, pRange.x,
				pToMax.y, pToMax.x);
	}
	private ExplosionBounds<Double> p;
	private ExplosionBounds<Double> p1;
	private ExplosionBounds<Double> p2;
	private ExplosionBounds<Double> p3;

	public ExplosionBoundsTest(ExplosionBounds<Double> p1, ExplosionBounds<Double> p2,
			ExplosionBounds<Double> p3, ExplosionBounds<Double> p) {
		this.p1 = p1;
		this.p2 = p2;
		this.p3 = p3;
	}


	public boolean contain(ExplosionBounds<Double> b) {
		/* If this test has a given p as its input, that is true */
		if (p!= null) {
			return p.contain(b);
		}

		/* Otherwise, the conditions are asserted */
		if (p1 == null) {
			return p2.contain(b);
		}
		if (p2 == null) {
			return p1.contain(b);
		}
		if (p3 == null) {
			return p.contain(b);
		}
		if (p2.contain(b)) {
			return true;
		}
		return false;
	}

	public ExplosionBoundsTest(ExplosionBounds<Double> p1, ExplosionBounds<Double> p2, ExplosionBounds<Double> p3) {
		this.p1 = p1;
		this.p2 = p2;
		this.p3 = p3;
	}

	public ExplosionBoundsTest(ExplosionBounds<Double> p1, ExplosionBounds<Double> p2, ExplosionBounds<Double> p3) {
	super();
	this.p1 = p1;
	this.p2 = p2;
	this.p3 = p3;}

	public void show() {
		System.out.println(""\n\n\n\n"");

		/* Define boundaries of the test case */
		Point p1MinX = p1.getMinX();
		Point p1MinY = p1.getMinY();
		Point p2MinX = p2.getMinX();
		Point p2MinY = p2.getMinY();
		Point p3MinX = p3.getMinX();
		Point p3MinY = p3.getMinY();
		Point p1MaxX = p1.getMax"
8e7d592c-7436-4696-98a0-27e55727bf03,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/BomberServer.java,55.64044189453125,length,"// BomberServer.java
package server;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.GlobalServerMsg;
import messages.global.SessionDetailsMsg;
import messages.global.SessionListMsg;
import org.apache.log4j.Logger;
import org.hsqldb.Server;
import org.hsqldb.jdbc.jdbcDataSource;
import common.Constants;

/**
 * This is the main server class. It is responsible for accepting connections
 * from clients and starting new games/session.
 *
 * @author Steffen, Bj�rn, Daniel
 */
public class BomberServer {

    /**
     * Static factory method.
     *
     * @return The BomberServer Singleton
     */
    public static BomberServer getInstance();
}
","// BomberServerTest.java
package server;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.GlobalServerMsg;
import messages.global.SessionDetailsMsg;
import messages.global.SessionListMsg;
import org.apache.log4j.Logger;
import org.hsqldb.Server;
import org.hsqldb.jdbc.jdbcDataSource;
import common.Constants;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberServer}.
* It contains one unit test case for the {@link BomberServer#getInstance()} method.
*/
class BomberServerTest {","// BomberServerTest.java
package server;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.GlobalServerMsg;
import messages.global.SessionDetailsMsg;
import messages.global.SessionListMsg;
import org.apache.log4j.Logger;
import org.hsqldb.Server;
import org.hsqldb.jdbc.jdbcDataSource;
import common.Constants;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberServer}.
* It contains one unit test case for the {@link BomberServer#getInstance()} method.
*/
class BomberServerTest {

	private static final String serverName = ""Hsqldb-BomberServer-Test"";
	
	/**
	 * Test of {@link bomberServer#run()} method, of the class {@link BomberServer}.
	 */
	@Test
	public void testGetInstance() {
		
		Server server = Server.getInstance();
		assertNotNull(server);
		assertTrue(server instanceof BomberServer);
	}

	/**
	 * Test of {@link bomberServer#run()} method, of the class {@link SessionHandler}.
	 */
	@Test
	public void testRun() throws SQLException {
				
        int port = Integer.parseInt(Constants.Jdbc_Port);
        System.setProperty(""db.port"", """" + port);
	
		System.out.println(""Connecting to the sever"");
        log.info(""Connecting to the sever"");
        String host = Constants.DB_Address + "":"" + port;
        Server server = new Server(host, port);
        
		log.info(""Starting DB connection"");
        Connection conn = new javax.sql.DataSource().getConnection();
        
        log.info(""Starting Session Handler"");
        
        javax.sql.DataSource datasource =  new javax.sql.DataSource();
        conn.setDataSource(datasource);
        
        SessionHandler handler = new SessionHandler(conn);
        Thread th = new Thread(handler);
        th.start();
        Thread.sleep(1000);
        log.debug(""Stopped Session Handler"");
    
        server.stop();
        sessionHandler.join(30000);
        
        //wait for the client to come up
        Thread.sleep(60000);
        log.debug(server.getPort() + "": Successful session handler test"");
        
		System.out.println(""Test complete"");
	}
	/**
	 * Test of {@link SessionHandler#waitUntilReady()} method, of the class {@link SessionHandler}.
	 */
	@Test
	public void testWaitUntilReady() throws SQLException {
		
		System.out.println(""Starting DB connection"");
        Connection conn = new javax.sql.DataSource().getConnection();
        
		System.out.println(""Stopping Session Handler"");
        sessionHandler.stop();
        Thread.sleep(1000);
        
        log.info(""Stopped Session Handler"");
    
        server.stop();
		
        sessionHandler.join(30000);
       
		//wait for the client to come up
        Thread.sleep(60000);
        
		System.out.println(""Waiting for client to come up"");
		SessionHolder holder = new SessionHolder(conn);
		holder.join(30000);
		log.debug(holder.getPort() + "": Client connected"");
		
		System.out.println(""Waiting for client to disconnect"");
		holder.join(10000);
		log.debug(holder.getPort() + "": Client disconnected"");
		
		System.out.println(sessionHandler.waitUntilReady().get();
			
		//check that all data are present
		Collection<Message> allMessages = sessionHandler.getMessagesSent();
        	Collection<Integer> allSays =  sessionHandler.getDetermineSaysList();
    
        	//now that all data are present, read them out by a method call
        	List<Message> messageList = sessionHandler.getMessagesAndSays();
        
        	//now that all data are present, read them out by a method call
    
        	Vector<SessionDetailsMsg> sessionDetailList = sessionHandler.getSessionDetailsList();
            
        	Vector<Integer> sessionDetailVector = sessionDetailList.get(0).getSays().get(0);
    
        	//check that all session details are present
        	for (int i = 1; i < sessionDetailList.size(); i++) {
	            	log.debug(sessionDetailList.get(i).getKey() + "" - Value: "" + sessionDetailList.get(i).getValue());
					assertTrue(sessionDetailList.get(i).getSessionDetails().containsKey(""say"")); //the key must be present
        	}	    
        	for ( int i = 0; i < sessionDetailList.size(); i++) {
	            	log.debug(sessionDetailList.get(i).getKey() + "" - Value: "" + sessionDetailList.get(i).getValue());
					assertTrue(sessionDetailList.get(i).getSessionDetails().containsKey(""say""));
					assertTrue(sessionDetailList.get(i).getSent().add(""message"") >= 0);
					assertTrue(sessionDetailList.get(i).getSent().add(""say"") >= 0);
					assertTrue(sessionDetailList.get(i).getDetermined().add(""says"") >= 0);
					assertTrue(sessionDetailList.get(i).getDetermined().add(""says"") >= 0); //the key must be present
    	        }
    
	        //check that all session details are present
	        for (int i = 0; i < sessionDetailList.size(); i++) {
	            	log.debug(sessionDetailList.get(i).getKey() + "" - Value: "" + sessionDetailList.get(i).getValue());
					assertTrue(sessionDetailList.get(i).getSessionDetails().containsKey(""say""));
    	        }
        	
          
        	log.info(sessionDetailVector);
        
    	
        //reconnect
        conn.setAutoCommit(false);
        
        log.info(""Connecting to the sever again"");
        server = new Server(host, port);
    
        log.info(""Starting DB connection"");
        conn = new javax.sql.DataSource().getConnection();
        
        log.info(""Stopping Session Handler2"");
        sessionHandler.stop();
        
        log.info(""Stopped Session Handler2"");
    
        server.stop();
		
        sessionHandler.join(30000);
       
		//wait for the client to come up
        Thread.sleep(60000);
        
		System.out.println"
8d991862-25e7-4631-915a-4f4480944469,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/ServerBomb.java,58.95490837097168,stop,"// ServerBomb.java
package server;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.Collection;
import java.util.Vector;
import messages.round.BombExplodedMsg;
import org.apache.log4j.Logger;
import common.Bomb;
import common.Constants;
import common.GameObject;
import common.Player;
import common.PowerUp;
import common.Tile;
import db.DBException;
import db.DBGameUser;
import db.DBServiceFactory;

/**
 * The Bomb Object of the Server. This Bomb ticks some times and then exploded.
 * Then it detects the player and the tile hits.
 *
 * @author Bj�rn, Steffen, Daniel
 */
public class ServerBomb extends Bomb {

    /**
     * handles the tick of the bomb
     *
     * @return
     */
    public boolean tick();
}
","// ServerBombTest.java
package server;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.Collection;
import java.util.Vector;
import messages.round.BombExplodedMsg;
import org.apache.log4j.Logger;
import common.Bomb;
import common.Constants;
import common.GameObject;
import common.Player;
import common.PowerUp;
import common.Tile;
import db.DBException;
import db.DBGameUser;
import db.DBServiceFactory;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerBomb}.
* It contains one unit test case for the {@link ServerBomb#tick()} method.
*/
class ServerBombTest {","// ServerBombTest.java
package server;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.Collection;
import java.util.Vector;
import messages.round.BombExplodedMsg;
import org.apache.log4j.Logger;
import common.Bomb;
import common.Constants;
import common.GameObject;
import common.Player;
import common.PowerUp;
import common.Tile;
import db.DBException;
import db.DBGameUser;
import db.DBServiceFactory;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerBomb}.
* It contains one unit test case for the {@link ServerBomb#tick()} method.
*/
class ServerBombTest {

    /**
    * Test unit test for {@link ServerBomb#tick()}. This method tests the behavior of the
    * {@link ServerBomb} when it is expected to be triggered at some later point within the world.
    * It test the case where only one tile can be found, and the bomb is triggered by another player.
    *
    * @throws DBException
    */
    @Test
    void tickTest() throws DBException {
        try {
            ServerBomb serverBomb = new ServerBomb();

            // The server should execute the method for every round which is done
            //   so that the server can detect player & tile hits.
            // The server can do so several times and
            //   it will try to find the bombs with a tile which is the tile we want
            serverBomb.tick();

            // There is a bug that causes the server to do so a lot of time
            //   but that is very rare
            final int N_TIME_LEAVES = 10;
            int i = 0;
            Collection<Point> points = new Vector<Point>();
            while(points.size() < Constants.MAX_POINTS || i < N_TIME_LEAVES){
                i++;
                try {
                    points = serverBomb.detect(GameObject.getActive(Constants.PLAYER_TILE), points);
                } catch (DBException e) {
                    // We hit a bug
                    Logger.getRootLogger().error(""Fatal Error occured while getting the bomb with tile: ""+Constants.PLAYER_TILE);    
                    assertTrue(false) : ""Error occured while getting the bomb with tile: ""+Constants.PLAYER_TILE;
                }
            }

            // The client is telling us there are no tiles to collide with.
            assertFalse(""There should be no tile to collide with"", points.isEmpty());
        } catch(DBException dbe) {
            Logger.getRootLogger().error(""Could not detect the bombs with the tile: "" + Constants.PLAYER_TILE +"" and the player: ""+Constants.PLAYER, dbe);
            assertTrue(false);
        }
    }
}
"
10c6b317-566b-4afe-aaf4-a5576e0be63d,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/StopServer.java,63.659379720687866,stop,"// StopServer.java
package server;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.Socket;
import messages.Message;
import messages.global.StopServerMsg;

/**
 * Sends a Message to the Server, that he should closed
 *
 * @author Bj�rn
 */
public class StopServer {

    /**
     * Connect to the Server
     */
    public boolean connectToSrv();
}
","// StopServerTest.java
package server;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.Socket;
import messages.Message;
import messages.global.StopServerMsg;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StopServer}.
* It contains one unit test case for the {@link StopServer#connectToSrv()} method.
*/
class StopServerTest {","// StopServerTest.java
package server;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.Socket;
import messages.Message;
import messages.global.StopServerMsg;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StopServer}.
* It contains one unit test case for the {@link StopServer#connectToSrv()} method.
*/
class StopServerTest {

	/**
	 * Test method for {@link StopServer#connectToSrv()}.
	 * The test case includes one exception, the following test cases:
	 * 	<ol>
	 *		<li>{@link StopServerTest#connectToSrv()} should return {@code false}</li>
	 *		<li>{@link StopServerTest#connectToSrv()} should throw {@link SocketClosedException}}</li>
	 *		<li>{@link StopServerTest#connectToSrv()} should throw {@link IOException}}</li>
	 *		<li>{@link StopServerTest#connectToSrv()} should throw {@link ClassNotFoundException  }}</li>
	 * 	</ol>
	 */
	@Test
	public void testConnectToSrvReturnFalse() throws IOException {
		try {
	        Socket temp = new Socket(TestServerClass.TESTING_IP, TestServerClass.TESTING_PORT);
	        OutputStream out = temp.getOutputStream();
	        ObjectOutputStream oos = new ObjectOutputStream(out);

	        ObjectOutputStream oos2 = new ObjectOutputStream(out);
	        oos2.writeObject(new  StopServerMsg());

	        oos2.close();
	        oos.close();
	        oos.flush();
	
	        assertEquals(false,  connectToSrv());
		}
		catch (ClassNotFoundException | SocketClosedException | IOException e) {
	        ExceptionManager.err(e.getMessage());
			fail(e.getMessage());
		}
	}
	
	/**
	 * Test method for {@link StopServer#connectToSrv(int)}.
	 * The test case includes one exception, the following test cases:
	 * 	<ul>
	 *
	 *		<li>{@link StopServerTest#connectToSrv()} should return {@code false}</li>
	 *		<li>{@link StopServerTest#connectToSrv()} should throw {@link IOFailure}}</li>
	 *		<li>{@link StopServerTest#connectToSrv(int)} should throw {@link SocketClosedException}}</li>
	 *		<li>{@link StopServerTest#connectToSrv(int)} should throw {@link IOException}}</li>
	 *		<li>{@link StopServerTest#connectToSrv(int)} should throw {@link ClassNotFoundException  }}</li>
	 *	</ul>
	 */
	@Test
	public void testConnectToSrvException(int port) throws IOException,  SocketClosedException, ClassNotFoundException {
	        final TestServerClass testClass = TestServerClass.getInstance();
	        
	        ObjectOutputStream oos = new ObjectOutputStream(new ObjectOutputStream(testClass.testSrvUDPHost.getOutputStream()));
	        TestServerClass.TESTING_SERVER_PORT = port;

	        try {
	        oos.writeObject(new  Message());
	        }
	        catch(IOException e) {
	        oos.close();
	        ClassNotFoundException.check(e);
	        throw e;
	        }

		try {
			connectToSrv();
		}
		catch (SocketClosedException e) {
	        oos.close();
			oops.close();
			oos.flush();
			oos.writeObject(new  ClassNotFoundException(""The socket wasn't closed""));
			throw e;
		}

		try {
			oos.close();
		} catch (IOException e) { //do nothing
		}

		try {
			oos.writeObject(new  IOFailure());
		} catch (IOException e) { //do nothing
		}

		try {
			connectToSrv(port + 10);
		}
		catch (IOException e) {
			IOGlobal.LOG_ALL.log(e);

			ExceptionManager.err(e.getMessage());
			oos.close();
			oops.close();
			oos.flush();
			oos.writeObject(new  ClassNotFoundException(""The socket wasn't closed""));
			throw e;
		}

		if (port!=  TestServerClass.TESTING_SERVER_PORT) {
			oos.close();
			oops.close();
			oos.flush();

			IOException e;
			e = ClassNotFoundException.check(new IOException(""We already closed a port""));
			try {
				connectToSrv(0);
			}
			catch (IOException e2) {
				e = e2;
			}
			
			oos.close();
			oops.close();
			oos.flush();
			oos.writeObject(new  ClassNotFoundException(""The socket wasn't closed""));
			
		
			
		}
		
	}

}

"
3cc81f1a-9c8a-4cb2-8ecf-94ed80e22368,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/Map_0Test.java,60.78051018714905,stop,"// Map.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;

/**
 * Map-Class with all information needed for map use of iterators tile-iterator:
 * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :
 * map.powerupiterator)
 *
 * @author christian
 */
public class Map implements Iterable<Tile>, Serializable {

    /**
     * return MapTile object at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @return MapTile object
     */
    public Tile getTileByIndex(int x, int y);
}
","// Map_0Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getTileByIndex(int, int)} method.
*/
class Map_0Test {","// Map_0Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getTileByIndex(int, int)} method.
*/
class Map_0Test {

		@Test
		public void getTileByIndex_1() {

		}

		@Test
		public void getTileByIndex_2() {

		}

        @Test
        public void getNeighbour_1() {
		}

		@Test
		public void getNeighbour_2() {
		}

        @Test
        public void getNeighbour_3() {
		}

		@Test
		public void isTile_4() {
		}

		@Test
		public void size_5() {
		}

        @Test
        public void getNeighbour_6() {
		}

		@Test
		public void getNeighbour_7() {
		}	

		@Test
		public void iterator_8() {
		}

		@Test
		public void powerup_9() throws NoSuchElementException {
		}

		@Test
		public void powerup_10() throws NoSuchElementException {
		}

		@Test
		public void powerup_11() throws NoSuchElementException {
		}

		@Test
		public void powerup_12() {
		}

        @Test
        public void powerup_13() {
		}


		@Test
		public void powerup_14() {
		}

		@Test
		public void getLocation_15() {
		}

		@Test
		public void getLocation_16() {
		}

        @Test
        public void getLocation_17() {
		}

		@Test
		public void getTile_18() {

		}

        @Test
        public void setTile_19() {
		}

        @Test
        public void setTile_20() {
		}

		@Test
        public void getLocation_21() {
		}

        @Test
        public void setLocation_22() {

		}

        @Test
        public void getTile_23() {

		}

        @Test
        public void setLocation_24() {

		}




	@Test
	public void put_25() {
	}

	@Test
	public void remove_26() {
	}

	@Test
	public void getTileIndex_27() {
		}

	@Test
	public void powerup_28() {
		}

	@Test
	public void powerup_29() {
		}

	@Test
	public void position_30() {
		}

	@Test
	public void position_31() {
		}

	@Test
	public void powerup_32() {
		}

    @Test
    public void powerup_33() {
        PowerUp poweruppe = new PowerUp();
        poweruppe.setPoint(new Point(100, 100));
        poweruppe.position();
        PowerUp.print(""Powerup position"");
    }
}"
8b1084e4-b76e-4215-947f-7aafd745eae0,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/Map_1Test.java,60.878915548324585,stop,"// Map.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;

/**
 * Map-Class with all information needed for map use of iterators tile-iterator:
 * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :
 * map.powerupiterator)
 *
 * @author christian
 */
public class Map implements Iterable<Tile>, Serializable {

    /**
     * return MapTile object at Position x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @return MapTile object
     */
    public Tile getTile(int x, int y);
}
","// Map_1Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getTile(int, int)} method.
*/
class Map_1Test {","// Map_1Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getTile(int, int)} method.
*/
class Map_1Test {

	public Map_1Test(int expectedTile) {
		this.expectedTile = expectedTile;
	}

	/**
	 * It returns a Map with 1 tile and a tile size of one pixel
	 *
	 * @throws Exception -
	 *             if an exception occured while loading the Map class or it was not possible to load it.
	 */
	@Test
	public void test_Map() throws Exception {
		Map map = new Map(""Map"", 1, 1);
		Tile tile = map.getTile(0, 0);
		assertNotNull(tile);
		assertFalse(tile == map.getTile(0, 0));
		assertEquals(expectedTile == map.getTile(0, 0), false);
	}

	/**
	 * It returns a Map from a given String
	 *
	 * @throws Exception -
	 *             if an exception occured while loading the Map class or it was not possible to load it.
	 */
	@Test
	public void test_List() throws Exception {
		Map map = new Map(""Map"", ""Tile"", 3, 3);
		Vector<Tile> v = map.getTileList();
		assertEquals(v.size(), 1);
		Tile t = v.iterator().next();
		assertEquals(expectedTile, t.getTileNumber());
	}

	/**
	 * It returns iterator of Map tiles
	 *
	 * @throws Exception -
	 *             if an exception occured while loading the Map class or it was not possible to load it.
	 */
	@Test
	public void test_Iterator() throws Exception {
		Map map = new Map(""Map"", ""Tile"", 3, 3);
		Point pom = new Point(0, 0);
		Vector<Tile> v = map.getTileList();
		Iterator<Tile> tileIt = map.iterator(pom);
		assertTrue(tileIt.hasNext());
		tileIt.next();
		assertFalse(tileIt.hasNext());
		assertFalse(tileIt.hasNext());
	}

	private int expectedTile;

}

// Map_2Test.java
"
9d05a2aa-ad86-46ad-a2dc-b74d47a18ebe,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/Map_2Test.java,60.897024154663086,stop,"// Map.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;

/**
 * Map-Class with all information needed for map use of iterators tile-iterator:
 * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :
 * map.powerupiterator)
 *
 * @author christian
 */
public class Map implements Iterable<Tile>, Serializable {

    /**
     * gets start-point-coordinates of player no. if not set, return coordinates
     * of field 1/1
     *
     * @param playerNo -
     *            number of player
     * @return Point with coordinates
     */
    public Point getStartPoint(int playerNo);
}
","// Map_2Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getStartPoint(int)} method.
*/
class Map_2Test {","// Map_2Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getStartPoint(int)} method.
*/
class Map_2Test {

	private int  playerNo = 1;
	private Position position;
	// private Map map;
	private Vector<PowerUp> powerUpList = new Vector<PowerUp>();
    private Map map;
    /**
     * test constructor
     * @throws Exception - exception thrown to test if all fields are set
     */
    public Map_2Test() throws Exception {
		
		// map = new Map();      
        map = createMapWithPos();
        
        for (Tile tile : map) {
            System.out.println(""Tile : "" + tile);
        }
    }

    /**
     * test with no position set
     */
    @Test
    public void testGetNoPosition() {
        // map = new Map();
        System.out.println(""No position set"");
        assertNull(map.getStartPoint(playerNo));
    }

    /**
     * test with position set
     */
    @Test
    public void testWithPosition() {
        pos = new Position(new Point(23, 34), new Date(342347.541));
        System.out.println(""pos : "" + pos);
        Map map1 = createMapWithPos();
//        System.out.println(""map1 : "" + map1);
        System.out.println(map1);
        // assertTrue(map1 == map);
        assertEquals(pos.getX(), map1.getStartPoint(playerNo).getX());
        assertEquals(pos.getY(), map1.getStartPoint(playerNo).getY());
        assertEquals(pos.getLatitude().getLatitude(), map1.getStartPoint(playerNo).getLatitude().getLatitude());
        assertEquals(pos.getLongitude().getLongitude(), map1.getStartPoint(playerNo).getLongitude().getLongitude());
        System.out.println(""start point of tile : "" + map1.getStartPoint(playerNo)
                            .getX());
        System.out.println(""end point of tile : "" + map1.getEndPoint(playerNo).getX());
        System.out.println(""start point of tile : "" + map1.getEndPoint(playerNo).getY());
        System.out.println(""end point of tile : "" + map.getEndPoint(playerNo).getX());
        System.out.println(map.getPosition());
        assertEquals(pos.getLatitude(), map.getPosition().getLatitude());
        assertEquals(pos.getLongitude(), map.getPosition().getLongitude());
    }
	
	/**
     * get end point coordinates for tile with powerup with no position set
     * @return Point with coordinates
     */
	public Point getEndPointTile() {
		return map.getEndPoint(playerNo);
	}

	/**
     * get start point coordinates for tile with powerup with no position set
     * @return Point with coordinates
     */
	public Point getStartPointTile() {
		return map.getStartPoint(playerNo);
	}

	/**
     * create map with playerNo position set
     * @return 
     */
    public Map createMapWithPos() {
        Position  start = new Position(23, 34);
        Position  end = new Position(64, 75);
        Vector<PowerUp> powerUps = new Vector<PowerUp>();
        // powerUps.add(new PowerUp(new Point(50, 35), new Point(0, 2), new
        // Point(30.6, 15.2), new Vector<String>(), new Date(361371.541),
        powerUpList.size()));
        Iterator<PowerUp> it = powerUps.iterator();
        powerUpList.iterator();
        // powerUps.add(new PowerUp(new Point(50, 33), new Point(0, 2), new
        // Point(30, 1), new Vector<String>(), new Date(361371.543),
        // it)//
        // powerUps.iterator();
        while (powerUpList.size() < 2) {
            powerUpList.add(it.next());
            powerUps.add(it.next());
        }
        System.out.println(powerUps);
        System.out.println(powerUpList);
        pos = start;
		map = new Map(powerUps,
				pos.getLatitude().getLatitude(),
				pos.getLongitude().getLongitude(),
				3);
		return map;
    }

	/**
     * create map with pos set with powerup position set
     * @return 
     */
    public Map createMapWithPosAndPowerup() {
        MoveToPos   pos = new MoveToPos(new Point(23, 34), new Date(342347.541));
        Position posi = new Position(new Point(23, 34), new Date(342347.541 + 2000));
        Vector<PowerUp> powerUps = new Vector<PowerUp>();
        powerUps.add(new PowerUp(new Point(50, 33), new Point(0, 2), new Point(30,
                1), new Vector<String>(), new Date(361371.543), it));
        Iterator<PowerUp> it = powerUps.iterator();
        powerUps.iterator();
        System.out.println(powerUps);
        System.out.println(powerUpList);
        posi = new Position(new Point(23, 34), new Date(342347.541 + 1000));
        map = new Map(powerUps, posi.getLatitude().getLatitude(), pos
               .getLongitude().getLongitude(), 3);
        return map;
    }

    /**
     * delete powerUpList if powerup is NULL
     */
    public void deletePowerUpIfNull() {
        if (powerUpList.isEmpty()) {
            powerUps = null;
        }
    }

	/**
     * @return
     */
    public Vector<Tile> getTiles() {
        Vector<Tile> tiles = new Vector<Tile>();
        System.out.println("""");
        Tile tile = new Tile(new Point(23, 34), new Date(342347.541), new Vector<String>()
                              , new Vector<PowerUp>(), 3);
        System.out.println(tile);
        System.out.println(""tiles : "" + tiles);
        tiles.add(tile);
        return tiles;
    }
}
"
798c89e8-8a3a-4bb7-b45d-9caf7557b680,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/ResourceService_0Test.java,35.45102262496948,stop,"// ResourceService.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

/**
 * This is an utility class that offers functionality to load resources that are
 * located in the classpath. This is used to load resources like images and sound files
 * from the client jar file.
 *
 * @author andi
 */
public class ResourceService {

    /**
     * Loads the {@link Image} that is located at the specified path.
     *
     * @param path The location of the image within the classpath.
     * @return The loaded {@link Image} or null if there was an IOException while trying
     * to read the image from a stream.
     */
    public static Image getImage(String path);
}
","// ResourceService_0Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getImage(String)} method.
*/
class ResourceService_0Test {","// ResourceService_0Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getImage(String)} method.
*/
class ResourceService_0Test {

    /**
     * Test method for {@link java.io.Resource#getResource(String)}.
     */
    @Test
    public void testGetResource() {
        // No parameter.
        Assert.assertNull(ResourceService.getImage(""""));

        // One parameter.
        String expected = "".png"";
        String result = ResourceService.getImage(expected);
        Assert.assertNotNull(result);
        assertEquals(expected, result);
    }

    /**
     * Test method for {@link java.io.File#getAbsolutePath()}.
     */
    @Test
    public void testGetAbsolutePath() {
        String expected = "".png"";
        String result = FileService.getAbsolutePath(expected);
        assertEquals(expected, result);
    }

    /**
     * Test method for {@link java.io.InputStream#getCode()}.
     */
    @Test
    public void testGetCode() throws IOException {
        InputStream os = ResourceService.getImage(""abc.png"");
        assertNotNull(os);
        byte[] readBuffer = new byte[100];
        assertEquals(""ABC.png"", new String(readBuffer));
    }

    /**
     * Test method for
     * {@link java.io.InputStream#isReadingFromJar()}
     *.
     */
    @Test
    public void testIsReadingFromJar() throws IOException {
//        InputStream is = this.getClass().getResource(""test.jar"").getInputStream();
//        
//        byte[] readBuffer = new byte[200]; 
//        InputStreamReader isr = new InputStreamReader(is);

        // No parameter.
//        ResourceService.isReadingFromJar(isr);
//        
//        isr = new InputStreamReader(is);
//
//        FileInputStream in = new FileInputStream(""test.jar"");
//        assertEquals(""test.jar"", ResourceService.getFileFromJar(in));
    }

    /**
     * Test method for {@link ResourceService#getFileFromJar(javax.imageio.ImageReader)}.
     */
    @Test
    public void testGetFileFromJar() throws IOException {
        ImageIcon imageIcon = new ImageIcon(""abc.png"");
        InputStream is = this.getClass().getResource(""test.jar"").getInputStream();
        assertNotNull(is);
        BufferedImage img = ImageIO.read(is);

        assertEquals(img.getColorModel(), isr.getFallbackColorModel());
        ImageIcon result = ResourceService.getFileFromJar(isr);
        assertNotNull(result);
        inputStreamToImage(is, img);
    }
    
    /** @return the inputstream to the image. */
    private static void inputstreamToImage(InputStream is, BufferedImage img) throws IOException {
        BufferedImageReader isr = new BufferedImageReader(is);
        
        int[] color = new int[1];
        Color c = isr.readColor(color);
        double[] rgb = new double[3]; // RGB is a 3x2-matrix.
        rgb = isr.getRGB();
        int w = isr.getWidth();
        int h = isr.getHeight();
        switch (c) {
            case WHITE:
                img.setRGB(0, 0, w, h, rgb, 0, w);
                break;
            case BLACK:
                img.setRGB(rgb[0], rgb[1], rgb[2], w, h, rgb, 0, w);
                break;
            case RED:
                img.setRGB(rgb[0], rgb[1], rgb[2], w, h, rgb, w, h);
                break;
            case GREEN:
                img.setRGB(rgb[0], rgb[1], rgb[2], w, h, rgb, 0, h);
                break;
            case BLUE:
                img.setRGB(rgb[0], rgb[1], rgb[2], w, h, rgb, w, h);
                break;
        }
        assertTrue(boundedValue(w));
        assertTrue(boundedValue(h));
    }

    /** @return true if the number is bounded. */
    private static boolean boundedValue(int i) {
        if (i == 1) return true;
        if (i == 2) return true;
        if (i == 3) return true;
        return false;
    }
}
"
42b0771f-7451-43cf-81e3-d3556f16bd63,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/ResourceService_1Test.java,26.241271495819092,stop,"// ResourceService.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

/**
 * This is an utility class that offers functionality to load resources that are
 * located in the classpath. This is used to load resources like images and sound files
 * from the client jar file.
 *
 * @author andi
 */
public class ResourceService {

    /**
     * Loads the {@link ImageIcon} that is located at the specified path.
     *
     * @param path The location of the image within the classpath.
     * @return The loaded {@link ImageIcon}
     */
    public static ImageIcon getImageIcon(String path);
}
","// ResourceService_1Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getImageIcon(String)} method.
*/
class ResourceService_1Test {","// ResourceService_1Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getImageIcon(String)} method.
*/
class ResourceService_1Test {

	// @Test
	// void testConstructor() throws IOException {
	// InputStream in = ResourceService.class.getClassLoader().getResourceAsStream(""testImage.png"");
	// BufferedImage im = ImageIO.read(in);
	// assertNotNull(""The Image cannot be null"",im);
	// assertEquals(""The Image must have the expected width and height"",im.getWidth(),64);
	// assertEquals(""The Image must have the expected height"",im.getHeight(),64);
	// }
	
	// Some common functions for unit tests. These functions contain a bunch of test cases.
	
	/**
	 * This is the default constructor of {@link ResourceService}.
	 *
	 */
	public ResourceService_1Test() {
	}
	
	/**
	 * This function is a static method that is called by {@link ResourceService_1Test#testConstructor()}.
	 * It contains one test case for the {@link ResourceService#getImageIcon(String)} method.
	 * @param in The location of the image within the classpath.
	 * @return The loaded {@link ImageIcon} of the specified path
	 */
	public static ImageIcon getImageIcon(InputStream in)
	throws IOException {
		return new ImageIcon(""image/png"", in);	
	}
	
	/**
	 * Tests for the case of loading the 'non existing' image by
	 * calling {@link ResourceService#getImageIcon(InputStream)} again.
	 */
	@Test(expected=IOException.class)
	public void testGetImageIcon() throws IOException {
		ImageIcon i = (ImageIcon) ResourceService.getImageIcon(ResourceService_1Test.class.getClassLoader().getResourceAsStream(""testImage.png"")); 
		expectThrown(""An Exception must have been thrown by the getImageIcon call"",() -> i.getImage());
	}
	
}"
b4854acc-0f9d-4ff6-b116-d05b62e31e9a,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/ResourceService_2Test.java,44.531705379486084,stop,"// ResourceService.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

/**
 * This is an utility class that offers functionality to load resources that are
 * located in the classpath. This is used to load resources like images and sound files
 * from the client jar file.
 *
 * @author andi
 */
public class ResourceService {

    /**
     * Creates a connection to the resource that is located at the specified
     * path via an {@link InputStream}.
     *
     * @param path The location of the resource within the classpath.
     * @return The {@link InputStream} that points the requested resource.
     */
    public static InputStream getInputStream(String path);
}
","// ResourceService_2Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getInputStream(String)} method.
*/
class ResourceService_2Test {","// ResourceService_2Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getInputStream(String)} method.
*/
class ResourceService_2Test {

	/**
	 * Unit test for getting a {@link Image} from the resource.
	 *
	 * @throws Exception 
	 */
	@Test
	public void testGetInputStream() throws Exception {
		InputStream is = getInputStream(""R:/resources/audio.wav"");
		
		assertTrue(is!= null);
		assertTrue(is instanceof AudioInputStream);
		
	}
	
	/**
	 * Unit test for getting a {@link BufferedImage} from the resource.
	 *
	 * @throws IOException
	 */
	@Test
	public void testGetBufferedImage() throws IOException {
		InputStream is = getInputStream(""R:/resources/audio.wav"");
		
		assertTrue(is!= null);
		BufferedImage image = ImageIO.read(is);

		assertNotNull(image);
		assertFalse(is.markSupported());
		
	}

	
	/**
	 * Unit test for getting an {@link ImageIcon}.
	 *
	 * @throws IOException 
	 */
	@Test
	public void testGetImageIcon() throws IOException {
		InputStream is = getInputStream(""R:/resources/audio.wav"");
		
		assertTrue(is!= null);
		ImageIcon icon = ImageIO.read(is);

		assertNotNull(icon);
		assertTrue(icon.getImage()!= null);
		assertTrue(icon.getImage().getWidth() > 0 && icon.getImage().getHeight() > 0);

	}
	
}

// ResourceService.java
"
3706fab6-a3f6-426a-b435-6fd372d03b05,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/MapPreview.java,56.55827355384827,stop,"// MapPreview.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;

/**
 * create a ImageIcon Map Preview of a map object
 *
 * usage example: MapPreview mp = new MapPreview(map); mp.setImageSet(""desert"");
 * (optional) ImageIcon ii = mp.getMapPreview(150); !!
 *
 * @author christian
 */
public class MapPreview {

    /**
     * returns preview of current map
     *
     * @param previewWidth -
     *            Width of preview. Proportions are constrained
     * @return BufferedImage with map preview
     */
    public ImageIcon getMapPreview(int previewWidth);
}
","// MapPreviewTest.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapPreview}.
* It contains one unit test case for the {@link MapPreview#getMapPreview(int)} method.
*/
class MapPreviewTest {","// MapPreviewTest.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapPreview}.
* It contains one unit test case for the {@link MapPreview#getMapPreview(int)} method.
*/
class MapPreviewTest {
// MapPreview.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;

/**
 * create a ImageIcon Map Preview of a map object
 *
 * usage example: MapPreview mp = new MapPreview(map); mp.setImageSet(""desert"");
 * (optional) ImageIcon ii = mp.getMapPreview(150);!!
 *
 * @author christian
 */
public class MapPreview {

    /**
     * returns preview of current map
     *
     * @param previewWidth -
     *            Width of preview. Proportions are constrained
     * @return BufferedImage with map preview
     */
    public ImageIcon getMapPreview(int previewWidth);
}

// MapPreviewTest.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapPreview}.
* It contains one unit test case for the {@link MapPreview#getMapPreview(int)} method.
*/
class MapPreviewTest {
		
    /**
     * Creates a new instance of {@link MapPreviewTest}
     * This constructor is for test cases ONLY.
     *
     * @param map - the map object to be used for preview
     */
    public MapPreviewTest(Map map) {
            this.map = map;
    }
    
    /**
     * creates a new ImageIcon for a preview
     */
    public ImageIcon getMapPreview(int previewWidth);


    /**
     * The Map object
     */
    private Map map = new Map();
    /**
     * The name to be used for preview
     */
    private String name = ""New Preview"";
    /**
     * Reference to test data to be used in creating preview
     */
    private Vector<String> stringData = new Vector<String>();
    /**
     * Constructor of MapPreviewTest
     *
     * @param previewWidth the width of the image set to be used for preview
     */
    @Test
    public void testCreateMapPreview(int previewWidth)
    {
        log = Logger.getLogger(this.getClass());
        int mapWidth = 300;
        String dataFileName = String.format(
        		""%s.map.%d"",
                name,
                mapWidth
        );

        // we create a new map preview and add this testcase to the vector
        image = new ImageIcon(mapWidth, 300);
        map.addNewMapPreview(image, mapWidth, mapWidth);

        // and we create a preview of the test data
        previewWidth = previewWidth;
        if(previewWidth >= 600)
        {
            String testData1 = ""The Test Data"";
            stringData.add(""The Test Data"");
            stringData.add(testData1);
            stringData.add(""The Test Data with spaces"");
            stringData.add(testData1);
        }
        previewWidth = previewWidth / 2;
        while(previewWidth < 300)
        {
        	 // add some test data
        	String testData1 = ""The Test Data"";
        	stringData.add(""The Test Data"");
        		stringData.add(testData1);
        	stringData.add(""The Test Data with spaces"");
        		stringData.add(testData1);
            log.setLevel(Logger.LEVEL_WARNING);
            log.setLevel(Logger.LEVEL_INFO);

            if(!previewWidth.equals(250) &&!previewWidth.equals(200) &&
              !previewWidth.equals(600) &&
              !previewWidth.equals(500) &&
              !previewWidth.equals(650) &&
              !previewWidth.equals(700) &&
              !previewWidth.equals(750))
            {
                System.out.println(""Test imageWidth wrong!"" + previewWidth);
                System.out.println(stringData);
                fail(""Test imageWidth wrong!"" + previewWidth);
            }
            previewWidth = previewWidth + 1;
        }
        int previewWidth2 = 0;
        while(previewWidth2 < 100)
        {
       	 // some test data
	String testData1 = ""The Test Data"";
	stringData.add(""The Test Data"");
	stringData.add(testData1);
        	stringData.add(""The Test Data with spaces"");
        		stringData.add(testData1);
            log.setLevel(Logger.LEVEL_INFO);
        		log.setLevel(Logger.LEVEL_INFO);
        		try
        		{
        			previewWidth2 = (previewWidth - 2);
        		}
        		catch (Exception e)
        		{
        			// System.out.print(e.getMessage())
        			log.info(e);
        		}
        }
        log.setLevel(Logger.LEVEL_WARNING);
        // now some more tests!
        log.setLevel(Logger.LEVEL_INFO);

        for(int i = 0; i < stringData.size(); i+= 2)
        {
                String testData = stringData.get(i);

                // we save the name to avoid a crash
                if(stringData.size()!= i+ 1)
                {
    				map.setName(i+ 1, stringData.get(i+ 1));
                }
                else
                {
    				map.setName(i+ 1, stringData.get(i)+ ""  - Test"");
                }
                Image testDataImage = dataFileName.replace(i, 2, testData).getImage();
                log.info(i + "" : Preview image width = "" + testDataImage.getWidth()
                    + "", height = "" + testDataImage.getHeight());
        }
        MapPreview mp = new MapPreview(map);
		assertTrue(""Map preview is not available"", mp.getMapPreview(previewWidth)!= null);
		assertTrue(""All expected results are available"", mp.getName()
				.equals(map.getName()));

    }

    /**
     * Creates a new ImageIcon for image data to be used in creating a preview
     */
    private ImageIcon image = null;
    private int imageWidth;
    private int imageHeight;

    /**
     * Create map preview of width = 500
     *
     * @param width
     * @return
     */
    ImageIcon getNewMapPreview(int width) {

        log.setLevel(Logger.LEVEL_INFO);

        /* Creating the new ImageIcon for the image data
        */
    	try
        {
            File imageFile = new File(dataFileName + ""_"" + mapWidth + "".map.bmp"");
            ImageIcon result = new ImageIcon(ImageIO.read(imageFile));
            imageHeight = result.getIconHeight();
			imageWidth = result.getIconWidth();
		}
        catch (IOException e)
        {
            log.setLevel(Logger.LEVEL_ERROR);
        }
    	return image;

        //return new ImageIcon(new BufferedImage
        //(imageHeight, imageWidth, BufferedImage.TYPE_INT_RGB));
    }
}
"
8025b9a4-865c-43e1-90a4-69e9095a2d7a,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/XmlFunctions_0Test.java,47.178356409072876,stop,"// XmlFunctions.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * basic functions for reading and writing xml files
 *
 * @author christian
 */
public class XmlFunctions {

    /**
     * returns value of specific xml element
     *
     * @param XmlPath -
     *            element path (XPath)
     * @return String with value of element
     */
    public String getXmlValue(String XmlPath);
}
","// XmlFunctions_0Test.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlFunctions}.
* It contains one unit test case for the {@link XmlFunctions#getXmlValue(String)} method.
*/
class XmlFunctions_0Test {","// XmlFunctions_0Test.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlFunctions}.
* It contains one unit test case for the {@link XmlFunctions#getXmlValue(String)} method.
*/
class XmlFunctions_0Test {

        /**
         * test method for
         * {@link XmlFunctions#getXmlValue(String)}
         *
         * @throws XPathExpressionException  XPathException
         * @throws TransformerException      TransformerException
         * @throws SAXException              SAXException
         * @throws IOException               IOException
         */
        @Test
        public void testGetXmlValue() throws XPathExpressionException, TransformerException, SAXException, IOException {
                /**
                 * set up test document
                 */
                Logger.getRootLogger().setLevel(Logger.LEVEL_INFO);
                try (DocumentBuilder db =
                        DocumentBuilderFactory.newInstance().newDocumentBuilder()) {
                        Document doc = db.newDocument();
                        doc.appendChild(doc.importNode(doc.createElement(""doc1""), true));
                        doc.appendChild(doc.importNode(doc.createElement(""doc2""), true));
                        Document docRoot = doc.getDocumentElement();

                        docRoot.setAttribute(""doc1"", ""string1"");
                        docRoot.setAttribute(""doc2"", ""string2"");

                        /**
                         * create the XML representation of the XML document
                         */
                        Transformer t = TransformerFactory.newInstance().newTransformer();

                        t.setOutputProperty(""indenting"", true);
                        t.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""1000"");
                        t.transform(new DOMSource(docRoot), new StreamResult(xmlFile()));

                        /**
                         * read test values from test file
                         * 
                         * @throws IOException Exception
                         */
                        String string1 = xmlFile().readString();
                        String string2 = xmlFile().readString();
                            // assertEquals(string1,string2);
                        System.out.println(xmlFile().readString());
                        assertEquals(string1,string2);


                } catch (ParserConfigurationException ex) {
                        fail(""createXml() exception : "" + ex.getMessage());
                } catch (TransformerException ex) {
                        fail(""createXml() exception : "" + ex.getMessage());
                }
        }

        /**
         * sets the XML file for which test values will be read
         *
         * @return XML Filename
         */
        private File xmlFile() {
                File xmlFile = new File(""test.xml"");

                try {
                        if (!xmlFile.exists()) {
                                xmlFile.getParentFile().mkdirs();
                        }
                        xmlFile.createNewFile();
                        FileOutputStream fos = new FileOutputStream(xmlFile);
                        fos.write(""<Test>test value 1</Test>"".getBytes());
                        fos.close();

                        return xmlFile;
                } catch (IOException ex) {
                        throw new RuntimeException(ex);
                }
        }
}
"
365f6557-1d9a-4137-9669-910fd3c4505d,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/XmlFunctions_1Test.java,47.0444118976593,stop,"// XmlFunctions.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * basic functions for reading and writing xml files
 *
 * @author christian
 */
public class XmlFunctions {

    /**
     * returns a list of nodes matching to the element name
     *
     * @param NodeName -
     *            name of element(s)
     * @return NodeList with found nodes
     */
    public NodeList findXmlNodes(String NodeName);
}
","// XmlFunctions_1Test.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlFunctions}.
* It contains one unit test case for the {@link XmlFunctions#findXmlNodes(String)} method.
*/
class XmlFunctions_1Test {","// XmlFunctions_1Test.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlFunctions}.
* It contains one unit test case for the {@link XmlFunctions#findXmlNodes(String)} method.
*/
class XmlFunctions_1Test {
/**
    * Returns list of nodes matching to the XPath expression.
		*
		* @param XPathExpr - XPath evaluation expression to execute
    * @return list with found nodes
		*/
	public NodeList findXmlNodes(String XPathExpr);
	}
// XMLFunctions_1Test(XmlFunctions_1Test.class)

"
8f3e3975-1e7d-496e-b201-0af59199426d,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/MapReader.java,61.190277338027954,stop,"// MapReader.java
package common;

import org.apache.log4j.Logger;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.awt.Point;
import javax.xml.xpath.*;
import java.util.Date;

/**
 * Loads a XML-file and write read properties, tiles and start points to
 * map-object
 *
 * @author christian
 */
public class MapReader {

    /**
     * Returns a specific value in a group of nodes using XPath expressions
     *
     * @param node -
     *            node(set) in which value should be searched
     * @param XMLPath -
     *            XPath expression
     * @return String - found value
     */
    public String getXMLValue(Node node, String XMLPath);
}
","// MapReaderTest.java
package common;

import org.apache.log4j.Logger;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.awt.Point;
import javax.xml.xpath.*;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapReader}.
* It contains one unit test case for the {@link MapReader#getXMLValue(Node, String)} method.
*/
class MapReaderTest {","// MapReaderTest.java
package common;

import org.apache.log4j.Logger;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.awt.Point;
import javax.xml.xpath.*;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapReader}.
* It contains one unit test case for the {@link MapReader#getXMLValue(Node, String)} method.
*/
class MapReaderTest {

    public static final String XPATH_EXPRESSION = ""/map/points/point"";
    public static final String ROOT_TAG = ""point"";


    /**
     * Returns a specific value in a group of nodes using XPath expressions
     *
     * @param node -
     *            node(set) in which value should be searched
     * @param XMLPath -
     *            XPath expression
     * @return String - found value
     */
    public String getXMLValue(Node node, String XMLPath){
	XPathFactory factory = XPathFactory.newInstance(); // factory is an in-memory factory of nodes
	XPathFactory factory2 = XPathFactory.newInstance(); // factory is a XPath-instance of XML-Nodes
				
	XPath xPath = factory.newXPath();
	XPathExpression expression = xPath.compile( XPATH_EXPRESSION );

	try {

	    // execute XPath expression
	    NodeList nodes = (NodeList) expression.evaluate( node, XPathConstants.NODESET );
	    int foundCount = nodes.getLength();
	    Logger.getAnonymousLogger().debug(""Number of found "" + foundCount + "" nodes"");

	    // retrieve nodes by the XPath expression
	    for (int i=0; i<nodes.getLength(); i++) {
		Node node = nodes.item( i );
		Logger.getAnonymousLogger().debug(""Node "" + i + "" ["" + node.getNodeName() + ""]"");
		Point point = new Point( (int) node.getChildNodes().item(0).getDoubleValue() );
		Logger.getAnonymousLogger().debug(""[Point: "" + toString(point) + ""]"");
		String value = xPath.evaluate( XPATH_EXPRESSION, node.getTextContent(), XPathConstants.STRING).
					toString();
		Logger.getAnonymousLogger().debug(""Returned value: "" + value);
		node = (Node) node.getTextContent();
		node.setTextContent(""NODE_ERROR"");
		node = null;
	    }

	} catch (XPathInitializationException ex) {
		System.out.println(""Exception occured when evaluating XPath expression"");
		ex.printStackTrace();
	}
			
	return null;
    }

    public Node getDataNode(String name){
	// create a new node with the provided name
	Node dataNode =  document.createElement(name);

	// add properties and fill in the property names
	dataNode.setAttribute(""name"", name);
	dataNode.setAttribute(""type"", ""number"");
	dataNode.setAttribute(""val"", ""1"");
	return dataNode;
    }

    public static Node getDataNode(String name, int type, int val, Date timestamp){

	Node dataNode = getDataNode(name);

	// add properties and fill in the given property names
	dataNode.setAttribute(""name"", name);
	dataNode.setAttribute(""type"", type);
	dataNode.setAttribute(""val"", val);
	dataNode.setAttribute(""timestamp"", timestamp.toGMTString());

	return dataNode;

    }

}"
0b4be4c0-0541-490b-b90d-d249eedb4e8f,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/MapFilesLister.java,61.83415389060974,stop,"// MapFilesLister.java
package common;

import java.io.File;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.apache.log4j.Logger;
import messages.global.MapInfo;

/**
 * class for listing maps and returning map information
 *
 * @author christian
 */
public class MapFilesLister {

    /**
     * reads directory and returns a list of found xml-files
     *
     * @param dir -
     *            directory to be searched in
     * @return Vector<File>
     */
    public Vector<File> ListMaps(String dir);
}
","// MapFilesListerTest.java
package common;

import java.io.File;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.apache.log4j.Logger;
import messages.global.MapInfo;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapFilesLister}.
* It contains one unit test case for the {@link MapFilesLister#ListMaps(String)} method.
*/
class MapFilesListerTest {","// MapFilesListerTest.java
package common;

import java.io.File;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.apache.log4j.Logger;
import messages.global.MapInfo;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapFilesLister}.
* It contains one unit test case for the {@link MapFilesLister#ListMaps(String)} method.
*/
class MapFilesListerTest {

	private static final String MAPS_DIR = ""/data/mapfiles"";
	private static Logger logger = Logger.getLogger(MapFileListerTest.class.getName());
	public MapFilesListerTest(){
	}
	

	/**
     * tests the {@link MapFilesLister#ListMaps(String)} method
     *
     * @throws Exception
     *
     * @author christian
     */
    @Test
    public void ListMapsTest() throws Exception {
        List<File> mapListFiles = ListMaps(MAPS_DIR);
        System.out.println(""the number of maps read is "" + mapListFiles.size());
        assertNotNull(""null"", mapListFiles);
    	assertTrue(""list is empty"", mapListFiles.size() > 0);
    	
    	for(File file: mapListFiles){
            logger.debug(""read xml file: "" + file.getName() );
        }
    	logger.error(""list contains unread map info with class: "" + classOfMap());
	}


}

"
cc6cbbf7-339b-4afc-81ed-ebc000dd3685,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/GameModel.java,57.06163763999939,stop,"// GameModel.java
package common;

import java.awt.Point;
import java.util.Collection;
import java.util.HashMap;
import java.util.Vector;
import java.util.Map.Entry;
import messages.round.RoundTimeOverMsg;
import org.apache.log4j.Logger;

/**
 * @author Steffen, Andi, Bj�rn
 */
public class GameModel {

    /**
     * Checks if the game is over and if yes returns the gameObjectId of the
     * winner.
     *
     * @return -1 if game still running, 0 in case of a tie, gameObjectId of the
     *         winner in all other cases
     */
    public int checkForWinner();
}
","// GameModelTest.java
package common;

import java.awt.Point;
import java.util.Collection;
import java.util.HashMap;
import java.util.Vector;
import java.util.Map.Entry;
import messages.round.RoundTimeOverMsg;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameModel}.
* It contains one unit test case for the {@link GameModel#checkForWinner()} method.
*/
class GameModelTest {","// GameModelTest.java
package common;

import java.awt.Point;
import java.util.Collection;
import java.util.HashMap;
import java.util.Vector;
import java.util.Map.Entry;
import messages.round.RoundTimeOverMsg;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameModel}.
* It contains one unit test case for the {@link GameModel#checkForWinner()} method.
*/
class GameModelTest {

	Logger logger = Logger.getLogger (GameModelTest.class);
	PlayerManager pm;
	Point start, end, winner;

	public GameModelTest (PlayerManager pm){
		this.pm = pm;
	}

	@Test
	/**
	 * Unit test method to access the {@link #checkForWinner()} method.
	*/
	public void testCheckForWinner(){
		//check for winner after start
		assertEquals(pm.start().getId(), CheckerManager.getWinner().get(GameModel.class).getId());
	}

	@Test
	/**
	 * Unit test method to get to the end of the game.
	*/
	public void testEnd(){
		winner = new Point (0, 0);

		Collection<RoundTimeOverMsg> timeOverMsgs = CheckerManager.getTimeOverMsgs ();
		timeOverMsgs.forEach(this::addMessage);

		//we wait for the GameModel#checkForWinner to return something.
		assertTrue (CheckerManager.getWinner().get(GameModel.class).getId() == -1);
	}

	private void addMessage(RoundTimeOverMsg timeOverMsg){
		logger.error (""ADDING: "" + timeOverMsg.getClass () + "" class: "" + timeOverMsg.getClass().getName ());
		pm.addMessage(timeOverMsg);
		assertEquals (pm.addMessage(timeOverMsg), ""1"");
		assertEquals (pm.addMessage(timeOverMsg), winner.get());
	}

	@Test
	/**
	 * Unit test method to get all round time over messages stored in the game.
	*/
	public void testRoundTimeOverMessages(){
		Collection<RoundTimeOverMsg> timeOverMsgs = pm.getAllMsg();

		timeOverMsgs.forEach(this::addMessage);

		//we wait for the GameModel#checkForWinner to return something.
		assertTrue (CheckerManager.getWinner().get(GameModel.class).getId() == -1);
	}

	@Test
	/**
	 * Unit test method to check the size of the list of messages.
	*/
	public void testMessages(){
		Collection<RoundTimeOverMsg> timeOverMsgs = pm.getAllMsg();
		assertEquals(timeOverMsgs.size(), 0);

		//add a message
		start = new Point (50, 50);
		end = new Point (100, 50);
		pm.addMessage(new RoundTimeOverMsg (start, end, 1));
		timeOverMsgs = pm.getAllMsg();
		assertEquals(timeOverMsgs.size(), 1);
	}

    @Test
    /**
     * Unit test method to check the integrity of the list of messages.
     */
    public void testMessagesIntegrity(){
	Collection<RoundTimeOverMsg> timeOverMsgs = pm.getAllMsg();
	assertFalse (timeOverMsgs.isEmpty());
    }
    
    @Test
    /**
     * Unit test method to create a map and iterate through it.
     */
    public void testMessagesHashMap(){
    	StringBuilder sb = new StringBuilder();
    	Map<Integer, Integer> map = new HashMap<>(12, 10);
    	for (String s: new Vector<String>() {{

        		int i=0;
        		while (i < 10)
        			i++;

    		}})
    	sb.append(s).append('\n');
    	Collection<RoundTimeOverMsg> timeOverMsgs = pm.getAllMsg();
    	for (RoundTimeOverMsg message : timeOverMsgs)
    		map.put(message.getStart().getId(), message.getEnd().getId());

    	assertEquals (sb.toString(), map.toString());
    }

	@Test
	/**
	 * Unit test method to get a map from a collection of messages.
	*/
	public void testMessagesMap(){
		Collection<RoundTimeOverMsg> timeOverMsgs = pm.getAllMsg();
        	assertEquals (timeOverMsgs.size(), 0);	

        	Map<String, Integer> messageMap = new HashMap(6, 10);
        	for (RoundTimeOverMsg message: timeOverMsgs)
        		messageMap.put(message.getClass().getSimpleName(), message.getMsgId());
        	messageMap.put(RoundTimeOverMsg.class.getSimpleName(), roundTimeOverMsg.getMsgId ());
        	
        	/*
        	 * Check that it is possible to create a map from a collection of messages.
        	*/
        	assertEquals (new HashMap<>(5, 10).equals(messageMap), true);
	}

    @Test
    /**
     * Unit test method to check the integrity of the map.
     */
    public void testMessagesMapIntegrity(){
    	Map<Integer, Integer> map = new HashMap<>(5, 10);
    	for (RoundTimeOverMsg message: pm.getAllMsg())
    		map.put(message.getStart().getId(), message.getEnd().getId());
        	
    	assertTrue (messageMap.equals(map));
	}

	@Test
	/**
	 * Unit test method to add a collection of messages.
	*/
	public void testAdditionalMessages(){
		pm.addAdditionalMsg(""1"", ""2"", 1);
		pm.addAdditionalMsg(""2"", ""1"", 2);
		pm.addAdditionalMsg(""1"", ""2"", ""3"");
	}
}
"
b571d6f5-b607-4680-b36d-3be2f77062b5,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientProperties_0Test.java,61.16175842285156,stop,"// ClientProperties.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;

/**
 * reads and writes properties to xml-file
 * properties file is saved to user directory
 *
 * @author christian
 */
public class ClientProperties {

    /**
     * get property value by element-name returns empty string if fileError is
     * true
     *
     * @param element -
     *            Name of element
     * @return String - value
     */
    public String getProperty(String element);
}
","// ClientProperties_0Test.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientProperties}.
* It contains one unit test case for the {@link ClientProperties#getProperty(String)} method.
*/
class ClientProperties_0Test {","// ClientProperties_0Test.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientProperties}.
* It contains one unit test case for the {@link ClientProperties#getProperty(String)} method.
*/
class ClientProperties_0Test {

	// Constants
	private static String TEST_DIR = ""TEST_DIR"";
	private static String TEST_FILENAME = ""TEST_FILENAME"";

    private File TEST_FILENAME_IN_DIR;
	private static String testDir;

    // File to read and store xml-data
    public static File FileOut = new File(Constants.TEST_DIR + File.separatorChar + ""ClientProperties_0Test.xml"");

	// private static Logger LOGGER;

    @Test
    public void Test_readParamsSetToString_FileOut_should_setToExistToString() throws IOException {
		ClientProperties clientProperties = new ClientProperties();
		assertEquals(fileInAndExistToNullAndExistString(), clientProperties.getProperty(TEST_DIR));
    }

    @Test
    public void Test_checkPropertiesStoredSuccessfully_should_clearLog4jException_onPropertyFileSaveFailure() {
        
        File temp = new File(Constants.logFileTemp);
        assertEquals(temp.exists(), false);

        TEST_FILENAME_IN_DIR = temp.getParentFile();
        FileOut.createNewFile();

        ClientProperties clientProperties = new ClientProperties();
        try {
            assertEquals(fileInAndNotExistToNullAndNotExistString(), clientProperties.getProperty(TEST_DIR));

            String fileName = fileOutAndFileInTempLocationForPropertiesSave(
                    fileInAndNotExistToNullAndNotExistString(), temp.getParentFile());

            assertEquals(fileName, Constants.getPropertyValueWithExclamationComma(fileName));
        } catch (IOException e) {
            assertEquals(e, true);

            // Check Exception is thrown with correct exception message
            String message = XmlFunctions.decode(e, Constants.Logger);
            String expectedErrorMsg = Constants.LOGGER.getMessage(Constants.SERVICE_ERROR_STRING);
            assertEquals(expectedErrorMsg, message);
            
            // Check correct exception occurs with wrong exception message
            assertTrue(String.format(""exception is expected: %s"", expectedErrorMsg), e.getCause() instanceof FileNotFoundException);
        }
    }

    /**
     * tests {@link ClientProperties#isPropertyFileAlreadyExistsUsingSystemProperty(String}  
     * with empty string as value return true
     */
    @Test
    public void Test_isPropertyFileAlreadyExistsUsingSystemPropertyValue_withNullValueReturnsTrue() {
        File temp = new File(Constants.logFileTemp);
        assertEquals(temp.exists(), false);

        // setting an empty value in the file
        FileOut.delete();
        TEST_FILENAME_IN_DIR = temp.getParentFile();
        String value= """";
        FileOut.createNewFile();
        XmlFunctions.writePropertiesFile(value);
        ClientProperties clientProperties = new ClientProperties();
        assertEquals(fileInAndNotExistToNullAndExistString(), clientProperties.getProperty(TEST_DIR));
        assertEquals(fileInAndNotExistToNullAndExistString(), clientProperties.getProperty(TEST_FILENAME));


        // getting value by its own property in xml file using method name as param
        try {
            String expectedValue = null;
            value = System.getProperty(TEST_FILENAME);
            String actualValue = XmlFunctions.readPropertiesFile(TEST_FILENAME);
            assertEquals(expectedValue, actualValue);
        } catch (IOException e) {
            fail();
        }

        // getting value by another param in xml file
        try {
            value = System.getProperty(TEST_FILENAME_IN_DIR);
            String actualValue = XmlFunctions.readPropertiesFile(TEST_FILENAME_IN_DIR, Constants.LOGGER);
            assertEquals(expectedValue, actualValue);
        } catch (IOException e) {
            fail();
        }
    }

    public static File Infile;
    
    // private static void writeFileToTmp(String aString) {
    // INFILE.createNewFile();
    // FileOutputStream outputStream = new FileOutputStream(INFILE);
    // String sString = """";
    //
    // try {
    // sString = Constants.TEST_STRING;
    // } catch (IOException e) {
    // fail();
    // }
    //
    // try {
    // outputStream.write(sString.getBytes());
    // } catch (IOException e) {
    // fail();
    // }
    //
    // }

}
"
578cb5cf-3501-4d96-a712-c4005089360a,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientProperties_1Test.java,60.435688495635986,stop,"// ClientProperties.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;

/**
 * reads and writes properties to xml-file
 * properties file is saved to user directory
 *
 * @author christian
 */
public class ClientProperties {

    /**
     * copies a file from a to b
     * used InputStream as provided from ResourceService class as
     * source and File as destination
     *
     * @param sourceFile -
     *            InputStream - File which should be copied
     * @param destFile -
     *            destination where file should be copied to
     * @return boolean - true if successfully copied, otherwise false
     */
    public static boolean fileCopy(InputStream sourceFile, File destFile);
}
","// ClientProperties_1Test.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientProperties}.
* It contains one unit test case for the {@link ClientProperties#fileCopy(InputStream, File)} method.
*/
class ClientProperties_1Test {","// ClientProperties_1Test.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientProperties}.
* It contains one unit test case for the {@link ClientProperties#fileCopy(InputStream, File)} method.
*/
class ClientProperties_1Test {

	// logger
	private static final Logger logger = Logger.getLogger(ClientProperties_1Test.class);

    // private static final String filePathRoot = XmlFunctions.XMLPATH + File.separator
    //                     + Constants.ROOT.getValue();
    @Test
    void testFileCopy() throws IOException{
    	// test case 0: copy a file from a to a 
     	File sourceFile1 = new File(Constants.SOURCE_FILE_ROOT + File.separator
     			+ Constants.XMLFRAGMENT.getValue() + ""/""+Constants.A.getValue()
     			+ File.separator
     			+  Constants.FILEID2.getValue());
     	File destFile1 = new File(Constants.TARGET_FILE_ROOT + Constants.FILE.getName());
     	int returnValue1 = fileCopy(sourceFile1.toURL(), destFile1.toURL());

     	// test case 1: if destination exists
     	File destFile2 = new File(Constants.TARGET_FILE_ROOT + Constants.FILE.getName());
     	assertTrue(""Unable to create file: ""+destFile2.getAbsolutePath(), destFile2.exists());

     	// test case 2: if destination exists, remove it after execution
        destFile2.setLastModifiedTime(destFile1.lastModified());
		File destFile3 = new File(Constants.TARGET_FILE_ROOT + Constants.FILE.getName());
//		destFile3.delete();       
        boolean deleteFile = destFile2.delete();
        assertTrue(""Unable to delete file: ""+destFile3.getAbsolutePath(), deleteFile);

     	// test case 3: test correct behavior when source and destination files have different lengths
        sourceFile1.setSize(Constants.TOMATO_SIZE-Constants.FILEID.getValue().length()-Constants.FILEID2.getValue().length());
        destFile1.setSize(Constants.TOMATO_SIZE-Constants.FILEID.getValue().length()-Constants.FILEID2.getValue().length());
//		destFile2.setSize(Constants.TOMATO_SIZE);

//		sourceFile1.setSize(destFile2.getPos());
//		destFile2.setSize(destFile1.getPos());
    }

    @Test
    void testInputStreamRead() throws IOException{
        InputStream sourceContent = new FileInputStream(Constants.SOURCE_FILE_ROOT + File.separator
        		+Constants.XMLFRAGMENT.getValue() + ""/""+Constants.A.getValue()
        		+ File.separator
        		+  Constants.FILEID.getValue());
     	InputStream destContent = new FileInputStream(Constants.TARGET_FILE_ROOT + File.separator
     			+Constants.XMLFRAGMENT.getValue() + ""/""+Constants.A.getValue()
     			+ File.separator
     			+  Constants.FILEID.getValue());
     	int returnValue = fileCopy(sourceContent, destContent);
//    	destContent.close();
         assertEquals(""Successful copy of xml fragment file."", Constants.SOURCE_FILE_ROOT+Constants.XMLFRAGMENT.getValue()+""/"",Constants.TARGET_FILE.getValue());

     	XmlFunctions.XMLREADER(Constants.XMLFRAGMENT.getValue()
     			+ File.separator
     			+ Constants.FILE.getName())
        	.readUntilEnd();

//    	String lastElementContent = XmlFunctions.XMLREADER(Constants.XMLFRAGMENT.getValue
//        		+ File.separator
//        		+ Constants.FILE.getName())
//            	.getContent();

    }
}
   "
1cf3e26e-6db3-4bb0-8345-66bbb00352ef,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientPlayer.java,62.413926124572754,stop,"// ClientPlayer.java
package client;

import java.awt.Point;
import org.apache.log4j.Logger;
import sound.SoundPlayer;
import common.Actor;
import common.Constants;
import common.Player;

/**
 * The client specific implemetation of a Player. This implementation will
 * notify any number of registered observers about changes to their state.
 *
 * @author Andi, Bj�rn
 */
public class ClientPlayer extends Player {

    /**
     * Returns weather the player can bowl bombs
     *
     * @return boolean can bowl bombs
     */
    public boolean canBowlBombs();
}
","// ClientPlayerTest.java
package client;

import java.awt.Point;
import org.apache.log4j.Logger;
import sound.SoundPlayer;
import common.Actor;
import common.Constants;
import common.Player;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientPlayer}.
* It contains one unit test case for the {@link ClientPlayer#canBowlBombs()} method.
*/
class ClientPlayerTest {","// ClientPlayerTest.java
package client;

import java.awt.Point;
import org.apache.log4j.Logger;
import sound.SoundPlayer;
import common.Actor;
import common.Constants;
import common.Player;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientPlayer}.
* It contains one unit test case for the {@link ClientPlayer#canBowlBombs()} method.
*/
class ClientPlayerTest {

    private static final Logger LOG = Logger.getLogger(ClientPlayerTest.class);
    
    /**
     * Test method for {@link ClientPlayer#canBowlBombs()}.
     * Checks if {@link ClientPlayer} can bowl bombs for the expected amount.
     */
    @Test
    public void testCanBowlBombs() {
        ClientPlayer player = getInstance(Constants.CLIENT_PLAYER);
        
		boolean bowlBombs = player.canBowlBombs();
		assertTrue(bowlBombs);
    }
		
    /**
     * Test method for {@link ClientPlayer#getOpponent()}.
     * Checks a player who doesn't have a opponent has the player opped on his state.
     */
    @Test
    public void testGetOpponent() {
        ClientPlayer player = new ClientPlayer();
        ClientPlayer opp = player.getOpponent();
        assertNull(opp);
    }

	/**
	 * Returns number of battles the player has.
	 *
	 * @return number battles
	 */
    @Test
    public void testNumberOfBattles() {
        ClientPlayer player = new ClientPlayer();
        int battleCount = player.numberOfBattles().intValue();
        assertEquals(""Wrong battle count"", 10, battleCount);
    }
}
// End ClientPlayerTest.java
"
a150013f-a573-429a-b72d-6e25fcd76e37,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientGameRound.java,51.372297286987305,length,"// ClientGameRound.java
package client;

import java.awt.Point;
import java.util.HashMap;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import org.apache.log4j.Logger;
import client.controller.LocalControl;
import client.gui.StartFrame;
import client.network.ForwardingObserver;
import client.view.BombView;
import client.view.GameCanvas;
import client.view.GameView;
import client.view.GfxFactory;
import client.view.OffGamePainter;
import client.view.PlayerView;
import client.view.PowerUpView;
import client.view.StatusView;
import client.view.TileView;
import common.Bomb;
import common.Constants;
import common.GameModel;
import common.GameObject;
import common.GameRound;
import common.Map;
import common.Player;
import common.PowerUp;
import common.Tile;

/**
 * Represents a game on the client side. This class serves as a connection
 * between the model, view and game loop.
 *
 * @author Andi, Bj�rn
 */
public class ClientGameRound extends GameRound implements Observer {

    /**
     * Searches and returns a GameObject by its id.
     *
     * @param id The id of the GameObject that should be returned.
     * @return The matching GameObject or null if the id is unknown.
     */
    public GameObject getGameObjectById(int id);
}
","// ClientGameRoundTest.java
package client;

import java.awt.Point;
import java.util.HashMap;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import org.apache.log4j.Logger;
import client.controller.LocalControl;
import client.gui.StartFrame;
import client.network.ForwardingObserver;
import client.view.BombView;
import client.view.GameCanvas;
import client.view.GameView;
import client.view.GfxFactory;
import client.view.OffGamePainter;
import client.view.PlayerView;
import client.view.PowerUpView;
import client.view.StatusView;
import client.view.TileView;
import common.Bomb;
import common.Constants;
import common.GameModel;
import common.GameObject;
import common.GameRound;
import common.Map;
import common.Player;
import common.PowerUp;
import common.Tile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientGameRound}.
* It contains one unit test case for the {@link ClientGameRound#getGameObjectById(int)} method.
*/
class ClientGameRoundTest {","// ClientGameRoundTest.java
package client;

import java.awt.Point;
import java.util.HashMap;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import org.apache.log4j.Logger;
import client.controller.LocalControl;
import client.gui.StartFrame;
import client.network.ForwardingObserver;
import client.view.BombView;
import client.view.GameCanvas;
import client.view.GameView;
import client.view.GfxFactory;
import client.view.OffGamePainter;
import client.view.PlayerView;
import client.view.PowerUpView;
import client.view.StatusView;
import client.view.TileView;
import common.Bomb;
import common.Constants;
import common.GameModel;
import common.GameObject;
import common.GameRound;
import common.Map;
import common.Player;
import common.PowerUp;
import common.Tile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientGameRound}.
* It contains one unit test case for the {@link ClientGameRound#getGameObjectById(int)} method.
*/
class ClientGameRoundTest {
private static final Logger log = Logger.getLogger(ClientGameRoundTest.class.getName());
	
	//TODO: Implement these two variables.
    
    // GameObject of the game
    private GameObject m_GameObject;
    
    // Canvas of the game
    private GameCanvas m_Canvas;
    
    // Canvas of the game with OffGamePainter
    private GameCanvas m_OffGameCanvas;
    
    // Player of the game
    private Player m_Player;
    
  // Canvas of the game with PlayerView and PowerUpView
   private GameCanvas m_MainCanvas;
   private PowerUpView m_PowerUpView;
   
    // Turn number (0 = North)
    private int m_TurnNumber;
    
    // GameObject for the bomb
    private Bomb m_Bomb;
    
    // Canvas (the main view) of the game
    private GameCanvas m_mainCanvas;
    
    // Canvas (Offgame view) for the game
    private GameCanvas m_offCanvas;
    
    // List of Map and GameObjects 
    private Vector<Map> m_MapList;
    
    // Map and GameObjects
    private HashMap<String, GameObject> m_GameObjectList;
    
    // Player of the game
    private Player m_Player;
    
  /**
   * This constructor is just a place holder for the {@link ClientGameRoundTest#testGetGameObjectById()} method. 
   * It is intended for future use.
   */
    public ClientGameRoundTest(){}
  
    /**
     * This constructor creates and initializes a new client game frame.
     *
     * @param player The current player.
     * @param turnNumber The current turn number.
     * @param gfxFactory The gfx factory.
     * @param playerList The player list.
     */
    public ClientGameRoundTest(int player, int turnNumber, GfxFactory gfxFactory,Vector<Player> playerList, Vector<Map> mapList) {
        m_TurnNumber = turnNumber;
        m_GameObject = gfxFactory.createGameObject(player);
        m_GameObject.setTick(Constants.START_TICK);
        m_MapList = mapList;
        m_GameObjectList = gfxFactory.createGameObjectList(player);
        m_OffGameCanvas = new GameView(player);
        m_mainCanvas = new GameView(player);
        
        PlayerView mainPlayerView = new PlayerView();
        PlayerView offGamePlayerView = new PlayerView();
        OffGamePainter offGamePainter = new OffGamePainter();
        
        log.debug(""new create"");
        if(player == 1){
            m_OffGameCanvas = new StatusView();
            m_mainCanvas = new PowerUpView();
            m_mainCanvas.setPlayerObject(player);
            
            MainFrame frame = new StartFrame();
            frame.addView(m_OffGameCanvas);
            frame.addView(m_mainCanvas);
            frame.addView(offGamePlayerView);
            frame.addView(mainPlayerView);
            frame.addFrameListener(player);
            frame.launchFrame();
        }else if(player == 2){
            m_OffGameCanvas = new StatusView();
            m_mainCanvas = new PowerUpView();
            m_mainCanvas.setPlayerObject(player);
            
            OffGamePainter offFrame = new OffGamePainter();
            m_OffGameCanvas.addView(offFrame);
            m_OffGameCanvas.addView(m_mainCanvas);
            m_mainCanvas.addFrameListener(player);
            m_offGameView = new PowerUpView();
            m_offGamePainter = new OffGamePainter();
            m_offGameView.setPlayerObject(player);
            
            offFrame.addView(m_offGameCanvas);
            offFrame.addView(m_offGamePainter);
            offFrame.addView(m_mainCanvas);
            offFrame.addFrameListener(player);
            offFrame.launchFrame();
        }
        log.debug(""creating list and map of gfx"");
        for (Map map : mapList)
            gfxFactory.createGameObjectList(map);
        
        
        // Create Map views
        m_mainCanvas = new GameView(1);
        m_offCanvas  = new GameView(2);
	
        TileView mainTileView = new TileView();
        TileView offTileView = new TileView();
        m_offCanvas.addView(offTileView);
        m_offCanvas.addView(mainTileView);

        TileView mainTilesView = new TileView();
        TileView mainTileWithPowerUp = new TileView();
        
        for (Map map: mapList)
        {
            Tile mainTile = gfxFactory.createTile(map.getId());
            Tile offTile = gfxFactory.createTile(Constants.OFFGAME_TILE);

            TileView tileView = new TileView(map.getId());
            addTileIntoListView(mainTileView, mainTile);
            tileView.addTileIntoView(m_offTileView);

            addTileIntoListView(offTileView, offTile);

            m_mainCanvas.addTileIntoView(tileView);
                
            TileView tileViewWithPowerUp = new TileView(map.getId());
            addTileIntoListView(m_mainTilesView, mainTileWithPowerUp);
            "
396c7d63-8b72-4de2-8f7c-0181385d27f9,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/BomberClient_0Test.java,56.78601121902466,stop,"// BomberClient.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;

/**
 * This is central client class. It is responsible for globally scoped messages
 * and the creation of sessions.
 *
 * @author andi
 */
public class BomberClient extends Observable {

    /**
     * Returns the singleton.
     *
     * @return The only BomberClient instance.
     */
    public static BomberClient getInstance();
}
","// BomberClient_0Test.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberClient}.
* It contains one unit test case for the {@link BomberClient#getInstance()} method.
*/
class BomberClient_0Test {","// BomberClient_0Test.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberClient}.
* It contains one unit test case for the {@link BomberClient#getInstance()} method.
*/
class BomberClient_0Test {

    /**
     * This represents the class itself.
     *
     * @param arguments
     */
    BomberClient_0Test(String[] arguments){
        
    }
    
    /**
     * Runs the testing with the specified parameters to create a client frame to play
     * with.
     * The connection is automatically closed after a successful communication via a
     * given socket (sock) and the expected type of the incoming messages.
     *
     * @param arguments
     */
    public static void main(String[] arguments) {
        BomberClient b = new BomberClient_0Test(arguments);
    }
    /**
     * Tests if an instance of {@link BomberClient} correctly was created.
     */
    @Test
    public void testProperties(){
        assertTrue(b == getInstance());
    }
    
	@Test
	public void getInstance_test(){
        String[] b_getInstance = new String[] { ""BomberClient"" };
        BomberClient b = this.getInstance();
    }
	@Test
	public void setUp() throws IOException, InterruptedException {
        startSwing();
    }
	@Test
	public void receive_test() {
		String msg = null, msg1_1, msg1_2, msg2_1, msg2_2;
		try {
			// send message
	
		}
		catch (Exception e) {
		    msg = e.getMessage();
        }
		// check expected message
		assertNotNull(""null returned"", msg);
		boolean equal = msg.equals(""Dummy message (1));"");
		assertTrue(""message does not have the same type (1)"", equal);
		// check response message with info request
		msg1_1 = ""InfoRequestMsg+2"";
		msg1_2 = ""/myInfo.xml"";
		try {
			assertFalse(""check info request msg with wrong type"", msg1_1.equals(""InfoRequestMsg+2""));  
			assertTrue(""msg has wrong type"",  msg1_2.equals(""InfoRequestMsg+2""));
		}
		catch (ClassCastException cast_exception) {
        }
		// create a client and wait until the connection with connection
	  	// will be established
		Socket sock = new Socket(getInfo(msg1_1), Server.PORT);
         new Server();
         
		
		List<ClientMsgSender> clientMsgSender = new ArrayList<ClientMsgSender>();
	    
		// send msg2
		ClientMsgSender clientMsgSender1 = new ClientMsgSender();
		clientMsgSender.add(clientMsgSender1);
	    
		new SessionDetailsMsg(2);
	    
	}
}

class ClientMsgSender extends ClientMsgReceiver {
	    Vector<ClientMsgSender> clients = new Vector<ClientMsgSender>();
	    List<Message> messageVector = new ArrayList<Message>();
	    
	    @Override
	    public void receiveMESSAGE(Socket clientSocket, String message) {
	      messageVector.add(new ServerMessage(new Message(message)));
	    }
	
	    synchronized void add(Object message) {
			messageVector.add((Message)message);
		}
	}

class ServerMessage {
	final Message m;
	
	public ServerMessage(Message msg) {
		m = msg;
	}
	
	@Override
    public String toString() {
		return ""{ message: ""+ m.getMessage()+"" }"";
	}
}

"
f387e572-6281-4842-b5ef-e389b05de4fb,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/BomberClient_1Test.java,55.623085260391235,stop,"// BomberClient.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;

/**
 * This is central client class. It is responsible for globally scoped messages
 * and the creation of sessions.
 *
 * @author andi
 */
public class BomberClient extends Observable {

    /**
     * Tries to connect to the server.
     *
     * @throws RuntimeException Thrown when the connection attempt was not successful.
     */
    public boolean connectToSrv();
}
","// BomberClient_1Test.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberClient}.
* It contains one unit test case for the {@link BomberClient#connectToSrv()} method.
*/
class BomberClient_1Test {","// BomberClient_1Test.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberClient}.
* It contains one unit test case for the {@link BomberClient#connectToSrv()} method.
*/
class BomberClient_1Test {
/**
		 * Default constructor.
		*/
    public BomberClient_1Test() {
        super();
        log(""Starting test"");
    }
    
	/**
	 * Starts a connection test using the client.
	*
	* @throws IOException Thrown when the connection attempt was not successful.
	*/
	@Test
    public void testConnectSrv() throws IOException {
        new BomberClient().connectToSrv();
    }
	
	
	/**
	 * Checks that a server could connect.
	*/
	@Test
    public void testCanConnectSrv() {
        assertFalse(new BomberClient().connectToSrv());
    }

	
	/**
	 * Checks that a server could send a message to us.
	*/
	@Test
    public void testCanSendMsgToSrv() {
        new BomberClient().connectToSrv();

        // Connect the client.
        boolean result;
        result = new BomberClient().connectToSrv();
        assertTrue(result);

		// Send a message.
		Message msg = new ClientMsgSender().
				buildMessage(""Message from client."").
				addParameter(""Message from server."").
				build();

		// SEND a message over the connection.
		msg.addParameter(""This was sent"");
        Result msgResult = new ClientMsgSender().
                buildMessage(""Message reply"").
                build();
        
        assertTrue(new ClientMsgSender().sendMessage(msg)).
                isSucceeded().andThen(msgResult.getSuccessKeyword());
    }

	/**
	 * Checks that a client could send map information.
	*/
	@Test
    public void testCanSendMaps_1() {
        new BomberClient().connectToSrv();

        // Connect the client.
        boolean result;
        result = new BomberClient().connectToSrv();
        assertTrue(result);

		// Send an message.
        MapInfo map = new MapInfo();
        result = new ClientMsgSender().
				buildMessage(""Message from client."").
				addParameter(""Message from server."").
				build();
        
        assertTrue(new ClientMsgSender().sendMessage(map)).
                isSucceeded().andThen(result);
    }

	/**
	* Checks that the client receive a map information sent to the server.
	*/
	@Test
    public void testCanRecieveMaps_1() {
        new BomberClient().connectToSrv();

        // Connect the client.
        boolean result;
        result = new BomberClient().connectToSrv();
        assertTrue(result);

        // Send an message.
        result = new ClientMsgReceiver().
                buildMessage(""Message from server."").
                addParameter(""Message from client."").
                build();
        
        assertTrue(new ClientMsgReceiver().recieveMessage().isSucceeded());
    }
    
    private static class Result {
        private boolean succeed;
        private final String succeedKeyword;


        private Result(String succeedKeyword) {
            this.succeedKeyword = succeedKeyword;
        }

        private Result(boolean succeed, String succeedKeyword) {
            this.succeedKeyword = succeedKeyword;
            this.succeed = succeed;
        }

        /**
         * Gets the set of successful keywors if a succeed.
         */
        public boolean isSuccess() {
            return succeed;
        }

        /**
         * Sets the complete message to be sent.
         */
        public void setSucceeded(boolean succeed) {
            this.succeed = succeed;
        }

        /**
         * Sets the complete message response as the keyword to be sent.
         */
        public void setSucceededKeyword(String succeedKeyword) {
            this.succeedKeyword = succeedKeyword;
        }
    }
    
    /**
     * Sends one message to the server.
     */
    private void assertTrue(boolean condition) {
        getAndAdvance(condition).checkedAndUnchecked();
    }

    private Observable<Boolean> getAndAdvance(boolean condition) {
        return System.err.getObservable(""Succeeded"")
               .filter(condition)
               .map(Boolean.class::cast);
    }

    /**
     * Sends an array of ClientMessage to the server.
     */
    private void assertNotNull(Object o) {
        assertNotNull(""Message from client."",o);
    }
    
}"
e4bb98a9-d7fb-4250-bd55-e2868745f080,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/view/GfxFactory.java,61.625330209732056,stop,"// GfxFactory.java
package client.view;

import java.awt.Image;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import javax.imageio.ImageIO;
import org.apache.log4j.Logger;
import common.ResourceService;

/**
 * @author Andreas Glauner
 * @autor Adam Kozielski
 */
public class GfxFactory {

    /**
     * Power up image loading
     *
     * @param type A String value describing the type of powerUp
     *  *
     */
    public Image getPowerUpImage(String type);
}
","// GfxFactoryTest.java
package client.view;

import java.awt.Image;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import javax.imageio.ImageIO;
import org.apache.log4j.Logger;
import common.ResourceService;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GfxFactory}.
* It contains one unit test case for the {@link GfxFactory#getPowerUpImage(String)} method.
*/
class GfxFactoryTest {","// GfxFactoryTest.java
package client.view;

import java.awt.Image;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import javax.imageio.ImageIO;
import org.apache.log4j.Logger;
import common.ResourceService;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GfxFactory}.
* It contains one unit test case for the {@link GfxFactory#getPowerUpImage(String)} method.
*/
class GfxFactoryTest {
// Logger.
		private final Logger LOG = Logger
				.getLogger(GfxFactoryTest.class);

		// Test cases.
		// private static final String TEST_JPG_NAME = ""Power-2.jpg"";
		// private static final String TEST_TGA_NAME = ""Power-2.ppm"";
		private HashMap<File, Image> data = null;
		/**
		* Creates a test class of {@link GfxFactory}.
		*/
		public GfxFactoryTest() {
			// data = new HashMap<File, Image>();
		}

		/**
		* Test method for
		* {@link GfxFactory#getPowerUpImage(String)}.
		*/
		@Test
		public void testPowerUpImage() throws IOException,
				NullPointerException {
			final Logger logger = Logger.getLogger(GfxFactoryTest.class);
			final File powerUpFile = new File(
					ResourceService.JIGAPREFILTION.substring(
							"""".substring(0,1), 0)
							+ GfxFactoryTest.class.getName()
							+ "".jpg"");
			PowerUpImage p = new PowerUpImage(powerUpFile);
			assertNotNull(p);
			assertFalse(p.isNotLoaded());
			powerUpImage(p);
			boolean saved = powerUpFile.delete();
			logger.debug(""Test Power Up Image Saved: ""
					+ saved);
			imageFile(powerUpFile);
			// powerUpImage(p);
			powerUpFile.delete();
			data.put(
					powerUpFile,
					ImageIO.read(GfxFactoryTest.class
							.getResource(""PowerUpImage.png"")));
		}

		private void powerUpImage(final PowerUpImage p) {
			assertTrue(data.containsKey(p.getFile()));
			assertTrue(data.get(p.getFile()).getSampleModel()
					instanceof GifImage.GifImageSampleModel);
			final Image src = data.get(p.getFile());
			assertEquals(""Image size should be equal to source size"",
					src.getWidth(null), p.getSize().width);
			assertEquals(""Image size should be equal to source size"",
					src.getHeight(null), p.getSize().height);
			assertEquals(""Image color should be equal to source color"",
					src.getRGB(null), p.getColor().getRGB());
			assertEquals(""Image is loaded"", GfxFactory.LOAD_SUCCESS,
					GfxFactory.isLoaded(p.getFile()));
			data.remove(p.getFile());
		}

		private void imageFile(final File file) throws IOException {
			final Image load = ImageIO
					.read(file);
			assertNotNull(load);
			assertTrue(load.getSampleModel()
					instanceof GifImage.GifImageSampleModel);
			assertTrue(load.getWidth(null) > 0
					&& load.getHeight(null) > 0);
			assertEquals(""image size should be equal to file size"",
					file.length(), load.getWidth(null));
			assertEquals(""image size should be equal to file size"",
					file.length(), load.getHeight(null));
			assertEquals(""image color should be equal to file color"",
					load.getRGB(null), colorToRGBA(load.getRGB(null)));
			assertTrue(load.getWidth(null) == 0
					&& load.getHeight(null) == 0);
		}

		private Integer colorToRGBA(final byte[] rgba) {
			final Integer value = new Integer(rgba[2]);

			return value;
		}

		private void assertTrue(final boolean result) {
			if (!result) {
				assertFalse(""unrecognized result:"" + result,
						result);
				LOG.error(""unrecognized result:"" + result);
				LOG.debug(""GfxFactory Test passed: ""
						+ result);
			} else {
				throw new RuntimeException(""expected not to be reached"");//$NON-NLS-1$
			}

		}

		/**
		 * Test class of {@link GfxFactory#load(java.io.File,
		 * resource.impl.Data)}.
		 */
		public static final class PowerUpImage {

			public PowerUpImage(final File file) {
				this.file = file;
			}

			public final File file;

			public final int width;

			public final int height;

			public PowerUpImage(final File file, final int width,
					final int height) {
				super();
				this.file = file;
				this.width = width;
				this.height = height;
			}

			public PowerUpImage(
					final File file, final int width, final int height,
					final ImageSource imageSource) {
				super();
				this.file = file;
				this.width = width;
				this.height = height;
			}

			public final int width;

			public final int height;

			public void setImage(final Image image) {
				this.image = image;
			}

			public Image getImage() {
				return image;
			}

			public final Image image;

			public final byte[] getRGBA() {
				final byte[] data = new byte[file.length()];
				ImageIO.write(image, ""png"", new File(file));
				return data;
			}

		}
	}

"
