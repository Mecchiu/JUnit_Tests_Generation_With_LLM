ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
c54629c2-d0a8-4331-a2e7-abda2d4cd7c3,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_0Test.java,63.91181039810181,stop,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    /**
     * Convenience methods since velocity does not understand the conditional
     * ""== null"". Returns true if this class implements an interface.
     *
     * @return true if this class implements an interface else false.
     */
    public boolean hasInterface() {
        return (this.getInterface() != null);
    }
}
","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {
// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    /**
     * Convenience methods since velocity does not understand the conditional
     * ""== null"". Returns true if this class implements an interface.
     *
     * @return true if this class implements an interface else false.
     */
    public boolean hasInterface() {
        return (this.getInterface()!= null);
    }
}

// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {
		
	/**
	 * Tests an attribute of an entity that is supposed to be a JavaFile interface.
	 * Returns false if the attribute is not a JavaSourceFile.
	 */
    public boolean hasInterface() {
        return java.util.List.class.isAssignableFrom(getObjectInterface());
    }

    /**
	 * Tests the content of a JavaSource object with the specified list.
	 * Returns an empty <code>java.util.List</code>.
	 */
    public java.util.List<JavaSource> getObject() {
    	java.util.List objectList = new ArrayList<JavaSource>();

        // Construct empty JavaSource.
    	List<JavaSource> javaSourceList = new ArrayList<JavaSource>();
    	Iterator<JavaSource> jusIterator = null;
    	if (hasInterface()) {
    		jusIterator = javaSourceList.listIterator();
    	} else {
    		jusIterator = getObjectInterface().listIterator();
    	}
        while (jusIterator.hasNext()) {
			// Test element.
			// Construct empty JavaSource.
			Object object = jusIterator.next();
			if (JSUtils.isString(object)) {
				// Test the type.
				if (java.util.List.class.isAssignableFrom(getObjectInterface())) {
					if (hasInterface()) {
						javaSourceList = getObjectInterface().list(jusIterator);
					} else {
						javaSourceList = new ArrayList<JavaSource>(getObjectInterface().size());
						javaSourceList.addAll((List)jusIterator);
					}

				// Test the content.
				} else {
					if (! hasInterface()) {
						if (object instanceof String
							|| object instanceof Boolean) {
							Object object = createJavaSource(object);
							if (object!= null) {
								javaSourceList.add((JavaSource) object);
							}
						}
						if (jusIterator.hasNext()) {
							if (! hasInterface()) {
								objectList = new ArrayList<JavaSource>(javaSourceList);
							} else if (hasInterface()) {
								objectList = getNewJavaSource(javaSourceList);
							} else {
								objectList = new ArrayList<JavaSource>(getNewJavaSource(javaSourceList));
							}
							javaSourceList = new ArrayList<JavaSource>();
								}
						}
					}
				}
			}
		}
		if (hasInterface()) {
			if (javaSourceList.size() > 0) {
				objectList = new ArrayList<JavaSource>(javaSourceList);
			}
		}
		return objectList;
    }
	
    /**
     * Tests the return type of an object. The test merely verifies the return type's
     * type name.
     */
    public JavaSource getObjectInterface() {
        return new JavaSource(getClass().getSuperclass(), getClass().getInterfaces(), false);
    }

    /**
     * Tests the content of a JavaFile object with the String contents.
     * The test does not modify the list.
     * The test does not verify that the list has no null elements.
     */
    public java.util.List<JavaSource> createJavaSource(java.util.List<JavaSource> javaSourceList) {
    	return null;
    }

    /**
     * Tests the content of a new JavaSource object with the String contents.
     */
    public java.util.List<JavaSource> getNewJavaSource(java.util.List<JavaSource> javaSourceList) {
    	javaSourceList.add(new JavaSource(""MyClass""));
    	return javaSourceList;
    }

}
"
35f82bd1-c5c7-469a-8cf6-40e01a3a2b85,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_1Test.java,61.684855461120605,stop,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    /**
     * Convenience method since velocity does not understand the conditional
     * ""== null"". Returns true if this class inherits from a superclass.
     *
     * @return true if this class has a superclass, else false.
     */
    public boolean hasSuperClass() {
        return (this.getSuperClass() != null);
    }
}
","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {
// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    /**
     * Convenience method since velocity does not understand the conditional
     * ""== null"". Returns true if this class inherits from a superclass.
     *
     * @return true if this class has a superclass, else false.
     */
    public boolean hasSuperClass() {
        return (this.getSuperClass()!= null);
    }
}

// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {
		
    /**
     * This test case contains one unit test case for the {@link JavaSource#getSuperClass()}
     * method.
     */
    @Test
    public void testGetSuperClass() {
        //TODO add unit test
        List list = null;
    }

}"
49646de6-8ede-4ae8-b69f-a34651e232cc,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDecoder.java,34.79826378822327,length,"// IFXDecoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;

/**
 * Decodes an IFX XML String to its equivalent Framework bean.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXDecoder {

    /**
     * Decodes the element into its equivalent IFX XML representation.
     *
     * @param element the Element to decode.
     * @return an IFXObject.
     * @exception IFXException wrapper for underlying exception.
     */
    public IFXObject decode(Element element) throws IFXException {
        try {
            String id = element.getAttributeValue(""Id"");
            String beanClassName = getBeanClassName(element);
            IFXObject obj = (IFXObject) Class.forName(beanClassName).newInstance();
            List children = element.getChildren();
            if (children.size() == 0) {
                String text = element.getText();
                if (text != null && text.trim().length() > 0) {
                    if (!(obj instanceof IBaseType)) {
                        throw new IFXException(""Leaf node not an instance of IBaseType: "" + obj.getClass().getName());
                    } else {
                        ((IBaseType) obj).setString(text);
                        return obj;
                    }
                } else {
                    // return the empty object
                    return obj;
                }
            } else {
                Iterator childIter = children.iterator();
                while (childIter.hasNext()) {
                    Element childElement = (Element) childIter.next();
                    IFXObject childObj = decode(childElement);
                    // run corresponding accessor method to see if the
                    // result is an array
                    Method accessorMethod = getAccessor(obj, childElement);
                    Object retValObj = accessorMethod.invoke(obj, null);
                    boolean isArray = accessorMethod.getReturnType().isArray();
                    // then get the mutator method and invoke it
                    Method mutatorMethod = getMutator(obj, childElement);
                    if (isArray) {
                        // if result is an array, build a new array with
                        // size = returned array size + 1, and stuff this
                        // object at the end of the array
                        IFXObject[] childObjs = null;
                        if (retValObj != null) {
                            int oldLen = Array.getLength(retValObj);
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { oldLen + 1 });
                            IFXObject[] retValObjs = (IFXObject[]) retValObj;
                            System.arraycopy(retValObj, 0, childObjs, 0, oldLen);
                            childObjs[oldLen] = childObj;
                        } else {
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { 1 });
                            childObjs[0] = childObj;
                        }
                        mutatorMethod.invoke(obj, new Object[] { childObjs });
                    } else {
                        mutatorMethod.invoke(obj, new Object[] { childObj });
                    }
                }
                // if Id attribute is specified, populate it
                if (id != null) {
                    Method mutatorMethod = getMutator(obj, ""Id"");
                    IFXString idObj = new IFXString();
                    idObj.setString(id);
                    mutatorMethod.invoke(obj, new Object[] { idObj });
                }
                return obj;
            }
        } catch (Exception e) {
            throw new IFXException(""Error decoding "" + element.getName(), e);
        }
    }
}
","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {
// IFXDecoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;

/**
 * Decodes an IFX XML String to its equivalent Framework bean.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXDecoder {

    /**
     * Decodes the element into its equivalent IFX XML representation.
     *
     * @param element the Element to decode.
     * @return an IFXObject.
     * @exception IFXException wrapper for underlying exception.
     */
    public IFXObject decode(Element element) throws IFXException {
        try {
            String id = element.getAttributeValue(""Id"");
            String beanClassName = getBeanClassName(element);
            IFXObject obj = (IFXObject) Class.forName(beanClassName).newInstance();
            List children = element.getChildren();
            if (children.size() == 0) {
                String text = element.getText();
                if (text!= null && text.trim().length() > 0) {
                    if (!(obj instanceof IBaseType)) {
                        throw new IFXException(""Leaf node not an instance of IBaseType: "" + obj.getClass().getName());
                    } else {
                        ((IBaseType) obj).setString(text);
                        return obj;
                    }
                } else {
                    // return the empty object
                    return obj;
                }
            } else {
                Iterator childIter = children.iterator();
                while (childIter.hasNext()) {
                    Element childElement = (Element) childIter.next();
                    IFXObject childObj = decode(childElement);
                    // run corresponding accessor method to see if the
                    // result is an array
                    Method accessorMethod = getAccessor(obj, childElement);
                    Object retValObj = accessorMethod.invoke(obj, null);
                    boolean isArray = accessorMethod.getReturnType().isArray();
                    // then get the mutator method and invoke it
                    Method mutatorMethod = getMutator(obj, childElement);
                    if (isArray) {
                        // if result is an array, build a new array with
                        // size = returned array size + 1, and stuff this
                        // object at the end of the array
                        IFXObject[] childObjs = null;
                        if (retValObj!= null) {
                            int oldLen = Array.getLength(retValObj);
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { oldLen + 1 });
                            IFXObject[] retValObjs = (IFXObject[]) retValObj;
                            System.arraycopy(retValObj, 0, childObjs, 0, oldLen);
                            childObjs[oldLen] = childObj;
                        } else {
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { 1 });
                            childObjs[0] = childObj;
                        }
                        mutatorMethod.invoke(obj, new Object[] { childObjs });
                    } else {
                        mutatorMethod.invoke(obj, new Object[] { childObj });
                    }
                }
                // if Id attribute is specified, populate it
                if (id!= null) {
                    Method mutatorMethod = getMutator(obj, ""Id"");
                    IFXString idObj = new IFXString();
                    idObj.setString(id);
                    mutatorMethod.invoke(obj, new Object[] { idObj });
                }
                return obj;
            }
        } catch (Exception e) {
            throw new IFXException(""Error decoding "" + element.getName(), e);
        }
    }
}

// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {
		/*
   * The number of objects in this test.
   */
    static final int NUMBER_OF_OBJECTS = 9;

		/*
    * The number of arrays in this test.
    */
	static final int NUMBER_OF_ARRAY_ELEMENTS = 4;

		/*
  * The number of class types in this test.
  */
	static final int NUMBER_OF_BEAN_CLASSES = 7;

  static final IFXClassType[] classTypes = new IFXClassType[NUMBER_OF_BEAN_CLASSES];
  static {
    // Initialize all class types
    int i = 0;
    for (i = IFXClassType.classTypeID;
			i < classTypes.length;
			i++) {
			if (!classTypes[i].isClass()) {
				System.out.println(""IFXClassType: ""+classTypes[i].getClass().getName()+"" not an IFXClass"");
				System.exit(255);
			} else {
				classTypes[i] = ClassTypeFactory.create(classTypes[i]);
			}
    }
  }

	/**
	 * Run the unit test case for {@link IFXDecoder#decode(Element)} method.
	*/
	@Test public void testCasesDecoding() {

          IFXObject[][] objects = new IFXObject[NUMBER_OF_OBJECTS] ;
	List classAndArrayTypes = ClassTypeFactory.getAllClassTypes();
	for (int i = 0; i < classAndArrayTypes.size(); i++) {
		objects[i] = new IFXObject[NUMBER_OF_ARRAY_ELEMENTS];
	}
	IFXDecoder decoder = new IFXDecoder();
	boolean done = false;
	try {
		for (int i = 0; i < NUMBER_OF_OBJECTS; i++) {
			IFXClassType classType = (IFXClassType)classAndArrayTypes.get(i);
			String id = classType.getName() + ""_"" + classType.getClass().getSimpleName() + ""_"" + classType.getExtends();
			IFXObject obj = decoder.decode(""ID="" + id);
			objects[i] = new IFXObject[NUMBER_OF_ARRAY_ELEMENTS];
            System.out.print(""Testing class "" + i);
            System.out.println("": "");

            System.out.print(""Testing object "" + obj.getName());
            System.out.println("": "");

			System.out.print(obj.getClass().getName());
            System.out.println("": "");

			int position = 0;
			Object arrayObj = Array.newInstance(obj.getClass().getName(), NUMBER_OF_ARRAY_ELEMENTS);
			for (int j = NUMBER_OF_ARRAY_ELEMENTS; j > 0; j--) {
				System.out.print(j + "": "");
				Method getMethod = classType.getMethod(""get""+j);
				if (getMethod!= null) {
					Object retValueObj = getMethod.invoke(obj);
					for (int n = 0; n < j; n++) {
						Object tmpObj = Array.get(retValueObj, position);
						Class type = tmpObj.getClass();
						if (tmpObj instanceof IFXObject)"
d77891d5-e10a-45d0-a871-c66127387681,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXEncoder.java,37.878833055496216,length,"// IFXEncoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;

/**
 * Encodes an IFXObject to its equivalent IFX XML Element.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXEncoder {

    /**
     * Builds a JDOM Element for the IFXObject supplied. No validation is
     * performed, regardless of the setting. To validate, use the encode()
     * methods instead.
     *
     * @param obj an IFXObject.
     * @return a JDOM Element.
     * @exception IFXException if an exception was encountered in encoding.
     */
    public Element encode(IFXObject obj) throws IFXException {
        try {
            Element element = new Element(getElementName(obj), namespace);
            List accessorList = getAccessors(obj);
            Iterator accessorIter = accessorList.iterator();
            while (accessorIter.hasNext()) {
                Method accessorMethod = (Method) accessorIter.next();
                if (accessorMethod.getName().equals(""getClass"")) {
                    continue;
                }
                Object retValObj = accessorMethod.invoke(obj, null);
                if (retValObj == null) {
                    continue;
                }
                IFXObject[] retVals = new IFXObject[1];
                if (retValObj.getClass().isArray()) {
                    retVals = (IFXObject[]) retValObj;
                } else {
                    retVals[0] = (IFXObject) retValObj;
                }
                for (int i = 0; i < retVals.length; i++) {
                    IFXObject retVal = retVals[i];
                    if (retVal instanceof IBaseType) {
                        String value = ((IBaseType) retVal).getString();
                        if (accessorMethod.getName().equals(""getId"")) {
                            element.setAttribute(""Id"", value);
                        } else {
                            Element baseElement = new Element(getElementName(retVal), namespace);
                            baseElement.setText(value);
                            element.addContent(baseElement);
                        }
                    } else {
                        element.addContent(encode(retVal));
                    }
                }
            }
            return element;
        } catch (Exception e) {
            throw new IFXException(""Error encoding "" + obj.getClass().getName(), e);
        }
    }
}
","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains one unit test case for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains one unit test case for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {

    /**
     * Test static methods of {@link IFXEncoder}.
     */
    @Test
    public void oneInstance() {
        assertTrue(new IFXEncoder().getAccessors().size() == 1);
        assertTrue(new IFXEncoder().getElement().getLocalName() == ""Element"");
    }

    /**
     * Test to write out to a string.
     */
    @Test
    public void writeString()  {
        IFXEncoder instance = new IFXEncoder();
        Element element = instance.encode(new IFXObject()).getRootElement();
        StringWriter sw = new StringWriter();
        instance.encode(new IFXObject(), sw).getRootElement().write(new OutputStreamWriter(sw));
        Element output = new Element(""IFXWriterTest"", namespace);
        output.addContent(element);
        System.out.println(output.toString());
        assertFalse(sw.toString().equals(""""));
    }

    @Test
    public void testWithResourceBundle() {
    		ResourceBundle rbn = ResourceBundle.getBundle( ""IFXEncodingResources"");
    		Element element = new Element(getElementName(), Namespace.getNamespace(""IFX"", ""IFX""));
    		OutputStream output = null;
    		try {
    			output = new ByteArrayOutputStream();
    			XMLOutputter.outputProperty(output, Namespace.getNamespace(""IFX"", ""IFX""));
    			XMLOutputter output2 = new XMLOutputter(output);
    			output2.write(element, null, true);
    		} catch (Exception e) {
    			e.printStackTrace();
    		}
    		assertTrue(rbn.getString(getElementName() + "".error.type"") == null);
    		assertFalse(rbn.getString(getElementName() + "".error.type"") == null);
    		assertFalse(rbn.getString(getElementName() + "".error.type"").equals(null));
    		assertFalse(rbn.getString(getElementName() + "".error.type"").equals(""""));
    		// Check the output stream is a byte array!
    		byte[] baOutput = output.toByteArray();
    		assertTrue(""output is not a byte array!"", baOutput.length > 0);
    		assertTrue(""output length is not 2"", baOutput.length == 2);
    }
}

class IFXEncodingResources {
    public String getElementName() {
        return ""IFXEncodingResources"";
    }
}

/**
 * Test harness for IFXEncoder.
 * It tests the {@link IFXEncoder#getElementList()} method - checks that list element is returned.
 *
 * @author Sujit Pal
 */
public class IFXEncoderHarness extends IFXEncoderTest {

    @Override
    protected ResourceBundle getResourceBundle() {
        return ResourceBundle.getBundle(""IFXEncodingResourcesBundle"");
    }

    private void assertEquals(List output, List expected) {
        List actual = new ArrayList();
        Iterator it = output.iterator();
        while (it.hasNext()) {
            Object obj = it.next();
            actual.add(String.valueOf(obj));
        }
        assertEquals(actual, expected);
    }

    private Namespace getElementNamespace() {
    	try {
	        return Namespace.getNamespace(""IFX"", ""IFX"");
    	} catch (MissingResourceException e) {
    		fail(""Element namespace not defined"");
    	} catch (IOException e) {
    		fail(e);
    	}
    	return null;
    }

    @Override
    protected Element getElement(Element current) {
    	try {
	        "
ca72c9d8-df18-469a-ad8b-30b7e40b7279,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_0Test.java,51.46530222892761,length,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * Builds a JDOM Document object from an IFXObject.
     *
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException {
        IFXEncoder encoder = null;
        if (namespaceURI != null) {
            encoder = new IFXEncoder(namespacePrefix, namespaceURI);
        } else {
            encoder = new IFXEncoder();
        }
        Element element = encoder.encode(obj);
        Document doc = new Document(element);
        return doc;
    }
}
","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {
// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * Builds a JDOM Document object from an IFXObject.
     *
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException {
        IFXEncoder encoder = null;
        if (namespaceURI!= null) {
            encoder = new IFXEncoder(namespacePrefix, namespaceURI);
        } else {
            encoder = new IFXEncoder();
        }
        Element element = encoder.encode(obj);
        Document doc = new Document(element);
        return doc;
    }
}

// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {
		
    /** The test case for build (should throw an IFXException for illegal arguments).*/
    @Test
    void testBuild_IllegalArgumentException() {
        try {
            build( null, null, null );
        }
        catch ( java.lang.Throwable ex ) 
		{
            fail( ""Should have thrown an IllegalArgumentException."" );
			assertThrownBy( ex, IllegalArgumentException.class, ""null inputStream"" );
		}
        
        //test illegal document name
   	try {
        	build( ""<myDoc1/>"" ); // illegal document name in input.
		}
        catch ( java.lang.Throwable ex )
		{
			assertThrownBy( ex, IllegalArgumentException.class, ""document name \""<myDoc1\"" is not legal"" );
		}
        
        //test forbidden namespace declaration
        try {
			build( ""<myDoc xmlns=\""myNS\""><foo/>""; // illegal document name in input.
			}
        catch ( java.lang.Throwable ex )
		{
			assertThrownBy( ex, IllegalArgumentException.class, ""illegal legal namespace prefix (\""myNS\"")"" );
		}
        
        //test forbidden namespace prefix
        try {
			build( ""<myDoc xmlns:foo=\""myNS\"">"" // illegal document name in input.
			        + ""<foo xmlns=\""myNS2\""/>""            // legal prefix for namespace decl in input.
			        + ""<foo>""; // illegal document name in input.
			    }
        catch ( java.lang.Throwable ex )
		{
			assertThrownBy( ex, IllegalArgumentException.class, ""illegal legal namespace prefix"" );
		}

        //test illegal namespace decl in the body
        try {
		    build( ""<bar>My object</bar>"" ); // illegal document name in body
            }
        catch ( java.lang.Throwable ex )
		{
            assertThrownBy( ex, IllegalArgumentException.class, ""illegal legal namespace declaration"" );
		}
        
        //test illegal namespace in the body
    	try {
        	build( ""<bar xmlns=\""my NS\""><myNS2/></bar>"" ); // illegal namespace declaration.
	        	
	        fail( ""Should throw an IllegalArgumentException"" );
			
        }
        catch ( java.lang.Throwable ex )
        {
            if ( ex.getMessage().toLowerCase().equals( ""illegal namespace declaration"" ) )
			{
				System.out.println( ""Expected exception."" );
				System.out.println( ex.getMessage() );
				return;
			}
			assertTrue( ""Expected exception message not found."", ex.getMessage()!= null &&!ex.getMessage().contains( ""prefix"" ));
			
            assertThrownBy( ex, IllegalArgumentException.class, ""illegal legal namespace declaration"" );
        }
        
        //test legal content encoding and encoding
        try {
	        build( ""<myDoc xmlns=\""myNS\""><text/plain/sx\""><sx/><x/>t</sx/></myDoc>"" );
        }
        catch ( java.lang.Throwable ex )
		{
            assertThrownBy( ex, IllegalArgumentException.class, ""illegal legal content encoding"" );
        }
    }
    
    /** Test object for {@link Document#getRootElement()}. */
    private static class Document_getRootElement_0Test extends IFXResource
    {
        /** Constructor. */
        public Document_getRootElement_0Test(IFXDocumentHandler handler)
        {
            super(handler);
        }
        
		/** Tests if the root element is <myDoc1/>. */
    	public void test() throws IOException
		{
    		doc = null;
    		try {
    			doc = build(""<myDoc xmlns=\""myNS\"">"" + 
    	    			""<foo/></myDoc>"", null, null);
    		} finally {
    			doc.getRootElement().clear();
    		}
			assertEquals( doc.getRootElement().getName(), ""doc"" );
		}
    }
    
    /** Test object for {@link Document#getRootElement()}. */
    private static class Document_getRootElement_1Test extends IFXResource
    {
        /** Constructor. */
        public Document_getRootElement_1Test(IFXDocumentHandler handler)
		{
            super(handler);
        }
        
		/** Tests if the root element is <myDoc1>.*/
    	protected void assertRootElement(IFXDocumentHandler handler, Element expectedRootElement) throws IOException
    	{
    		XMLOutputter out = new XMLOutputter();
    		OutputStream outPut = null;
    		InputStream input;
    		try {
    			input = getIFXDocument().getInputStream();
    			outPut = getOutputStream();
    			outPut.write(input, 0, input.available());
    			handler.beginDocument();
	        	XMLOutputter.getOutputter(Constants.ENCODING).indent(0).encodeAll(new Document(createRootDocument()), outPut, false).flush();
    		} finally {
    			if (outPut!=null) {
            	    outPut.close();
            	} 
    		}
    		assertRootElement(expectedRootElement);
    	}
    	
    	/** {@inheritDoc} */
        protected Document createRootDocument() throws IOException {
            Element document = new Element(""doc"", Namespace.getNamespace(Constants.ROOT));
            return document;
        }
"
6c8e793a-e8a2-4ceb-b1c6-fa6346abb073,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_1Test.java,55.45129036903381,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     *
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException {
        Element element = doc.getRootElement();
        IFXDecoder decoder = new IFXDecoder();
        return decoder.decode(element);
    }
}
","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {
/**
		 * Test the <code>parse()</code> method.
		 *
		 * @throws IOException if I/O error occurred.
		 */
	@Test
    public void test1Parse() throws IOException {
        XMLOutputter out = new XMLOutputter();
        OutputStream outStream = null;
        try {
            out.setProperty(""jdom.topLevelTag"", ""doc"");
            SAXBuilder builder = new SAXBuilder();
            Document document = new Document(builder.build(new InputStreamReader(IFXDocumentHandler.class.getResourceAsStream(""IFXDocumentHandler_1.xml""), ""UTF-8"")));
            outStream = document.getRootElement().newOutputStream();
            new XMLOutputter().output(document, out);
            Document actualDocument = XMLOutputter.createDocument();
            try {
                XMLOutputter.output(actualDocument, outStream);
            } finally {
                outStream.close();
            }
            assertTrue(""IFXDocumentHandlers don't always return valid XML"", actualDocument.getRootElement().isValid());
        } finally {
            outStream.close();
        }
    }
}

// IFXDocumentHandlerTest.java
"
49562fdc-990a-4fa9-aef2-b4362a78099a,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_2Test.java,45.58482217788696,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     *
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException {
        SAXBuilder builder = null;
        if (validate) {
            builder = new SAXBuilder(""org.apache.xerces.parsers.SAXParser"", true);
            builder.setFeature(""http://apache.org/xml/features/validation/schema"", true);
            if (validationProperties != null) {
                Iterator propIter = validationProperties.keySet().iterator();
                StringBuffer buf = new StringBuffer();
                int i = 0;
                while (propIter.hasNext()) {
                    String key = (String) propIter.next();
                    String value = (String) validationProperties.get(key);
                    if (i > 0) {
                        buf.append("" "");
                    }
                    buf.append(key).append("" "").append(value);
                    i++;
                }
                builder.setProperty(""http://apache.org/xml/properties/schema/external-schemaLocation"", buf.toString());
            }
        } else {
            builder = new SAXBuilder();
        }
        Document doc = null;
        try {
            doc = builder.build(istream);
        } catch (Exception e) {
            throw new IFXException(""Error reading Document"", e);
        }
        return doc;
    }
}
","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {
// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     *
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException {
        SAXBuilder builder = null;
        if (validate) {
            builder = new SAXBuilder(""org.apache.xerces.parsers.SAXParser"", true);
            builder.setFeature(""http://apache.org/xml/features/validation/schema"", true);
            if (validationProperties!= null) {
                Iterator propIter = validationProperties.keySet().iterator();
                StringBuffer buf = new StringBuffer();
                int i = 0;
                while (propIter.hasNext()) {
                    String key = (String) propIter.next();
                    String value = (String) validationProperties.get(key);
                    if (i > 0) {
                        buf.append("" "");
                    }
                    buf.append(key).append("" "").append(value);
                    i++;
                }
                builder.setProperty(""http://apache.org/xml/properties/schema/external-schemaLocation"", buf.toString());
            }
        } else {
            builder = new SAXBuilder();
        }
        Document doc = null;
        try {
            doc = builder.build(istream);
        } catch (Exception e) {
            throw new IFXException(""Error reading Document"", e);
        }
        return doc;
    }
}

// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {
		
    /**
     * Test method for {@link IFXDocumentHandler#read(InputStream, boolean, Map)}.
     * @throws MalformedInputException throws if the XML is invalid.
     */
    @Test
    public void testRead_2() throws MalformedInputException {

        // Create a new document builder
        final Document doc = new Document();
        try {
            // Create an XMLStreamReader using a Reader
            final InputStream istream = new InputStream() {

                public int read() throws IOException {
                    return -1;
                }
                public int read(byte[] b, int offset, int len) throws IOException {
                    return -1;
                }
                public void close() throws IOException {
                    
                }
            };

                SAXBuilder builder = null;
                if ( istream instanceof SAXBuilder ) {
                    try {
                        builder = (SAXBuilder) istream;
                    } catch (Exception ex) {
                        throw new RuntimeException(""Cannot create the document using input stream"", ex);
                    }

                } else if ( istream instanceof InputStream ) {
                    try {
                        builder = new SAXBuilder();
                    } catch (RuntimeException ex) {
                        throw ex;
                    }
                }
                
                final Document doc = builder.build(new InputStreamReader(istream));
            }
            
            // Save the document
            final OutputStream ostream = new OutputStream() {

                public void write(byte[] b, int off, int len) throws IOException {
                    
                }
                public void write(int b) throws IOException {
                    
                }
                            
            };
            XMLOutputter outputter = new XMLOutputter(true);
            doc.setRootElement( new Element(""root""));

            // Create a document in which the Document is the root element
            Document doc1 = doc;

            // Create a Element
            Element el = new Element(""p"");
            el.setAttribute(""foobar"", ""fooValue"");
            el.setAttribute(""nfoobar"", ""foobarValue"");
            el.setAttribute(""bazd"", ""bazValue"");
            el.setAttribute(""name"", ""foobar2"");

            // Save the document
            ostream.write(doc.getAsString().getBytes(""UTF-8""));
            // Verify the serialized Document against the original document
            outputter.output(doc1);
            Document doc2 = (Document) outputter.output();
            checkSerializedAttributes(doc);

            // Create a Document
            Document doc3 = null;
            try {
                // Create a Document without root element
                doc3 = new Document();

            } catch(Exception ex2) {
                throw new RuntimeException(ex2);
            }

            // Create the Element in the Document after serialization of the Document without root element
            el = doc.getRootElement().addElement(""par"");

            // Save the Document
            ostream.write(doc3.asXML().getBytes(""UTF-8""));

            // Verify the serialized Document against the original document
            outputter.output(doc3);

            // Verify the serialized Document against the original document
            try {
                Document doc4 = (Document) outputter.output();
                assertTrue(true);
            } catch(Exception ex4) {
                ex4.printStackTrace();
                assertFalse(true);
            }

        } catch(Exception e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

    /**
     * Verify that serialized attributes are in alphabetical order.
     */
    @Test
    public void checkSerializedAttributes( Document document ) {
        Iterator it1 = document.getRootElement().getChildren().iterator();
        while ( it1.hasNext() ) {
            Element el = (Element) it1.next();
            Iterator it2 = el.getChildren().iterator();
            while ( it2.hasNext() ) {
                Element e = (Element) it2.next();
                String name = e.getName();
                String value = e.getBaseVal();
                String n = e.getNamespaceURI();
                assertTrue(""Name not in alphabetical order"", name.compareTo(n) < 0);
                assertTrue(""Value wrong"", value.compareTo(n) < 0);
            }
        }
    }
}
"
