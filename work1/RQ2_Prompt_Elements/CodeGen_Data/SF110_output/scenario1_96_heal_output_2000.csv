ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
f44f347d-d0f4-4ff6-9464-09020a3aa1a9,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/approver/ModifyApprovalQueueEntryAction.java,59.32352042198181,stop,"// ModifyApprovalQueueEntryAction.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Modifies an approval queue entry.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
public class ModifyApprovalQueueEntryAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// ModifyApprovalQueueEntryActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyApprovalQueueEntryAction}.
* It contains one unit test case for the {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyApprovalQueueEntryActionTest {","// ModifyApprovalQueueEntryActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyApprovalQueueEntryAction}.
* It contains one unit test case for the {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyApprovalQueueEntryActionTest {
private final static QueuedRecordBean currentRecord = new QueuedRecordBean();
	/** private constructor */
	private ModifyApprovalQueueEntryActionTest() { }

	/**
	* Tests {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
	*/
	@Test
	public void testMustLogin() {
		// arrange
		final QueuedRecordBean savedRecord = new QueuedRecordBean();
		currentRecord.setApprovalRecordId(savedRecord.getApprovalRecordId());
		currentRecord.setApplication(""java"");
	
	// act
	boolean requireLoginResult = true;
	
	// assert
	assertTrue(""Must require login in addOrUpdateApprovalQueueEntry"", requireLoginResult);
	}

	/**
	* Tests adding an updated record.
	* It also tests {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
	*/
	@Test
	public void testUpdateRecord() {
	// arrange
		final QuequeuedRecordBean newRecord = new QuequeuedRecordBean();
	currentRecord.setApprovalRecordId(newRecord.getApprovalRecordId());
	newRecord.setApplication(""java"");
	newRecord.setDescription(""Java Server for java"");
	newRecord.setName(""New Software"");
	newRecord.setQueueId(""myQueueId"");
	currentRecord.setCurrentVersion(""currentVersion"");
	currentRecord.setUpdatedAt(System.currentTimeMillis());
					
	// act
	boolean requireLoginResult = true;
	boolean updatedResult = true;
	
	// assert
	assertTrue(""Must require login in updateRecord"", requireLoginResult);
	assertTrue(""Must update the record with an updated object"",updatedResult);
	assertEquals(""Error message was not found"", ""Name is required"", newRecord.getErrorMessage());
	
	}
	
	/**
	* Tests a valid update.
	* It also tests {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
	*/
	@Test
	public void testUpdate() {
	// arrange
		final QuequeuedRecordBean newRecord = new QuequeuedRecordBean();
	currentRecord.setApprovalRecordId(newRecord.getApprovalRecordId());
	newRecord.setApplication(""java"");
	newRecord.setDescription(""Java Server for java"");
	newRecord.setName(""New Software"");
	newRecord.setQueueId(""myQueueId"");
	currentRecord.setCurrentVersion(""currentVersion"");
					
	// act
	boolean requireLoginResult = true;
	boolean updatedResult = true;
	
	// assert
	assertTrue(""Must require login in updateRecord"", requireLoginResult);
	assertTrue(""Must update the record with an updated object"",updatedResult);
	assertEquals(""Error message was not found"", ""Name is required"", newRecord.getErrorMessage());
	
	}

					
	
	
	/**
	* Tests deleting an updated record.
	* It also tests {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
	*/
	@Test
	public void testDelete() {
	// arrange
		final QuequeuedRecordBean deletedRecord = new QuequeuedRecordBean();
	currentRecord.setApprovalRecordId(deletedRecord.getApprovalRecordId());
	currentRecord.setApplication(""java"");
	currentRecord.setDescription(""Java Server for java"");
	currentRecord.setName(""New Software"");
	currentRecord.setQueueId(""myQueueId"");
	currentRecord.setCurrentVersion(""currentVersion"");
					
	// act
	boolean requireLoginResult = true;
	boolean updatedResult = true;
	
	// assert
	assertTrue(""Must require login in deleteRecord"", requireLoginResult);
	assertTrue(""Must update the record with an updated object"",updatedResult);
	assertEquals(""Error message was not found"", ""A record cannot be deleted when it was created with a queue"", deletedRecord.getDescription());
	assertEquals(""Error message was not found"", ""A record cannot be deleted when it was created with a queue"",deletedRecord.getName());
	assertEquals(""Error message was not found"", ""The name of the record"",deletedRecord.getName());
	assertEquals(""Error message was not found"", ""The queueId"",deletedRecord.getQueueId());
	
	}
					
					
					}





}
"
4dfd35b5-6839-4862-a327-aefb042d0914,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/approver/ShowApprovalQueueAction.java,57.277045011520386,length,"// ShowApprovalQueueAction.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * An {@link org.heal.servlet.Action} which fetches the information needed to
 * display the approval queue.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
public class ShowApprovalQueueAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// ShowApprovalQueueActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowApprovalQueueAction}.
* It contains one unit test case for the {@link ShowApprovalQueueAction#actionRequiresLogin()} method.
*/
class ShowApprovalQueueActionTest {","// ShowApprovalQueueActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowApprovalQueueAction}.
* It contains one unit test case for the {@link ShowApprovalQueueAction#actionRequiresLogin()} method.
*/
class ShowApprovalQueueActionTest {
private final static String REQUEST_URI =
			""/org/heal/servlet/actions/ShowApprovalQueueActionTest/ShowApprovalQueueAction"";

	private final static String INVOKE_USER_ID_PARAM = ""InvokeUserId"";

	private final static String INVOKE_USER_ID_PARAM_2 = ""InjectUserId"";

	private final static String INVOKE_USER_ID = ""user_id"";

	private final static String INVOKE_PASSWORD_PARAM = ""InjectPassword"";

	private final static String INVOKE_PASSWORD = ""password"";

	private final static String PASSPHRASE_PARAM = ""passphrase"";

	private final static String PASSPHRASE = ""passphrase_for_this_test"";

	private final static String PASSPHRASE_2 = ""password_for_this_test"";

	private final static String ACTION_NAME = ""ShowApprovalQueueAction"";

	// Test the action's implementation

			private void testAction(AuthenticationTools authent) throws Exception {
				RequestDispatcher rd =
					// create a TestActionDispatcher
					ActionUtilsTest.createRequestDispatcher(REQUEST_URI, TestActionDispatcher.class,
															  ActionUtilsTest.PAGE_PATH_PARAM, TestActionDispatcher.PAGE_DISPATCHER_MAPPING_REQUIRED_PARAM, authent);

				TestActionDispatcher dispatcher = (TestActionDispatcher)rd;

				List<Object> params = this.getParams();
				assertEquals(params == null? 0 : params.size(), 1);

				assertEquals(params.get(0), InjectUserIdParam);
				assertEquals(params.get(1), InvokeUserIdParam);
				assertEquals(params.get(2), InvokePasswordParam);
				assertEquals(params.get(3), PASSPHRASE_PARAM);
				assertEquals(params.get(4), PASSPHRASE_2);
				assertEquals(params.get(5), ACTION_NAME);
				assertEquals(params.get(6), INVOKE_USER_ID);

                                assertNotNull(dispatcher.getCalledUser());
                                assertEquals(1, dispatcher.receivedUser());

				this.verify(dispatcher);
			}

			private void verifyParam(int pos, Object val) {
				assertEquals(
						params.get(pos).toString(),
						String.valueOf(val));
			}

			private void verifyParam(int pos, SecurityTools.Params params) {
				assertEquals(
						params.get(pos).toString(),
						params.getValue(0).toString());
			}

			private void verifyParam(int i, HttpServletRequest req) throws ServletException,
													   IOException {
				verifyParam(i,
					req.getParameter(AuthenticationTools.PARAM_INVOKE_USER_ID,
										null));
			}

/*
					private List<Object> getParams() throws ServletException,
															  IOException {
						List<Object> params = new LinkedList<>();

						verifyParam(0, params);

						return params;
					}
*/

				private String getParam(int n) throws IOException {
					return (String)params.get(n);
				}

				private int getParam(int i) throws IOException, ServletException {
					return Integer.parseInt(getParam(i));
				}

				private void assertEquals(String expectedValue, String actualValue) {
					assertEquals(expectedValue, actualValue);
				}
	}

	/**
	 * Create a {@link ShowApprovalQueueAction} from the given {@link HttpServletRequest}.
	 *
	 * @param req The servlet request to get the parameters from.
     * @return The resulting {@link ShowApprovalQueueAction} instance.
	 * @throws ServletException If the parameters couldn't be read.
	 * @throws IOException If a problem occurred.
	 */
	private ShowApprovalQueueAction createAction(HttpServletRequest req) throws ServletException, IOException,
			Exception, InterruptedException {
		final QueueDAO queueDao = QueueDAO.getInstance();

			return (ShowApprovalQueueAction)queueDao.getAction(queueDao.getQueueActionName(req.getParameter(ACTION_NAME)));
	}

	// Test the {@link ShowApprovalQueue action}

	@Test
	public void testRequiresLogin() throws ServletException, IOException {
		this.testAction(AuthenticationTools.createEmptyAuthentication());
	}

	@Test
	public void testActionSuccessfulInvoke() throws ServletException, IOException {
		final QueueDAO queueDao = QueueDAO.getInstance();

			final ShowApprovalQueueAction action = this.createAction(new HttpServletRequest() {
				@Override
				public String getMethod() {
					return ""GET"";
				}
				@Override
				public String getActionName() {
					return ""ShowApprovalQueueAction"";
				}
				@Override
				public String getPathInfo() {
					return """";
				}
				@Override
				public String getRequestURI() {
					return REQUEST_URI;
				}
				@Override
				public String getQueryString() {
					return """";
				}
				@Override
				public String getParameter(String name) {
					return getURIParameter(""org.heal.servlet.actions"", name, false);
				}
				@Override
				public String getURIParameters() {
					return """";
				}
				@Override
				public String getEncodedURL() {
					return """";
				}
				@Override
				public String getRemoteUser() {
					return null;
				}
				@Override
				public String getUserInfo() {
					return null;
				}
				@Override
				public int getUserId() throws ServletException, IOException {
					throw new ServletException(""UNAVAILABLE USER!!!"");
				}
				@Override
				public Object getSessionAttribute(String name) {
					throw new ServletException(""UNAVAILABLE USER!!!"");
				}
				private String getURIParameter(String name, String defaultValue) {
					return getQuery"
69c71e77-5ab9-4304-82da-1bcd072097d4,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditContextURLAction.java,57.387590646743774,stop,"// EditContextURLAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Context URL.  If
 * there isn't an existing Context URL which can be found to edit,
 * we assume that a new Context URL should be edited.
 */
public class EditContextURLAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// EditContextURLActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContextURLAction}.
* It contains one unit test case for the {@link EditContextURLAction#actionRequiresLogin()} method.
*/
class EditContextURLActionTest {","// EditContextURLActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContextURLAction}.
* It contains one unit test case for the {@link EditContextURLAction#actionRequiresLogin()} method.
*/
class EditContextURLActionTest {
private EditContextURLAction action;
		private HttpServletRequest request;
		private HttpServletResponse response;
		private RequestDispatcher requestDispatcher;

		/**
	 * Constructor.
	*/
		private EditContextURLActionTest() {
			super();
			request = new MockHttpServletRequest();
			response = new MockHttpServletResponse();
			requestDispatcher = new MockRequestDispatcher();
		}

		/**
		 * Constructor.
		 * @param aRequest Servlet request.
		 * @param aResponse Servlet response.
		 * @param aUrlname Servlet name to use, or <code>.edit</code> if none exists.
		 */
		public EditContextURLActionTest(HttpServletRequest aRequest, HttpServletResponse aResponse, String aUrlname) {
			request = aRequest;
			response = aResponse;
			requestDispatcher = getRequestDispatcher(aUrlname);
		}
		
        /**
	 * Test {@link EditContextURLAction#actionRequiresLogin()}.
	 * 
	 * <p>The test is designed to verify that when the URL is edited
	 * the user is logged in and that the Context URL is correctly
	 * looked up.
	 * 
	 * <p>The problem is that we have no way to pass in a different user
	 * session information.  So the user ID is needed to find out the URL.
	 * 
	 * @throws IOException
	 * @throws ServletException
	 */
	@Test
	public void testEditWithDifferentSessionId() throws ServletException, IOException
	{
		// setup
		final CompleteMetadataBean metadata = new CompleteMetadataBean();
		metadata.setContextURL("""");
		final ContextURLBean newValue = new ContextURLBean("""", """", """", metadata);
		newValue.setSessionId(""differentSessionId1"");
		newValue.setVersion(""1.0"");
		action = new EditContextURLAction();
		action.setMetadata(metadata);

		// test
		assertTrue(""Wrong result from call to {@link EditContextURLAction#actionRequiresLogin()}\n""
		""The call to EditContextURLAction should return false"",
				action.actionRequiresLogin());

		// check that the correct request comes through from {@link #requestDispatcher}
		for (int i=0; i<10; i++) {
			assertNotNull(""Missing request before testing"", request);
			assertTrue(""Unexpected request"", action.getRequestURI().endsWith(String.valueOf(i)));
			assertNotNull(""Missing RequestDispatcher"", requestDispatcher);
			request = requestDispatcher.getRequest();
			// assert that the right URL is in the query string
			// this means that the proper parameter was added
			assertTrue(""query parameters are not added"", 
					request.getQueryString().contains(""foo="" + String.valueOf(i)));
			// assert that the right URL is in the header
			// this means that the proper parameter was added
			assertEquals(""Header value should be correct"", ""sessionId=differentSessionId1"", 
					request.getHeader(""Context-Session-Id""));
			// assert that the right URL is in the header
			// this means that the proper parameter was added
			assertEquals(""Header value should be correct"", ""version=1.0"", 
					request.getHeader(""Custom-HttpVersion""));
			
			// assert that the correct user's session info is returned
			assertEquals(""Session Info: wrong user session is returned"", 
					(new ValueObjectImpl(""differentSessionId1"")).getValue(), request.getSession().getId());
		}
	}
	
	private void assertRequestBodyExists(HttpServletRequest theRequest, String expectedBody) throws IOException
	{
		final Iterator<String> theRequestBodyIt = theRequest.getHeaderNames();
		while (theRequestBodyIt.hasNext()) {
			if (expectedBody.equals(theRequestBodyIt.next())) {
				assertTrue(""Request body does not match!"", theRequest.getContentType().equals(theRequestBodyIt.next()));
			}
		}
		assertTrue(""Unexpected request body"", theRequest.getContentLength() > 0);
	}
	
	private RequestDispatcher getRequestDispatcher(String urlname) {
		RequestDispatcher theRequestDispatcher = request.getRequestDispatcher(urlname);
		assertNotNull(""Can't get RequestDispatcher!"", theRequestDispatcher);
		return theRequestDispatcher;
	}

	private class MockRequestDispatcher implements RequestDispatcher {
		public void forward(String theUri, HttpServletRequest theRequest) throws IOException, ServletException {
			requestDispatcher.forward(theUri, theRequest);
		}
	}

}
"
c74bea09-a135-4b16-a576-773e16cb487d,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyMetadataAction.java,52.18833255767822,stop,"// ModifyMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>An {@link Action} that saves the metadata from a form into
 * the session's {@link CompleteMetadataBean} by mapping {@link MetadataModifier}s
 * to forms.  The {@link MetadataModifier} which matches the form determines
 * the next {@link Action} to execute.</p>
 *
 * <p>The mapping is currently defined as:</p>
 *
 * <ul><li>'metadata' : {@link MetadataRecordModifier}
 * <li>'contextURL' : {@link ContextURLRecordModifier}
 * <li>'contributor' : {@link ContributorRecordModifier}
 * <li>'copyrightHolder' : {@link CopyrightHolderRecordModifier}
 * <li>'controlledVocabulary' : {@link ControlledVocabularyRecordModifier}
 * <li>'requirement' : {@link RequirementRecordModifier}
 * </ul>
 */
public class ModifyMetadataAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// ModifyMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyMetadataAction}.
* It contains one unit test case for the {@link ModifyMetadataAction#actionRequiresLogin()} method.
*/
class ModifyMetadataActionTest {","// ModifyMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyMetadataAction}.
* It contains one unit test case for the {@link ModifyMetadataAction#actionRequiresLogin()} method.
*/
class ModifyMetadataActionTest {

  /**
 * Test method for {@link ModifyMetadataAction#actionRequiresLogin()}.
 * @throws Exception
*/
@Test
  public void testRequiresLogin() throws Exception {
    assertEquals(true, this.actionRequiresLogin());
  }
	
	/** Test {@link ModifyMetadataAction} to complete the Form, and the Map of metadata fields. */
	@Test
  public void completeSectionsAndFieldsTest() throws IOException {
		MetadataModifier m = new MetadataModifier();
		m.setFormName(""Form name"");
		m.setFormType(""Form type"");
		m.setContextURL(""ContextURL"");
		m.setCopyableVocabulary(""Copyable vocabulary"");
		m.setControlledVocabulary(3, true);
		m.setIncludeContributionVocabulary(true);
		Map  record = m.createMetadata();
		CompleteMetadataBean completeBean = (CompleteMetadataBean) record.get(""completeData"");
		assertEquals(""Form name"", completeBean.getFieldValue(""name""));
		assertEquals(""Form type"", completeBean.getFieldValue(""type""));
		
		//TODO: verify the Map
//		Map<String, Map<String, String>> fieldsMap = new HashMap<String, Map<String, String>>();
//		fieldsMap.put(""value1"", createMap(""v1"", ""value1"", ""v2""));
//		fieldsMap.put(""value2"", createMap(""v3"", ""value1"", ""v2""));
//		fieldsMap.put(""value3"", createMap(""v4"", ""value2"", ""v4""));
//		completeBean.setFieldsMap(fieldsMap);
	}
}
"
7b6dc915-339e-4e93-a7bf-729e3615b96c,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/SaveMetadataAction.java,47.55442404747009,stop,"// SaveMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Iterator;

/**
 * An {@link org.heal.servlet.Action Action} used to save metadata
 * records.
 */
public class SaveMetadataAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// SaveMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SaveMetadataAction}.
* It contains one unit test case for the {@link SaveMetadataAction#actionRequiresLogin()} method.
*/
class SaveMetadataActionTest {","// SaveMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SaveMetadataAction}.
* It contains one unit test case for the {@link SaveMetadataAction#actionRequiresLogin()} method.
*/
class SaveMetadataActionTest {

	/**
	 * Class constructor.
	 */
	public SaveMetadataActionTest() {
		
	}
	
	@Test
	public void actionTest() throws IOException, ServletException {
		
		String id = ""1"";
		SaveMetadataAction sa = new SaveMetadataAction();
		try {
			RequestDispatcher reqMain = this.getMainAction();
			reqMain.forward(this.getMainRequest(), this.getMainResponse());
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		
	}
	
	/**
	 * Main function.
	 */
	private RequestDispatcher getMainAction() throws ServletException {
		
		// Main content.
		StringBuffer sb = new StringBuffer(500);
		sb.append(actionHeader());
		sb.append(actionBody(id));
		
		// Return a main request.
		return this.getMainRequest();
	}
	
	/**
	 * Action header.
	 */
	private String actionHeader() {

        return ""Action <strong>SaveMetadataAction</strong>"";
	}
	
	/**
	 * Action body.
	 */
	private String actionBody(String id) {

        return ""<strong>Request ID: "" + id + ""</strong><hr>""
        	+ ""<br>Action: SaveMetadataAction"";
	}
	
    private RequestDispatcher getMainRequest() {

        // Initializer.
        ContextURLBean url = new ContextURLBean();
        url.setHref(""/app/catalog/metadata/metadata"");
        
        // Main content.
        StringBuffer sb = new StringBuffer(512);
        sb.append(actionHeader());
        sb.append(actionBody(""4""));
        sb.append(actionBody(id));
        sb.append(actionBody(id));

        return this.getServletContext().getRequestDispatcher(""/cataloging.jsp"").
    	getServletContext().getRequestDispatcher(""/application.jsp"").
    	getRequestDispatcher(""/catalog-view.jsp"").
    	getRequestDispatcher(""/catalog-metadata.jsp"").
    	getRequestDispatcher(""/catalog-metadata.jsp"").
    	getRequestDispatcher(""/catalog-metadata.jsp"").
    	getRequestDispatcher(""/catalog-summary.jsp"").
    	getRequestDispatcher(""/catalog-summary.jsp"").
    	getRequestDispatcher(""/catalog-status.jsp"").
    	getRequestDispatcher(""/catalog-detail-view.jsp"").
    	getRequestDispatcher(""/catalog-detail-view.jsp"").
    	getRequestDispatcher(""/catalog/metadata/metadata"").
    	getRequestDispatcher(""/catalog/metadata/metadata"").
    	getRequestDispatcher(""/catalog/metadata/metadata"").getRequestDispatcher(url.getHref()).
    	getRequestDispatcher(url.getHref()).getRequestDispatcher(url.getHref());
    	
	}
	
    private RequestDispatcher getServletContext() {
//		return new MainRequestDispatch()
    	return null;
	}

}
"
5b176748-99c3-49ae-bbbc-0c5c3b279e6e,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/CreateMetadataAction.java,51.15339636802673,length,"// CreateMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * An {@link Action} which creates a new metadata record to edit,
 * puts it into the session, and then directs the user to the editing
 * page.
 */
public class CreateMetadataAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// CreateMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CreateMetadataAction}.
* It contains one unit test case for the {@link CreateMetadataAction#actionRequiresLogin()} method.
*/
class CreateMetadataActionTest {","// CreateMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CreateMetadataAction}.
* It contains one unit test case for the {@link CreateMetadataAction#actionRequiresLogin()} method.
*/
class CreateMetadataActionTest {
private CreateMetadataAction action;
    	
		/** CreateMetadataActionTest.java
		 * Setup for the unit test.
		 */
    	@Before
		public void before(){
    		action = new CreateMetadataAction();
    		action.action = true;
    		action.init();
    	}

		/** Test the request is created and the action is called the first time.
		* The request should not be cached.
		*/
		@Test
	    public void testStarted() throws Exception {
	    	HttpServletRequest request = new MockHttpServletRequest();
	    	HttpServletResponse response = new MockHttpServletResponse();
	    	request.setParameter(""query"", ""{}"");
	    	RequestDispatcher dispatcher =
	    		getServletContext().getRequestDispatcher(""/cataloger/metadata"");
	    	action.init(request, response, true);
	    	assertEquals(""No catalog should be created in the response"", 0, response.getStatus());
	    	assertNull(""The catalog should not be created"", response.getAttribute(""catalog""));
	    	
	    	try{
	    		// Set the parameter
	    		request.setParameter(""query"", ""{<CATALOG_PATH/>}&<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>"");
	    	}catch(Exception e){
	    		fail(""Problem setting parameter 'query'."");
	    	}
	    	
	    	List<CompleteMetadataBean> catalog = action.createMetadata();
	    	Iterator<CompleteMetadataBean> catIter = catalog.iterator();
	    	CompleteMetadataBean catalogBean = (CompleteMetadataBean)catIter.next();
	    	assertEquals(""The catalog should be a set of instances"", 2, catalog.size());
	    	
	    	assertEquals(""The catalog should contain the correct number of taxonomy fields"", 4, catalogBean.getTaxonomy().size());
	    	assertEquals(""The catalog should contain the correct number of taxonomy taxonomies"", 1, catalogBean.getTaxonomies().size());
	    	assertEquals(""The catalog should contain the correct number of taxonomies taxonomies"", 1, catalogBean.getTaxonomies().iterator().next().getChildren().size());
	    	
	    	// Now check the parameters
	    	request.setParameter(""query"", ""{<CATALOG_PATH/>}&<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>"");
	    	catIter = catalog.iterator();
	    	catalogBean = (CompleteMetadataBean)catIter.next();
	    	
	    	assertEquals(""The catalog should contain the correct name"", ""CATOLOGY"", catalogBean.getName());
	    	assertEquals(""The catalog should contain the correct date"", new Date(), catalogBean.getCreated());
	    	assertEquals(""The catalog should contain the correct number of taxonomies"", 1, catalogBean.getTaxonomies().size());
	    	taxonomies = catalogBean.getTaxonomies().iterator();
	    	assertEquals(""The taxonomies should contain the correct name"", ""PROTEIN_NAMESPACE"", taxonomies.next());
	    	assertEquals(""The taxonomies should contain the correct number of taxonomies"", 1, taxonomies.next().getChildren().size());
	    	
	    	assertEquals(""The taxonomy should contain the correct name"", ""AUTH_TOKEN"", taxonomies.next().getChildren().get(0).getName());
	    	
	    	// And now check the category field
	    	request.setParameter(""query"", ""{<CATALOG_PATH/>}&<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>"");
	    	catIter = catalog.iterator();
	    	catalogBean = (CompleteMetadataBean)catIter.next();
	    	
	    	assertEquals(""The category should contain the correct name"", ""CATOLOGY"", catalogBean.getName());
	    	// Check the value
	    	assertEquals(""The category should contain the correct number of taxonomies"", 1, catalogBean.getTaxonomies().size());
	    	taxonomies = catalogBean.getTaxonomies().iterator();
	    	assertEquals(""The taxonomies should contain the correct name"", ""PROTEIN_NAMESPACE"", taxonomies.next().getName());
	    	
	    	
	    	// There should be two queries in the request
	    	assertEquals(""A typical use of a query is to set and select a catalog."", 3, request.getParameterValues(""query"").length);
	    	assertEquals(""The search for the path must match"", ""{<CATALOG_PATH/>}"", request.getParameter(""query""));
	    	assertEquals(""A typical use of a query is to set and select a taxonomy."", 1,
	    		    	request.getParameterValues(""query"").length);
	    	assertEquals(""The taxonomy must match."", ""{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>{<AUTH_TOKEN>>>>"",
	    				request.getParameter(""query""));
	    	
	    	
	    	// Check that the query is not"
cdd6cdf8-fc93-446f-bb60-5d166dd6a3a4,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyCatalogQueueEntryAction.java,50.6997709274292,length,"// ModifyCatalogQueueEntryAction.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.FileLocator;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.sql.SQLException;

/**
 * An {@link org.heal.servlet.Action Action} which is called in order to edit a metadata item which is in
 * the catalog queue.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @version 1.0
 */
public class ModifyCatalogQueueEntryAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// ModifyCatalogQueueEntryActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.FileLocator;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.sql.SQLException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyCatalogQueueEntryAction}.
* It contains one unit test case for the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyCatalogQueueEntryActionTest {","// ModifyCatalogQueueEntryActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.FileLocator;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.sql.SQLException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyCatalogQueueEntryAction}.
* It contains one unit test case for the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyCatalogQueueEntryActionTest {

    /**
    * Test the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.
    * It tests the return of whether or not an appropriate user is allowed to modify a metadata item which is in
    * the catalog queue.
    *
    * @throws ServletException an error occurred trying to create the test case environment.
    * @throws IOException an error occurred during the writing to the log file.
    */
    @Test
    public void testGetLoginRequired() throws ServletException, IOException {
        AuthenticationTools
               .testPermissions(""catalog queue"", new Object[]{""admin"", ""modify-metadata""});
    }
    /**
    * Tests to assert that the necessary parameters are passed to the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.
    * @throws ServletException an error occurred trying to create the test case environment.
    * @throws IOException an error occurred during the writing to the log file.
    */
    @Test
    public void testPassRequiredParameters() throws ServletException, IOException {
        QueueDAO
               .getInstance()
               .initDefaultCatalog()
               .setMaxMessagesToQueueAsInt(
                        new String[]{""5000"", ""5"",
                                 ""6"", ""7"",
                                 ""8"", ""9""
                        });
        QueueDAO.getInstance()
               .saveQueuedRecord(""MetadataItem"");
        QueueDAO.getInstance()
               .saveQueuedRecord(""MetadataItem"");
        QueueDAO.getInstance()
               .saveQueuedRecord(""MetadataItem"");

        AuthenticationTools.authenticate(""admin"",""admin"", null);
        QueuedRecordBean recordBean = QueuedRecordBean.createInstance();
		QueueDAO.getInstance().deleteQueuedRecord(recordBean);
        AuthenticationTools.authenticate(""admin"",""modify-metadata"",""modify-metadata"");
        
        QueueDAO.getInstance().deleteQueuedRecord(recordBean);
        
	FileOutputStream fos = new FileOutputStream(
			FileLocator.getTestDataDirectory() + File.separator
			+ ""files\tmetadata-file-1.log"");
        FileLocator.closeStdStreamsOpen(fos) ;
        fos.close();

        QueueDAO.getInstance()
               .getMaxMessagesFromQueueAsInt()
               .setMaxMessagesToQueueAsInt([
                        ""500"", ""501"", ""502"", ""503"",
                        ""505"", ""506"", ""507"", ""508"", ""509"", ""510""
                ]);
        QueueDAO.getInstance().getMaxMessagesFromQueueAsInt()
               .setMaxMessagesToQueueAsInt([
                        ""5000"", ""5"",
                        ""5"", ""6"",
                        ""5"", ""7"",
                        ""5"", ""8"",
                        ""5"", ""9""
                ]);
        QueueDAO.getInstance()
               .getMaxMessagesFromQueueAsInt()
               .setMaxMessagesToQueueAsInt([
                        ""5000"", ""5"",
                        ""5"", ""6"",
                        ""5"", ""7"",
                        ""5"", ""8"",
                        ""5"", ""9""
                ]);
        QueueDAO.getInstance()
               .getMaxMessagesFromQueueAsInt()
               .setMaxMessagesToQueueAsInt([
                        ""5000"", ""5"",
                        ""5"", ""6"",
                        ""5"", ""7"",
                        ""5"", ""8"",
                        ""5"", ""9""
                ]);
        QueuedRecordBean recordBean1 = QueuedRecordBean.createInstance();
        QueueDAO.getInstance().saveQueueEntry(recordBean1);
        Thread.sleep(5);
        QueueDAO.getInstance().saveQueueEntry(recordBean1);
        Thread.sleep(5);
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 5000));
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 501));
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 502));
        Thread.sleep(5);
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 502));
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 502));
        Thread.sleep(5);
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 502));
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 502));
        Thread.sleep(5);
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 502));
        Thread.sleep(5);
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 502));
        Thread.sleep(5);
        QueueDAO.getInstance()
           .getQueueEntries()
           .add(QueueEntry.createInstance(""MetadataItem"", 502));


        HttpServletRequest
               .getRequest()
               .getParameterMap()
               .values()
               .stream()
               .map(param -> ""{}"""
cbe30128-a6b2-4542-8235-bf861183f975,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/RelationRecordModifier.java,55.316969871520996,stop,"// RelationRecordModifier.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.CompleteMetadataBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;

/**
 * Saves changes to a {@link RelationBean} and acts as
 * an {@link Action} which is called to edit a Relation.  If
 * there isn't an existing Relation which can be found to edit,
 * we assume that a new Relation should be edited.
 */
public class RelationRecordModifier implements Action, MetadataModifier {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// RelationRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.CompleteMetadataBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RelationRecordModifier}.
* It contains one unit test case for the {@link RelationRecordModifier#actionRequiresLogin()} method.
*/
class RelationRecordModifierTest {","// RelationRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.CompleteMetadataBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RelationRecordModifier}.
* It contains one unit test case for the {@link RelationRecordModifier#actionRequiresLogin()} method.
*/
class RelationRecordModifierTest {
static class TestAction extends Action {
		    @Override
                    public void action(ServletRequest request, ServletResponse response) throws ServletException, IOException {
                        RelationBean relation = new RelationBean();
                        @SuppressWarnings(""unchecked"")
                        Iterator<String> i = request.getParameterNames();
                        String id = i.next();
                        relation.add(id, ""test"");
                        @SuppressWarnings(""unchecked"")
                        List<String> values = (List<String>) request.getParameterValues(id);
                        assertEquals(values.size(), 1);
                        String value = values.get(0);
						if (!(value+"""").equals(Id.toString(ids.length+1))) {
                            response.sendError(HttpServletResponse.SC_CONFLICT);
                        } else {
							response.getWriter().write(""true"");
                        }
                    }

		    }
		    
		}
		
		static void testAction(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			
			ServerBean.beacon().beacon(""test"", ""rel"");
			
			String id = request.getParameter(""id"");
			
			List list = (List) RequestDispatcher.
                                     getRequestDispatcher(null).includeRequest(request, response);
			
			Iterator<String> i = list.iterator();
			
			String s;
			
			if (!i.hasNext()) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND);
			} else {
				
				s = i.next();
				
				String value = s;
				
				while (i.hasNext()) {
					s = i.next();
					
					if (!(s + """").equals(value)) {
						TestAction testAction = new TestAction();
						testAction.setId(Id.toString(ids.length+1));
						testAction.setValue(value);
						
						List expected = new CompleteMetadataBean(""test"");
						testAction.action(request, response);
						
						CompleteMetadataBean c = new CompleteMetadataBean(""value"");
						List actual = c.getList();
						assertEquals(expected, actual.iterator());
						
						c.toString();
					}
				}
				
				request.getSession().setAttribute(""name"", s);
			}
		}
		
		static HttpServlet getServlet() {
			HttpServlet servlet = new HttpServlet() {
				@Override
                      public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                                         RelationRecordModifierTest.testAction(request, response);
                                }
                                
                 };
			return servlet;
		}
}"
be159d92-09ca-4e5f-ac95-e50f81cc9938,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/CancelEditMetadataAction.java,58.5606324672699,length,"// CancelEditMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;

/**
 * A simple {@link Action} which clears the session variable used
 * for editing metadata.
 */
public class CancelEditMetadataAction implements Action {

    public boolean actionRequiresLogin() {
        return false;
    }
}
","// CancelEditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CancelEditMetadataAction}.
* It contains one unit test case for the {@link CancelEditMetadataAction#actionRequiresLogin()} method.
*/
class CancelEditMetadataActionTest {","// CancelEditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CancelEditMetadataAction}.
* It contains one unit test case for the {@link CancelEditMetadataAction#actionRequiresLogin()} method.
*/
class CancelEditMetadataActionTest {

    /**
     * Test method of {@link CancelEditMetadataAction#actionRequiresLogin()}.
     */
    @Test
    public void testActionRequiresLogin() {
        final CancelEditMetadataAction action = new CancelEditMetadataAction();
        assertNotNull( action );
        assertTrue(! action.requiresLogin() );
    }
    
    /**
     * Test method of {@link CancelEditMetadataAction#actionRequiresLogin()}.
     */
    @Test
    public void testCancelAllMetadataAction() {
        final CancelEditMetadataAction action = CancelEditMetadataAction.actionCancelAllMetadata();
        assertSame( action, action );
    }    
    
    /**
     * Test method of {@link CancelEditMetadataAction#actionRequiresLogin()}.
     */
    @Test
    public void testRedirectToMetadataForLogin() {
        final CancelEditMetadataAction action = CancelEditMetadataAction.actionCancelAllMetadata();
        final RequestDispatcher d1 = RequestDispatcher.getInstance(""view"");
        d1.forward( null, new String[]{""test""} );
        final HttpServletRequest req = null;
        final HttpServletResponse res = null;
        assertEquals( ""test"", d1.getTheRequestURL(req, res).getParameter(""metadata""));
        
        assertSame( d1, d1.getParent() );
        
        assertEquals( HttpServletResponse.SC_MOVED_PERMANENTLY, res.getStatus());
        assertEquals(""redirected"", res.getHeader(""Location""));
    }
    
    /**
     * Test method of {@link CancelEditMetadataAction#actionRequiresLogin()}.
     */
    @Test
    public void actionCancelAllMetadata() {
        final CancelEditMetadataAction action = CancelEditMetadataActionTest.testActionCancelAllMetadata();
        final RequestDispatcher d1 = RequestDispatcher.getInstance(""view"");
        assertEquals(""view"", d1.getServletPath());
        assertEquals( ""/cataloger/editMetadata.jsp"", d1.getServletPath());
        assertEquals( (String)""/cataloger/editMetadata.jsp"", d1.getUrl());
        assertIsRedirected( action.getClass().getName(), ""/cataloger/editMetadata.jsp"" );
            
        assertSame( d1, d1.getParent() );
        
        assertFalse( d1.containsRequest( d1.getParent().getRequest() ) );
    }
    
    /**
     * Test method of {@link CancelEditMetadataAction#isSucceeded()}.
     */
    @Test
    public void testIsSucceeded() {
        final CancelEditMetadataAction action = CancelEditMetadataActionTest.testActionCancelAllMetadata();
        final RequestDispatcher d1 = RequestDispatcher.getInstance(""view"");
        assertTrue( d1.containsRequest( d1.getParent().getRequest() ) );
        assertTrue( action.isSucceeded() );
        
        final HttpServletRequest req = null;
        final HttpServletResponse res = null;
        assertFalse( d1.containsRequest( req ) );
        
        assertTrue( d1.containsRequest( d1.getParent().getRequest() ) );
    }
    
    /**
     * Test method of {@link CancelEditMetadataAction#isSucceeded()}.
     */
    @Test
    public void testSucceededWithErrorResponse() throws IOException {
        final HttpServletRequest req = null;
        final HttpServletResponse res = null;
        final CancelEditMetadataAction action = CancelEditMetadataActionTest.testActionCancelAllMetadata();
        assertTrue( action.isSucceeded() );
        assertNotNull( action.getErrorMessage() );
        
        assertTrue( action.hasErrorResponse() );
    }
    
    @Test
    public void testInvalidActionName() throws Exception {
        try {
            // invalid action name (expect invalid name in the action name
            final CancelEditMetadataAction invalidAction = CancelEditMetadataAction.actionCancelAllMetadata().withName(""invalid_action_name"");
            assertThrows( ServletException.class, invalidAction::doGet );
            
            // invalid action name (should have error message
            
        } catch( final ServletException e ) {
            assertEquals( HttpServletResponse.SC_NOT_FOUND, e.getResponse().getStatus() );
            assertEquals( ""cancelMetadata"", e.getMessage());
        }
    }
    
    /**
     * Test method of {@link RequestDispatcher#sendError(int, java.lang.Exception)}.
     */
    @Test
    public void testSendError() throws IOException, ServletException {
        final HttpServletRequest req = null;
        final HttpServletResponse res = null;
        final RequestDispatcher d1 = RequestDispatcher.getInstance(""view"");
        d1.forward( req, res );
        
        assertTrue( d1.containsRequest( req ) );
        assertTrue( res.contains( ""POST"", ""/cataloger/editMetadata.jsp"", null ) );
        
        int status = d1.getStatus();
        final Exception err = (Exception) d1.getException();
        assertEquals( 401, status );
        assertSame( err, (ServletException)d1.getException() );
        assertFalse( res.contains( ""POST"", ""/cataloger/editMetadata.jsp"", null ) );
        
        getRequest( req );
    }
    
    /**
     * Gets request.
     * 
     * @param req
     *            the req
     * @return the request
     */
    protected void getRequest( final HttpServletRequest req ) {
        assertNotNull( req );
        assertFalse( req.containsParameter( ""action"" ) );
        assertFalse( req.containsParameter( ""cataloger"" ) );
        assertNotNull( authTools.checkAuthentication( req ) );
    }
    
    /**
     * Gets authTools.
     * 
     * @return the authTools
     */
    protected AuthenticationTools authTools() {
        return AuthenticationTools.create(""user"", ""guest"", ""password"");
    }
    
    /**
     * Gets HttpServlet.
     * 
     * @return the HttpServlet
     */
    protected HttpServlet getHttpServlet() {
        return new HttpServlet(""http://example.com/cataloger/editMet"
999858f5-fd9b-430f-92fb-96fac1d3ba90,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditControlledVocabularyAction.java,55.67745852470398,length,"// EditControlledVocabularyAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Controlled Vocabulary item.  If
 * there isn't an existing Controlled Vocabulary item which can be found to edit,
 * we assume that a new Controlled Vocabulary entry should be edited.
 */
public class EditControlledVocabularyAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// EditControlledVocabularyActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditControlledVocabularyAction}.
* It contains one unit test case for the {@link EditControlledVocabularyAction#actionRequiresLogin()} method.
*/
class EditControlledVocabularyActionTest {","// EditControlledVocabularyActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditControlledVocabularyAction}.
* It contains one unit test case for the {@link EditControlledVocabularyAction#actionRequiresLogin()} method.
*/
class EditControlledVocabularyActionTest {

	@Test
	/** 
	 * Test case for the constructor of an action.
	 * The constructor is not null-checked.
	 */
	public void testConstructor() throws ServletException {
		
		assertNotNull(new EditControlledVocabularyAction());

		// Test for action parameter validity checks
		assertNotNull(new EditControlledVocabularyAction(""""));

		final String v = ""newVocab"";
		assertNotNull(new EditControlledVocabularyAction(v));
	}


	@Test
	/** 
	 * Test case for the case when a parameter is missing.
	 * We use {@link #testConstructor()}
	 */
	public void testMissingParam() {
		
		assertNotNull(new EditControlledVocabularyAction());
		
		// If the parameter is missing, an exception should be raised after the action is completed.
		String v = null;
		try {
			new EditControlledVocabularyAction(v);
		} catch (IllegalArgumentException e) { 
			assertNull(e);
		}
	}
	
	// ===================================================================================
	
	/** Test data. */
	private final static String SPECIFIED_PARAM = ""--specified--"";
	
	/** Test data for a {@link CompleteMetadataBean} with the {@link #specifiedParam}. */ 
	private final static String SPECIFIED_VAL = ""some specific data"";
	

	/** Test data where the final data is a complete {@link CompleteMetadataBean}, but where the specified 
	 * {@link #specifiedParam} is the prefix of the current {@link CompleteMetadataBean}. <br>
	 * If a {@link #specifiedParam} is absent, the current {@link CompleteMetadataBean} will be returned. 
	 * @see #SPECIFIED_PARAM
	 */
	public final static String SPECIFIED_VAL_COMPLETE_METADATA = "".complete-metadata"";

	/** Test data where the final data is a complete {@link CompleteMetadataBean}, but where the current 
	 * {@link CompleteMetadataBean} is not a complete {@link CompleteMetadataBean}. 
	 * @see #SPECIFIED_VAL
	 */
	public final static String NONE_SPECIFIED_VAL = ""--NONE--"";

	/** Test data where the final data is null. */
	public final static String NULL_VAL = ""null"";
	
	/** Test data where the final data is an empty string. */
	public final static String EMPTY_VAL = """";


	/** Test data where the final data is the specified {@link CompleteMetadataBean}. */
	private final static String SPECIFIED_VAL_COMMON_METADATA = "".common-metadata"";

	/** Test data where the specified {@link CompleteMetadataBean}. */
	private final static String SPECIFIED_SOMETHING_COMPLEMETADATA = ""some-other-metadata-something"";
	
	/** Test data where the {@link CompleteMetadataBean} has metadata but it is not a valid key. */
	private final static String SPECIFIED_KEY_MALFORMED_COMMON_METADATA = ""--specified-malformed--"";

	/** Test data where the {@link CompleteMetadataBean} has no metadata except {@link #SPECIFIED_KEY_MALFORMED_COMMON_METADATA}. */
	private final static String SPECIFIED_KEY_MALFORMED_SPECIFIED_COMMON_METADATA = ""--some_specified_malformed--"";


	/** Test data where the {@link CompleteMetadataBean} has no metadata. */
	private final static String NONE_VAL_COMPLETE_METADATA = "".complete-metadata-none"";
	
	

	/** Test data where the complete metadata is missing because the current metadata has the key 
	 * ""{@link #SPECIFIED_KEY_MALFORMED_SPECIFIED_COMMON_METADATA}"". */ 
	private final static String SAME_VAL_SOMETHING_COMPLEMETADATA = ""--same-something--"";
	
	// ===================================================================================
	
	@Test
	public void testActionRequiresLogin() throws ServletException, IOException {
		
		EditControlledVocabularyAction action = new EditControlledVocabularyAction(""test"", null, """", false, true);
		assertFalse(action.requiresLogin());
		
		// We should not fail here if an action requires a login.
		//action.setRequiresLogin(true);

		try{
			action.actionRequiresLogin();
			fail(""An error has been expected."");
		} catch (ServletException e) { 
			assertNotNull(e); 
		}
	}
	
	@Test
	public void testNoAuthUserWithNoSpecifiedMetadata() throws ServletException, IOException {	
		EditControlledVocabularyAction action = new EditControlledVocabularyAction(null, null, """", false, true);
		assertTrue(action.requiresLogin());
		assertTrue(action.actionRequiresLogin());
	}
	
	@Test
	public void testNoAuthAuthenticatedUserWithNoSpecifiedMetadata() throws ServletException, IOException {
		EditControlledVocabularyAction action = new EditControlledVocabularyAction("""", null, """", false, true);
		assertTrue(action.requiresLogin());
		assertTrue(action.actionRequiresLogin());
	}	
	
	@Test
	public void testNoAuthUserWithNoSpecifiedValue() throws ServletException, IOException {
		EditControlledVocabularyAction action = new EditControlledVocabularyAction("""", null, """", false, false);
		assertFalse(action.requiresLogin());
		assertFalse(action.actionRequiresLogin());
	}
	
	@Test
	public void testNoAuthUserWithNoSpecifiedMetadataValue() throws ServletException, IOException { 
		EditControlledVocabularyAction action = new EditControlledVocabularyAction("""", null, null, false, false);
		assertFalse(action.requiresLogin());
		assertFalse(action.actionRequiresLogin());
	}	
	
	@Test
	public void testNoAuthAuthUserMissing() throws ServletException, IOException {
		EditControlledVocabularyAction action = new EditControlledVocabularyAction(""someKey"", """", """", false, false);
		assertFalse(action."
15327ce7-2c59-48f1-99a1-161db566bf7a,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/MetadataRecordModifier.java,39.21659755706787,stop,"// MetadataRecordModifier.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.CopyrightTextBean;
import org.heal.module.metadata.DiseaseDiagnosisBean;
import org.heal.module.metadata.FormatBean;
import org.heal.module.metadata.KeywordBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.ThumbnailBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.servlet.Action;
import org.heal.util.DateTools;
import javax.servlet.ServletRequest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * <p>A {@link MetadataModifier} which fills the basic metadata information
 * from a <code>ServletRequest</code> into a {@link CompleteMetadataBean}.</p>
 */
public class MetadataRecordModifier implements MetadataModifier {

    public Action getNextAction(ServletRequest request) {
        Action ret;
        String nextActionKey = request.getParameter(""nextAction"");
        if (nextActionMap.containsKey(nextActionKey)) {
            ret = (Action) nextActionMap.get(nextActionKey);
        } else {
            ret = NEXT_ACTION_DEFAULT;
        }
        return ret;
    }
}
","// MetadataRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.CopyrightTextBean;
import org.heal.module.metadata.DiseaseDiagnosisBean;
import org.heal.module.metadata.FormatBean;
import org.heal.module.metadata.KeywordBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.ThumbnailBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.servlet.Action;
import org.heal.util.DateTools;
import javax.servlet.ServletRequest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MetadataRecordModifier}.
* It contains one unit test case for the {@link MetadataRecordModifier#getNextAction(ServletRequest)} method.
*/
class MetadataRecordModifierTest {","// MetadataRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.CopyrightTextBean;
import org.heal.module.metadata.DiseaseDiagnosisBean;
import org.heal.module.metadata.FormatBean;
import org.heal.module.metadata.KeywordBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.ThumbnailBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.servlet.Action;
import org.heal.util.DateTools;
import javax.servlet.ServletRequest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MetadataRecordModifier}.
* It contains one unit test case for the {@link MetadataRecordModifier#getNextAction(ServletRequest)} method.
*/
class MetadataRecordModifierTest {


//----------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------
    @Test
    void testExtensionWithNoParam() throws Exception {
        new MetadataRecordModifier().doTest(null);
    }
    
    @Test
    void testExtensionWithStringParam() throws Exception {
        new MetadataRecordModifier().doTest(""id"");
    }    
    
    @Test
    void testExtensionWithNullStrParam() throws Exception {
        new MetadataRecordModifier().doTest((String)null);
    }
    
//----------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------

}
"
d0f7680b-5c55-4b46-a461-a84818abda3e,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditMetadataAction.java,50.02645564079285,length,"// EditMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.VCardBean;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

/**
 * An {@link org.heal.servlet.Action Action} used to edit metadata
 * records.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @version 1.0
 */
public class EditMetadataAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// EditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.VCardBean;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditMetadataAction}.
* It contains one unit test case for the {@link EditMetadataAction#actionRequiresLogin()} method.
*/
class EditMetadataActionTest {","// EditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.VCardBean;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditMetadataAction}.
* It contains one unit test case for the {@link EditMetadataAction#actionRequiresLogin()} method.
*/
class EditMetadataActionTest {

	@Test
    public void testEditMetadataSuccessfully() throws Exception {

    		List<CompleteMetadataBean> metadatas = this.service.findCompleteMetadata();

    		// Test the list
    		Map<String, String> metadataChangedMap = new HashMap<>();
    		metadataChangedMap.put(""updatedby"", ""foo"");
    		metadataChangedMap.put(""updatedbygroup"", ""bar"");
    		metadataChangedMap.put(""updatedbyuser"", ""baz"");
    		metadataChangedMap.put(""updatedbygroupuser"", ""quux"");
    		metadataChangedMap.put(""updatedbyuseruser"", ""baz"");
    		metadataChangedMap.put(""updatedbygroupuser"", ""quux"");
    		// Test that it doesn't return a 404
    		assertEquals(true, this.service.editMetadata(new CompleteMetadataBean(metadatas), metadataChangedMap).isSuccess());
    	}

    @Test
    public void testEditMetadataMissingFields() throws Exception {

    		// Test that an IllegalArgumentException occurs if a required field
    		// is not set
    		Exception invalidTestException = new IllegalArgumentException(""Missing required field: updatedbyuser group"");

    		this.service.editMetadata(new CompleteMetadataBean(), null);
    		assertEquals(invalidTestException.getClass(), Exception.class);
    		assertEquals(""Missing required field: updatedby"", invalidTestException.getMessage());
    	}

    @Test
    public void testEditMetadataFailure() throws Exception {
    		// Test the list
    		List<CompleteMetadataBean> metadatas = this.service.findCompleteMetadata();

    		// Test that there is no success
    		assertEquals(true, this.service.editMetadata(new CompleteMetadataBean(), new HashMap<String, String>()).isSuccess());
    }

    @Test
    public void testEditMetadataFailureWithEmptyValues() throws Exception {
    	Map<String, String> metadataChangedMap = new HashMap<>();
    	metadataChangedMap.put(""updatedby"", """");
    	metadataChangedMap.put(""updatedbyuser"", """");
    	metadataChangedMap.put(""updatedbyusergroup"", """");
		this.service.editMetadata(new CompleteMetadataBean(), metadataChangedMap);
		assertEquals(false, this.service.editMetadata(new CompleteMetadataBean(), metadataChangedMap).isSuccess());
    }

    @Test
    public void testEditMetadataFailureWithInvalidValues() throws Exception {
    	Map<String, String> metadataChangedMap = new HashMap<>();
    	metadataChangedMap.put(""updatedby"", ""foo"");
    	metadataChangedMap.put(""updatedbygroup"", ""foo"");
		this.service.editMetadata(new CompleteMetadataBean(), metadataChangedMap);
		assertEquals(false, this.service.editMetadata(new CompleteMetadataBean(), metadataChangedMap).isSuccess());
    }

    @Test
    public void testEquality() throws Exception {

    	// Test that each object has the same hash code
    	Map<String, String> map1 = new HashMap<>();
    	Map<String, String> map2 = new HashMap<>();

    	metadata1: {
    	    	CompleteMetadataBean metadata = new CompleteMetadataBean();
    	    	metadata.setName(""This metadata should not change!"");
    	    	map1.put(""updatedbygroup"", ""foo"");
    	    	map1.put(""updatedbygroupgroup"", ""bar"");
    	        map1.put(""updatedbyuser"", ""baz"");
    	    	map1.put(""updatedbyusergroup"", ""quux"");
    	        map1.put(""updatedbyuseruser"", ""baz"");
    	    	map1.put(""updatedbyuseruser"", ""quux"");
    	    	map1.put(""updatedbyuserusergroup"", ""quux"");
    	        map1.put(""updatedbygroupuser"", ""quux"");
    	        map1.put(""updatedbyusergroupuser"", ""quux"");
    	        map1.put(""updatedbygroupuseruser"", ""quux"");
    	        map2.put(""updatedbygroup"", ""bar"");
    	        map2.put(""updatedbygroup"", """");
    	        map2.put(""updatedby"", ""baz"");
    	        map2.put(""updatedbyuser"", ""baz"");
    	        map2.put(""updatedbyusergroup"", ""bar"");
    	    	map2.put(""updatedbyuseruser"", ""baz"");
    	    	map2.put(""updatedbyuserusergroup"", ""bar"");
    	        map2.put(""updatedbygroupuser"", ""quux"");
    	        map2.put(""updatedbygroupuser"", ""baz"");
    	    	map2.put(""updatedbygroupuseruser"", ""quux"");
    	        map2.put(""updatedbygroupuseruser"", ""baz"");
    	        map2.put(""updatedbygroupuserusergroup"", ""quux"");
    	    	map2.put(""updatedby"", """");
    	        map2.put(""updatedbygroup"", """");
    	        map2.put(""updatedbygroupuser"", """");
    	        map2.put(""updatedbyuseruser"", """");
    	        map2.put(""updatedbyuserusergroup"", """");
    	        map2.put"
90890630-c208-4910-8a11-4e878bd8beed,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditContributorAction.java,57.18848371505737,length,"// EditContributorAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContributorBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Contributor.  If
 * there isn't an existing Contributor which can be found to edit,
 * we assume that a new Contributor should be edited.
 */
public class EditContributorAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// EditContributorActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContributorBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContributorAction}.
* It contains one unit test case for the {@link EditContributorAction#actionRequiresLogin()} method.
*/
class EditContributorActionTest {","// EditContributorActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContributorBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContributorAction}.
* It contains one unit test case for the {@link EditContributorAction#actionRequiresLogin()} method.
*/
class EditContributorActionTest {

	@Test
	public void testNullObject() throws ServletException, IOException {
		EditContributorAction action = new EditContributorAction();
		if (""edit"".equals(action.getRequestParameter(""edit""))) {
			assertNull(action.getRequestParameter(""contributorList""));
		} else {
			assertNotNull(action.getRequestParameter(""contributorList""));
		}
	}
	
//	@Test
//	public void testSuccess() throws ServletException, IOException, SQLException {
//
//		ContributorBean existingContributor = new ContributorBean();
//		existingContributor.setId(""test1"");
//		existingContributor.setFirstName(""test1First"");
//		existingContributor.setLastName(""test1Last"");
//		existingContributor.setEmail(""test2@test.com"");
//		existingContributor.setWebsite(""http://example.test.com"");
//		existingContributor.setLocation(""http://example.test"");
//
//		ContributorBean newContributor = new ContributorBean();
//		newContributor.setId(""test2"");
//		newContributor.setFirstName(""test2First"");
//		newContributor.setLastName(""test2Last"");
//		newContributor.setEmail(""test2@test.com"");
//		newContributor.setWebsite(""http://example.test.com"");
//		newContributor.setLocation(""http://example.test"");
//
//		CompleteMetadataBean metadata = new CompleteMetadataBean();
//		ContributorBean editedContributor = metadata.getContributorBeanById(""test2"");
//		assertNotNull(existingContributor);
//		assertNotNull(newContributor);
//		assertEquals(metadata.getContributionId(), editContributor.getId());
//		assertEquals(metadata.getLastName(), editContributor.getLastName());
//		assertEquals(metadata.getFirstName(), editContributor.getFirstName());
//		assertEquals(metadata.getEmail(), editContributor.getEmail());
//		assertEquals(metadata.getWebsite(), editContributor.getWebsite());
//		assertEquals(metadata.getLocation(), editContributor.getLocation());
//
//		Iterator<ContributorBean> iter = metadata.contributors().iterator();
//		assertTrue(iter.hasNext());
//		ContributorBean currentContributor = iter.next();
//		assertEquals(metadata.getContributorId(), currentContributor.getId());
//		assertEquals(metadata.getLastName(), currentContributor.getLastName());
//		assertEquals(metadata.getFirstName(), currentContributor.getFirstName());
//		assertEquals(metadata.getEmail(), currentContributor.getEmail());
//		assertEquals(metadata.getWebsite(), currentContributor.getWebsite());
//		assertEquals(metadata.getLocation(), currentContributor.getLocation());
//
//		assertNotNull(currentContributor);
//
//		EditContributorAction action = new EditContributorAction();
//		if (existingContributor.id()!= newContributor.id()) {
//			action.setRequestParameter(""edit"");
//			action.setComponentIdList(""test1,other"");
//		}
//		if (existingContributor.id() == newContributor.id()) {
//			assertNull(action.getRequestParameter(""contributorList""));
//			assertEquals(1, action.actionRequiresLogin());
//		} else {
//			assertNotNull(action.getRequestParameter(""contributorList""));
//			assertEquals(1, action.editContribution());
//		}
//
//		currentContributor = edtContribuitor();
//		assertNotNull(currentContributor);
//
//		iter = metadata.contributors().iterator();
//		currentContributor = iter.next();
//		assertEquals(existingContributor.id(), currentContributor.id());
//		assertEquals(edtFirstName, currentContributor.firstName());
//		assertEquals(edtLastName, currentContributor.lastName());
//		assertEquals(""test2Last"", currentContributor.email());
//		assertEquals(""localhost"", currentContributor.emailAddress());
//		assertEquals(metadata.getLastName(), currentContributor.lastName());
//		assertEquals(metadata.getEmail(), currentContributor.email());
//		assertEquals(metadata.getWebsite(), currentContributor.emailAddress());
//		assertEquals(metadata.getLocation(), currentContributor.emailAddress());
//
//	}
//
//	public ContributorBean edtLastName() throws SQLException {
//
//		assertNotNull(editContributor.firstName());
//		assertNotNull(editContributor.lastName());
//
//		return editContributor;
//	}
//
//	public ContributorBean edtContribution() throws SQLException, InterruptedException {
//
//		contributorContribution();
//
//		Iterator<ContributorBean> contributors = edtContributors();
//		ContributorBean c = contributors.next();
//		assertEquals(1, c.getId().length());
//		assertEquals(metadata().getLastName(), c.getLastName());
//		assertEquals(""test2Last"", c.getFirstName());
//		assertEquals(""localhost"", c.getEmail());
//
//		return c;
//	}
//
//	private ContributorBean edtContributor(com.mycompany.Test.Test test) throws SQLException, InterruptedException {
//
//		iterator.set(test);
//		iterator.set(0);
//		edtContribution();
//
//		Iterator<ContributorBean> contributors = edtContributors();
//		Iterator<ContributorBean> iterator = contributors;
//		assertEquals(test, iterator.next().getTest());
//
//		ContributorBean c;
//		while (iterator.hasNext()) {
//			c = iterator.next();
//			c.setLastName(c.getLastName() + "" "" + test.lastName());
//		}
//		return c;
//	}
//
//	private ContributorBean edtContributor() throws InterruptedException {
//
//		return edtContribution();
//	}
//
//	private class TestContribution implements Comparable<TestContribution> {
//
//		final ContributorBean"
ed6019c0-7490-4c2a-bc39-c4e6621a3750,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ShowCatalogQueueAction.java,56.666823387145996,stop,"// ShowCatalogQueueAction.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * An {@link org.heal.servlet.Action} which fetches the information needed to
 * display the catalog queue.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
public class ShowCatalogQueueAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// ShowCatalogQueueActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowCatalogQueueAction}.
* It contains one unit test case for the {@link ShowCatalogQueueAction#actionRequiresLogin()} method.
*/
class ShowCatalogQueueActionTest {","// ShowCatalogQueueActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowCatalogQueueAction}.
* It contains one unit test case for the {@link ShowCatalogQueueAction#actionRequiresLogin()} method.
*/
class ShowCatalogQueueActionTest {

	private static final String TLD = ""ttld"";
	private static final String US = ""ust"";
	private static final String NAMESPACE = ""http://www.opentahy.org/catalog/policies/namespaces/"";
//		private static final String NAMESPACE = ""test/pdc"";
	
	private final QueueDAO queueDAO = QueueDAO.getInstance();
	
	// tests
	
	@Test
	public void testGetCatalogUrlsForNamespaces() throws ServletException, IOException {
		
		HttpServletRequest request = new HttpServletRequest(""GET"", ""/servlet/catalog-request-example.html"");
		QueueDAO.getInstance().initialise(request);
		List<String> content = queueDAO.getCatalogUrlsForNamespaces(TLD, US);
		assertEquals(""Only one catalog url should be returned"", 1, content.size());
	}
	
	@Test
	public void testShowCatalogWithMultipleTLDs() throws ServletException, IOException {
		
		long numResults = queueDAO.count();
		HttpServletRequest request = new HttpServletRequest(""GET"", ""/servlet/catalog-request-example-with-multiple-ttlds.html"");
		QueueDAO.getInstance().initialise(request);
		List<String> m = queueDAO.getCatalogUrlsForNamespaces(null, TLD);
		assertContains(""1.0"", m);
		assertContains(""1.0"", queueDAO.getCatalogUrlsForNamespaces(US, TLD));
		assertContains(""1.0"", queueDAO.getCatalogUrlsForNamespaces(TLD, US));
		assertDoesNotContain(""1.0"", queueDAO.getCatalogUrlsForNamespaces(US, null));
		assertDoesNotContain(""1.0"", queueDAO.getCatalogUrlsForNamespaces(""not-a-pk"", null));
		request = new HttpServletRequest(""GET"", ""/servlet/catalog-request-example-with-multiple-namespaces.html"");
		QueueDAO.getInstance().initialise(request);
		m = queueDAO.getCatalogUrlsForNamespaces(TLD, NAMESPACE);
		assertContains(""1.0"", m); // ""ns"" is default namespace.
		m = queueDAO.getCatalogUrlsForNamespaces(US, NAMESPACE);
		assertContains(""1.0"", m); // ""ns"" is default namespace.
		request = new HttpServletRequest(""GET"", ""/servlet/catalog-request-with-multiple-namespaces.html"");
		QueueDAO.getInstance().initialise(request);
		m = queueDAO.getCatalogUrlsForNamespaces(null, NAMESPACE);
		assertDoesNotContain(""1.0"", m);
		m = queueDAO.getCatalogUrlsForNamespaces(US, NAMESPACE);
		assertDoesNotContain(""1.0"", m);
	}
	
	@Test
	public void testGetCatalogUrlsWithEmptyCatalog() throws ServletException, IOException {
		HttpServletRequest request = new HttpServletRequest(""GET"", ""/servlet/catalog-request-empty-catalog.html"");
		List<String> content = queueDAO.getCatalogUrlsForNamespaces(TLD, US);
		assertEquals(""0.0"", content.get(0));
	}
	
//	@Test
//	public void testAddToCache() throws ServletException, IOException {
//		HttpServletRequest request = new HttpServletRequest(""GET"", ""/servlet/catalog-request-update-namespace.html"");
//		QueueDAO.getInstance().initialise(request);
//		String updatedNameSpace = ""test/namespace/new-name"";
//		queueDAO.addCatalogToCache(updatedNameSpace);
//		assertEquals(""Cache record should add a new entry"", updatedNameSpace, queueDAO.getCacheNamespace(false));
//		request = new HttpServletRequest(""GET"", ""/servlet/catalog-request-missing-namespace.html"");
//		QueueDAO.getInstance().initialise(request);
//		assertEquals(""Cache record should not add a new entry"", """");
//	}
	
}

// EOF
"
7485f7f9-3e00-4343-a4e9-5a7c4e275044,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditCopyrightHolderAction.java,56.97790241241455,stop,"// EditCopyrightHolderAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.CopyrightHolderBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Copyright Holder.  If
 * there isn't an existing Copyright Holder which can be found to edit,
 * we assume that a new Copyright Holder should be edited.
 */
public class EditCopyrightHolderAction implements Action {

    public boolean actionRequiresLogin() {
        return true;
    }
}
","// EditCopyrightHolderActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.CopyrightHolderBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditCopyrightHolderAction}.
* It contains one unit test case for the {@link EditCopyrightHolderAction#actionRequiresLogin()} method.
*/
class EditCopyrightHolderActionTest {","// EditCopyrightHolderActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.CopyrightHolderBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditCopyrightHolderAction}.
* It contains one unit test case for the {@link EditCopyrightHolderAction#actionRequiresLogin()} method.
*/
class EditCopyrightHolderActionTest {
/**
* The {@link EditCopyrightHolderAction} class.
*/
	private final EditCopyrightHolderAction action = new EditCopyrightHolderAction();

	/**
* Test method to edit a {@link CopyrightHolder} when there
* isn't an existing CopyrightHolder.  Assert that the
* {@link AboutCopyrightHolderAction} instance will work.
*/
	@Test
    public void testEditCopyrightHolder_noExistingCopyrightHolder() {
        // The correct request should be made
		request(""EditCopyrightHolderAction.action"", null);
	}

	/**
* Test method to edit a {@link CopyrightHolder} which matches
* the {@link CopyrightHolder} supplied.  If the edited
* {@link CopyrightHolder} is empty, we do not do any
* action, which is the expected behaviour.
*/
	@Test
    public void testEditCopyrightHolder_duplicateCopyrights() throws ServletException, IOException {
		CopyrightHolderBean copyrightHolder = new CopyrightHolderBean();

        publish(copyrightHolder);
		assertThrown(() -> request(""EditCopyrightHolderAction.action"", copyrightHolder),
				getServletContext().getMessage(""EditCopyrightHolderAction.exception.CopyrightsMismatch"")
				);
	}

	/**
* Test method to edit a {@link CopyrightHolder} which matches
* the {@link CompleteMetadataBean} supplied.  If the edited
* {@link CopyrightHolder} is empty, we do not do any
* action, which is the expected behaviour.
*/
	@Test
    public void testEditCopyrightHolder_duplicateCompleteMetadata() {
        CompleteMetadataBean completeMetadata = new CompleteMetadataBean();

        publishAndSave(completeMetadata);
		assertThrown(() -> request(""EditCopyrightHolderAction.action"", completeMetadata),
				getServletContext().getMessage(""EditCopyrightHolderAction.exception.MetadataCompleteMismatch"")
				);
	}

	/**
* Test method to edit a {@link CopyrightHolder} which matches
* the {@link CompleteMetadataBean} supplied.  If the edited
* {@link CopyrightHolder} is empty, we do not do any
* action, which is the expected behaviour.
*/
	@Test
    public void testEditCopyrightHolder_duplicateCompleteMetadataAndCopyright() {

        CompleteMetadataBean completeMetadata = new CompleteMetadataBean();
        CompleteMetadataBean copyrightMetadata = new CompleteMetadataBean();

        publish(completeMetadata);
        publish(copyrightMetadata);
		assertThrown(() -> request(""EditCopyrightHolderAction.action"", completeMetadata, copyrightMetadata),
				getServletContext().getMessage(""EditCopyrightHolderAction.exception.MetadataDifferentCopyrightMismatch"")
				);
	}

	private void publish(CopyrightHolderBean copyrightHolder) {
        HttpServletRequest request = this.request(""EditCopyrightHolderAction.action"", copynrHolder);
        request.getSession().setMaxInactiveInterval(1);
        request.getSession().setAttribute(""copynr"", copynrHolder);
      
        Iterator<String> iterator = author.getFieldNames().iterator();
        while (iterator.hasNext()) {
            String fieldName = iterator.next();

            request.getSession().setAttribute(fieldName, author.getPublicField(fieldName));
        }
      
        try {
            request.getSession('cat' + this.getClass().getSimpleName() + "".class"").setAttribute(""cat"", request.getParameter(""cat""));
        } catch (NullPointerException nullpE) {
        } catch (IllegalArgumentException e) {
            fail(""Field is present"");
        }
        request.getSession().setAttribute(""cat"", request.getParameter(""cat""));

        RequestDispatcher dispatcher = this.getContext().getRequestDispatcher(""cataloger/edit"");
        dispatcher.include(request);
	}

	/* Get a response object */
	private HttpServletRequest request(String baseAction, CopyrightHolderBean copyrightHolder, 
			CompleteMetadataBean metadata) throws ServletException, IOException {
		final HttpServletRequest request = this.request(baseAction, copyrightHolder, metadata);
		request.setAttribute(""user"", USER_NAME);
		return request;
	}

	private HttpServletRequest request(String baseAction, 
			CopyrightHolderBean copyrightHolder, CompleteMetadataBean metadata,
			String session) throws ServletException, IOException {
		final HttpServletRequest request = this.request(baseAction, copyrightHolder, metadata, session);
		request.setAttribute(""user"", USER_NAME);
		return request;
	}

}
"
bf4fc43f-8709-4e1a-a7d4-c602dc938868,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/upload/AlphanumericFileRenamePolicy.java,62.89746332168579,stop,"// AlphanumericFileRenamePolicy.java
package org.heal.servlet.upload;

import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;
import java.io.File;

/**
 * A FileRenamePolicy that strips non-alphanumeric characters.
 */
public class AlphanumericFileRenamePolicy extends DefaultFileRenamePolicy {

    public File rename(File original) {
        File ret = new File(stripSpecialCharacters(original.getPath()));
        return super.rename(ret);
    }
}
","// AlphanumericFileRenamePolicyTest.java
package org.heal.servlet.upload;

import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;
import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AlphanumericFileRenamePolicy}.
* It contains one unit test case for the {@link AlphanumericFileRenamePolicy#rename(File)} method.
*/
class AlphanumericFileRenamePolicyTest {","// AlphanumericFileRenamePolicyTest.java
package org.heal.servlet.upload;

import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;
import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AlphanumericFileRenamePolicy}.
* It contains one unit test case for the {@link AlphanumericFileRenamePolicy#rename(File)} method.
*/
class AlphanumericFileRenamePolicyTest {

    @Test
    public void testPass() {
        File tmp = null;
        try {
            tmp = File.createTempFile(""123"", ""name"");
            tmp.deleteOnExit();
            
            // create a new file
            File f1 = File.createTempFile(""123"", """");
            f1.deleteOnExit();
            f1.delete();

            File file2 = new File(tmp.getPath());
            assertNotNull(file2.getPath());
            f1 = new File(tmp.getPath());

            // rename the file to a different name
            f1.renameTo(new File(f1.getPath()+""1""));

            // validate the new path
            assertEquals(f1.getPath(), f1.getParentFile().getPath());
            
        } catch (IllegalStateException exp) {
                fail(""This cannot happen"");
        }
    }

}"
14bf7816-16d9-4082-ad13-3f5fcf0054d0,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_0Test.java,55.943766355514526,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static String format(Date date) {
        if (null == date) {
            return null;
        }
        SimpleDateFormat formatter = new SimpleDateFormat(DEFAULT_DATE_FORMAT);
        return formatter.format(date);
    }
}
","// DateTools_0Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date)} method.
*/
class DateTools_0Test {","// DateTools_0Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date)} method.
*/
class DateTools_0Test {
private final String formatDate
			= """";     // this format is not yet specified

		@junit.jupiter.BeforeAll
	    //@before:
		//@param: format {@value} is not yet specified
		public void setFormatter(String format) {
			if (!formatNullValid) {
				this.format = format;
				getTimeDateStr();
			} else {
				// if you don't make any changes, 
				// then this should be executed before the junit tests!
				// set the DateTools constants
		        //getTimeDate();
			}
	    }

		@Test
		public void getTimeDate() {
			assertNotSame(getTimeDateStr(), getTimeDateStr());
			assertSame(formatDate, this.format);
		}

		@Test
		public void testFormat() throws ParseException {
			//System.setProperty(""date.locale.format.default"", formatDate);
			assertEquals(formatDate, this.format);
			final Date d = dateConvert(this.format, DEFAULT_DATE_FORMAT);
			assertSame(DateTools.format(d), dateConvert(this.format));
		}

		@Test
			void dateConvertDateFromString() throws ParseException {
			final Date d = dateConvert(this.format, ""yyyy-MM-dd"");
				assertTrue(d instanceof Date);
			assertEquals(d, dateConvert(this.format));
			}

		@Test
			void dateConvertDateFromClass() throws ParseException {
			final Date d = dateConvert(this.format, DateTools.class);
				assertTrue(d instanceof Date);
			assertEquals(d, dateConvert(this.format));
			}
}

// DateTools_1Test.java
"
6e38160e-87f8-46b2-af40-90491ac1d267,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_1Test.java,49.894208669662476,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static String format(Date date, String format) {
        if (null == date) {
            return null;
        }
        SimpleDateFormat formatter = new SimpleDateFormat(format);
        return formatter.format(date);
    }
}
","// DateTools_1Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date, String)} method.
*/
class DateTools_1Test {","// DateTools_1Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date, String)} method.
*/
class DateTools_1Test {
private Date Tools;

		public DateTools_1Test() {
			Tools = new Date();
		}

		public void dateAndFormat() {
			Date newDate = new Date();
			DateTools.format(newDate, new SimpleDateFormat(""yyyy-MM-dd""));
			assertEquals(""2002-11-07"", Tools.toString());
		}

		@Test
		void dateFormat() {
			String dateString = ""2002-10-11"";
			DateTools.format(Tools.getTime(), dateString);
			//if (false) {
				//assertEquals(dateString, Tools.toString());
			//}
		}

		public void DateTools_2Test() {
			System.out.println(""dateTools_2Test"");
			DateTools.dateAndFormat();
			Date tmp = null;
			DateTools.dateAndFormat();
			assertEquals(Tools.getTime(), tmp.getTime());
		}
}
//DateTools_1Test.java"
802f00b1-8138-4e5f-9915-4c8ace6e09e7,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_2Test.java,54.30090022087097,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static Date parse(String dateString) {
        Date ret = null;
        if (null != dateString) {
            boolean match = false;
            SimpleDateFormat formatter = new SimpleDateFormat();
            formatter.setLenient(false);
            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {
                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);
                try {
                    ret = formatter.parse(dateString);
                    match = true;
                } catch (ParseException e) {
                    // do nothing
                }
            }
        }
        return ret;
    }
}
","// DateTools_2Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String)} method.
*/
class DateTools_2Test {","// DateTools_2Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String)} method.
*/
class DateTools_2Test {
// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static Date parse(String dateString) {
        Date ret = null;
        if (null!= dateString) {
            boolean match = false;
            SimpleDateFormat formatter = new SimpleDateFormat();
            formatter.setLenient(false);
            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length &&!match; ++i) {
                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);
                try {
                    ret = formatter.parse(dateString);
                    match = true;
                } catch (ParseException e) {
                    // do nothing
                }
            }
        }
        return ret;
    }
}

// DateTools_2Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String)} method.
*/
class DateTools_2Test {
		
	@Test
	void testParse() {
        assertEquals("""", parse(""""));
		assertEquals(""2009"", parse(""09z"", Locale.getDefault(), true));
		Date date;
		try {
			date = parse(""13"", Locale.getDefault());
			fail();
		} catch (ParseException ignored) {
			// do nothing
		}
		date = parse(""13"", Locale.US);
		assertEquals(""2013"", date.toString(Locale.US));
		
	}

}"
434b54b3-5e6c-48e2-9978-c3d65f063bff,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_3Test.java,62.006552934646606,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static Date parse(String dateString, String format) {
        Date ret = null;
        if (null != dateString) {
            SimpleDateFormat formatter = new SimpleDateFormat(format);
            formatter.setLenient(false);
            try {
                ret = formatter.parse(dateString);
            } catch (ParseException e) {
                // do nothing
            }
        }
        return ret;
    }
}
","// DateTools_3Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String, String)} method.
*/
class DateTools_3Test {","// DateTools_3Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String, String)} method.
*/
class DateTools_3Test {
// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static Date parse(String dateString, String format) {
        Date ret = null;
        if (null!= dateString) {
            SimpleDateFormat formatter = new SimpleDateFormat(format);
            formatter.setLenient(false);
            try {
                ret = formatter.parse(dateString);
            } catch (ParseException e) {
                // do nothing
            }
        }
        return ret;
    }
}

// DateTools_3Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String, String)} method.
*/
class DateTools_3Test {
		private final static String DATE = ""yyyy-MM-dd hh:mm:ss"";
		private static final String DATE_TIME = ""yyyy-MM-dd HH:mm:ss"";
		private static final String DATE_TIME_TIME = ""yyyy-MM-dd HH:mm:ss.ffffffff"";

    /** 
     * Tests parsing a DATE string with a date with no format.
     */
    @Test
    public void testParse_01() throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat(DATE);
        formatter.setLenient(false);
        Date date = formatter.parse(""test"");
        assertEquals(formatter.parse(""test""), date);
    }

    /** 
     * Tests parsing a DATE string with a date with format.
     */
    @Test
    public void testParse_02() throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_TIME);
        formatter.setLenient(false);
        Date date = formatter.parse(""test"");
        assertEquals(formatter.parse(""test""), date);
    }
    
    /** 
     * Tests parsing a DATE_TIME string with a date with no format.
     */
    @Test
    public void testParseDateTime_01() throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_TIME_TIME);
        formatter.setLenient(false);
        Date date = formatter.parse(""test"");
        assertEquals(formatter.parse(""test""), date);
    }

    /** 
     * Tests parsing a DATE_TIME string with a date with format.
     */
    @Test
    public void testParseDateTime_02() throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_TIME_TIME);
        formatter.setLenient(false);
        Date date = formatter.parse(""test"");
        assertEquals(formatter.parse(""test""), date);
    }

}"
991c9eac-e141-4580-a96d-a036419eb242,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_4Test.java,45.189626693725586,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static boolean isValidDate(String dateString) {
        boolean match = false;
        if (null != dateString) {
            SimpleDateFormat formatter = new SimpleDateFormat();
            formatter.setLenient(false);
            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {
                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);
                try {
                    formatter.parse(dateString);
                    match = true;
                } catch (ParseException e) {
                    // do nothing
                }
            }
        }
        return match;
    }
}
","// DateTools_4Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String)} method.
*/
class DateTools_4Test {","// DateTools_4Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String)} method.
*/
class DateTools_4Test {
// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static boolean isValidDate(String dateString) {
        boolean match = false;
        if (null!= dateString) {
            SimpleDateFormat formatter = new SimpleDateFormat();
            formatter.setLenient(false);
            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length &&!match; ++i) {
                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);
                try {
                    formatter.parse(dateString);
                    match = true;
                } catch (ParseException e) {
                    // do nothing
                }
            }
        }
        return match;
    }
}

// DateTools_4Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String)} method.
*/
class DateTools_4Test {
		
	public static final String DATE_PATTERN          = ""dd/MM/yyyy"";
    public static final String DATE_FORMAT           = ""dd/MM/yyyy,M.d.,yyyy"";
    private static final SimpleDateFormat SIMPLE_DATE = new SimpleDateFormat(DATE_PATTERN);
	private static final String DATE_PARSE_EXCEPTION   = ""The date cannot be parsed"";

    @Test
    public void testIsValidDate() {
        assertTrue(DateTools.isValidDate(""04/04/2009""));
        try {
            // date parse should always take the year before the day, i.e., 0
            SIMPLE_DATE.parse(""19901"");
            fail(""Should not accept the year before the day"");

        } catch (ParseException e) {
            assertTrue(e.getMessage().contains(DATE_PARSE_EXCEPTION));
        }
        
        // make sure the year is set in case the DateFormat in the 
        // exception message doesn't match the Date formatting pattern
        SIMPLE_DATE.setLenient(false);
        assertTrue(DateTools.isValidDate(""4/04/2009""));
        assertFalse(DateTools.isValidDate(""4/04/2009,13/1/2009""));
    }
	
	@Test
	public void testIsValidDateWithDayString() {
		String dateString = SIMPLE_DATE.format(new Date());

		// create valid date, i.e., 01/04/2009 with days in the pattern
		boolean isValidDate = DateTools.isValidDate(dateString)
				&& dateString.length() == SIMPLE_DATE.format(new Date(dateString.length())).length()
				&& dateString.charAt(SIMPLE_DATE.format(new Date(dateString.length())) + 1) == '.';

		assertTrue(isValidDate);
	}

	@Test
	public void testGetCorrectDateForPattern() throws ParseException {
		assertThrows(NullPointerException.class, () ->
			DateTools.getCorrectDateForPattern(null, DATE_PATTERN));

        SIMPLE_DATE.setLenient(false);
		String dateString = DATE_PATTERN + ""d"";
		assertThrows(IllegalArgumentException.class, () ->
				DateTools.getCorrectDateForPattern(dateString, DATE_FORMAT));

        SIMPLE_DATE.setLenient(true);
		String dateString2 = DATE_FORMAT + ""d"";
		isValidDate = DateTools.isValidDate(DateTools_4Test.DATE_PARSE_EXCEPTION);
		assertThrows(ParseException.class, () ->
				DateTools.getCorrectDateFromString(dateString2, DATE_FORMAT));
		SIMPLE_DATE.setLenient(true);
		dateString = DATE_FORMAT + ""d"";
		isValidDate = DateTools.isValidDate(DateTools_4Test.DATE_PARSE_EXCEPTION);
		assertThrows(ParseException.class, () ->
				DateTools.getCorrectDateFromString(dateString, DATE_PATTERN));
	}

	private static boolean isValidDate(String dateString) {
		try {
			DateTools.SIMPLE_DATE.parse(dateString);
			return true;
		} catch (ParseException e) {
			return false;
		}
	}
}
/*
 * Copyright 2012-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"
a24db666-7fd4-4d7c-a447-c17978dfe39b,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_5Test.java,34.097771883010864,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    public static boolean isValidDate(String dateString, String format) {
        boolean match = false;
        SimpleDateFormat formatter = new SimpleDateFormat(format);
        formatter.setLenient(false);
        try {
            formatter.parse(dateString);
            match = true;
        } catch (ParseException e) {
            // do nothing
        }
        return match;
    }
}
","// DateTools_5Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String, String)} method.
*/
class DateTools_5Test {","// DateTools_5Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String, String)} method.
*/
class DateTools_5Test {
/**
		 * Test the {@code isValidDate()} method.
		*/
		@Test
		public void testIsValidDate() {
			// Given
			String dateString = ""10/03/2015"";
			String format = ""yyyy-MM-dd"";
			
			// When
      assertTrue(DateTools.isValidDate(dateString, format));

			// Then
			assertFalse(DateTools.isValidDate(dateString, format));
			dateString = ""10/03/2020"";
			assertFalse(DateTools.isValidDate(dateString, format));
			dateString = ""10/03/2015 00:00:00"";
      assertTrue(DateTools.isValidDate(dateString, format));
	}
}
"
2100d46f-4bf0-4c77-80cb-5527ca86c798,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/catalog/QueueDAO_0Test.java,54.219200134277344,length,"// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    public List<QueuedRecordBean> getQueueByType(final String type) {
        List<QueuedRecordBean> result = null;
        Connection conn = null;
        try {
            conn = dataSource.getConnection();
            result = getQueue(type, conn);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (null != conn) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
        return result;
    }
}
","// QueueDAO_0Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#getQueueByType(String)} method.
*/
class QueueDAO_0Test {","// QueueDAO_0Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#getQueueByType(String)} method.
*/
class QueueDAO_0Test {
// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    public List<QueuedRecordBean> getQueueByType(final String type) {
        List<QueuedRecordBean> result = null;
        Connection conn = null;
        try {
            conn = dataSource.getConnection();
            result = getQueue(type, conn);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (null!= conn) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
        return result;
    }
}

// QueueDAO_0Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#getQueueByType(String)} method.
*/
class QueueDAO_0Test {
		
	Connection conn;

	String sql = ""select * from queue where type = '0'"";
	PreparedStatement prepStmt;

	@Test
	void getQueueByName() throws SQLException {
		
		/* Prepare SQL result */
		ResultSet rs = CommonDAO.executeQuery(conn, sql);

		
		/* Result */
		java.io.Reader resultReader = new InputStreamReader(rs.getBinaryStream(1));
		java.sql.Statement stmt = conn.createStatement();
		java.sql.ResultSetMetaData rsmd = rs.getMetaData();
        int columnCount = rsmd.getColumnCount();

		/* Get Result */
		List<CompleteMetadataBean> recordBean = new ArrayList<CompleteMetadataBean>();
		CompleteMetadataBean meta = null;
		Object obj = null;
		while (rs.next()) {
		    meta = new CompleteMetadataBean();
		    obj = rs.getObject(1);
		    if(obj!= null){
		    	meta = Convert.convert(CompleteMetadataBean.class, obj);
		    }
		}
		
		/* Set Result */
		for(int i=0 ; i < columnCount ; i++){
			meta.set(rsmd.getColumnLabel(i+1), rsmi.getString(i+1));
		}
		
		/* Get Result */
    	System.out.println(""Result: "");
		System.out.println(resultReader);
		System.out.println();
		System.out.println(recordBean);
		
		/* Verify Result */
		for(int i=0 ; i < recordBean.size() ; i++) {
			
			CompleteMetadataBean record = recordBean.get(i);
			CompleteMetadataBean readResult = new CompleteMetadataBean();
			CompleteMetadataBean readMetaData = new CompleteMetadataBean();

			readMetaData.set(record.get(""name""));
			readMetaData.set(record.get(""desc""));
			readMetaData.set(record.get(""priority""));
			readResult.set(""id"", Integer.toString(record.get(""id"")));
			readResult.set(""name"", readMetaData.get(""name""));
			readResult.set(""desc"", readMetaData.get(""desc""));
			readResult.set(""queue_id"", Integer.toString(0));
			record.put(""queue_id"", Integer.toString(i));
			System.out.println(""Result: "");
			System.out.println(recordResult);
			System.out.println();
			
			System.out.println(""Record ID[""+i+""] = ""
			+ record.get(""id"") + "" - ""
			+ record.get(""name"") + "" - ""
			+ record.get(""desc""));
			System.out.println();
		}
	}
	
	public void setUp() throws Exception {
			conn = dataSource.getConnection();
			prepStmt  = conn.prepareStatement(sql);
}
	
	public void tearDown() throws Exception {
		if (null!= conn &&! CommonDAO.dropStatement(conn)) {
			conn.close();
		}
	}
	
	/*
	* Test getQueueBean for the empty table.
	*/
    @Test
    public void testGetQueueBean() {
        Exception ex = null;

        try {
			conn.prepareStatement(""select * from queue"").executeQuery();
            fail(""The test should not include the table"");
        } catch (SQLException e) {
            ex = e;
        }

        assertEquals(""The data source is not correctly used."",
                    1, stmt.executeQuery(""select * from queue"").getResultSet().next());

        conn.close();
    }
    
    /*
   * Test getTableDataSets() for the empty table.
   */
    @Test
    public void testGetTableDataSets2() {
        try {
            conn.prepareStatement(""select * from queue"").executeQuery();

            fail(""The test should not include the table"");
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            conn.prepareStatement(""select id from queue"").executeQuery();
            fail(""The test should not include the table"");
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            conn.prepareStatement(""select priority from queue"").executeQuery();
            fail(""The test should not include the table"");
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            conn.prepareStatement(""select queue_id from queue where name = '0'"").executeQuery();
            fail(""The test should not include the table"");
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            conn.prepareStatement(""select id from queue where name = '10'"").executeQuery();
            fail(""The test should not include the table"");
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            conn.prepareStatement(""select id from queue where priority = '2'"").executeQuery();
            fail(""The test should not include the table"");
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            conn.prepareStatement(""select id from queue where queue_id = 10"").executeQuery();
            fail(""The test should not include the table"");
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            conn.prepareStatement(""select queue_id from queue where queue_id > 0"").executeQuery();
            fail(""The test should not include the table"");
        } catch (SQLException e) {
            e.printStackTrace();
        }"
29815b5b-918c-4f84-8b7e-50e7ebf88121,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/catalog/QueueDAO_1Test.java,50.663390159606934,length,"// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {
        boolean result = false;
        if (null == queuedRecord) {
            throw new IllegalArgumentException(""queuedRecord argument must be non-null"");
        }
        if (null == queuedRecord.getType()) {
            throw new IllegalArgumentException(""Cannot save a QueuedRecordBean without a type"");
        }
        if (null == queuedRecord.getShortMetadata() || null == queuedRecord.getShortMetadata().getMetadataId()) {
            throw new IllegalArgumentException(""Cannot save a queued record without a metadataId"");
        }
        Connection conn = null;
        try {
            conn = dataSource.getConnection();
            saveQueuedRecord(queuedRecord, conn);
            result = true;
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (null != conn) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
        return result;
    }
}
","// QueueDAO_1Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
*/
class QueueDAO_1Test {","// QueueDAO_1Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
*/
class QueueDAO_1Test {
// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {
        boolean result = false;
        if (null == queuedRecord) {
            throw new IllegalArgumentException(""queuedRecord argument must be non-null"");
        }
        if (null == queuedRecord.getType()) {
            throw new IllegalArgumentException(""Cannot save a QueuedRecordBean without a type"");
        }
        if (null == queuedRecord.getShortMetadata() || null == queuedRecord.getShortMetadata().getMetadataId()) {
            throw new IllegalArgumentException(""Cannot save a queued record without a metadataId"");
        }
        Connection conn = null;
        try {
            conn = dataSource.getConnection();
            saveQueuedRecord(queuedRecord, conn);
            result = true;
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (null!= conn) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
        return result;
    }
}

// QueueDAO_1Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
*/
class QueueDAO_1Test {
		
	/**
	* Constructor.
	*/
	public QueueDAO_1Test() {
	}

	/**
	* Simple testing to ensure a QueuedRecordBean can be saved using the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
	*/
	@Test
	void QueueDAO_1Test_Simple_1() {
		String cid = ""cid1"";
		String status = ""status1"";
		boolean deleted = true;
		CompleteMetadataBean metadata = new CompleteMetadataBean();
    	metadata.setCid(cid);
    	metadata.setMetadataId(""100"");
    	metadata.setDeleted(deleted);
    	metadata.setStatus(status);
		metadata.setDt1(new Date());
    	metadata.setDt2(null);
    	metadata.setCreatedt(null);
    	metadata.setDt3(null);
    	metadata.setDt4(null);

		QueueRecordBean bean = new QueueRecordBean();
		bean.getMetadata().addMetadata(metadata);
	    
        Connection conn = null;
        try {
            conn = dataSource.getConnection();
            conn.setAutoCommit(false);

            // The test for successful operation
            conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
            PreparedStatement pstmt = conn.prepareStatement(""INSERT INTO Queue (cid, shortMetadata) VALUES (?,?)"");
            pstmt.setString(1, cid);
            pstmt.setObject(2, bean);
            pstmt.executeUpdate();


            // The test for an unsuccessful operation
            pstmt = conn.prepareStatement(""INSERT INTO Queue (cid, shortMetadata, deleted) VALUES (?,?,?)"");
            pstmt.setString(1, cid);
            pstmt.setObject(2, bean);
            pstmt.setObject(3, new Object());
            pstmt.executeUpdate();
			
            conn.commit();
            
        } catch (SQLException se) {
            se.printStackTrace();
			fail();	
        } finally {
            CommonDAO.returnConnection(conn);
        }

        assertTrue(""Error while running the test: saveQueuedRecord"", result);

        // Verify data
        ResultSet rs = conn.getMetaData().getColumnPrivileges(cid, ""cid"", null);
        boolean found = false;
        while (rs.next()) {
            String columnPrivilege = rs.getString(1);
            String privilege = rs.getString(2).toUpperCase();
            found = found || columnPrivilege.equals(""CODE"");
        }
        assertTrue(""Error while running the test: getColumnPrivileges"", found);
        assertTrue(""Error while running the test: getColumnPrivileges"", result);

        // Now remove the user
        conn = null;
		deleteUser(cid);

        conn = dataSource.getConnection();
        try {
            PreparedStatement ps = conn.prepareStatement(""DELETE FROM Queue WHERE cid=?"");
            ps.setString(1, cid);
            result = ps.executeUpdate();
            assertTrue(""Error while running the test: before deletion of the user"", result);

        } catch (SQLException se) {
            se.printStackTrace();
            fail();
        } finally {
            try {
                conn.close();
            } catch (SQLException se) {
                se.printStackTrace();
            }
        }

        conn = dataSource.getConnection();
        deleteUser(cid);
        rs = conn.getMetaData().getColumnPrivileges(cid, ""cid"", null);
        boolean found5 = false;
        boolean found6 = false;
		while (rs.next()) {
            String columnPrivilege = rs.getString(1).toUpperCase();
            found5 = found5 || columnPrivilege.equals(""T"");
            found6 = found6|| columnPrivilege.equals(""F"");
        }
		assertFalse(""Error while running the test: getColumnPrivileges"", found5);
		assertTrue(""Error while running the test: getColumnPrivileges"", found6);
	}

    /* 
     * Remove the user from the database.
     * The user is also deleted from the database, and is now hidden from the 
     * database from further operations.
     */
	private void deleteUser(final String cid) {
		Connection conn = null;
        try {
            conn = dataSource.getConnection();
            PreparedStatement ps = conn.prepareStatement(""DELETE FROM AuthenticationUsers WHERE cid=?"");
            ps.setString(1, cid);
            int result = ps.executeUpdate();
            assertTrue(""Error while running the test: before deletion of the user"", result);
            
            // This will only happen if there was a problem with the user already there
            // or if the user wasn't in there
            PreparedStatement ps2 = conn.prepareStatement(""DELETE FROM AuthenticationUsers WHERE cid=?"");
            ps2.setString(1, cid);
            result = ps2.executeUpdate();
			assertTrue(""Error while running the test: after deletion of the user"", result);
			
        } catch (SQLException se) {
            se.printStackTrace();
			fail();
        } finally"
cd3970e9-5601-40c7-9fcc-2f735050ca69,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/search/ParameterBean.java,65.34381341934204,length,"// ParameterBean.java
package org.heal.module.search;

import java.util.*;

public class ParameterBean {

    public int size() {
        return searchParameters.size();
    }
}
","// ParameterBeanTest.java
package org.heal.module.search;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParameterBean}.
* It contains one unit test case for the {@link ParameterBean#size()} method.
*/
class ParameterBeanTest {","// ParameterBeanTest.java
package org.heal.module.search;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParameterBean}.
* It contains one unit test case for the {@link ParameterBean#size()} method.
*/
class ParameterBeanTest {

	/**
	* Test method for {@link ParameterBean#size()}.
	*/
	@Test
	public void testSize() {
		// A case for a search parameter with no set of parameter types.
		{
		Map<Long, String> expected = new HashMap<>();
		expected.put(-1L, String.class.getName());
		test(expected);
		}
		// A case for a search parameter of multiple types.
		{
		Map<Long, Map<String, String>> expected = new HashMap<>();
		expected.put(-1L, new HashMap<>());
		expected.get(-1L).put(String.class.getName(), String.class.getName());
		test(expected);
		}
		// A case for a search parameter with multiple types.
		{
		Map<Long, Map<String, String>> expected = new HashMap<>();
		expected.put(-1L, new HashMap<>());
		expected.get(-1L).put(String.class.getName(), ""A"");
		expected.put(-2L, new HashMap<>());
		expected.get(-2L).put(String.class.getName(), ""B"");
		test(expected);
		}
	}
	
	/**
	* Test method for {@link ParameterBean#size()}.
	*/
	@Test
	public void testSize2() {	
		List<Map<String, String>> badSearchParameters = new ArrayList<>();
		List<Map<String, String>> badSearchParameters2 = new ArrayList<>();
		// A case for a search parameter for search parameter with multiple types.
		{
		badSearchParameters.add(new HashMap<>());
		badSearchParameters.add(new LinkedHashMap<>());
		badSearchParameters.add(new ArrayList<>());
		badSearchParameters.add(new HashSet<>());
		badSearchParameters.add(new HashSet<>());
		badSearchParameters.add(new ArrayList<>());
		badSearchParameters.add(new ArrayList<>());
		badSearchParameters.add(new HashMap<>());
		badSearchParameters.add(new Map<>());
		badSearchParameters.add(new Vector<>());
		badSearchParameters.add(new List<>());
		badSearchParameters.add(new Collection<>());
		badSearchParameters.add(new Set<>());
		badSearchParameters.add(new Map<>(badParameterArray));
		badSearchParameters.add(new Object());
		badSearchParameters.add(new int[1]);
		badSearchParameters.add(new HashSet(badParameterArray));
		badSearchParameters.add(new StringBuilder(), badParameterArray);
		badSearchParameters.add(new BigDecimal(new BigInteger(""99"")));
		badSearchParameters.add(new BigDecimal(0));
		badSearchParameters.add(new long[1]);
		badSearchParameters.add(new HashSet<>());
		badSearchParameters.add(new Boolean());
		badSearchParameters.add(new Object[1]);
		badSearchParameters.add(new List<>());
		badSearchParameters.add(new HashMap<>());
		badSearchParameters.add(new HashMap<>());
		badSearchParameters.add(new Vector<>());
		badSearchParameters.add(new HashSet<>());
		badSearchParameters.add(new HashSet<>());
		badSearchParameters.add(new Map<>());
		badSearchParameters.add(new HashSet<>());
		badSearchParameters.add(new List<>());
		badSearchParameters.add(new Set<>());
		badSearchParameters.add(new HashSet<>(badParameterArray));
		badSearchParameters.add(new HashSet<>(badParameterArray));
		badSearchParameters.add(new Set<>(badParameterArray));
		badSearchParameters.add(new HashSet<>(badParameterArray));
		badSearchParameters.add(new HashSet<>(badParameterArray));
		badSearchParameters.add(new Set<>(badParameterArray));
		badSearchParameters.add(new HashSet<>(badParameterArray));
		badSearchParameters.add(new HashSet<>(badParameterArray));
		badSearchParameters.add(new HashSet<>(badParameterArray));
		badSearchParameters.add(new List<String>());
		badSearchParameters.add(new Vector<String>());
		badSearchParameters.add(new ArrayList<String>());
		badSearchParameters.add(new HashSet<String>(badParameterArray));
		badSearchParameters.add(new HashSet<String>(badParameterArray));
		badSearchParameters.add(new Set<String>(badParameterArray));
		badSearchParameters.add(new Vector<String>(badParameterArray));
		badSearchParameters.add(new HashSet<String>(badParameterArray));
		badSearchParameters.add(new Map<String, String[][]>(""array"", badParameterArray));
		badSearchParameters.add(new Object[10]);
		badSearchParameters.add(new Object[]{badParameterArray});
		badSearchParameters.add(badParameterArray + badParameterArray); // Also test null parameter
		
		badSearchParameters2.add(new ArrayList<>());
		badSearchParameters2.add(new Object[] { badParameterArray });
		badSearchParameters2.add(new Object[] { new StringBuilder() } );
		badSearchParameters2.add(new Vector<String>() );
		badSearchParameters2.add(new HashSet<>() );
		badSearchParameters2.add(new HashSet<>() );
		badSearchParameters2.add(new HashSet<>() );
		badSearchParameters2.add(new ArrayList<>() );
		badSearchParameters2.add(new Set<>() );
		badSearchParameters2.add(new Collection<>() );
		badSearchParameters2.add(new HashMap<>() );
		badSearchParameters2.add(new HashMap<>() );
		badSearchParameters2.add(new BigDecimal(new BigInteger(""99"")));
		badSearchParameters2.add(new BigDecimal(0));
		badSearchParameters2.add(new long[] { 1 } );
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new Boolean() );		
		badSearchParameters2.add(new String[] { ""abcdefg"", ""mna"" } );
		badSearchParameters2.add(new Object[] { 1, null } );
		badSearchParameters2.add(new Vector<String>());
		badSearchParameters2.add(new Object[] { badParameterArray });
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new Vector<>());
		badSearchParameters2.add(new HashMap<>() );
		badSearchParameters2.add(new String[][] {badParameterArray  });
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new Vector<String>(badParameterArray));
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(badParameterArray + badParameterArray); // Also test null parameter
		
		badSearchParameters2.add(new ArrayList<String>());
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new HashSet<>());
		badSearchParameters2.add(new HashSet<>"
1a1b8b58-2700-494a-8298-074383c071e8,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/download/DownloadQueueBean_0Test.java,56.14781355857849,stop,"// DownloadQueueBean.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;

/**
 * Stores a list of contentIds and a package file location and url.
 *
 * @author Seth Wright
 * @version 0.1
 */
public class DownloadQueueBean implements Serializable {

    public boolean removeAllFromQueue() {
        packageModifiedSinceFileCreated = true;
        contentSet.clear();
        return true;
    }
}
","// DownloadQueueBean_0Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#removeAllFromQueue()} method.
*/
class DownloadQueueBean_0Test {","// DownloadQueueBean_0Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#removeAllFromQueue()} method.
*/
class DownloadQueueBean_0Test {

	@Test
	public void removeAllFromQueue_works() {
		// System.out.println(""removeAllFromQueue_works"");
		
	}
}"
68f65e7b-763f-4d09-911e-05e557235337,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/download/DownloadQueueBean_1Test.java,62.01162075996399,stop,"// DownloadQueueBean.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;

/**
 * Stores a list of contentIds and a package file location and url.
 *
 * @author Seth Wright
 * @version 0.1
 */
public class DownloadQueueBean implements Serializable {

    public boolean clearPackageFileSettings() {
        packageFileLocation = null;
        packageURL = null;
        packageModifiedSinceFileCreated = true;
        packageFormat = -1;
        return true;
    }
}
","// DownloadQueueBean_1Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#clearPackageFileSettings()} method.
*/
class DownloadQueueBean_1Test {","// DownloadQueueBean_1Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#clearPackageFileSettings()} method.
*/
class DownloadQueueBean_1Test {

	  
	int testNumber;
	
	
	/**
	 * Test case of {@link DownloadQueueBean#clearPackageFileSettings()}.
	*/
	@Test
	void ClearPackageFileSettings() {
	  boolean result = (DownloadQueueBean.clearPackageFileSettings())? true:false;
	  
	  assertTrue( result );
	}
	
	@Test
	void testClearPackageFileSettings() {
		testNumber = 19;
		
	  assertTrue(""A temporary queue is initialized"", DownloadQueueBean.clearPackageFileSettings());	  
	}
 

}
"
cabbe5d9-82d7-4120-92c6-2d4ca4d6578c,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTag_0Test.java,33.29046964645386,stop,"// DownloadFolderTag.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;

/**
 * A tag which is basically acts as a container for attributes which
 * nested tags will utilize.
 *
 * @version 1.0
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @see org.heal.tag.download.DownloadFolderActionTag
 */
public class DownloadFolderTag extends TagSupport {

    public int doStartTag() {
        FileLocator locator = (FileLocator) pageContext.getServletContext().getAttribute(""healFileLocator"");
        if (""web page"".equals(shortMetadata.getFormat().toLowerCase()) || !shortMetadata.getLocation().toLowerCase().startsWith(locator.getServerBaseURL())) {
            if (""image"".equals(shortMetadata.getFormat().toLowerCase())) {
                downloadFolderType = REMOTE_IMAGE;
            } else {
                downloadFolderType = UNAVAILABLE;
            }
        } else if (downloadQueue.isQueuedAlready(shortMetadata.getMetadataId())) {
            downloadFolderType = REMOVE;
        } else {
            downloadFolderType = ADD;
        }
        return TagSupport.EVAL_BODY_INCLUDE;
    }
}
","// DownloadFolderTag_0Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doStartTag()} method.
*/
class DownloadFolderTag_0Test {","// DownloadFolderTag_0Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doStartTag()} method.
*/
class DownloadFolderTag_0Test {
// DownloadFolderTag.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;

/**
 * A tag which is basically acts as a container for attributes which
 * nested tags will utilize.
 *
 * @version 1.0
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @see org.heal.tag.download.DownloadFolderActionTag
 */
public class DownloadFolderTag extends TagSupport {

    public int doStartTag() {
        FileLocator locator = (FileLocator) pageContext.getServletContext().getAttribute(""healFileLocator"");
        if (""web page"".equals(shortMetadata.getFormat().toLowerCase()) ||!shortMetadata.getLocation().toLowerCase().startsWith(locator.getServerBaseURL())) {
            if (""image"".equals(shortMetadata.getFormat().toLowerCase())) {
                downloadFolderType = REMOTE_IMAGE;
            } else {
                downloadFolderType = UNAVAILABLE;
            }
        } else if (downloadQueue.isQueuedAlready(shortMetadata.getMetadataId())) {
            downloadFolderType = REMOVE;
        } else {
            downloadFolderType = ADD;
        }
        return TagSupport.EVAL_BODY_INCLUDE;
    }
}

// DownloadFolderTag_0Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doStartTag()} method.
*/
class DownloadFolderTag_0Test {
		public DownloadFolderTag_0Test() {
			// Test constructor.
		}

		@Test
		public void testTag() throws Exception {
			shortMetadata.setLocation(""somelocation"");
            Thread.currentThread().sleep(300);
			DownloadQueueBean queue = DownloadQueueBean.createWithoutStartingServer(7, true);
			shortMetadata.setDownloadQueue(queue);
			shortMetadata.setFormat(""txt"");
			shortMetadata.setLocation(""somelocation"");
			shortMetadata.setLastUpdated(""2010-05-24T15:57:42Z"");
            Thread.currentThread().sleep(300);
			ShortMetadataBean newMetadata = FileLocator.createFrom(queue, new ByteArrayInputStream(""Some new content"".getBytes()), DownloadQueueBean.BLANK);
            assertNotNull(""Some new content (should be available)"", newMetadata);
			assertTrue(""Download queue should not be queued yet"",!queue.isQueuedAlready(newMetadata.getMetadataId()));

			DownloadFolderTag tag = new DownloadFolderTag();
			tag.setShortMetadata(shortMetadata);

			TagSupport.EVAL_BODY_INCLUDE(tag, null);
			//System.err.println(newMetadata);
			assertEquals(shortMetadata, newMetadata);
			assertNull(tag.getPagePath(""/whatever""));
		}
        FileLocator f = new FileLocator(""filelocator"");
        assertTrue(""filelocator returned unexpected value"", f==null || f.path().compareTo(""filelocator"")<0);
        
		FileLocator.CUSTOM_EXTENSIONS_PATTERN = ""*.png"";
		
        TagSupport.CUSTOM_EXTENSIONS_PATTERN = ""*.htm"";
}
"
258e1706-82fd-45f6-9195-aca5e342ba08,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTag_1Test.java,48.9371874332428,stop,"// DownloadFolderTag.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;

/**
 * A tag which is basically acts as a container for attributes which
 * nested tags will utilize.
 *
 * @version 1.0
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @see org.heal.tag.download.DownloadFolderActionTag
 */
public class DownloadFolderTag extends TagSupport {

    public int doEndTag() {
        // In case the servlet container re-uses this object
        resetTag();
        return EVAL_PAGE;
    }
}
","// DownloadFolderTag_1Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doEndTag()} method.
*/
class DownloadFolderTag_1Test {","// DownloadFolderTag_1Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doEndTag()} method.
*/
class DownloadFolderTag_1Test {
private final String FILE_NAME = FileLocator.getFileName(""/media/testfile1.txt"");
		public static final String FILE_NAME_2 = FileLocator.getFileName(""/media/testfile2.txt"");
		private DownloadQueueBean dqb = new DownloadQueueBean();
		
		@Test
		public void test1(){
			assertEquals(3, dqb.getCount());
			assertTrue(dqb.isAvailable(FILE_NAME));
			assertTrue(dqb.isAvailable(FILE_NAME_2));
			assertFalse(dqb.isAvailable(FILE_NAME));
			assertFalse(dqb.isAvailable(FILE_NAME_2));
			
			long startTime = System.nanoTime();
			QueueBean result = dqb.getItem(FILE_NAME);
			assertNotNull(result);
			long duration = System.nanoTime() - startTime;
			System.out.print(""Took "" + duration + "" "" + result);
			assertTrue(duration<=20000);
		}
		
		@Test
		public void test2(){
			assertEquals(3, dqb.getCount());
			assertEquals(FileLocator.getLocalPath(""static/images/download-48x48.png""), FILE_NAME_2);
			assertEquals(FileLocator.getLocalPath(""static/images/download-48x48.png""), FileLocator.getLocalPath(""/media/static/images/download-48x48.png""));
			assertEquals(FileLocator.getLocalPath(""/var-6/static/images/download/static/images/download-48x48.png""), FileLocator.getLocalPath(""/var-6/static/images/download/static/images/download-48x48.png""));
			assertEquals(FileLocator.getLocalPath(""/var-6/static/images/download/static/images/download.png""), FileLocator.getLocalPath(""/var-6/static/images/download/static/images/download-48x48.png""));
		}
		
		@Test
		public void test3(){
			assertEquals(3, dqb.getCount());
			assertEquals(FileLocator.getLocalPath(""/media/testfile2.txt""), FileLocator.getLocalPath(""/media/testfile1.txt""));
			assertFalse(dqb.isAvailable(null));
			assertFalse(dqb.isAvailable(""""));
		}
		
		@Test
		public void test4(){
			// Set some more things up
			dqb.setDownloadLocation(FileLocator.getLocalPath(""/media/""));
			assertEquals(FileLocator.getLocalPath(""/media/testfile1.txt""), FILE_NAME);
			assertEquals(FileLocator.getLocalPath(""/media/testfile2.txt""), ""testfile2.txt"");
			assertEquals(FileLocator.getLocalPath(""/media/static/images""), ""static"");
        assertEquals(FileLocator.getLocalPath(""/media/static/images/download/static""), ""static"");
			assertEquals(FileLocator.getLocalPath(""/var-6/static""), ""static"");
			System.out.println(FileLocator.getLocalPath(""/media/testfile2.txt""));
			assertEquals(FileLocator.getLocalPath(""/var-6/static/images/download""), ""static/images"");
		}
}"
f4668ca0-89cb-4acd-8793-5002c64bc738,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResult.java,6.971336126327515,stop,"// SearchResult.java
package org.merlot.fedsearch.type;

public class SearchResult implements java.io.Serializable {

    public static org.apache.axis.description.TypeDesc getTypeDesc() {
        return typeDesc;
    }
}
","// SearchResultTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResult}.
* It contains one unit test case for the {@link SearchResult#getTypeDesc()} method.
*/
class SearchResultTest {","// SearchResultTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResult}.
* It contains one unit test case for the {@link SearchResult#getTypeDesc()} method.
*/
class SearchResultTest {

	@Test
	public void testGetTypeDesc(){
	
		
	}

}
// SearchResultTest.java
"
5a5eae32-03c2-4487-b523-5340d6080847,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultElement.java,12.703604221343994,stop,"// SearchResultElement.java
package org.merlot.fedsearch.type;

public class SearchResultElement implements java.io.Serializable {

    public static org.apache.axis.description.TypeDesc getTypeDesc() {
        return typeDesc;
    }
}
","// SearchResultElementTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResultElement}.
* It contains one unit test case for the {@link SearchResultElement#getTypeDesc()} method.
*/
class SearchResultElementTest {","// SearchResultElementTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResultElement}.
* It contains one unit test case for the {@link SearchResultElement#getTypeDesc()} method.
*/
class SearchResultElementTest {

    /**
    * Test case for {@link SearchResultElement#getTypeClass()}.
    * It contains one unit test case for the {@link SearchResultElement#getTypeDesc()} method.
    */
    @Test
    public void testGetTypeClass() {
        assertEquals(SearchElementType.class, searchResultElement.getTypeClass());
        assertNotNull(searchResultElement.getTypeDesc());
    }
    
}
"
