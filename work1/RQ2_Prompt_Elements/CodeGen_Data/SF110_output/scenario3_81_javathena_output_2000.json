[
{
    "choices": [
        {
            "text": "private\n\tprivate final static CharConfig config = CharConfig.initialDefault();\n\t// Test File paths with a basePath of '/etc'.\n\tprivate final static File root = new File(\"/etc\");\n\tprivate final static File test_root =\n            new File(root, Constants.TXT_TEST);\n\tprivate final static File home = new File(test_root, \"temp\");\n\tprivate final static File test = new File(\"/tmp\");\n\tprivate final static String str = \"/etc/test.txt\";\n\tprivate final static File testFile = new File(test.getPath() + str);\n\n\t@Test\n\tpublic void testLoad() throws IOException {\n\t\t//load character data without config\n\t\tconfig = CharConfig.initialDefault();\n\t\tIndexedFastMap<Integer, ROCharacter> map =\n                load(); /*load character data*/;\n\n\t\t//assertTrue(\"map.size() == 0\",map.isEmpty());\n\t\tassertEquals(\"map.size() == 0\",0,map.size());\n\n\t\t//load character data\n\t\tROCharacter roc = load();\n\t\tassertNotNull(\"null returned for loaded character\", roc);\n\t\tassertNotNull(\"no char created for loaded character\", roc.character);\n\n\t\t//assertTrue(\"ROC character.character.toString().startsWith(\n\t\t//    CharData.CHR_NAME_TO+\")\",\n\t\t//    ROCcharacter.character.toString().startsWith(CharData.CHR_NAME_TO+\"\"));\n\t\tIndexedFastMap<Integer, ROCharacter> roC = load();\n\t\tassertNotNull(\"null returned for loaded character ROC\", roC);\n\t\tassertFalse(\"load failed\", roc.character.equals(roC.character));\n\t\tassertFalse(\"same character\", roC.equals(map));\n\n\t\t// get loaded character by id\n\t\tRoCharacter roc2 = map.get(0x11);\n\t\tassertNotNull(\"null returned for loaded character with id 0x11\", roc2);\n\t\tassertEquals(\"character.toString().startsWith(\n                  \"Character (0x11 -> CharData \" +\n                  \"   characterId: 0x11) \" +\n                  \"   text: 'Test Character' \" +\n                  \"   basePath: '\" +\n                  String\n                  + test_root)\n                  , roc2.getBaseName());\n\t\tassertTrue(\"character.isLoaded()==false\", roc2.isLoaded());\n\n//\t\tassertEquals(\"loaded ROCharacter by id\", map.get(0x11).character,roc);\n\t\tassertEquals(\"loaded ROCharacter by id\", roc2.character, map.get(0x11));\n\t}\n\n\tprivate RoCharacter load() throws IOException {\n\t\tROCharacter roc = ROCharacter.initialDefault();\n\t\tFileOutputStream fOut = null;\n\t\ttry {\n\t\t\tfOut = new FileOutputStream(testFile);\n\t\t} catch (FileNotFoundException e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\tBufferedReader in = null;\n\t\ttry {\n\t\t\tin = new BufferedReader(new FileReader(test));\n\t\t\tBufferedReader in1 = null;\n\t\t\ttry {\n\t\t\t\tin1 = new BufferedReader(new FileReader(test));\n\t\t\t\twhile (in.ready()) {\n\t\t\t\t\tin1.readLine();\n\t\t\t\t\tString [] line = in1.readLine().split(\" \");\n\t\t\t\t\tassertEquals(\"line[0]\", line[0], roc.getBaseName());\n\t\t\t\t\tassertTrue(\"line[1]\", line.length==2);\n\t\t\t\t\tassertEquals(\"character.toString().startsWith(\n        \t\t\t\t    \"Character (0x11 -> CharData \" +\n        \t\t\t\t    \"   characterId: 0x11) \" +\n        \t\t\t\t    \"   text: 'Test Character' \" +\n        \t\t\t\t    \"   basePath: '\" +\n        \t\t\t\t    filePath\n        \t\t\t\t    + filePath.getPath()\n        \t\t\t\t    + str\n        \t\t\t\t    + \")\",\n        \t\t\t\t    line[1]);\n\t\t\t\t\tmap.addEntry(0x11, roc);\n\t\t\t\t\tassertTrue(\"roc.character.equals(map.get(0x11)), roc.character.equals(map.get(0x11))\", roc.character.equals(map.get(0x11)));\n\t\t\t\t\tif (in!= null) {\n\t\t\t\t\t\tin1.readLine();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t//assertTrue(\"loaded characters after load\",roc.character.equals(\n\t\t\t\t\t //map.get(0x11)),\n\t\t\t\t\t//\troc.character.equals(map.get(0x11)));\n\t\t\t\tif (in1!= null) {\n\t\t\t\t\tin1.close();\n\t\t\t\t\tin1 = null;\n\t\t\t\t}\n\t\t\t\tin = null;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tin.close();\n\t\t\t\t} catch (Exception e2) {\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tin1.close();\n\t\t\t\t} catch (Exception e2) {\n\t\t\t\t}\n\t\t\t\tin = null;\n\t\t\t}\n\t\t} catch (Exception e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\tassertNull(\"No return for invalid character\",in);\n\n\t\tassertTrue(\"loaded ROCharacter by id\", roc.character.equals(map.get(0x11)));\n\t\tfOut.close();\n\t\treturn roc;\n\t}\n\n\tprivate ROCharacter ROCharacterTest = null;\n\tprivate ROCharacter ROCharacterLoad = null;\n\tprivate ROCharacter ROCharacterEmpty = null;\n\tprivate ROCharacter ROCharacterGetBaseName = null;\n\tprivate ROCharacter ROCharacterToString = null;\n\tprivate ROCharacter ROCharacterToBaseName = null;\n\tpublic static ROCCharacter ROCharacterNew = null;\n\n\tprivate static void\n\tload(\n\t    RoCharacter roc1,\n\t    ROCharacter roc2\n\t)\n\t{\n\t\tassertTrue(\"load failed\", false);\n\t\tFILE_PATH RO",
            "finish_reason": "length"
        },
        {
            "text": "\n\t@Test\n\tpublic void oneTest() {\n        /* Load the TxtChars as defined in the file \"TestTxtChars.txt\" */\n\t    /* The file has to be the main config file in order for this \n\t     * to work correctly. */\n\t\t\n\t\t// Load the main config file\n\t    CharConfig mainCfg = CharConfig.loadMainFile();\n\t    mainCfg.getCharsAsIndexFile();\n\t    \n\t    /* Construct the first TxtCharacter */\n\t\t/* Test method for {@link TXTCharacter#load()} */\n\t\tIndexedFastMap<Integer, ROCharacter> initialCfg = TXTCharacter.load();\n\t\t\n\t\t/* Test method for {@link TXTCharacter#load()} */\n\t\tIndexedFastMap<Integer, ROCharacter> reloadedCfg = TxtCharacter.load();\n\t\t\n\t\t/* Compares the two indexed maps */\n\t\t\n\t\t// Compare the indexes of loaded character.\n\t    assertArrayEquals(initCfg.getKeys(), reloadedCfg.getKeys());\n\t    \n\t    // Compare the main config.\n\t    assertArrayEquals(mainCfg.getCharsAsIndexFile(), reloadedCfg.getKeys());\n\t}\n\t\n\t\n\t/*\n\t * Tests the index operation\n\t *\n\t */\n\t\n\t@Test\n\tpublic void twoTests() {\n\t    /* A map with one character */\n\t    IndexedFastMap<Integer, ROCharacter> indexedMainCfg = load();\n\t    \n\t    ROCharacter roMainCfg = indexedMainCfg.getKeys()[0];\n\t    \n\t    assertEquals(\"Test character not loaded\", roMainCfg.getName(), \"TestCharacter\");\n\t    \n\t    /* A map with two characters */\n\t    \n\t    IndexedFastMap<Integer, ROCharacter> indexedTxtMainCfg = load();\n\t    \n\t    IndexedFastMap<Integer, ROCharacter> indexedTxtCfg = indexedTxtMainCfg.getKeys();\n\t    assertNotNull(\"Indexed map not found\", indexedTxtCfg);\n\t    \n\t    assertArrayEquals(\"Test character not loaded\", indexedMainCfg.getKeys().length,\n\t                       indexedTxtCfg.getKeys().length);\n\t}\n\t\n\t@Test\n\tpublic void threeTests() {\n\t    ROCharacter roTxtMainCfg = load().getKeys()[0];\n\t    \n\t    assertEquals(\"Test character not loaded\", roTxtMainCfg.getName(), \"TestCharacter\");\n\t}\n\n\tprivate static final File TAB = File.createTempFile(\"Test\", \".txt\");\n\t\n\tprivate static FileReader TxtFileReader = null;\n\tprivate FileReader TxtReader = null;\n\t\n\t@Test\n\tpublic void saveAndLoadTxtReader() throws IOException {\n\t    /* File reader and buffer for saving the Txt Chars' data */\n\t\t\n\t\t// Initializes a temp reader\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new FileReader(TAB));\n\t\t\n\t\t// Initializes the Txt reader\n\t\t\n\t\tTxtReader = new FileReader(TxtFileReader);\n\t\t\n\t\t// Reads the Txt from Txt File\n\t\t\n\t\tString txt = reader.readLine();\n\t\t\n\t\t/* Check the contents */\n\t\t\n\t\tassertNotNull(\"File must not be null\", txt);\n\t\tassertTrue(\"File must be a valid file\", txt.length() > 0);\n\t\t\n\t\tindexedTxtCfg = TXTCharacter.load();\n\n\t\tassertTrue(\"Indexed character map must be a map\", indexedTxtCfg!= null);\n\t}\n\t\n\t@Test\n\tpublic void saveAndLoadTxtReader() throws IOException {\n\t    /* File reader and buffer for saving the Txt Chars' data */\n\t\t\n\t    // Initializes a temp reader\n\t    \n\t    BufferedReader reader = new BufferedReader(new FileReader(TAB));\n\t    \n\t    // Initializes the Txt reader\n\t    \n\t    TxtReader = new FileReader(TxtFileReader);\n\t    \n\t    // Reads the Txt from Txt File\n\t    \n\t    String txt = reader.readLine();\n\t    \n\t    /* Check the contents */\n\t    \n\t    assertNotNull(\"File must not be null\", txt);\n\t    assertTrue(\"File must be a valid file\", txt.length() > 0);\n\t    \n\t    indexedTxtCfg = TXTCharacter.load();\n\n\t    assertTrue(\"Indexed character map must be a map\", indexedTxtCfg!= null && indexedTxtCfg.size() <= 0);\n\t    \n\t    /* Check the loaded map's size */\n\t     \n\t    int loadedSize = indexedTxtCfg.size();\n\t    \n\t\t/* Check that TxtCfg has all loaded characters in its main map */\n\t\t\n\t\tassertTrue(\"There must be loaded character\", loadedSize == indexedTxtCfg.size());\n\t\t \n\t\t/* Load the Txt file */\n\t\t\n\t\t/* Unsupported by this test suite */\n\t    /*\n\t    String content = \"The quick brown fox jumps over the lazy dog\";\n\t\tindexedTxtCfg = TxtCharacter.load(content);\n\t\t\n\t\tassertEquals(\"File contents\", content, indexedTxtCfg.toString());\n\t\t\n\t\t*/\n\t}\n\t\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n    /**\n     * Test for loading a character from an xml_file.\n     */\n    @Test\n    void testCharacterLoad() throws IOException {\n        String fName = \"./sample\";\n        String fDir = \"./xml\";\n        File f = new File(fName);\n        f = new File(fDir);\n        BufferedReader freader = new BufferedReader(new FileReader(f));\n        try {\n            FileReader fr = new FileReader(freader);\n            String readLine;\n            StringBuilder readbufs = new StringBuilder();\n\n            while ((readLine = freader.readLine())!= null) {\n                readbufs.append(readLine);\n            }\n\n            freader.close();\n            fr.close();\n            f = new File(fName);\n\n\n            String readFile = readbufs.toString();\n            assertEquals(readFile, \"#ROOT\\n\" +\n\t\t\t      \"    class ROCharacter {\\n\" +\n                            \"        @Override\\n\" +\n                            \"        public void playToJail() {\\n\" +\n                            \"        }\\n\" +\n                            \"        //@Override\\n\" +\n                            \"        int getName() {\\n\" +\n                            \"            return 0;\\n\" +\n                            \"        }\\n\" +\n                            \"        //@Override\\n\" +\n                            \"        void playToPavillion() {\\n\" +\n                            \"        }\\n\" +\n                            \"        /*@Override\\n\" +\n                            \"        public void playToHanoi() {\\n\" +\n                            \"        }\\n\" +\n                            \"        //@Override\\n\" +\n                            \"        public void playToDuke() {\\n\" +\n                            \"        }\\n\" +\n                            \"        @Override\\n\" +\n                            \"        public void playToMonster() {\\n\" +\n                            \"        }\\n\" +\n                            \"        @Override\\n\" +\n                            \"        public void playToWar() {\\n\" +\n                            \"        }\\n\" +\n                            \"    }\\n\"\n                        );\n        } catch (IOException ex) {\n            fail();\n        } finally {\n            f.delete();\n        }\n\n        f = new File(fDir);\n        freader = new FileReader(f);\n        readLine = freader.readLine();\n        assertNotNull(readLine);\n        readFully(f, readLine);\n    }\n    \n    @Test\n    void testCharacterFailedLoad() throws IOException {\n        String fName = \"./sample\";\n        String fDir = \"./xml\";\n        File f = new File(fName);\n        f = new File(fDir);\n        BufferedReader freader = new BufferedReader(new FileReader(f));\n        try {\n            FileReader fr = new FileReader(freader);\n            String readLine;\n            StringBuilder readbufs = new StringBuilder();\n\n            while ((readLine = freader.readLine())!= null) {\n                readbufs.append(readLine);\n            }\n\n            freader.close();\n            fr.close();\n            f = new File(fName);\n\n            String readFile = readbufs.toString();\n            System.err.println(readFile);\n            assertEquals(readFile, \"#ROOT\\n\" +\n\t\t\t      \"         * ROCharacter\\n\" +\n                            \"   #ROOT\\n\" +\n                            \"  @{}\";\n        } catch (IOException ex) {\n            fail();\n        } finally {\n            f.delete();\n        }\n    }\n    \n    @Test\n    void testCharacterFailedLoadFromDifferentFormat() throws IOException {\n        int formatNumber = 1400; // 1500+\n        String fName = \"./sample\";\n        String fDir = \"./xml\";\n        File f = new File(fName);\n        f = new File(fDir);\n        BufferedReader freader = new BufferedReader(new FileReader(f));\n        try {\n            FileReader fr = new FileReader(freader);\n            String readLine;\n            StringBuilder readbufs = new StringBuilder();\n\n            while ((readLine = freader.readLine())!= null) {\n                readbufs.append(readLine);\n            }\n\n            freader.close();\n            fr.close();\n            f = new File(fName);\n\n            String readFile = readbufs.toString();\n            System.err.println(readFile);\n            assertEquals(readFile, \"#ROOT\\n\" +\n\t\t\t      \"         * ROCharacter\";\n        } catch (IOException ex) {\n            fail();\n        } finally {\n            f.delete();\n        }\n    }\n    \n    \n    private void fail() throws IOException {\n        fail();\n    }\n\n    private String readChars(BufferedReader fr) throws IOException {\n        StringBuffer chars = new StringBuffer();\n        char[] buff = new char[256];\n        for (int readIndex = 0; readIndex < 256; readIndex++) {\n            buff[readIndex] = (char) fr.read();\n        }\n        chars.append(new String(buff));\n        buff = null;\n        return chars.toString();\n    }\n    \n    private void readFully(File fp, String str) throws IOException {\n        FileReader fr = new FileReader(fp);\n        char[] buff = new char[256];\n        for (int readIndex = 0; readIndex < 256; readIndex++) {\n            buff[readIndex] = (char) fr.read();\n        }\n        fr.close();\n        str.replace(\"\\\"\", \"\");\n        str.replace(\"\\\\\", \"\");\n        assertEquals(str, new String(buff));\n    }\n\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t/**\n\t * Load character under the last format version only version 0 (homun +\n\t * mapindex maps)\n\t *\n\t * @return indexed\n\t * @throws {@link IOException}\n\t */\n\t@Test\n\tpublic void testLoad_EmptyFile() throws IOException {\n\t\tFileReader reader = new FileReader(\"txt_test.txt\");\n\t\tIndexedFastMap<Integer, ROCharacter> fastMap = TXTCharacter.load(reader);\n\t\tassertNotNull(fastMap);\n\t\tassertEquals(1, fastMap.size());\n\t\tassertEquals(200, fastMap.get(200));\n\t\tassertEquals(255, fastMap.get(150));\n\t}\n\n\t/**\n\t * Load character with a version greater than current version (homun + mapindex\n\t * maps)\n\t *\n\t * @return indexed\n\t * @throws {@link IOException}\n\t */\n\t@Test\n\tpublic void testLoad_VersionGTWithCurrentVersion() throws IOException {\n\t\tFileReader reader = new FileReader(\"txt_test.txt\");\n\t\tFile formatVersion = new File(\"txt_test_v\" + Fast.getFormatVersion() + \".txt\");\n\t\tIndexedFastMap<Integer, ROCharacter> fastMap = TXTCharacter.load(reader, formatVersion);\n\t\tassertNotNull(fastMap);\n\t\tassertEquals(1, fastMap.size());\n\t\tassertEquals(200, fastMap.get(200));\n\t}\n\n\t/**\n\t * Load character with a version greater than current version (homun + mapindex\n\t * maps)\n\t *\n\t * @return indexed\n\t * @throws {@link IOException}\n\t */\n\t@Test\n\tpublic void testLoad_VersionGTWithCurrentVersionWithoutFile() throws IOException {\n\t\tFileReader reader = new FileReader(\"UTF-8\");\n\t\tFile formatVersion = new File(\"UTF-8\");\n\t\tIndexedFastMap<Integer, ROCharacter> fastMap = TXTCharacter.load(reader, formatVersion);\n\t\tassertNotNull(fastMap);\n\t\tassertEquals(0, fastMap.size());\n\t}\n\n\t/**\n\t * Test method for {@link TXTCharacter#load(File)}\n\t */\n\t@Test\n\tpublic void testLoad() throws IOException {\n\t\tFileReader reader = new FileReader(\"txt_test.txt\");\n\t\tIndexedFastMap<Integer, ROCharacter> fastMap = TXTCharacter.load(reader);\n\t\tassertNotNull(fastMap);\n\t\tassertEquals(1, fastMap.size());\n\t\tassertEquals(200, fastMap.get(200));\n\t\tassertEquals(255, fastMap.get(150));\n\t}\n\n\t/**\n\t * Test method for\n\t * {@link TXTCharacter#load(File, int)}\n\t *\n\t * @throws {@link IOException}\n\t */\n\t@Test\n\tpublic void testLoad_BadFile() throws IOException {\n\t\tFileReader reader = new FileReader(\"txt_test.txt\");\n\t\tIndexedFastMap<Integer, ROCharacter> fastMap = TXTCharacter.load(reader, 0);\n\t\tassertNotNull(fastMap);\n\t\tassertEquals(1, fastMap.size());\n\t\tassertEquals(200, fastMap.get(200));\n\t\tassertEquals(255, fastMap.get(150));\n\t}\n\n\t/**\n\t * Test method for\n\t * {@link TXTCharacter#load(File, int)}\n\t *\n\t * @throws {@link IOException}\n\t */\n\t@Test\n\tpublic void testLoad_WrongFormat() throws IOException {\n\t\tFileReader reader = new FileReader(\"Bad_txt_test.txt\");\n\t\tIndexedFastMap<Integer, ROCharacter> fastMap = TXTCharacter.load(reader, 0);\n\t\tassertNotNull(fastMap);\n\t\tassertEquals(2, fastMap.size());\n\t}\n\n\t/**\n\t * Test method for\n\t * {@link TXTCharacter#load(File, int)}\n\t *\n\t * @throws {@link IOException}\n\t */\n\t@Test\n\tpublic void testLoad_WorseType() throws IOException {\n\t\tFileReader reader = new FileReader(\"txt_test.txt\");\n\t\tIndexedFastMap<Integer, ROCharacter> fastMap = TXTCharacter.load(reader, 0);\n\t\tassertNotNull(fastMap);\n\t\tassertEquals(1, fastMap.size());\n\t\tassertEquals(150, fastMap.get(200));\n\t}\n\n\t/**\n\t * Check character by object and by its name\n\t *\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testLoad() throws IOException {\n\t\tFileReader reader = new FileReader(\"txt_test.txt\");\n\t\tIndexedFastMap<Integer, ROCharacter> fastMap = TXTCharacter.load(reader);\n\t\tROCharacter character = fastMap.get(200);\n\t\tassertNotNull(character);\n\t\tROCharacter character2 = fastMap.get(150);\n\t\tassertNotNull(character2);\n\t}\n\n\t/**\n\t * Check character by object and by its name\n\t *\n\t * @throws MalformedDataException\n\t */\n\t@Test\n\tpublic void testLoadCharByName() throws IOException {\n\t\tFileReader reader = new FileReader(\"txt_test.txt\");\n\t\tIndexedFastMap<Integer, ROCharacter> fastMap = TXTCharacter.load(null, reader);\n\t\tROCharacter character = fastMap.get(200);\n\t\tROCharacter character2 = fastMap.get(150);\n\t\tassertNotNull(character);\n\t\tassertNotNull(character2);\n\t}\n\n\t/**\n\t * Check character by object and by its name (not loaded yet)\n\t *\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testLoadCharCharacterByNameAsync() throws IOException {\n\t\tFileReader reader = new FileReader(\"txt",
            "finish_reason": "length"
        },
        {
            "text": "/**\n\t\t * Executed once before each test is run.\n\t\t */\n\t\t\tpublic static File getTestDirectory()\n    \t\t\t\t{\n\t\t\t\treturn new File(CharacterTestPath);\n    \t\t\t}\n\n    /**\n     * Executed once before each test is run.\n     */\n        @Test\n\t\tpublic void testLoad()\n                {\n                    // Load character.\n                    try {\n                        TXTCharacter character = TVTI.load()\n                               .field(TXTCharacter.class, \"name\", \"Hiraka\")\n                               .load();\n                        assertEquals(\"Hiraki\",\"Hiraka\",character.getName());\n                        assertEquals(\"Hiraki\",\"Hiraka\",character.getName());\n                        assertEquals(TXTCharacter.class.getSimpleName(),\"TXTCharacter\");\n                    }\n                    catch (IOException ex)\n                    {\n                        fail(\"File not found: \"+ex.getMessage());\n                    }\n                    catch (ClassNotFoundException ex)\n                    {\n                        fail(\"Class not found.\");\n                    }\n        }\n\n\t\t/**\n\t\t * Executed once before each test is run.\n\t\t */\n\t\t\tpublic static final String getName(ROCharacter charObj)\n\t\t\t\t{\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString name = Functions.<String>findField(ROCharacter.class, \"name\");\n\t\t\t\t\t\tif (String.valueOf(charObj.getName()).equals(name)) return Functions.getFirstField(ROCharacter.class, \"name\");\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\treturn String.valueOf(charObj.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\n    /**\n     * Executed once before each test is run.\n     * @throws IOException \n     */\n        @Test\n\t\tpublic void testLoadF()\n                {\n                    // Load character with first character as first entry\n                    try {\n                        TXTCharacter character = TVTI.load()\n                               .field(ROCharacter.class, \"name\")\n                               .load(getName(ROCharacter.class));\n                        assertEquals(\"Hiraki\",character.getName());\n                        assertEquals(ROCharacter.class.getSimpleName(),\"ROCharacter\");\n                    }\n                    catch (IOException ex) {\n                        fail(\"File not found: \"+ex.getMessage());\n                    }\n                    catch (ClassNotFoundException ex)\n                    {\n                        fail(\"Class not found.\");\n                    }\n                }\n\n    /**\n     * Executed once before each test is run.\n     * @throws IOException \n     */\n        @Test\n\t\tpublic void testLoadS()\n                {\n\n                    // Load character with first character as first entry\n                    try {\n\n                        TVTI.load()\n                               .field(ROCharacter.class, \"name\", getName(ROCharacter.class))\n                               .load(Character.getCharacterType(ROCharacter.class.getName()));\n\n                            String name = Functions.findField(ROCharacter.class, \"name\");\n                        assertEquals('H',Character.getCharacterType(name).getSuffix());\n                        assertEquals('r',Character.getCharacterType(name).getPrefix());\n                    }\n                    catch (IOException ex) {\n                        fail(\"File not found: \"+ex.getMessage());\n                    }\n                    catch (ClassNotFoundException ex) {\n                        fail(\"Class not found.\");\n                    }\n\n                }\n\n                /**\n                 * Executed once before each test is run.\n                 * @throws IOException \n                 */\n                @Test\n                void testLoadP()\n                        throws IOException {\n                            try (\n                                    BufferedReader read = new BufferedReader(new FileReader(getTestDirectory().getAbsolutePath()+ File.separator + \"charTest0.txt\"));\n                                    PrintWriter output = new PrintWriter(new FileWriter(getTestDirectory().getAbsolutePath()+ File.separator + \"charTest0P.txt\"))\n                               ) {\n\t\t\t\tread.readLine();\n\t\t\t\toutput.println(\"NAME\");\n\t\t\t\tassertTrue(Functions.<String[]>findList(ROCharacter.class, \"name\")\n\t\t\t\t\t.isEmpty());\n\t\t\t\tassertTrue(Functions.<String>findList(ROCharacter.class, \"name\")\n\t\t\t\t\t.containsAll(new String[]{\"Hiraki\",getName(ROCharacter.class), \"Hiraki\",getName(ROCharacter.class)}));\n\t\t\t\tread.readLine();\n\t\t\t\toutput.println(\"RANK\");\n\t\t\t\tassertEquals(100,Functions.<Integer>findList(ROCharacter.class, \"rank\").size());\n                }\n\t\t}\n\n\t\t/**\n\t\t * Executed once before each test is run.\n\t\t * @throws IOException \n\t\t */\n\t\t@Test\n\t\tpublic void testLoadX() throws IOException {\n\t\t\tFile charPath = new File(getTestDirectory().getAbsolutePath() + File.separator + \"charTest1.txt\");\n\t\t\t// Load character with first character as first entry\n\t\t\ttry {\n\t            String name = Functions.<String>findField(ROCharacter.class, \"name\");\n\t            IndexedFastMap<Integer, ROCharacter> charMap = Functions\n\t               .findEntries(ROCharacter.class, \"name\", getName(ROCharacter.getCharacterType(name)));\n\t            assertEquals(\"Hiraki\",\"Hiraki\",Functions.findFirst((IndexedFastMap<Integer, ROCharacter>)Functions.findEntries(ROCharacter.class, \"name\", \"Hiraki\")));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tfail(\"File not found: \"+charPath.getAbsolutePath());\n\t\t\t}\n\t\t}\n\n\n       /**\n* Test of <code>getName()</code> method, of class  {@link TXTCharacter}.\n*/\n            @Test\n        public void testGetName()\n            {\n                Class<?> inst = ROCharacter.class;\n                Class<?> char1 = ROCharacter.class;\n                String name = \"name\";\n                assertEquals",
            "finish_reason": "length"
        },
        {
            "text": "public void testLoad(){\n\t\t\ttry {\n\t\tString f = \"character\";\n\t\tFile f1 = new File(chkPath, f);\n\t\tBufferedReader br = new BufferedReader(new FileReader(f1));\t\t\t\n\t\tint pos;\n\t\t//test the new format 1500 files\n\t\twhile ((pos=br.readLine().indexOf(\"Version: \"))!=-1) {\n\t\t\t//check for the format version at the end. If so, break the loop..\n\t   \t\tint end = pos+5;\n\t   \t\tif(br.readLine().indexOf(\"Version: \")!=-1) end = pos+5;\n\t   \t\tf1.delete();\n  \n\t   \t\t//test the new format\n\t   \t\tThread.sleep(1000);\t\n\t\t}\n\t\tassertTrue(br.readLine().indexOf(\"Version: \")!=-1);\n\t\t\n\t\t//read the first line\n\t\tString line = br.readLine();\n\t\t\tassertEquals(line, \"<!DOCTYPE file version=\\\"1\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\">\\n<file name=\\\"character.txt\\\">\\n\");\n\t\t//assertReadLines(\"character.txt\");\n\t\t\n\t\t//read the data from the new format\n\t\t//Read the data from the new format\n\t}\n\n\t\tpublic void testLoad_without_file(){\n\t\ttry {\n\t\t\tThread.sleep(10000);\n\t\t} catch(InterruptedException e) {}\n\t\tFile f = new File(\"D:\\\\temp\\\\testfile.txt\");\n\t\tFileReader r = new FileReader(f);\n\t\tBufferedReader br = new BufferedReader(r);\n\t\tString line;\n\t\t//test the original file\n\t\ttry {\n\t\t\tline = br.readLine();\n\t\t\tassertEquals(\"Hello,World\",line);\n\t\t} catch(IOException e){\n\t\t\tassertTrue(false);\n\t\t}\n\t\t\t\n\t\t//Read the next line\n\t\twhile ((line = br.readLine())!=null){\n\t\tassertTrue(\"Hello,World\", line.equals(\"Hello,World\"));\n\t\t}\n\t}\n\n\t\tpublic void testEmptyCharacter(){\n\t\t//generate the file\n\t\tFile f = new File(\"D:\\\\temp\\\\testfile.txt\");\n\t\tFileReader r = new FileReader(f);\n\t\tBufferedReader b = new BufferedReader(r);\n\t\twhile(true) {\n\t\t\tString line = b.readLine();\n\t\t\tif(line==null) \n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//read the file\n\t\tint pos;\n\t\tString line;\n\t\twhile ((line = b.readLine())!=null) {\n\t\t\tassertEquals(\"Hello,World\",line);\n\t\t\tpos = line.indexOf(\":\");\n\t\t\tassertEquals(pos,6 && line.length()-pos-1>4 && line.length()-pos-1<9 && line.substring(pos+1,pos+2).equals(\"\\\"\\\"\"));\n\t\t}\n\t\tf.delete();\n\t}\n\n\tpublic void assertReadLines(String f){\n\t\ttry {\n\t\t\tThread.sleep(10000);\n\t\t\tBufferedReader br = new BufferedReader(new FileReader(f));\n\t\t\tString line;\n\t\t\twhile ((line = br.readLine())!=null) {\n\t\t\t\tAssert.assertTrue(line.substring(0,1).equals(\"!\") && line.substring(1,14).equals(\"\\\"\"));\n\t\t\t}\n\t\t} catch(InterruptedException e) {}\n\t}\n\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t/**\n\t * Test of load method, of the class {@link TXTCharacter}.\n\t */\n\t@Test\n\tpublic void loadFile() {\n\t\t// TODO This test needs major fix\n\t\tString filename = \"data/data/characters.txt\";\n\t\t\n\t\tIndexedFastMap<Integer, ROCharacter> loaded = TXTCharacter.load(filename);\n\t\tassertNotNull(\"Cannot load character file\", loaded);\n\t}\n\n\t@Test\n\tpublic void loadFile2() {\n\t\t\n\t\tFile f = new File(\"data/data/characters.txt\");\n\t\tIndexedFastMap<Integer, ROCharacter> loaded = TXTCharacter.load(f);\n\t\tassertNotNull(\"Cannot load character file\", loaded);\n\t}\n}\n\n// TXTCharacterMapTest.java\npackage org.character.data.Config;\n\npublic class TXTCharacterMapTest {\n\n    @Test\n    public void test() throws IOException {\n        \n        String fileName = \"data/data/characters_map.txt\";\n        IndexedFastMap<Integer, ROCharacter> indexed = TXTCharacter.load(fileName);\n        \n        assertNotNull(\"Cannot load character file\", indexed);\n        ROCharacter temp = indexed.get(16000);\n        assertEquals(\"A character with ID=16000 should be found\", 816000000, temp.getId());\n        assertEquals(\"A character with ID=816000000 should be found\", 816000000, indexed.get(816000000));\n    }\n}",
            "finish_reason": "stop"
        },
        {
            "text": "\n    @Test\n    public void test1() throws IOException {\n        // Test case 1\n        \n        // Load character under the last format version only version 1500 (homun +\n        // mapindex maps)\n        String fileName = new File(CharConfig.BETA_XML).getName();\n        \n        BufferedReader reader = new BufferedReader(new FileReader(new File(new File(CharConfig.DATA_FOLDER_C, fileName).getCanonicalPath()), \"UTF8\"));\n        String data = reader.readLine();\n        reader.close();\n        \n        ROCharacter character = TXTCharacter.load(data);\n        \n        assertTrue(character.getData() instanceof String);\n        \n        assertTrue(Functions.notNull(character.getClass(), \"character\"));\n    }\n\t\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "public static void main(String[] args) {\n\t\t\n\t\t}\n\t\t@javax.inject.Inject(scope = CharConfig.class)\n\t\tprivate CharConfig   config;\n\t\t\n\t\t/**\n\t\t* Function to load character under the last\n\t\t*  formats version {NODE, VERSION}\n\t\t*/\n\t\t@Test\n\t\tvoid loadCharacterWithoutName() throws IOException {\n\t\t\tindexMap();\n\t\t\tString path =  FileUtil.getHomeDir().getAbsolutePath() + \"/char/character/test/txt/txt\"\n                            + File.separatorChar+ \"_1504_test.txt\";\n\t\t\tBufferedReader reader = new BufferedReader(new FileReader(new File(path)));\n\t\t\tString element = reader.readLine();\n\t\t\tassertNull(element);\n\t\t}\n\t\t@Test\n\t\tvoid loadCharacterWithNullName() throws IOException {\n\t\t\tloadCharacter(\"NODE\", null);\n\t\t}\n\t\t@Test(expected = IllegalArgumentException.class)\n\t\tvoid loadCharacterWithNameWithoutPath() throws IOException {\n\t\t\tloadCharacter(\"NODE\", \" \");\n\t\t}\n\t\t@Test(expected = IllegalArgumentException.class)\n\t\tvoid loadCharacterWithNameWithLongPath() throws IOException {\n\t\t\tloadCharacter(\"NODE\", FilenameUtils.addExtension(\"NODE\"));\n\t\t}\n\t\t@Test\n\t\tvoid loadCharacterWithName() throws IOException {\n\t\t\tString path =  FileUtil.getHomeDir().getAbsolutePath() + \"/char/character/test/txt/txt\"\n                            + File.separatorChar+ \"_1504_test.txt\";\n\t\t\tBufferedReader reader = new BufferedReader(new FileReader(new File(path)));\n\t\t\tString element = reader.readLine();\n\t\t\tassertNotNull(element);\n\t\t\tassertEquals(\"NODE\", element);\n\t\t}\n\t\t@Test\n\t\tvoid loadCharacterWithoutNameAndSetMapIndex() throws IOException {\n\t\t\tint count = 10;\n\t\t\tconfig.setMapIndexMap(null);\n\t\t\tconfig.setMapIndex(new Integer[0]);\n\t\t\tindexMap();\n\t\t\tString path =  FileUtil.getHomeDir().getAbsolutePath() + \"/char/character/test/txt/txt\"\n                            + File.separatorChar+ \"_1504_test.txt\";\n\t\t\tString[] fileNodes = readFile(path);\n\t\t\tFile[] files = new File[count];\n\t\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\t\tfiles[i] = new File(fileNodes[i]);\n\t\t\t}\n\t\t\tReader reader = new BufferedReader(new FileReader(new File(files[0].getAbsolutePath())));\n\t\t\tString character = new BufferedReader(new BufferedReader(reader)).readLine();\n\t\t\treader.close();\n\t\t\tcharacters(fileNodes, 1);\n\t\t\tcharacters(new File(files[1].getAbsolutePath()), 1);\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tif (count <= files[i].length()) {\n\t\t\t\t\t\tbuffToIterator(files[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t@Test\n\t\tvoid loadCharacterWithSetMapIndex() throws IOException {\n\t\t\tString file =  FileUtil.getHomeDir().getAbsolutePath()\n                            + \"/char/character/test/txt/txt\"\n                            + File.separator + \"_1504_test.txt\";\n\t\t\tconfig.setMapIndexMap(config.getMapIndexMap());\n\t\t\tconfig.setMapIndex(config.getMapIndex());\n\t\t\tindexMap();\n\t\t\tcharacters(getFileNodes(file), 1);\n\t\t\tcharacters(new File(file), 1);\n\t\t\ttry {\n\t\t\t\treadFile(file);\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t* Function to search character\n\t\t*/\n\t\tpublic String[] getFileNodes(String file) throws IOException {\n\t\t\tloadCharacter(null, file);\n\t\t\treturn readFile(file);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Function to load character\n\t\t*\n\t\t* @param path\n\t\t* @param file\n\t\t* @return\n\t\t* @throws IOException\n\t\t*/\n\t\tpublic static String[] readFile(String file) throws IOException {\n\t\t\tBufferedReader br = new BufferedReader(new FileReader(new File(file)));\n\t\t\tString character = null;\n\t\t\tint pos = 0;\n\t\t\twhile ((character = br.readLine())!= null) {\n\t\t\t\tpos += \"\".length();\n\t\t\t\tcharacter = character.substring(0, pos);\n\t\t\t}\n\t\t\tbr.close();\n\t\t\treturn character.replace(\"\\n\", \"\").replace(\"\\r\", \"\").split(\",\");\n\t\t}\n\t\t\n\t\t/**\n\t\t* Function to search character\n\t\t*\n\t\t* @param c\n\t\t* @param in\n\t\t* @return\n\t\t* @throws IOException\n\t\t*/\n\t\tpublic static String[] searchFile(String c, String in) throws IOException {\n\t\t\tBufferedReader br = new BufferedReader(new FileReader(new File(in)));\n\t\t\tString character = null;\n\t\t\tint pos = 0;\n\t\t\tboolean found = false;\n\t\t\tString [] results = new String[0];\n\t\t\tchar [] achr = new char[c.length()+1];\n\t\t\tfor(int i = 0; i < c.length()+1; i++) {\n\t\t\t\tachr[i] = c.charAt(i);\n\t\t\t}\n\t\t\tachr[0] = '\\",
            "finish_reason": "length"
        },
        {
            "text": "\n\tprivate static TXTCharacter character;\n\tprivate static TXTRecord record;\n\t\n\t/**\n\t* Loads the character under the last test version only version 1500\n\t*/\n\t@Test\n\tpublic void loadTXTCharacterTest() throws IOException {\n\t\t\n\t\tloadFileTXTCharacter();\n\t\t\n\t\tassertTrue(Functions.isFileExists(new File(new File(\"tmp/file.txt\"))));\n\t\t\n\t}\n\t\n\t/**\n\t* Loads the character under the latest format version\n\t*/\n\t@Test\n\tpublic void loadTXTCharacter() throws IOException, MalformedDataException {\n\t\t\n\t\tFile fileTxt = new File(new File(\"tmp/file.txt\"));\n\t\t\n\t\tboolean failed = false;\n\t\t\n\t\twhile (!fileTxt.exists()) {\n\t\t\tif (failed) {\n\t\t\t\tfail(\"File already deleted\");\n\t\t\t} else {\n\t\t\t\tfailed = true;\n\t\t\t}\n\t\t\tfileTxt = new File(new File(\"tmp/file.txt\"));\n\t\t\t\n\t\t\trecord = TXTRecord.read(new FileReader(fileTxt));\n\t\t\tfileTxt.delete();\n\t\t}\n\t\t \n\t\tassertTrue(record.isValid());\n\n\t\trecord = TXTRecord.load(new FileReader(fileTxt));\n\t\t\n\t\tassertTrue(record.isValid());\n\t\t\n\t\tassertTrue(Functions.isFileExists(new File(\"tmp/file.txt\")));\n\t\tassertTrue(record.getName()!= null);\n\t\t\n\t}\n\t\n\t/**\n\t* Returns all the character indexes loaded for a given version\n\t* @param version the test version\n\t* @return all the character indexes in an indexedFastMap indexed by index\n\t*/\n\t@Test\n\tpublic IndexedFastMap<Integer, ROCharacter> load(int version) throws IOException {\n\t\t\n\t\treturn load(version, false);\n\t}\n\t\n\t/**\n\t* Returns all the character indexes loaded for a given version in specified\n\t* directory\n\t* @param version the test version\n\t* @param directory whether the character indexes will be returned in a sub-\n\t* directory\n\t* @return all the character indexes in an indexedFastMap indexed by index\n\t*/\n\tprivate IndexedFastMap<Integer, ROCharacter> load(int version, boolean subDir) throws IOException {\n\t\t\n\t\tFile file = new File(\"tmp\");\n\t\tif (!file.exists()) {\n\t\t\tfile.mkdir();\n\t\t}\n\t\t\n\t\tString dirFileName = \"\" + version;\n\t\t\n\t\tif (subDir) {\n\t\t\tdirFileName = dirFileName + File.separator;\n\t\t}\n\t\t\n\t\tif (!file.exists()) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tString fullFileName = \"/\" + (new File(file, dirFileName + VERSION + \".txt\" + (subDir? File.separator : \"\")));\n\t\t\n\t\tFileReader reader = null;\n\t\ttry {\n\t\t\treader = new FileReader(fullFileName);\n\t\t} catch (Exception ex) {\n            System.err.println(\"TODO: create test failed...\");\n            return null;\n        }\n\t\t\n\t\tStringBuilder content = new StringBuilder();\n\t\tint current = 0;\n\t\tchar[] characters = new char[256];\n\t\tboolean first = true;\n\t\t\n\t\ttry {\n\t\t\t// load character indexes in file\n\t\t\twhile(true) {\n\t\t\t\tassertTrue(reader.skip(0x1FFF) > -1);\n\t\t\t\t\n\t\t\t\tcurrent = reader.read();\n\t\t\t\t\n\t\t\t\tcharacters[current] = (char) current;\n\t\t\t\tcontent.append(String.copyValueOf(characters));\n\t\t\t\t\n\t\t\t\tif (current > 0x7F) {\n\t\t\t\t\tcharacters[current] = 0;\n\t\t\t\t\tcontent.setLength(0);\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (current + 1 > (256) && current + 1 <= reader.read()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException ex) {\n            System.err.println(\"TODO: create failed...\");\n        } finally {\n            try {\n                reader.close();\n            } catch (Exception ex) {\n                System.err.println(\"TODO: Failed to close file reader\");\n            }\n        }\n\t\t\n        String text = Functions.getLineByLength(content.toString(), 64);\n        \n\t\tIndexedFastMap<Integer, ROCharacter> result = new IndexedFastMap<>();\n\t\t\n\t\tif (!subDir) {\n\t\t\tresult.putAll(record.getAllMap());\n\t\t} else {\n\t\t\tfor (int i=1; i<=record.size()-record.getKeySize(); i++) {\n\t\t\t\ttext = Functions.getLineByLength(text, 64);\n\t\t\t\t\n\t\t\t\tint keySize = record.getKeySize();\n\t\t\t\tresult.put(record.getKey(i-1), record.getMap().get(keySize-1));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t\t\n\t}\n\t \n}\n\nclass TXTRecord {\n\t\n\tprivate final int start; // version must be 0\n\tprivate String filename;\n\t\n\tString getName() {\n\t\treturn filename;\n\t}\n\t\n\t/**\n\t* Creates the character index for the specified version\n\t* version can be 0, but the value must be > 0.\n\t* @param version the test version\n\t* @throws IllegalArgumentException if the version is < 1\n\t* @return newly created character index\n\t*/\n\tpublic static TXTRecord read(File file) throws IOException {\n\t\t\n\t\tif (!file.exists()) {\n\t\t\tif (file.mkdir()) {\n\t\t\t\tfile.setReadable(true, true);\n\t\t\t} else {\n\t\t\t\tthrow new IOException(\"Can't create directory\");\n\t\t\t}\n\t\t\tfile.setReadable(true, true);\n\t\t",
            "finish_reason": "length"
        }
    ],
    "id": "5c29a8ff-d4e0-41c0-85cb-a6cfcfeaca7b",
    "prompt_id": "/EvoSuiteBenchmark/original/81_javathena/src/main/java/org/character/data/TXTCharacter.java",
    "original_code": "// TXTCharacter.java\npackage org.character.data;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport org.character.data.config.CharConfig;\nimport org.javathena.core.data.Friend;\nimport org.javathena.core.data.Hotkey;\nimport org.javathena.core.data.IndexedFastMap;\nimport org.javathena.core.data.Item;\nimport org.javathena.core.data.PersistenteData;\nimport org.javathena.core.data.Point;\nimport org.javathena.core.data.ROCharacter;\nimport org.javathena.core.data.Skill;\nimport org.javathena.core.data.ROCharacter.JOB;\nimport org.javathena.core.utiles.Functions;\n\npublic class TXTCharacter implements PersistenteData<IndexedFastMap<Integer, ROCharacter>> {\n\n    /**\n     * Load character under the last format version only version 1500 (homun +\n     * mapindex maps)\n     *\n     * @return indexedChar a fastmap containing loaded characters\n     * @throws MalformedDataException\n     */\n    @Override\n    public IndexedFastMap<Integer, ROCharacter> load() throws IOException;\n}\n",
    "test_prompt": "// TXTCharacterTest.java\npackage org.character.data;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport org.character.data.config.CharConfig;\nimport org.javathena.core.data.Friend;\nimport org.javathena.core.data.Hotkey;\nimport org.javathena.core.data.IndexedFastMap;\nimport org.javathena.core.data.Item;\nimport org.javathena.core.data.PersistenteData;\nimport org.javathena.core.data.Point;\nimport org.javathena.core.data.ROCharacter;\nimport org.javathena.core.data.Skill;\nimport org.javathena.core.data.ROCharacter.JOB;\nimport org.javathena.core.utiles.Functions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TXTCharacter}.\n* It contains one unit test case for the {@link TXTCharacter#load()} method.\n*/\nclass TXTCharacterTest {",
    "time_taken": 53.79386520385742,
    "usage": {
        "prompt_tokens": 664
    }
}
]