ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
bbdc8864-6779-4517-81da-3913db744a8c,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_0Test.java,63.08839797973633,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return string array of public fields
     */
    public String[] printFields();
}
","// ClassInfo_0Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {","// ClassInfo_0Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {
/**
		* Provides implementation of the {@link #printFields()} method.
		* <p>
		* This method is to be called while running a unit test.
		*
		* @param s The string to be returned by this method
		*/
        @Test
        public void printFields(final String s) {
            new ClassInfo(s);
        }
}
"
d1d8fab6-8ef7-4c7a-badc-35c9ae97f8c6,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_1Test.java,60.56327772140503,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return string array of public methods
     */
    public String[] printMethods();
}
","// ClassInfo_1Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {","// ClassInfo_1Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {

    
    @Test
    public void testParseClassInfo() {
        assertTrue(""ClassInfo_1Test:  error."", ClassInfo_1Test.isParseClassInfo());
    }

    @Test
    public void testParseClassInfo2() {
        Class[] types = ClassInfo_1Test.class.getTypes();
        ClassInfo_1Test t = new ClassInfo_1Test();
        ClassInfo_1 test = getClassInfo(t, types[0].getName(), null);
        ClassInfo_1 target = getClassInfo(test, types[1].getName(), null);
        assertEquals(""ClassInfo_1Test:  error."", t, test);
        assertEquals(""ClassInfo_1Test:  error."", target, test);
        
        String targetClassName = ""com.jstevh.viewer.ClassInfo_1Test$Test"";
        ClassInfo_1 test2 = getClassInfo(t, targetClassName, null);
        assertNull(""ClassInfo_1Test:  error."", test2);
    }
    
    private boolean isParseClassInfo(){
        return true;
    }

    private ClassInfo getClassInfo(ClassInfo_1 t, String cFullName,  Class cOuterMostOfClass) {
        ClassInfo tClass = null;
        
        try {
            tClass = getClassInfo(t.getClassInfo(), cFullName, t);
            t.setClassInfo(null);
        }
        catch (javax.swing.UnsupportedLookAndFeelException e) { }
        catch (ClassNotFoundException e) { }
        
        if (cOuterMostOfClass == null) {
            if (tClass == null) { return null; }
            javax.swing.JFrame f = new javax.swing.JFrame();
            f.setTitle(cFullName);
            f.setResizable(false);
            f.getContentPane().add(tClass);
            f.pack();
            f.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
            f.addWindowListener(new java.awt.event.WindowAdapter() {
                @Override
                public void windowClosed(java.awt.event.WindowEvent e) {
                    tClass.setClassInfo(null);
                }
            });
            f.setVisible(true);
            f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setResizable(false);
            return t;
        } else {
            return tClass;
        }
    }
}
"
338a6dfa-75e6-462a-82b1-a700ff4fb528,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_2Test.java,59.35645771026611,length,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return string array of public methods
     */
    public String[] printMethods(int param);
}
","// ClassInfo_2Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {","// ClassInfo_2Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {

	@Test
	public void testNoMethods() {
		
		final ClassInfo ci = new ClassInfo(null);
		assertTrue(""No methods"", ci.getPrintMethods().length > 0);
		
		JPanel panel = new JPanel();
		try {
			ci.jstestMethods(panel);
			fail(""The following methods should be accessible but are inaccessible"");
		} catch (InstantiationException ie) {
			assertNotNull(ie);
			assertEquals(IllegalStateException.class.getName(), ie.getMessage());
		} catch (IllegalAccessException iae) {
			assertNotNull(iae);
		} catch (InstantiationError ie) {
			assertNotNull(ie);
			assertEquals(IllegalStateException.class.getName(), ie.getMessage());
		}
		//
		assertEquals(PanelInfo.class, panel.getClass());
		assertEquals(""PanelInfo not null"", panel.getName());
		assertNotNull(panel.getLayout());
		assertNotNull(panel.getBorder());
		assertNotNull(panel.getParent());
		assertNotNull(panel.getMaximumSize());
		assertNotNull(panel.getMinimumSize());
	}
		
	@Test
	public void testNoInterfaceMethods() {
		
		final ClassInfo ci = new ClassInfo(null);
		assertEquals(""There should only be one set of interfaces"", 1, ci.getSetOfInterfaces().size());
		assertEquals(""There should only be one set of methods"", 1, ci.getPublicMethods().size());
		assertFalse(""There should no interfaces"", ci.getSetOfInterfaces().isEmpty());
		assertFalse(""There should only be a method with a return type not null"", ci.getPublicMethods().get(0) instanceof MethodWithReturns);
		
		assertEquals(""A method should be in the set of interfaces"", ci.getSetOfInterfaces().get(0), ci.getSetOfMethods().get(0));
		//
		JPanel panel = new JPanel();
		try {
			ci.jstestMethods(panel);
			fail(""The following methods should be inaccessible but are inaccessible"");
		} catch (InstantiationException ie) {
			assertNotNull(ie);
			assertEquals(IllegalStateException.class.getName(), ie.getMessage());
		} catch (IllegalAccessException iae) {
			assertNotNull(iae);
		}
		panel.setVisible(false);
		panel.setOpacity(0);
		panel.setTitle(""PanelInfo"");
		panel.setForeground(Color.red);
		panel.setBackground(Color.white);
		panel.setBorder(BorderFactory.createEmptyBorder());
		assertEquals(""Javadoc has not been executed"", 0, ci.getTotalExecutedDocs());
	}
	
	@Test
	public void testImplementationMethods() {
		
		final ClassInfo ci = new ClassInfo(null);
		List<MethodWithReturns> list = Arrays.asList(new MethodWithReturns(null, ""hi"", null));
		set(list);
		JPanel panel = new JPanel();
		try {
			ci.jstestMethods(panel);
			fail(""The following methods should be inaccessible but are inaccessible"");
		} catch (InstantiationException ie) {
			try {
				String methodName = ci.getMethodWithReturns().getName();
				System.currentTimeMillis();
				MethodWithReturns methodWithReturns = ci.getMethodWithReturns();
				System.currentTimeMillis();
			} catch (InstantiationException ie1) {
				assertNotNull(ie1);
			} catch (IllegalAccessException iae) {
				assertNotNull(iae);
			}
			List<MethodWithReturns> otherList = new ArrayList<>();
			otherList.add(null);
			try {
				otherList.add(methodInheritance(null, list.get(0), list.get(1)));
				fail(""Another method should be inherited: "" + otherList.size() + "". Other methods were: "" + otherList.size());
			} catch (InstantiationException ie2) {
				System.currentTimeMillis();
				String message = ci.getMethodWithReturns().getName();
				System.currentTimeMillis();
				assertEquals(""Found method from two parents "", otherList.size(), message.length());
				otherList.get(0).setInheritedTo(null);
				assertEquals(""Method inherited not called"", otherList.get(1), otherList.get(0));
				otherList.get(0).setInheritedTo(null);
				assertEquals(""Method inherited twice"", otherList.get(1), otherList.get(0));
				otherList.get(1).setInheritedTo(null);
				assertEquals(""Method inherited to null"", otherList.get(1), otherList.get(0));
			} catch (IllegalAccessException iae1) {
				assertNotNull(iae1);
			}
			list = otherList;
			panel.setVisible(false);
			panel.setOpacity(0);
			panel.setForeground(Color.red);
			panel.setText(""PanelInfo"");
			panel.setTitle(""PanelInfo"");
			panel.setBackground(Color.white);
			panel.setBorder(BorderFactory.createEmptyBorder());
			assertEquals(""Javadoc has not been executed"", 0, ci.getTotalExecutedDocs());
		} finally {
			panel.setVisible(true);
		}
		
		if (list.size() == 0) fail(""There should be an element"");
		set(list);

		panel = new JPanel();
		try {
			ci.jstestMethods(panel);
			fail(""The following methods should be inaccessible but are inaccessible"");
		} catch (InstantiationException ie) {
			try {
				String methodName = ci.getMethodWithReturns().getName();
				System.currentTimeMillis();
				MethodWithReturns methodWithReturns = ci.getMethodWithReturns();
				System.currentTimeMillis();
				try {
					if (list.size()!= 1) throw new RuntimeException();
					if (methodName == ""add"") {
						throw new UnsupportedOperationException();
					} else {
						methodWithReturns.setInheritedTo(null);
						try {
							String result = null;
							result = ci.getMethodWithReturns().getInheritedTo();
							System.currentTimeMillis();
							throw new RuntimeException(); // throws a RuntimeException as the second case is checked
						} catch (Throwable e) {
						}
					}
				} catch (UnsupportedOperationException uoe) {
					try {
						System.currentTimeMillis();
						methodWithReturns.setInheritedTo(null);
						try {
							String result ="
320be61b-8cf7-4ab4-834e-a02c5a099308,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_3Test.java,59.63499164581299,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return string array of public constructors
     */
    public String[] printConstructors();
}
","// ClassInfo_3Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {","// ClassInfo_3Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {
// Class Info
    private final ClassInfo classInfo = new ClassInfo();

    /**
     * Tests printing methods.
     *
     * @throws MethodNotFoundException
     */
	@Test
	public void testPrintConstructors_1() throws MethodNotFoundException {

		// Call methods
		classInfo.printConstructors();

		// Check methods
		List methodsCreated = (List) ((Class) ClassInfo.class.getDeclaredConstructors()[0]).newInstance();
		assertNotNull(""The List that was created is null"", methodsCreated);
		assertTrue(""List created is empty"", methodsCreated.size() > 0);
		Iterator methodIt = methodsCreated.iterator();
		while (methodIt.hasNext()) {
			Object method = methodIt.next();
			System.out.println(""Test passed: "" + method.toString());
		}
	}
	
	/**
	 * Tests printing methods.
	 *
	 * @throws MethodNotFoundException
	 */
	@Test
	public void testPrintConstructors_2() throws MethodNotFoundException {
	
	
		// Call methods
		classInfo.printConstructors();
	}

	/**
	 * Tests printing methods.
	 *
	 * @throws MethodNotFoundException
	 */
	@Test
	public void testPrintMethods_1() throws MethodNotFoundException {
		
		// Initialise test with null (classInfo.printConstructors() was not called)
		assertTrue(""constructors should have been made and not a null value"", classInfo.printConstructors()!=null);
		assertTrue(""constructors should not have been made and a null value"", classInfo.printConstructors() ==null);
	}
		
	/**
	 * Tests printing methods.
	 *
	 * @throws MethodNotFoundException
	 */
	@Test
	public void testPrintMethods_2() throws MethodNotFoundException {
	
		// Set print data to false
		classInfo.printConstructors(System.out);

		// Call methods
		classInfo.printConstructors();
	}
	
	/**
	 * Tests printing methods.
	 *
	 * @throws MethodNotFoundException
	 */
	@Test
	public void testPrintMethods_3() throws MethodNotFoundException {
	
		// Set print data to false
		classInfo.printConstructors(null);

		// Call methods
		classInfo.printConstructors();
	}
	
	/**
	 * Tests that all non null fields and methods are printed to the output.
	 *
	 * @throws MethodNotFoundException
	 */
	@Test
	public void testPrintData_1() throws MethodNotFoundException {
		
		// Set print data to false
		classInfo.printConstructors(new String[]{null});

		// Create null fields
		classInfo.printConstructors(new String[]{null,null});
		classInfo.printConstructors(new String[]{null,null,null});
		classInfo.printConstructors(new String[]{null,null,null,null});

		// Call methods
		classInfo.printConstructors();
	}

	/**
	 * Tests printing methods.
	 *
	 * @throws MethodNotFoundException
	 */
	@Test
	public void testPrintData_2() throws MethodNotFoundException {
	
		// Set print data to false
		classInfo.printConstructors(new String[]{new Integer(1)});

		// Set print data to false
		classInfo.printConstructors(new String[]{new Boolean(true)});
		
		// Call methods
		classInfo.printConstructors();
	}

	/**
	 * Setup a new test class by passing one of the parameters.
	 *
	 * @param data	class information object, as set by test constructors
	 * @throws MethodNotFoundException if any method was not found
	 */
	void setUp(ClassInfo data) throws MethodNotFoundException {
		classInfo.setData(data);
	}
	
	private ClassInfo setData(ClassInfo data) {
		classInfo.setData(data);
		return classInfo;
	}

}
"
695cc9c6-bd29-4c78-8ffd-6b3e774d9f02,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_4Test.java,59.71084022521973,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return string array of interfaces
     */
    public String[] printInterfaces();
}
","// ClassInfo_4Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {","// ClassInfo_4Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {
public static class MyObject {
			String s = ""Hello World from the class"";

			public MyObject() {
				System.out.println(""Created"");
			}

			public MyObject(final String x) {
				System.out.println(""Setting x = "" + x);
				this.s = x;
			}

			public MyObject(final int x) {
				System.out.println(""Setting x = "" + x);
				this.s = Integer.toString(x);
			}
		}


		public class MyClass extends Class {
			public MyClass(String[] interfaces) {
				this(interfaces, null);
			}

			public MyClass(ClassLoader classLoader) {
				this(null, classLoader);
			}

			public MyClass(final ClassInfo[] interfaces, ClassLoader classLoader) {
				super(interfaces, classLoader);
				super.setModifierExclude(""static"", Modifier.STATIC);
			}

			MutableStringData[] getData(final ClassInfo[] infos) {
				final String[] data = new String[infos.length];
				final Set<String> dataClasses = new HashSet<String>();
				final Enumeration<Class> enum = getParentClasses(this, 0);

				// Enumerate all interfaces.
				System.out.println(""Getting interfaces."");

				while (enum.hasMoreElements()) {
					final ClassInfo info = enum.nextElement();
					String className = info.getClassName();
					final String packageName = className.substring(0, className.lastIndexOf("".""));

					if (className.equals(classLoader.getClass().getName())) {
						addData(data, className, dataClasses);
					}

					System.out.println(""Adding class: "" + className);
					if (! info.isLocal()) {
						try {
							final Class c = Thread.currentThread().getContextClassLoader().loadClass(info.getClassName());
							addData(data, c.getName(), dataClasses);
						} catch (ClassNotFoundException exception) {
							exception.printStackTrace();
						}
					}
				}

				addData(data, className, dataClasses);
				return new MutableStringData[0];
			}

			private void addData(String[] name, String className, final Set<String> data) {
				for (int i = 0; i < name.length; i++) {
					final String key = i + ""."" + className.substring(0, className.lastIndexOf(""."") + 1);
					data.add(key);
				}
			}

			Class[] getInterfaces() {
				return new Class[]{this.getClass()};
			}
		}

		public MyClass obj = null;

		MyClassInfo() {
			System.out.println(""Created"");
			obj = ClassInfo.class.getDeclaredConstructor().newInstance();
		}

		@Test
		public void getInterfaces() {
			assertEquals(1, this.getInterfaces().length);
			assertEquals(""ClassInfoObject"", this.getInterfaces()[0].getName());
		}
}"
e16e7099-36af-431a-aebe-6745bfad960a,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_5Test.java,60.04765319824219,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param m array of Member objects
     * @return string array of names
     */
    public static String[] getData(Member[] m);
}
","// ClassInfo_5Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {","// ClassInfo_5Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {
/**
		 * A string array of names that each element of the array
        * corresponds to.
		 * <p>
		 * It always returns immediately.
		 *
		 * @return string array of names
		 */
        public static String[] getData() {
            return new String[] {""one"", ""two"", ""three""};
        }
	
	/**
	 * Runs the suite of tests in this method.
	 */
        @Test
        public void runTest() {
            // This is the actual run of the test, but it uses a Method on the class (jstevh.tools::TestRunInfo)
            // to determine the exact outcome of each test.
			
            // Note that we just want to verify that the various cases it accepts.
            assertSame(""same size"", getData(), getData());
			assertSame(""same number of strings"", getData(), getData());
		}
}"
497fa004-1fdb-4b70-a979-074a11d70670,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_6Test.java,42.557781457901,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param m array of Class objects
     * @return string array of names
     */
    public static String[] getData(Class[] m);
}
","// ClassInfo_6Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {","// ClassInfo_6Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {
/**
		 * Test the ClassInfo.getData() method, where we get
		 * the {@link Class[]} object as a <code>String[]</code>.
		 */
     @Test
     @SuppressWarnings(""unused"")
		public void testGetData()
			throws ClassNotFoundException
		{
			// Class[] classArray
		assertEquals("""",new String[0]);

		// Class[] classArray2		
	}

	// ClassInfo_4.java
	public static String[] getData(Class[] m) {
        List<ClassInfo> mClassInfos = ClassInfo.classInfoList(m); 
        return mClassInfos.toArray(new ClassInfo[0]);
    }
        /**
     * @param m class array of Class objects
     * @return List of classinfos
     *
     */
    public static List<ClassInfo> classInfoList(Class[] m) {

        List<ClassInfo> classInfos = new Vector<ClassInfo>();

        for (Class clazz : m)
        {
            try
            {
                Method[] mt = clazz.getMethods();
        
                for (Method method : mt) {
                    Class[] cn = new Class[]{};
            	    String className = method.getName();
                    while (className!= null)
                    {
                        int endIndex = className.lastIndexOf('.');
                        if (endIndex == -1) {
                            if (className.length() == 1) {
                                className = className.substring(0, 1);
                            }
                            // throw new
                        } else 
                        {
                            className = className.substring(endIndex + 1);
                        }
                    }
                    // This is the test class itself.
        
                    for (int i = 0; i < mt.length; i++) // Method is first class
                    {
                        Class memberclass = mt[i].getDeclaringClass();
                        if (className.equals(memberclass.getName())) {
                            cn = new Class[]{mt[i].getReturnType()};
                        }
                    }
                    classInfos.add(new ClassInfo(className,cn));
                }
            } 
            catch (NoClassDefFoundError e) {
            	throw new RuntimeException(e);
            }
        }
        return classInfos;
    }
}
"
8b3eb2a8-d5b9-481b-98fd-096429fabd99,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_7Test.java,59.384647369384766,length,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param tempStr string fragment with which to search
     * @return string array of found methods
     */
    public String[] srchMethods(String tempStr);
}
","// ClassInfo_7Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {","// ClassInfo_7Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {
/**
		 * Test constructor.
		 */
	@Test
	 public void ctor() {
		TestClassInfo tci = new TestClassInfo(""A"");
		String tempStr = ""B"";
		String tl = ""a"";
		tci.className = tl;
		Class tmp = tci.classInfo.getClass();
		ClassInfo tmpIt = tci.classInfo;
		Class clsInfo = tci.classInfo.getClassInfo().getClass();

		String m1;

		assertEquals(tci.classInfo.getClassName(), ""A"");
		//assertEquals(tci.classInfo.getClassName(), ""M"");
		//assertEquals(tci.classInfo.getClassName(), ""P"");
		assertEquals(tempStr, tci.classInfo.getClassName());
		assertEquals(tmpIt, tci.classInfo);
		assertEquals(clsInfo, tci.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo());
		assertTrue((tci.classInfo.getConstructors() instanceof Collection));
		Iterator it = tci.classInfo.getConstructors();
		while(it.hasNext()) {
			m1 = (String) it.next();
		}
		assertTrue(m1.equals(tl));
		assertTrue(it.hasNext());
		m1 = (String) it.next();
		assertTrue(!m1.equals(tci.classInfo.getClassName()));		
		//assertTrue(m1.equals(tci.classInfo.getClassInfo().getClassInfo().getClassName()));
		//assertTrue(it.hasNext());
		tci.className = tci.classInfo.getClassName();
	 }

	/**
* Test class of {@link ClassInfo} with getClassName().
*/
	@Test
	public void tci_getClassName_GetClassName() {
		ClassInfo tci = new ClassInfo(""A"");
		//tci.classInfo.setClassName(""A"");
		ClassInfo tci1 = new ClassInfo(""B"");
		String tempStr = ""A"";
		String tl = ""a"";
		tci.className = tl;
		Class cls = tci.classInfo.getClass();

		assertEquals(tci.classInfo.getClassName(), tci.className);
		//        assertEquals(tci.className, tci.classInfo.getClassName());
		//        assertEquals(tl, tci.classInfo.getClassName());
		//        assertTrue((tci1.className == tci.className));
		//        assertTrue((tci1.getClassName() == cls));
		tci.className = tci1.className;
	}


	/**
* Test class of {@link ClassInfo} with the return type of String.getClassName().
*/
	@Test
	public void tci_returnType_ReturnType() {
		ClassInfo tci = new ClassInfo(""A"");
		//tci.classInfo.setClassName(""A"");
		ClassInfo tci1 = new ClassInfo(""B"");
		ClassInfo tci2 = new ClassInfo(""B"");
		String tempStr = ""B"";
		//        assertEquals(tci.classInfo.getClassName(), tci.classInfo.getClassName());
		//        assertEquals(tci.classInfo.getClassName(), tci.classInfo.getClassName());
		assertEquals((tci.classInfo.getClassName() == tci.classInfo.getClassName()), true);
		assertEquals(tci.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo(), tci.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo());
		assertEquals(tci.classInfo.getClassName(), tci.className);
		assertEquals(tci.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo(), tci.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo());
		tci.returnType = tci1.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo();
		assertNotNull((tci.returnType == tci1.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo()));
		String tempStr2 = tci.returnType.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo();
		String tl = tci.returnType.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo();
		assertTrue((tci.returnType == tci1.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo()));
		assertEquals(tci.classInfo.getClassName(), tci2.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo());
		// 		tci.classInfo.setClassName(tl);
		// 		tci2.classInfo.setClassName(tci.classInfo.getClassName());
		tci1.returnType = tci2.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo()
				.setClassName(tl);
		tci1.className = tci2.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo();
		tci2.className = tci.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo();
		tci2.className = tci.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo();
		tci1.className = tci2.classInfo.getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassInfo().getClassName();
		assert"
e84467b0-8634-4f64-924b-6e025bc5aba3,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_8Test.java,59.658644676208496,length,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param pos position of found methods in array 0 is first.
     * @return MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos);
}
","// ClassInfo_8Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_8Test {","// ClassInfo_8Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_8Test {

    private int classNumber;
    private ClassInfo classInfo;
    private TestFrame testFrame;
    
    /**
     * Initialises with classes to search and the current class number as
     * the ""number"" of the class
     */
    TestInfo createTestInfo(Object[] classesToSearch, int classNumber) {
        Class<?> currentClass = classesToSearch[classNumber] instanceof Class<?>? (Class<?>) classesToSearch[classNumber] : null;
        
        return new TestInfo(this.testFrame, (currentClass == null? ""noClass"" : currentClass.getSimpleName()), classesToSearch[0], this.classNumber);
    }
	
    /**
     * Run the suite of {@link TestInfo}s for classes found by {@link ClassInfo#getFoundMethod(int)}
     * at the given position and class number.
     * @param classesToSearch classes to test with
     * @param startPosition starting index of test
     */
    public void runTest(Object[] classesToSearch, int startPosition) {
		
		// Set up with current set of classes and expected result in case test is skipped
		this.testFrame = new TestFrame(new TestInfo(this.testFrame, ""classTest"", this.classInfo.getClassName(), this.classNumber));

		this.classNumber = startPosition;
		
		// Test each class
		for(int i = startPosition; i >= 0; i--) {
			this.testFrame.setClassInfoToSearch(this.classesAndFields(this.classInfo, (clazz) classesToSearch[i]), this.getFoundMethod(i));
		}
		
		// Add footer and show the frame and test info
		this.testFrame.addFooter(""Found "" + this.classInfo.getClassName() + "" ("" + this.classesAndFields(this.classInfo, (clazz)classesToSearch[classNumber]).length + "")"");
		this.testFrame.setVisible();
		this.testFrame.setTitle(classesToSearch[classNumber] + "" Class Information"");
	}
    
    /**
     * Returns a map from {@code clazz} to {@code method name} of
     * {@code clazz}'s methods.
     *
     * @param clazz
     * @return map from clazz to method name
     */
	private static Map<Object, String> getClassNameToMethodMap(Class<?> clazz) {
		
        // Collect all methods
		LinkedHashSet<Method> methods = new LinkedHashSet<>();
        List<Member> members = new LinkedList<Member>(); // List for members.
		
        clazz.getDeclaredMethods();
        for(int i = 0; i < clazz.getDeclaredMethods().length; i++) {
            Method method = clazz.getDeclaredMethods()[i];
            if(method.getName().startsWith(""get"")) {
                addElementMethod(method, members);
            }
        }
        
        // Collect all fields
        List<Member> fields = new LinkedList<Member>();
        for(int i = 0; i < clazz.getFields().length; i++) {
            Field field = clazz.getFields()[i];
            if(field.getName().startsWith(""get"")) {
                addElementField(field, fields);
            }
        }
        
        // Add up all methods and fields
        Member[] members2 = fields.toArray(new Member[fields.size()]);
        List<Member> fields2 = new LinkedList<Member>(); // List for members.
        for(Member member : members2) {
            fields2.add(member);
        }
        
        Collections.sort(fields2, new Comparator<Member>() {
            public int compare(Member left, Member right) {
                int n1 = 0;
                int n = 0;
                int m1 = left.getModifiers();
                int m2 = right.getModifiers();
                while(n1 < 0 && n2 < 0 && (m1 > 0 && m1 < m2) || (m1 < 0 && m2 > 0)) {
                    m1 = left.getModifiers();
                    m2 = right.getModifiers();
                    n1++;
                }
                if(m1 < m2) {
                    return -1;
                }
                if(m2 < m1) {
                    return 1;
                }
                return 0;
            }
        });
        
        // Convert fields2 to map from field names to methods
        Map<String, Set<Member>> field2MethodMap = new HashMap<String, Set<Member>>();
        for(Member member: fields2) {
            String fieldName = member.getName();
            // Get method that corresponds to fieldName
            Method method = member.getDeclaringClass().getDeclaredMethod((String)fieldName);
            addElementTypeMethod(method, member, field2MethodMap);
        }
        
        // Now populate with all classes and interfaces
        Map<Object, Class<?>> class2ClassMap = new HashMap<Object, Class<?>>();
        for(Object currentClassFromClassInfo : this.classesAndFields(this.classInfo, (clazz)classesToSearch[classNumber])) {
            if(!currentClassFromClassInfo.equals(clazz)) {
                addElementClass(currentClassFromClassInfo, class2ClassMap);
                class1 = (Class<?>)currentClassFromClassInfo;
            }
        }
        
        return new HashMap<Object, Class<?>>(class2ClassMap);

	}

	private static void addElementClass(Object currentClassFromClassInfo, Map<Object, Class<?>> class2ClassMap) {
        Class c = (Class) currentClassFromClassInfo;
        // Get the real classes
        for(Class<?> p : currentClassFromClassInfo.getInterfaces()) {
            class2ClassMap.put(p.getName(), p);
        }
        // Add as member of classes
        // The classes and interfaces can't be null, because
        // classes could add null for example.
        if(c!= null) {
            // Set names of all interfaces and classes
            Set<String> interfaces = new HashSet<String>();
            Set<Class<?>> classes = new HashSet<Class<?>>();
            for(Class<?> p: c.getInterfaces()) {
                interfaces.add(p.getName());
                classes.add(p);
            }
            // Get the name of the first class that is not a interface
            for(Class<?> p: c.getInterfaces()) {
                if(!interfaces.contains((String)p.getInternalName())) {
                    break;
                }
                classes.add((Class<?>)p);
            }
            addElementClass(classes.iterator().next(), class2ClassMap);
        }
	}

    /** Creates new ClassInfo_8Test"
