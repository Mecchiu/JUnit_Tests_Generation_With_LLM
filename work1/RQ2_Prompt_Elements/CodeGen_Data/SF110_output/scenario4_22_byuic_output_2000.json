[
{
    "choices": [
        {
            "text": "DecompilerTest() {\n\t\t\tSystem.out.println(\"DecompilerTest()\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t@Test\n\tvoid testDecompile() {\n\n\n\t\t// initial values\n\t\tint flags = 1 << 0;\n\t\tint sourceFileOffset = 0;\n\t\tint sourceLineOffset = 0;\n\n\t\t// input representation\n\t\tString source =\n\t\t\t\"function X\\n\" +\n\t\t\t\"     declare\\n\" +\n\t\t\t\"X();\\n\" +\n\t\t\t\"{\\n\" +\n\t\t\t\"       use();\\n\" +\n\t\t\t\"     }\\n\" +\n\t\t\t\"X();\\n\" +\n\t\t\t\"{\\n\" +\n\t\t\t\"       use();\\n\" +\n\t\t\t\"    }\\n\" +\n\t\t\t\"\";\n\n\t\t// parameters\n\t\tString regexp = \"/\\\\/\\\\/\\\\/\\\\/\";    // only one pattern for now\n\t\t\t\t// this has no effect and will lead to the same behavior\n\t\tString numProperties = null;\n\t\tString flagsProperties = null;\n\n\t\tString output =\n\t\t\t\"X = function X(){}\\n\" +\n\t\t\t\"X.doIt();\\n\";\n\t\tassertEquals(\n\t\t\t\"X.prototype.prototype$getNext\\n\",\n\t\t\toutput,\n\t\t\tDecompiler.decompile(source, flags | flagsProperties | numProperties, properties(flagsProperties), sourceFileOffset, sourceLineOffset));\n\n\n\t}\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n    /**\n     * Test that the decompilation of the String, the initial indentation offset,\n     * an additional \"indentation gap\", and a \"preserved comment\" is\n     * saved properly.  The method also checks the return value of the\n     * {@link #decompile} method.\n     */\n\t@Test\n\tvoid test1() throws Exception {\n        String source = \"a\\nb\\nc\\nd\";\n        String expected = \"a\";\n        int i = 0;\n        assertEquals(\"incorrect encoding\",expected,decompile(source,1,0));\n\t\ti=getOffsetAfter(source,\"indent\\n1\\n\");\n        assertEquals(\"incorrect number of tokens\", 3,i);\n\t\ti=getOffsetAfter(source,\"indent\\n\");\n        assertEquals(\"incorrect number of tokens\", 2,i);\n\t\ti=getOffsetAfter(source,\"indent\\n#b\\nc\");\n        assertEquals(\"incorrect number of tokens\", 8,i);\n\t\ti=getOffsetAfter(source,\"indent\\n#b\\nd\");\n        assertEquals(\"incorrect number of tokens\", 20, i);\n\t}\n    \n    /**\n     * Test that the decompilation of only the first line of source information\n     * is saved.\n     */\n\t@Test\n\tvoid test2() throws Exception {\n        String source = \"1\\t2\\na\\tc\";\n        String expected = \"1\";\n        int i = 0;\n        assertEquals(\"incorrect encoding\",expected,decompile(source,1,0));\n\t\ti=getOffsetAfter(source,\"\\n\");\n        assertEquals(\"incorrect number of tokens\", 1,i);\n\t\ti=getOffsetAfter(source,\"\\n\");\n        assertEquals(\"incorrect number of tokens\", 1,i);\n\t\ti=getOffsetAfter(source,\"\\n\\n\");\n        assertEquals(\"incorrect number of tokens\", 3,i);\n\t\ti=getOffsetAfter(source,\"\\n\\n\\n\\n\");\n        assertEquals(\"incorrect number of tokens\", 10,i);\n\t}\n    \n    /**\n     * Test that when an initial indentation offset is omitted the method\n     * also restores it to be the initial case.\n     */\n\t@Test\n\tvoid test3() throws Exception {\n        String source = \"aaaaaaa\\nl\\nbbbbbbb\\nlbbb\\nb\\nccccccccc\\n\";\n        int i = 0;\n        assertEquals(\"incorrect encoding\",\"ccccccccc\",\n                               decompile(source,0,-1));\n        i+=getOffsetAfter(source,\"\\n\");\n        assertEquals(\"incorrect number of tokens\",\n                3,i);\n        i+=getOffsetAfter(source,\"\\\\n\");\n        assertEquals(\"incorrect number of tokens\",\n                1,i);\n        i+=getOffsetAfter(source,\"\\\\n\\\\n\");\n        assertEquals(\"incorrect number of tokens\",\n                1,i);\n        i+=getOffsetAfter(source,\"\\\\n\\\\n\");\n        assertEquals(\"incorrect number of tokens\",\n                1,i);\n        i+=getOffsetAfter(source,\"\\\\nbbb\\\\n\");\n        assertEquals(\"incorrect number of tokens\",\n",
            "finish_reason": "length"
        },
        {
            "text": "\n\tprivate static String script;\n\t//private static List<ErrorRecoveryData> recoveryData;\n\n\tstatic {\n\t\tscript = \"// Test decompilation\\n\"+\n        \"var source = [\\n    [\\\"abc\\\", 3], [\\\"abd\\\", 4], [\\\"wxyz\\\", 5],\\n    [\\\"wxyz\\\", 6],\\n    [\\\"abc\\\", 7], [\\\"abd\\\", 8],\\n    [\\\"wxyz\\\", 9],\\n    [\\\"abc\\\", 10],\\n    [\\\"abd\\\", 11],\\n    [\\\"wxyz\\\", 12],\\n    [\\\"abc\\\", 123], [\\\"abc\\\", 234],\\n    [\\\"abc\\\", 235],\\n    \\\"abc\\\"\\n  ]\\n\";\n\t}\n\n\tprivate static void testDecompile() {\n\t\ttry {\n\t\t\tDecompiler d = new Decompiler();\n\t\t\tString compressedSource = d.decompile(script, FORMAT_INT_TO_CHARS);\n\t\t\tfail(\"IllegalStateException expected\");\n\t\t} catch (IllegalStateException e) {\n\t\t\tString decompiledSource = e.getMessage();\n\t\t\tassertStringEquals(\"[\\\"abc\\\", 3], [\\\"abc\\\", 4], [\\\"wxyz\\\", 5],\\n    [\\\"wxyz\\\", 6],\\n    [\\\"abc\\\", 7], [\\\"abc\\\", 8],\\n    [\\\"abc\\\", 9],\\n    [\\\"abc\\\", 10],\\n    [\\\"abc\\\", 11],\\n    [\\\"abc\\\", 3], [\\\"abc\\\", 4], [\\\"abc\\\", 5],\\n    [\\\"abc\\\", 6],\\n    [\\\"abc\\\", 7],\\n    [\\\"abc\\\", 8],\\n    [\\\"abc\\\", 9],\\n    [\\\"abc\\\", 10],\\n    [\\\"abc\\\", 11],\\n    [\\\"abc\\\", 6],\\n    \\\"abc\\\"]\", decompiledSource);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testDecompile() {\n\t\ttestDecompile();\n\t\tDecompilerTest.recoveryData = decompiler.recoveryData;\n\t}\n\n\t/**\n\t * @return source encoded as a javascript string\n\t */\n\tpublic static String getEncodedSource() {\n\t\treturn decompilerTest.sourceToString(0);\n\t}\n\n\t/**\n\t * @return the next source byte position in the source\n\t */\n\tpublic static int getNext(String source) {\n\t\treturn getNext(source, source.length(), 0);\n\t}\n\n\t/**\n\t * @return byte position of the first byte after all code-units in source, which may be past the end (usually 0)\n\t */\n\tpublic static int getSourceStringEnd(String source) {\n\t\treturn getSourceStringEnd(source, 0);\n\t}\n\n\t/**\n\t * @return the byte position of the first byte of a UTF-8 encoded string\n\t */\n\tpublic static int getSourceStringStart(String source) {\n\t\treturn getSourceStringEnd(source, -1);\n\t}\n\n\t/**\n\t * @return position of the last byte of a UTF-8 encoded string,\n\t *         0 if no UTF-8 encoded string\n\t */\n\tpublic static int getSourceStringEnd(String source) {\n\t\treturn getSourceStringEnd(source, -1);\n\t}\n\n\t/**\n\t",
            "finish_reason": "length"
        },
        {
            "text": " /**\n\t\t  * The single test fixture used for testing {@link DecompilerTest} class\n\t\t  * functionality.\n\t\t  */\n\t  private DecompilerTest() {}\n\n\t /**\n\t  * Test of decompile method of Decompiler.\n\t  */\n\t @Test\n  public void testDecompile() {\n\t\t String[] sourceArray = {\n\t\t\t\"abc\", \"defghijklmnoop\", \"\", \"\", \"\\n\\n\",\n\t\t\t\"abc\\n\\ndefghijklmnoop\", \"\", \"\", \"\\n\\ndefghijklmnoop\"\n\t\t};\n\t\tint sourceStart, newOffset;\n\t    if (printSource) {\n\t      // test that decoding of source string correctly includes a quote-safe opening\n\t    \tnewOffset = printSourceString(decompile(Util.toString(sourceArray), TO_SOURCE_FLAG, null, null), 0, null, null);\n\t    \tsourceStart = 1; // start of decompile sequence\n\t    } else {\n\t\ttry {\n\t\t\t// this will always succeed, even for a bad source!\n\t\t\t// decompile is not supposed to return a 0 or ERROR!\n\t\t\tnewOffset = decompile(decompile(Util.toString(sourceArray), TO_SOURCE_FLAG, null, null), TO_SOURCE_FLAG, null, null);\n\t\t\treturn;\n\t\t} catch (RuntimeException re) {\n\t\t\tnew OffsetErrorException(re).printStackTrace();\n\t\t\tthis.fail(\"decompiling a bad source: expected ERROR (or a non-zero value for TO_SOURCE_FLAG) but got \"+re.getMessage());\n\t\t\treturn;\n\t\t}\n\t    }\n\n\t    assertEquals(Util.INDEX_TOO_BIG, newOffset);\n\t    assertEquals(1, sourceArray.length); // ensure the length is not exceeded\n\t    final Utf8StringPool poolString = Utf8StringPool.INSTANCE ;\n\t    final String sourceStr = Util.toString(sourceArray, sourceStart, sourceArray.length - sourceStart);\n\t    String s = poolString.get(sourceStr);\n\t    // the code below will print a source string with a quote-safe opening\n\t    printSourceString(Util.toString(s), newOffset, true, null);\n\t    if (printSource) {\n\t      assertEquals(s, new OffsetErrorException().getDecompiledSource());\n\t    } else {\n\t      // make a little little bit more liberal by checking to make sure the source string still works when the string to string conversion fails\n\t      s = s.replace('\\xfe', '\\ufffe') ;\n\t      assertEquals(s, new OffsetErrorException().getDecompiledSource());\n\t    }\n\t    newOffset = printSourceString(decompile(s, TO_SOURCE_FLAG, null, null), 0, null, null);\n\t    // make sure the source was properly decoded\n\t    s = poolString.get(Util.toString(s));\n\t    assertEquals(s, new OffsetErrorException().getDecompiledSource());\n\t    newOffset = printSourceString(s, 0, true, null);\n\t    // make sure the source string can be stringified\n\t    s = poolString.get(Util.",
            "finish_reason": "length"
        },
        {
            "text": "\n    @Test\n    public void testSimple() {\n        String source = decompile(\"x=1\",\"TO_SOURCE\", UintMap.EMPTY_MAP);\n        assertEquals(\"decompiled\", \"<x >1>\", source);\n        assertEquals(sourceTop, 3);\n    }\n\n    @Test\n    public void testComplex() {\n        String source = decompile(\"1=1\\n1=2\\n\\ndeclaration:\\n\\ntabs:1\\n\\nreturn\\n\\n\\tx\\n\\nliteral:\\n\\n(function ()\\n\\n{\\ntree\\n\\n}\\n\\n\");\n        assertEquals(\"decompiled\", \"1\\n\\ndeclaration: <undefined>\\n\\ntree:\\n\\n(function () { tree {\\n\\n\\t|>x\\n}\\t);\\n\\n(function (x) { tree {\\n\\n\\t}\\n\\t;\\n\\t\\t// NOTE: To get here the function may be compiled with flags TO_SOURCE.\\n\\tif (x) {\\n\\t}\\n};\\n})\\n\\n\", source);\n        assertEquals(sourceTop, 5);\n    }\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "private final int lineOffset;\n\t\tprivate final int sourceStart;\n\t\tprivate int braceDepth;\n\t\tprivate Decompiler decompiler;\n\t\tprivate int tokenStart;\n\t\tprivate int endOffset;\n\t\tprivate ErrorRecoveryTest debug;\n\t\tprivate UintMap properties;\n\t\tprivate static int NO_PROPS = 100; // don't modify properties yet\n\n\t/**\n\t * Constructor for the class DecompilerTest.\n\t *\n\t * @param line no. of line in the source file\n\t * @param sourceStart offset of the source start (inclusive)\n\t * @param endOffset offset of the end   (inclusive)\n\t * @param properties UintMap with debug information of this node in effect\n\t */\n\tDecompilerTest(int line, int sourceStart, int endOffset, UintMap properties) {\n\t\tthis.lineOffset = endOffset;\n\t\tthis.sourceStart = sourceStart;\n\t\tthis.endOffset = endOffset;\n\t\tthis.tokenStart = getFirstToken(sourceStart);\n\t\tthis.debug = new ErrorRecoveryTest(properties);\n\t\tthis.braceDepth = sourceStart - 1;\n\t\tthis.decompiler = new Decompiler(line, sourceStart, endOffset, properties);\n\t\tthis.properties = properties;\n\t}\n\n    @Test\n    public void testDecompileSource() {\n        if (debug.enabled) {\n            debug.decision(OP_DECOMPILE, lineOffset);\n        }\n\n        assertFalse(decompiler.needsRecovery());\n        String s = decompiler.compile(\"abc\", NO_PROPS);\n\n        if (printSource) {\n            System.out.println(s);\n        }\n\n        assertTrue(decompiler.needsRecovery());\n        assertNotNull(decompiler.getEncodedSource());\n\n        String result = decompiler.decompile(s, NO_PROPS);\n\n        if (printSource) {\n            System.out.println(result);\n        }\n\n        assertEquals(result, s);\n    }\n\n    @Test\n    public void testDecompileWithSource() {\n\t\tdecompiler.setSourceString(sourceStart, sourceStringLength(sourceStart));\n        decompiler.setEndPosition(sourceStart + sourceStringLength(sourceStart));\n\n        String s = decompiler.compile(\"abc\", NO_PROPS);\n\n        decompiler.decompile(s, NO_PROPS);\n\n        String result = decompiler.decompile(s, NO_PROPS);\n\n        decompiler.decompile(result, NO_PROPS);\n\n        String resultSource = decompiler.getEncodedSource();\n        assertEquals(resultSource.length(), s.length());\n        if (printSource) {\n            System.out.println(s);\n            System.out.println(resultSource);\n        }\n\n        String resultJSC = decompiler.decompileWithSource(s, result.length());\n        if (printSource) {\n            System.out.println(resultJSC);\n        }\n        assertTrue(resultJSC.equals(s));\n    }\n\n    @Test\n    public void testDecompileWithSourceWithoutDebug() {\n        decompiler.setEndPosition(-1);\n        String s = decompiler.compile(\"abc\", NO_PROPS);\n\n        decomp",
            "finish_reason": "length"
        },
        {
            "text": "private boolean testPassed = true;\n\t\tprivate String source;\n\t\tprivate int sourceLength;\n\t\tprivate Decompiler d;\n\n\t\t@Test\n\t\tpublic void testDecompileString() {\n\t\t\tthis.testPassed = false;\n\t\t\tString source = \"function foo(arg0) {\\n return arg0;\\n}\\n\";\n\t\t\td = Decompiler.decompile(source, 0, null);\n\t\t\tassertEquals(source, d.getEncodedSource());\n\t\t\tassertEquals(source, sourceLength); // the encoded source does no longer represent the original source\n\t\t\tassertEquals(1, d.getSourceTop());\n\t\t\ttestPassed = true;\n\t\t}\n\n\t\t@Test\n\t\tpublic void testDecompileEmptyString() {\n\t\t\tthis.testPassed = false;\n\t\t\tString source = \"\";\n\t\t\td = Decompiler.decompile(source, 0, null);\n\t\t\tassertEquals(source, d.getEncodedSource());\n\t\t\tassertEquals(sourceLength, d.getSourceTop());\n\t\t\ttestPassed = true;\n\t\t}\n\n\t\t@Test\n\t\tpublic void testDecompileFunctionBody() {\n\t\t\tthis.testPassed = false;\n\t\t\tString source = \"function foo() { return 1; }\";\n\t\t\td = Decompiler.decompile(source, 0, null);\n\t\t\tassertEquals(source, d.getEncodedSource());\n\t\t\tassertEquals(sourceLength, d.getSourceTop());\n\t\t\ttestPassed = true;\n\t\t}\n\n\t\t@Test\n\t\tpublic void testDecompileFunctionEnd() {\n\t\t\tthis.testPassed = false;\n\t\t\tString source = \"function foo() {\\n return 1;\\n}\\n\";\n\t\t\td = Decompiler.decompile(source, 0, null);\n\t\t\tassertEquals(source, d.getEncodedSource());\n\t\t\tassertEquals(sourceLength, d.getSourceTop());\n\t\t\ttestPassed = true;\n\t\t}\n\n\t\t@Test\n\t\tpublic void testDecompileCase() {\n\t\t\tthis.testPassed = false;\n\t\t\tString source = \"case 1\\n:\\n x();\\n\\n\\ncase 2\\n:\\n y();\\n:\\n z();\\n\\n\\np();\\n;\\nend\\nend\\nvar x = 2; x++;\";\n\t\t\td = Decompiler.decompile(source, 0, null);\n\t\t\tassertEquals(source, d.getEncodedSource());\n\t\t\tassertEquals(sourceLength, d.getSourceTop());\n\t\t\ttestPassed = true;\n\t\t}\n\n\t\t@Test\n\t\tpublic void testDecompileDefault() {\n\t\t\tthis.testPassed = false;\n\t\t\tString source = \"1,\\n\\n\\n\";\n\t\t\td = Decompiler.decompile(source, 0, null);\n\t\t\tassertEquals(source, d.getEncodedSource());\n\t\t\tassertEquals(sourceLength, d.getSourceTop());\n\t\t\ttestPassed = true;\n\t\t}\n\n        @Test\n        public void testDecompileCaseClosed() {\n            this.testPassed = false;\n            String source = \"case 1\\ncase 2\\ncase 3\\ncase 4\\n    = 1,\\nexpr x();\\n\":\n                \"1,1\\n\\n\\n\\n",
            "finish_reason": "length"
        },
        {
            "text": "/**\n\t\t* @test\n\t\t*/\n\t\t@Test\n\t\tpublic void testDecompile() {\n\t\t\t// create string to be decompiled\n\t\t\tString source = \"123\\n234\\n\\n\";\n\t\t\t// generate code to run during test\n\t\t\tString expected = \"123\";\n\t\t\tString decoded = DecompilerTest.decompile(source, Decompiler.ONLY_BODY_FLAG, System.undefined);\n\t\t\tassertEquals(expected, decoded);\n\t\t}\n\n\n\t}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\n\tprivate String source =\n\t\t\"function foo() {this.c = 1;}\\n\" +\n\t\t\"function bar() {return 1;}\\n\" +\n\t\t\"function qux() {return 1+3-2+5-this.c;}\\n\" +\n\t\t\"function boo() {return 4;}\\n\" +\n\t\t\"function func() {}\\n\";\n\n\tstatic DecompilerTest oneUnitTestCase() {\n\t\tDecompilerTest test = new DecompilerTest();\n\t\ttest.runDecompile(source, TO_SOURCE_FLAG, UintMap.EMPTY);\n\t\treturn test;\n\t}\n\n\tprivate void runDecompile(String input, int flags, UintMap properties) {\n\t    DecompilerTest test = oneUnitTestCase();\n\t    assertEquals(input, test.decompile(input, flags, properties).length());\n\t}\n\n\tprivate void runDecompile(String input) {\n\t\trunDecompile(input, TO_SOURCE_FLAG | INITIAL_INDENT_PROP | CASE_GAP_PROP, UintMap.EMPTY);\n\t}\n\n\t/**\n\t * Check that the proper offsets are set when decoding\n\t * an encoded source string.\n\t */\n\t@Test\n\tvoid testOffset() {\n\t\tassertEquals(DECOMPILE_UNENCODED_SOURCE_OFFSET,\n\t\t\t\tDecompiler.decompile(source, DECOMPILE_UNENCODED_SOURCE_OFFSET, UintMap.EMPTY).length());\n\t\tassertEquals((DECOMPILE_UNENCODED_SOURCE_OFFSET >>> 8) + 1,\n\t\t\t\tDecompiler.decompile(source, (DECOMPILE_UNENCODED_SOURCE_OFFSET << 16) | 0x4, UintMap.EMPTY).length());\n\t\tassertEquals(DECOMPILE_UNENCODED_SOURCE_OFFSET,\n\t\t\t\tDecompiler.decompile(source, (DECOMPILE_UNENCODED_SOURCE_OFFSET << 8) | DECOMPILE_UNENCODED_SOURCE_OFFSET, UintMap.EMPTY));\n\t\tassertEquals(0, Decompiler.decompile(source, DECOMPILE_UNENCODED_SOURCE_OFFSET | DECOMPILE_UNENCODED_SOURCE_OFFSET, UintMap.EMPTY).length());\n\t}\n\n\t/**\n\t * Check that the proper offsets are set when decoding an encoded source string.\n\t */\n\t@Test\n\tvoid testOffset2() {\n\t\tint min = 10;\n\t\tint max = 20;\n\t\tint originalLength = (max - min) + (max - 10);\n\t\tchar [] charArray = source.toCharArray();\n\t\tfor(int i = 0; i < charArray.length; i++) {\n\t\t\tmin = 10;\n\t\t\tmax = 20;\n\t\t\tsource = \"0\" + charArray[i] + \"1\" + charArray[i] + \"2\" + charArray[i] + \"3\" + charArray[i] + \"4\" + charArray[i]\n\t\t\t\t\t    + \"5\" + charArray[i] + \"6\" + charArray[i] + \"7\" + charArray[i];\n\t\t\toriginalLength = (max - min) + (max - 10",
            "finish_reason": "length"
        },
        {
            "text": "static { NativeJavaLevel.init(); }\n\n\tprivate String encoded;\n\tprivate int compiled;\n\tprivate int unescapedCount;\n\tprivate boolean inUseEscaped = false;\n\n    public DecompilerTest(String encoded, int compiled) {\n\t\tthis.encoded = encoded;\n\t\tthis.compiled = compiled;\n\t\tthis.unescapedCount = 0;\n\t}\n\n\t@Test\n\tvoid testDecompile() throws CompilerError {\n\t\tif ( inUseEscaped )\n\t\t\tthrow error(\"inUseEscaped is set.\");\n\n\t\tDecompiler decompiler = new Decompiler();\n\n\t\tif (inUseEscaped)\n\t\t\tdecompiler = decoder(deoptimize());\n\n\t\tdecompiler.setSource(this.encoded);\n\t\tdecompiler.decompile(sourceTop, source, UNESCAPED_PROP, properties);\n\t\tassertTrue(DECOMPILE_VALID, decompiler.hasErrors());\n\t\tassertEquals(\"source\", 1, unescapedCount);\n\t\tif ( printSource)\n\t\t\tdecompiler.printSource();\n\t\tassertEquals(\"source\", 0, sourceTop);\n\t\tdecompiler.printSource();\n\t\tassertTrue(DECOMPILE_VALID, decompiler.hasErrors());\n\t}\n\n\tprivate Decompiler deoptimize() {\n\t\tDecompiler decompiler = new Decompiler();\n\t\tdecompiler.setSource(encoded);\n\t\tdecompiler.deoptimize();\n\t\treturn decompiler;\n\t}\n\n\tpublic int getSource() {\n\t\treturn compiled;\n\t}\n\n\tpublic int getCompiled() {\n\t\treturn compiled;\n\t}\n\n\tpublic List<UnescapedToken> getTokens() {\n\t\tList<UnescapedToken> tokens = new LinkedList<UnescapedToken>();\n\t\tunescapedCount = 0;\n\t\tsourceTop = 0;\n\t\taddToken(Token.ASSIGN, Token.TRUE);\n\t\taddName(encoded);\n\t\taddEOL(Token.EOF);\n\t\t//\n\t\tdecompiler.setSource(encoded);\n\t\ttokens.add(decompiler.decodeToken());\n\t\tdecompiler.setSource(encoded);\n\t\treturn tokens;\n\t}\n\n\tDecompiler clone() {\n\t\t\treturn new Decompiler(encoded, compiled);\n\t}\n\n\tpublic void reset() {\n\t\tdecompiler.reset();\n\t\tsourceTop = 0;\n\t\tunescapedCount = 0;\n\t}\n}\n",
            "finish_reason": "stop"
        }
    ],
    "id": "a0d32905-c5ef-401e-8135-3d55860331da",
    "prompt_id": "/EvoSuiteBenchmark/original/22_byuic/src/main/java/org/mozilla/javascript/Decompiler.java",
    "original_code": "// Decompiler.java\npackage org.mozilla.javascript;\n\n/**\n * The following class save decompilation information about the source.\n * Source information is returned from the parser as a String\n * associated with function nodes and with the toplevel script.  When\n * saved in the constant pool of a class, this string will be UTF-8\n * encoded, and token values will occupy a single byte.\n *\n * Source is saved (mostly) as token numbers.  The tokens saved pretty\n * much correspond to the token stream of a 'canonical' representation\n * of the input program, as directed by the parser.  (There were a few\n * cases where tokens could have been left out where decompiler could\n * easily reconstruct them, but I left them in for clarity).  (I also\n * looked adding source collection to TokenStream instead, where I\n * could have limited the changes to a few lines in getToken... but\n * this wouldn't have saved any space in the resulting source\n * representation, and would have meant that I'd have to duplicate\n * parser logic in the decompiler to disambiguate situations where\n * newlines are important.)  The function decompile expands the\n * tokens back into their string representations, using simple\n * lookahead to correct spacing and indentation.\n *\n * Assignments are saved as two-token pairs (Token.ASSIGN, op). Number tokens\n * are stored inline, as a NUMBER token, a character representing the type, and\n * either 1 or 4 characters representing the bit-encoding of the number.  String\n * types NAME, STRING and OBJECT are currently stored as a token type,\n * followed by a character giving the length of the string (assumed to\n * be less than 2^16), followed by the characters of the string\n * inlined into the source string.  Changing this to some reference to\n * to the string in the compiled class' constant pool would probably\n * save a lot of space... but would require some method of deriving\n * the final constant pool entry from information available at parse\n * time.\n */\npublic class Decompiler {\n\n    /**\n     * Flag to indicate that the decompilation should omit the\n     * function header and trailing brace.\n     */\n    public static final int ONLY_BODY_FLAG = 1 << 0;\n\n    /**\n     * Flag to indicate that the decompilation generates toSource result.\n     */\n    public static final int TO_SOURCE_FLAG = 1 << 1;\n\n    /**\n     * Decompilation property to specify initial ident value.\n     */\n    public static final int INITIAL_INDENT_PROP = 1;\n\n    /**\n     * Decompilation property to specify default identation offset.\n     */\n    public static final int INDENT_GAP_PROP = 2;\n\n    /**\n     * Decompilation property to specify identation offset for case labels.\n     */\n    public static final int CASE_GAP_PROP = 3;\n\n    // the last RC of object literals in case of function expressions\n    private static final int FUNCTION_END = Token.LAST_TOKEN + 1;\n\n    String getEncodedSource();\n\n    int getCurrentOffset();\n\n    int markFunctionStart(int functionType);\n\n    int markFunctionEnd(int functionStart);\n\n    void addToken(int token);\n\n    void addEOL(int token);\n\n    void addName(String str);\n\n    void addString(String str);\n\n    void addRegexp(String regexp, String flags);\n\n    void addJScriptConditionalComment(String str);\n\n    void addPreservedComment(String str);\n\n    void addNumber(double n);\n\n    private void appendString(String str);\n\n    private void append(char c);\n\n    private void increaseSourceCapacity(int minimalCapacity);\n\n    private String sourceToString(int offset);\n\n    /**\n     * Decompile the source information associated with this js\n     * function/script back into a string.  For the most part, this\n     * just means translating tokens back to their string\n     * representations; there's a little bit of lookahead logic to\n     * decide the proper spacing/indentation.  Most of the work in\n     * mapping the original source to the prettyprinted decompiled\n     * version is done by the parser.\n     *\n     * @param source encoded source tree presentation\n     *\n     * @param flags flags to select output format\n     *\n     * @param properties indentation properties\n     */\n    public static String decompile(String source, int flags, UintMap properties);\n\n    private static int getNext(String source, int length, int i);\n\n    private static int getSourceStringEnd(String source, int offset);\n\n    private static int printSourceString(String source, int offset, boolean asQuotedString, StringBuffer sb);\n\n    private static int printSourceNumber(String source, int offset, StringBuffer sb);\n\n    private char[] sourceBuffer = new char[128];\n\n    // nested functions source and uses function index as a reference instead.\n    private int sourceTop;\n\n    // whether to do a debug print of the source information, when decompiling.\n    private static final boolean printSource = false;\n}\n",
    "test_prompt": "// DecompilerTest.java\npackage org.mozilla.javascript;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Decompiler}.\n* It contains one unit test case for the {@link Decompiler#decompile(String, int, UintMap)} method.\n*/\nclass DecompilerTest {",
    "time_taken": 33.34746956825256,
    "usage": {
        "prompt_tokens": 1277
    }
}
]