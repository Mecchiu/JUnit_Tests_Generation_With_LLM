ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
88c3b7d7-2270-4ae5-8079-86d0686845a4,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_0Test.java,64.08390593528748,stop,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    /**
     * Convenience methods since velocity does not understand the conditional
     * ""== null"". Returns true if this class implements an interface.
     *
     * @return true if this class implements an interface else false.
     */
    public boolean hasInterface();
}
","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {

    /** Unit test test constructor. */
    @Test
    void hasInterface() {
    	assertTrue(""This method should be implemented correctly"", JavaSource.hasInterface() );
	}
    
	/** Unit test {@link JavaSource#hasInterface()} method. */
    @Test
    void hasInterfaceIntent() {
    	final java.lang.Class clz = Class.forName(""org.sourceforge.ifx.tools.JavaSource_0Test"");
    	assertEquals (true, java.lang.Class.isInstance (clz, clz.getDeclaredConstructors ()[0]));
    }

	/** @see JavaSource#hasInterface() */
	@Test
	void hasInterfaceNull() {
	    assertNull(""This method should be implemented correctly if the class doesn't implements interface with null methods"", 
	            JavaSource.hasInterface (null));
    }

	/** @see JavaSource#hasInterface() */
	@Test
	void hasInterfaceTrue() {
	    assertTrue(""This method should be implemented correctly if the class implements interface with null methods and the true value is true"",
	            JavaSource.hasInterface (true));
    }

	/** @see JavaSource#hasInterface() */
	@Test
	void hasInterfaceTrueIntent() {
	    final java.lang.Class clz = Class.forName (""org.sourceforge.ifx.tools.JavaSource_0Test"");
	    final boolean ret = true;
	    assertEquals (true, java.lang.Class.isInstance (clz, clz.getDeclaredConstructors ()[0]));
	    assertEquals (false, ret);
	}

	/** @see JavaSource#create(java.lang.String) */
	@Test
	void create() {
		final String s = ""JavaSource_0Test"";
		final JavaSource javaSource = (JavaSource) JavaSource_0Test.class.getDeclaredMethod(""create"", String.class).invoke(null, s);
		assertNotNull(""This method should not fail unless there's a problem to create the class."", javaSource);
	}

	/** @see JavaSource#list(java.lang.String) */
	@Test
	void list() {
		final String s = ""JavaSource_0TestList"";
		final List list = new ArrayList();
		JavaSource_0Test.list (list, s);
		final Iterator iterator = list.iterator();
		final java.lang.Class clz = java.lang.Class.forName (""org.sourceforge.ifx.tools.JavaSource_0Test"");
		final boolean ret = iterator.hasNext();
		assertEquals (true, ret);
		while (iterator.hasNext()) {
			assertTrue(""Iterator should not accept null values."", iterator.next()!= null);
		}
	}

	/** @see JavaSource#list(java.lang.String, java.lang.String) */
	@Test
	void listString() {
		final String s = ""JavaSource_0TestListString"";
		final List list = new ArrayList();
		JavaSource_0Test.list (list, s, s);
		final Iterator iterator = list.iterator();
		final java.lang.Class clz = java.lang.Class.forName (""org.sourceforge.ifx.tools.JavaSource_0Test"");
		final boolean ret = iterator.hasNext();
		assertEquals (true, ret);
		while (iterator.hasNext()) {
			assertTrue(""Iterator should not accept null values."", iterator.next()!= null);
		}
	}

}
"
b8519058-2b8f-4576-b431-95b69e247da6,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_1Test.java,26.325605869293213,stop,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    /**
     * Convenience method since velocity does not understand the conditional
     * ""== null"". Returns true if this class inherits from a superclass.
     *
     * @return true if this class has a superclass, else false.
     */
    public boolean hasSuperClass();
}
","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {

	/**
	 * Test method for
   * {@link org.sourceforge.ifx.tools.JavaSource#getClassName(java.lang.Class)}.
   * Expects superclass to be present.
   */
	@Test
    void classNameIsSuperclassOfClass() {
		assertTrue( ""HasSuperClass"", JavaSource.hasSuperClass() );
	}

	/**
	 * Test method for
   * {@link org.sourceforge.ifx.tools.JavaSource#getClassName(java.lang.Class)}.
   * Expects superclasses to not be present.
   */
	@Test
    void classNameNotHasSuperClass() {
		assertFalse( ""HasSuperClass"", JavaSource.hasSuperClass() );
	}

	/**
	 * Test method for
   * {@link org.sourceforge.ifx.tools.JavaSource#getSubstitutedClassFileName(java.lang.Class)}.
   * Expects the first substitution to be present.
   */
	@Test
    void substItselfToThisClass() {
		assertEquals( ""To this class"",
		                 NewClass.substitutedClassFileName(OldClass) );
	}

	/**
	 * Test method for
   * {@link org.sourceforge.ifx.tools.JavaSource#getSubstitutedClassFileName(java.lang.Class)}.
   * Expects an instance of {@link NewClass}.
   */
	@Test
    void findSubstitutedClassFileName() {
		assertNotNull( ""To this class"",
		               NewClass.substitutedClassFileName(OldClass) );
		
		// Test substitutions, if applicable
		String substClassName = NewAssociation.substitutedClassName(OldClass);
		assertNotNull( ""To this class"",
		               Util.substitute( substClassName, OldClass ) );
	}

}
"
02f0c6fb-9da4-4c56-8ccd-ab7fa9a42998,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDecoder.java,57.5755660533905,length,"// IFXDecoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;

/**
 * Decodes an IFX XML String to its equivalent Framework bean.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXDecoder {

    /**
     * Decodes the element into its equivalent IFX XML representation.
     *
     * @param element the Element to decode.
     * @return an IFXObject.
     * @exception IFXException wrapper for underlying exception.
     */
    public IFXObject decode(Element element) throws IFXException;
}
","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {
/**
		* Decodes the element into its equivalent IFX XML representation.
		*
		* @param element the Element to decode.
		* @return an IFXObject.
		* @exception IFXException wrapper for underlying exception.
		*/
		@Test
    public void decode(Element element) throws IFXException {
			IFXString string;
			Class<?> tClass;
			Object array;
			int n = 10;

			// Test <string></string>
			string = findElement(element, ""string"", ""java.lang.String"", n);
			assertNotNull(string);

			// Test other types
			tClass = IFXString.class;
			array = IFXDecoder.parseArrayOfObjects(element, tClass);
			assertNotNull(array);
			assertTrue(""Array of objects expected"", array instanceof IFXObject[0]);
			assertTrue(""Array of string expected"", array instanceof IFXString[]);

			// Test only <string></string>
			string = findElement(element, ""string"", """", n);
			assertEquals(IFXString.class.getSimpleName(), string.getClassName());

			// Test only <string></string>
			string = findElement(element, ""string"", """", 0);
			assertEquals(IFXString.class.getSimpleName(), string.getClassName());

			// Test <array></array>
			array = IFXDecoder.parseArrayOfObjects(element, IFXString[].class);
			assertNotNull(array);
			assertTrue(""Array of string expected"", array instanceof IFXString[0]);

			// Test only <array></array>
			array = IFXDecoder.parseArrayOfObjects(element, IFXString[].class);
			assertNotNull(array);
			assertTrue(""Array of string expected"", array instanceof IFXString[0]);

			// Test missing <string></String>
			string = findElement(element, ""string"", """", 1);
			assertNull(string);
		}

        /**
         * Find the object corresponding to the type of Element element.
         *
         * @param element the Element to parse.
         * @param targetClass the target Class where to extract the corresponding
         *        object.
         * @param name the fully qualified name of the object.
         * @param n the index of the element in the array.
         * @return the object corresponding to the Element element.
         * @throws MissingResourceException if <String></String>
         * @throws IllegalArgumentException if <array></array>
         * @throws IFXException wraps underlying problems with the underlying
         *        underlying implementation.
         */
        private <T> T findObjectImpl(Element element, Class<T> targetClass, String name, int n) throws
                MissingResourceException, IllegalArgumentException, IFXException {
                return targetClass.getDeclaredConstructor(Object.class).newInstance(element);
        }

        /**
         * Find Element in xml string.
         *
         * @param xmlString String that acts as a String array.
         * @param expectedClass Class name of the element.
         * @return an Element corresponding to the Element specified in xmlString.
         * @throws IFXException wrapper for underlying exception.
         */
        private Element findElement(String xmlString, String expectedClass, String name, int n) throws
                IFXException {
            try {
                Element result = getXML(xmlString, expectedClass);
                assertNotNull(result);
                Element target = result.getChild(name);
                assertNotNull(target);
                return target.element(n);
            } catch (BadElementException ex) {
               throw new IFXException(ex.getMessage()+"" "" + name,ex);
            }
        }

        // Get xmllist from xmlString
        private Element getXML(String xmlString, String expectedClass) throws
                IFXException {
            try {
                return new org.jdom.input.XMLInputSource(xmlString).asDOM().getRootElement();
            } catch (XMLStreamException ex) {
                throw new IFXException(ex.getMessage()+"" "" + expectedClass,ex);
            }
        }

		/**
		* Parses a set of object from an array of objects.
		*
		* @param array Object array.
		* @param targetClass The array of classes from which elements should be
		*        consumed.
		* @return an array of the object corresponding to each element in the array.
		* @throws IllegalArgumentException if <array></array>
		* @throws IFXException wraps underlying problems with the underlying
		*        underlying implementation.
		*/
        private Object[] parseArrayOfObjects(String xmlString, Class<?>[] targetClass)
                throws IFXException {
            List<Object> result = null;
            try {
                result = getXML(xmlString, targetClass).getChild(""objects"").getChildren();
            } catch (BadElementException ex) {
                throw new IFXException(ex.getMessage() + "" "" + targetClass.length + ""("" + targetClass.length + "") "" +
                                         result.size(),ex);
            } catch (XMLStreamException ex) {
                throw new IFXException(ex.getMessage() + "" "" + targetClass.length + ""("" + targetClass.length + "")"",ex);
            }
            return (result == null? null : result.toArray());
        }

        /**
         * Decodes an IFX XML Element.
         *
         * @param element the Element to decode.
         * @return an IFXObject.
         * @exception IFXException wrapper for underlying exception.
         */
        public IFXObject decode(Element element) throws IFXException {
            Class<?> targetClass;
            Object array;
            int n = 10;
            System.out.println(""Target Class for element in \""""+element.getName()+""\"":"");
            try {
                targetClass = IFXDecoder.findTargetClass(element.getName());
            } catch (MissingResourceException ex) {
                System.out.println(""No target class specified, returning empty array of class: "");
                targetClass = IFXObject.class;
            }
            TypeDescriptor tDesc = TypeDescriptorFactory.findTypeDescriptor(targetClass);
            if (tDesc == null) {
                System.err.println(""Could not find target class"");
                n = 0;
                return new IFXObject(IN"
181dfe19-3a76-4418-8644-a7302e941a21,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXEncoder.java,52.114182472229004,stop,"// IFXEncoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;

/**
 * Encodes an IFXObject to its equivalent IFX XML Element.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXEncoder {

    /**
     * Builds a JDOM Element for the IFXObject supplied. No validation is
     * performed, regardless of the setting. To validate, use the encode()
     * methods instead.
     *
     * @param obj an IFXObject.
     * @return a JDOM Element.
     * @exception IFXException if an exception was encountered in encoding.
     */
    public Element encode(IFXObject obj) throws IFXException;
}
","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains one unit test case for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains one unit test case for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {

    /** The resourceBundle. */
    private static ResourceBundle res = ResourceBundle.getBundle(""org.sourceforge.ifx.utils"");


    /**
     * Test the {@link IFXEncoder#encode(IFXObject)} method.
     */
    @Test
    void testEncode() throws IOException, MissingResourceException, IllegalAccessException {
        IFXObject obj = new IFXObject();

        XMLOutputter xmlout = new XMLOutputter();
        Writer out = obj.getOutputStream(""/testEncoding/test_encoding_3.xml"");
//        out = obj.getOutputStream(""/testEncoding/test_encoding_4.xml"");
        xmlout.setOmitXMLDeclaration(true);
        xmlout.setFormatForStructure(false);
        xmlout.output(out,null);
        assertEquals(""test_encoding_3.xml"", obj.toString(""UTF-8""));

        XMLEmitter xmlemitter = new XMLEmitter();
        XMLOutputter output = xmlemitter.createOutputter(""UTF-8"");
        output.setIndentSize(4);
        ArrayList<IFXClass> list = new ArrayList<IFXClass>();
        XMLBuilder xml = new XMLBuilder(list);
        xml.setIndentSize(4);
        xml.build(res.getString(""/testEncoding/test_encoding_3.xml""), obj);
        String xml_string = convertOutput(xml);
//        String xml_string = obj.toString(""UTF-8"");
        assertEquals(""test_encoding_3.xml"", xml_string);
        assertEquals(""UTF-8"", xmlemitter.getXMLVersion());
        setLocale(xml);
    }

    private void setLocale(XMLEmitter xml){
        XMLBuilder builder = new XMLBuilder();
        builder.add(new LocaleData(""en""),"""",builder);
        xml.add(builder);
    }

	/**
     * @throws Exception
     */
    @Test
    void testEncodeXmlNamespace() throws Exception {

        String name = ""xml_namespace_1"";
        IFXObject obj = new IFXObject();
//        obj.setName(name);
        obj.setName(res.getString(""/xml_namespace/tag:tag.xml""));
//        obj.setName(""xml_namespace_3"");
        obj.getXMLNamespace().setBundle(""urn:xxx"");

        XMLOutputter xmlout = new XMLOutputter();
        Writer out = obj.getOutputStream(""/xml/out/out.xml"");
//        out = obj.getOutputStream(""/xml/out/out.xml"");
        xmlout.setOmitXMLDeclaration(true);
        xmlout.setFormatForStructure(false);
        xmlout.output(out, null);
        String xml_string = convertOutput(obj);

        int index = xml_string.indexOf(""xmlns:"" + name) + name.length();
        int last_index = 0;
        while (index >= 0) {
            if (index > last_index) {
                assertTrue(index <= xml_string.length());
            }
            index = xml_string.indexOf(""xmlns:"" + name, index);
            assertEquals(0, xml_string.indexOf(""?"", index));
            last_index = index + name.length();
            index = name.indexOf(""xmlns:"" + name, index);
            assertEquals(0, index);
            index = name.indexOf("">"", index);
            assertEquals('""', xml_string.charAt(index - 1));
            System.out.println(xml_string.substring(index, out.size()));
            index = out.size();
            out.write(xml_string.substring(index));
            out.write(""\n"");
            index = xml_string.indexOf("">"", index + 1);
            assertTrue(index >= 0);
        }

    }
}
"
746adc46-4f4b-4058-9436-d0641dae7d8e,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_0Test.java,53.96435856819153,length,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * Builds a JDOM Document object from an IFXObject.
     *
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException;
}
","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {
private Document testObj;

		/**
		 * The constructor.
		 * @throws IFXException when there was a problem getting the object
		 */
		public IFXDocumentHandler_0Test() throws IFXException {
			testObj = build(1);
		}

		/**
		 * Sets up the test for the class.
		 * @exception IFXException when the test object could not be built
		 */
		@Test
		public void setup() throws IFXException {
			assertNotNull(""Document object must not be null."", testObj);
		}

		/**
		 * Test for the empty constructor.
		 * @throws IFXException when there was a problem getting the object
		 */
		@Test
		public void empty_ctor() throws IFXException {
			IFXDocumentHandler handler = new IFXDocumentHandler();
			try {
				handler.build(null, null, null);
				fail(""Expected an exception not thrown"");
			} catch (IFXException e) {
				// expected
			}
		}

		/**
		 * Test for the build().
		 * @throws IFXException when there was a problem getting the object
		 */
		@Test
		public void build() throws IFXException {
			IFXDocumentHandler handler = new IFXDocumentHandler();
			handler.setup();

			assertNotNull(""Document object must not be null."", handler.testObj);
			// test 1 - The output should start with the namespace prefix.
			String expOutputStr = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"" + 
				""<!DOCTYPE IF XML PUBLIC \""-//W3C//DTD IF XML Soft 1.0//EN\"" \""http://www.w3.org/2001/XMLSchema-instance\"">"" + 
				""<IF XMLns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"""" +
				"" XSI:type=\""http://www.w3.org/2001/XMLSchema-instance\"" xsi:type=\""type\"">"" +
				""	<type xsi:type=\""type\"">test</type>"" +
				""</IF>"" + 
				""<IF XMLns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"""" +
				"" XSI:type=\""type\"">"" +
				""	<type xsi:type=\""type\"">test</type>"" +
				""</IF>"" + 
				""<IF XMLns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"""" +
				"" XSI:type=\""type\"">"" +
				""	<type xsi:type=\""type\"">test</type>"" +
				""</IF>"";

			assertEquals(""Unescaped characters should have been preserved."", expOutputStr.substring(1, 4), testObj.getDocumentElement().getText());

			// test 2 - The output should contain the namespace prefix
			String expOutputDom = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"" + 
				""<root><xsi:type=\""type\"">test</xsi:type></root>"";

			assertEquals(""Unescaped characters should have been preserved."", expOutputDom, testObj.getDocumentElement().getText());

			// test 3 - Build the document
			Document expResultDoc = XMLOutputter.outputStringAsUTF8(expOutputStr, ""UTF-8"").getRootElement();

			// test 4 - The output should contain the namespace URI
			String expResultDom = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"" + 
				""<root>"" + 
				""	<xsi:type xsi:type=\""type\"">test</xsi:type>"" + 
				""</root>"";

			assertEquals(""Unescaped characters should have been preserved."", expResultDom, new String(testObj.getDocumentElement().getText()));

			// test 5 - Build the document and check validity
			handler.setup();
			Document resultDoc = handler.build(testObj);

			// test 6 - The document returned should have the proper content
			assertTrue(""Document should start with the correct prefix."", expResultDoc.getPrefix(Namespace.getNamespaceURI(""xsi"")).equals(""xsi""));
			assertTrue(""Document should have the right namespace prefix."", expResultDoc.getNamespaceContext().getNamespaceURI(""xsi"").equals(""xsi""));
			assertTrue(""Document should be empty."", resultDoc.getRootElement().getChildren().size() == 0);

			// test 7 - Clear the output
			XMLOutputter.outputStringAsUTF8(StringUtils.EMPTY_STRING, ""UTF-8"").flush();
		}

		/**
		* Test for the setBuildParams() method.
		* @throws IFXException when there was a problem getting the object
		*/
		@Test
		public void setBuildParams() throws IFXException {
			IFXDocumentHandler handler = new IFXDocumentHandler();
			handler.setup();

			assertNotNull(""Document object must not be null."", handler.testObj);
			// test 1 - The output should not end with the namespace prefix.
			String expOutputStr = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"" + 
				""<!DOCTYPE IF XML PUBLIC \""-//W3C//DTD IF XML Soft 1.0//EN\"" \""http://www.w3.org/2001/XMLSchema-instance\"">"" + 
				""<IF XMLns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"""" +
				"" xsi:type=\""type\"">"" +
				""	<type xsi:type=\""type\"">test</type>"" +
				""</IF>"" + 
				""<IF XMLns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"""" +
				"" xsi:type=\""type\"">"" +
				""	<type xsi:type=\""type\"">test</type>"" +
				""</IF"
ad34ca7f-2ff8-440e-adb9-5d5cf1506fe0,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_1Test.java,56.30191922187805,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     *
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException;
}
","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {
private Parser pars;
    private Document out;
    private void Parse(String doc) throws IOException {
        Document doc2 = parser.parse(doc);
    }

    @Test
    void test1() throws IOException,
               Exception {
        XMLOutputter xmlOutput = new XMLExportToDOM().sax(getClass().getResourceAsStream(""IFXDocumentHandler_1Test.doc""));
        xmlOutput.setIndenting(true);
        assertTrue(xmlOutput.toString().contains(""Version""));
        Element element = (Element) xmlOutput.getRootElement().getChild(""IFXObject"");
        assertNotNull(element);
        assertNotNull(element.getName());
        assertNotNull(element.getNamespace());
        assertEquals(""1.0"", element.getValue().trim());
        out = xmlOutput.toOutputStream();
        in = new InputStream() {
            public int read() throws IOException {
                return 0;
            }
            public int read(byte[] b, int off, int len)
            throws IOException {
              return 0;
            }
        };
    }

	@Test
    void test2() throws IOException,
               Exception {
        InputStream inputStream = getClass().getResourceAsStream(""IFXDocumentHandler_1Test.doc"");
        Map<String,  IFXObject.ObjectType> types = IFXObject.ObjectType.getTypes();
        Parser parser = ParserFactory.getParser(types);
        Document document = parser.parse(inputStream);

        out = XMLOutputter.getDefaultFormat().setIndenting(true).
           setStandalone(false).
           createPrettyPrintedTree(document);
        in = new InputStream() {
            public int read() throws IOException {

            	return 0;
            }
            public int read(byte[] b, int off, int len)
            throws IOException {
              return 0;
            }

        };
    }

    @Test
    void test3() throws IOException,
               Exception {
        InputStream inputStream = getClass().getResourceAsStream(""IFXDocumentHandler_1Test.doc"");
        Document document = parser.parse(inputStream);
        out = parser.getDocumentHandler(parse(document).getDocument());// Parses document into a document object
        in = new InputStream() {
            public int read() throws IOException {

            	return 0;
            }
            public int read(byte[] b, int off, int len)
            throws IOException {
              return 0;
            }

        };
    }

    @Test
    void test4() throws IOException,
               Exception {
        Element element = out.getRootElement();
        Iterator iterator = element.getContent().iterator();
        while (iterator.hasNext()) {
            String s = ElementHelper.toString(element.getContent());
            System.out.println(""<""+s+"">"");
        }
        SAXBuilder builder = new SAXBuilder();
        Document document = builder.build(new InputStream() {
                public int read() throws IOException {
                    return 0;
                }
                public int read(byte[] b, int off, int len)
                throws IOException {
                    return 0;
                }

            });
       out = parser.getDocumentHandler(document);// Parses document into a document object
        in = new InputStream() {
            public int read() throws IOException {

            	return 0;
            }
            public int read(byte[] b, int off, int len)
            throws IOException {
              return 0;
            }
        };
       assertNotNull(out.getContent());
       }

}
"
91149e04-0d3d-483c-a375-86f676384ae8,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_2Test.java,54.318198680877686,length,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     *
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException;
}
","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {
public final String DOC_TESTSET[] = {
						""root0"", // No child element.
						""root1a"", // One child element.
						""root1b"", // One child nested element.
						""root2"", // One child child element.
						""root2b"", // One child nested child element.
						""root3"", // One child child nested child element.
						""root4"", // One nested element.
						""child_1"",  // One child element.
						""root5"", // One child child element.
						""child_5"", // One child nested child element.
						""child_6"", // One child child nested child element.
						""child_7"", // One nested child element.
						""child_8"", // One nested child element.
						""child_9"", // One nested child element.
						""child_10"", // One nested child element.
						""child_11"", // One nested child element.
						""root_1a"", // Child element.

						""root_2"", // Child element.
						""child_6"",  // Child element.
						""child_7"",  // Child element.
						""child_8"",  // Child element.
						""child_9"",  // Child element.
						""child_10"", // Child element.
						""root_4"",  // Child root element.
						""child_5"",

						""child_4"",  // Child root element.
						""child_5b"", // Child nested element.
						""child_5c"", // Child nested child element.
						""child_6"",  // Child nested child element.
						""child_6b"", // Child nested child nested child element.
						""child_7"",  // Child nested child nested child element.
						""child_8"",  // Child nested child element.
						""child_9"",  // Child nested child element.
						""child_10"", // Child nested child element.
	};

    /**
     * Constructs an empty Document object.
     */
    public IFXDocumentHandler_2Test() {
    }

////////////////// Test Method declarations //////////////////////

    @Test
    public void testRead(){
        // Tests the Document constructor.
        Document d = read(new ClassLoaderResource(""org/sourceforge/ifx/utils/""+Doc_TESTSET[4]),""true"","""");
        assertNotNull(d);
        assertEquals(Doc_TESTSET[4], d.getDocumentElement().getName());
        assertTrue(d.getPublicId(){});
        assertTrue(d.getSystemId()!= null);
        
        // The getNamespaces() method is used internally.
        Iterator it = d.getNamespaces().iterator();
        assertNotNull(it);
    }

	@Test
	public void testReadXML() throws IOException {

		SAXBuilder sb = new SAXBuilder();
		sb.setDocumentHandler(this);

		Document document = sb.build(new ClassLoaderResource(""org/sourceforge/ifx/utils/""+Doc_TESTSET[5]));

		// Test the getPublicId() method.
		assertNotNull( document.getPublicId() );
		assertEquals(Doc_TESTSET[5], document.getPublicId());

		// Test getSystemId().
		assertNotNull( document.getSystemId() );
		assertNotNull( document.getSystemId() );

		// Test setDocumentHandler(Document d, IFXDocumentHandler handler):
		document.setDocumentHandler(this);

		// Test getDocumentType(Document d)
		assertNotNull( document.getDocumentType() );
		assertEquals( ""XML"", document.getDocumentType().getDomName() );

		// Test setDocumentHandler(IFXDocumentHandler handler)
		document.removeAttribute (""version"");
		document.setDocumentHandler(this);
		document.setDocumentType(null);
	}

	@Test
	public void testReadSAXOutput() throws IOException {

		SAXBuilder sb = new SAXBuilder();
		sb.setDOMOutput(new XMLOutputter().getDOMOutput());

		SAXBuilder sb_nested = new SAXBuilder(Namespace.XML_NAMESPACE);
		sb_nested.setDOMOutput(new XMLOutputter().getDOMOutput());

		SAXBuilder sb_nested_1 = new SAXBuilder(Namespace.XML_NAMESPACE);
		sb_nested_1.setDOMOutput(new XMLOutputter().getDOMOutput());

		SAXBuilder sb_nested_2 = new SAXBuilder(Namespace.XMLNS_ATTR_NS, Namespace.XMLNS_NULLNS);
		sb_nested_2.setDOMOutput(new XMLOutputter().getDOMOutput());

		SAXBuilder sb_nested_3 = new SAXBuilder(Namespace.XMLNS_ATTR_NULL, Namespace.XMLNS_NULLNS);
		sb_nested_3.setDOMOutput(new XMLOutputter().getDOMOutput());

		SAXBuilder sb_nested_4 = new SAXBuilder(Namespace.XMLNS_ATTR_NULL,
				Namespace.XMLNS_NULLNS);
		sb_nested_4.setDOMOutput(new XMLOutputter().getDOMOutput());

		SAXBuilder sb_nested_5 = new SAXBuilder(Namespace.XMLNS_NULL_ATTR_NS, Namespace.XMLNS_NULL_NULLNS);
		sb_nested_5.setDOMOutput(new XMLOutputter().getDOMOutput());

		SAXBuilder sb_nested_6 = new SAXBuilder(Namespace.XMLNS_NULL_ATTR_NULL, Namespace.XMLNS_NULL_NULLNS);
		sb_nested_6.setDOMOutput(new XMLOutputter().getDOMOutput());

		SAXBuilder sb_nested_7 = new SAXBuilder(Namespace.XMLNS_NULL_NULL_ATTR_NS,
				Namespace.XMLNS_NULL_NULL_NULLNS);
		sb_nested_7.setDOMOutput(new XMLOutputter().getDOMOutput());

		"
