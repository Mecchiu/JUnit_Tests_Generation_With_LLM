ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
4dc0ccba-d680-4936-9f2a-a6e140ba8877,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/preferences/GenericSortedListModel.java,65.12783980369568,stop,"// GenericSortedListModel.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;

public class GenericSortedListModel<T extends Comparable> extends AbstractListModel {

    /**
     * Returns the value at the specified index.
     *
     * @param index the requested index
     * @return the value at <code>index</code>
     */
    public T getElementAt(int index);
}
","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains one unit test case for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {","// GenericSortedListModelTest.java
package de.huxhorn.lilith.swing.preferences;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GenericSortedListModel}.
* It contains one unit test case for the {@link GenericSortedListModel#getElementAt(int)} method.
*/
class GenericSortedListModelTest {

    /**
	* Test method for {@link #getElementAt(int) getElementAt(int)}.
	* Tests for the exception that is thrown when the index is out of bounds.
	*/
	@Test
	public void testGetElementAtIndexOutOfBounds() {
		GenericSortedListModel<String> listModel =
				new GenericSortedListModel
						<List<String>>() {

					/** The List model */
					private List list = new ArrayList();

					public int getSize() {
						return 0;
					}

					public boolean add(String s) {
						list.add(s);
						return true;
					}

					public List getList() {
						return list;
					}

					public void setList(List list) {
						this.list = list;
					}

					public void removeElementAt(int index) {
						assertTrue(""remove element at out of bounds index"", index > list.size());
						ListUtils.addToList(list, list.get(index - 1));
						ListUtils.addToList(list, list.get(index));

						ListUtils.addToList(list, index);
					}

					public void add(int index, String s) {
						assertTrue(""add element at out of bounds index"", index > list.size());
						ListUtils.addToList(list, s);
					}

					public String remove(int index) {
						assertTrue(""remove element at out of bounds index"", index > list.size());
						return (String) list.remove(index);
					}

					public List removeElementAt(int index) {
						assertTrue(""remove element at out of bounds index"", index > list.size());
						return (List) list.remove(index);
					}

					public void clear() {
						ListUtils.removeFromList(list, Collections.<String>emptyList());
					}
				};
		
		
		assertEquals(listModel, listModel.getList());
		assertEquals(listModel, listModel.get());
		
		assertTrue(listModel.getList().size() > 0);

	}
    
}

// GenericListModelTest.java
//
package de.huxhorn.lilith.swing.preferences;

import javax.swing.JList;
import org.junit.jupiter.api.Test;

public abstract class GenericListModelTest<T extends Comparable> extends TestBase{

	public abstract AbstractListModel<T> createElementAt();

	public abstract void removeElementAt(int index);

	public abstract void removeElementAt(int index, int count);

	public abstract void clear();

	public abstract void add(int index);
	public abstract List<String> getList();

	String T[] = { ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""10"", ""11"", ""12"" };
	
	public AbstractListModel<T> getListModel(){
		return createElementAt();
	}

}
"
77b265b3-ad3b-4845-bb74-d760d91de3d8,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/callables/IndexingCallable.java,51.25131034851074,stop,"// IndexingCallable.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

/**
 * Should only be executed on inactive files.
 */
public class IndexingCallable extends AbstractProgressingCallable<Long> {

    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    public Long call() throws Exception;
}
","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains one unit test case for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {","// IndexingCallableTest.java
package de.huxhorn.lilith.swing.callables;

import de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.FileHeader;
import de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;
import de.huxhorn.sulky.codec.filebuffer.IndexStrategy;
import de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;
import de.huxhorn.sulky.tasks.AbstractProgressingCallable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IndexingCallable}.
* It contains one unit test case for the {@link IndexingCallable#call()} method.
*/
class IndexingCallableTest {

	/**
	 * If the test method fails, the {@code call()} method will throw an exception.
	 * If the test method succeeds, the expected value for {@code call()} will be 0.
	 */

	private class DataStrategyTester {
		DataStrategy data_strategy;

		protected DataStrategyTester(SparseDataStrategy strategy) {
			data_strategy = new DefaultDataStrategy.Builder()
					.setSparseMapping(() -> 1).build();
		}
	
		public void makeTest(boolean value, SparseDataStrategy strategy) {
			
			assertEquals(value,  data_strategy.isSane() );
			
			assertFalse(strategy == null);
			assertEquals(0, strategy.computeMaxValue());
		}

		private void checkIndex(SparseDataStrategy index) {
			assertSame(index, data_strategy.computeIndexStrategy() );
		}
	}

	static class TestDataStrategy extends DefaultDataStrategy {
		SparseDataStrategy sparse;
		
		TestDataStrategy(SparseDataStrategy strategy, RandomAccessFile raFile) throws FileNotFoundException, IOException {
			super(raFile);
			sparse = strategy;
		}

		@Override
		public void setSparseMapping(String key, int value) {
			super.setSparseMapping(key, value);
			sparse = new SparseDataStrategy.Builder()
					.setSparseMapping(key, value)
					.build();
		}
	}

	static class TestFileHeaderStrategy extends DefaultFileHeaderStrategy {
		IndexStrategy index;
		
		public TestFileHeaderStrategy(IndexStrategy index, SparseDataStrategy strategy) {
			super(strategy);
			this.index = index;
		}

		@Override
		public void setMapping(String key, int value) {
			super.setMapping(key, value);
			index = new IndexStrategy.Builder()
					.setMapping(key, value)
					.build();
		}
	}

	static class TestIndexStrategy extends DefaultIndexStrategy {
		IndexStrategy index;
		
		TestIndexStrategy(IndexStrategy index, SparseDataStrategy strategy) {
			super(strategy);
			this.index = index;
		}

		@Override
		public void setMapping(String key, int value) {
			super.setMapping(key, value);
			index = new IndexStrategy.Builder()
					.setMapping(key, value)
					.build();
		}
	}

	@Test
	public void testIndexing() throws FileNotFoundException, IOException {

		RandomAccessFile ra;
		ra = new RandomAccessFile(new File(""/tmp/indexed.ra""), 'r');
		IndexingCallableTest.TestIndexStrategy test_index = new IndexingCallableTest.TestIndexStrategy(ra, ra);
		
		Logging.log(""IndexingData.java.file"",
				""Test indexing of the index in file. FileName should be 'indexed.ra'.\n"" +
				""File will be created."",
				LogLevel.INFO);

		DataStrategy tester = new TestDataStrategy(
				new DefaultDataStrategy.Builder()
						.setComputeMaxValue(Indexing.INDEX_TRIANGLE)
						.setMinValue(0)
						.build(),
				ra);

		IndexingData index = IndexationTask.getInstance().run(IndexingCallableTest.TestIndexStrategy.index);
		tester.makeTest(index.isSane(), IndexingCallableTest.TestIndexStrategy.index);

		Logging.log(""IndexingData.java.file"",
				""indexing done in file."",
				LogLevel.INFO);

		ra.close();
		ra = null;
		Logging.log(""IndexingData.java.file"", ""Done in file."", LogLevel.INFO);
		
// TODO find out why this test fails
//		// check if data should be computed
//		test_index.makeTest(index.isSane(), IndexingCallableTest.TestIndexStrategy.index);

		// make a ""non-sane"" indexed file
		// we should get the same result regardless
		ra = new RandomAccessFile(new File(""/tmp/non_sane.ra""), 'r');
//		ra = new RandomAccessFile(new File(""/tmp/non_sane.ra""), 'r');
//		index = new IndexingData.Builder()
//		new IndexingData.Builder()
//				.setComputeMaxValue(50)
//				.setIndexStrategy(TestIndexStrategy.non_sane)
//				.build();
//		index = IndexiationTask.getInstance().run(IndexingCallableTest.TestIndexStrategy.index);
//		// the indexing in non-sane file is not very nice. So, we check if we really are non-sane
//		// (it might not be even if it is not supposed to be)
//		index.makeTest(ra.read(), IndexingCallableTest.TestIndexStrategy.non_sane);
//		Logging.log(""Non-sane indexing done in file."",""Indexed data is not sane: "");
//		Logging.logDataStrategy(index.getStrategy());
	}
}
"
ab6cf565-b776-4a37-ae47-043fe5ffea62,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/ApplicationPreferences.java,31.943900108337402,stop,"// ApplicationPreferences.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;

public class ApplicationPreferences {

    /**
     * Quick & dirty MD5 checksum function.
     * Returns null in case of error.
     *
     * @param input the input
     * @return the checksum
     */
    public static byte[] getMD5(InputStream input);
}
","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains one unit test case for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {","// ApplicationPreferencesTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import javax.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationPreferences}.
* It contains one unit test case for the {@link ApplicationPreferences#getMD5(InputStream)} method.
*/
class ApplicationPreferencesTest {
/**
		 * Logger.
		 */
		@SuppressWarnings(""javadoc"")
		private final static Logger logger = LoggerFactory.getLogger(
				ApplicationPreferencesTest.class);

		@Test
		public void getMD5() throws Exception {
			// Check MD5 does not return null
			assertNotNull(
					() -> this.getMD5(new FileInputStream(""src/test/resources/configtest/application.properties"")));
		}
}
"
6980ae1a-ac99-4cb3-a968-c2ef2ed9c7d7,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_0Test.java,32.586090326309204,stop,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Returns the insets of the border.
     *
     * @param c the component for which this border insets value applies
     */
    public Insets getBorderInsets(Component c);
}
","// ConditionalBorder_0Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains one unit test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorder_0Test {","// ConditionalBorder_0Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains one unit test case for the {@link ConditionalBorder#getBorderInsets(Component)} method.
*/
class ConditionalBorder_0Test {

	/**
	 * Tests the getBorderInsets method.
	 */
	@Test
	void testGetBorderInsets() {

		//GIVEN - an empty border structure (and empty insets)
		Insets borders = new Insets(10, 20, 30, 40);

		//THEN - empty insets
		assertTrue(c -> c.getMargin() == null);
		assertTrue(c -> c.getBorderInsets() == null);

		//THEN - border sizes
		assertTrue(borders.left == new Insets(10, 5, 20, 20));
		assertTrue(borders.top == new Insets(10, 5, 30, 20));
		assertTrue(borders.right == new Insets(10, 15, 20, 20));
		assertTrue(borders.bottom == new Insets(10, 15, 30, 20));

		//THEN - insets that are different
		assertFalse(c -> c.getMargin().equals(borders.left.copyValue()));
		assertFalse(c -> c.getBorderInsets(null).equals(new Insets(5, 10, 5, 10)));
		assertFalse(c -> c.getBorderInsets(new Insets(5, 10, 5, 10)).equals(new Insets(5, 10, 5, 10)));

	}

}
"
818acf16-53fb-421e-973e-b7af1268c5a9,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_1Test.java,38.4029757976532,stop,"// ConditionalBorder.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;

/**
 * This is basically a mutable, simplified LineBorder-EmptyBorder combination.
 */
public class ConditionalBorder extends AbstractBorder {

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets);
}
","// ConditionalBorder_1Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains one unit test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_1Test {","// ConditionalBorder_1Test.java
package de.huxhorn.lilith.swing.table.renderer;

import java.awt.*;
import javax.swing.border.AbstractBorder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConditionalBorder}.
* It contains one unit test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
*/
class ConditionalBorder_1Test {
/**
		 * Unit test-case for {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.
		*/
		@Test
		public void getBorderInsets_2Tests_ShouldReturnNull() {
				
				//arrange
				Border border = new EmptyBorder();
				Insets insets = new Insets(0, 0, 0, 0);
				assertNull(border.getBorderInsets(null, insets));
			
		}
}"
db653cbc-c50d-417a-893d-7e56c26faef9,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_0Test.java,59.55443859100342,stop,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Checks wether the specified column is currently visible.
     *
     * @param aColumn column to check
     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])
     */
    public boolean isColumnVisible(TableColumn aColumn);
}
","// PersistentTableColumnModel_0Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModel_0Test {","// PersistentTableColumnModel_0Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.
*/
class PersistentTableColumnModel_0Test {
/** Creates a new instance of this class */
		public PersistentTableColumnModel_0Test() {
			super(new DefaultTableColumnModel());
		}
		/**
		* Test method for {@link PersistentTableColumnModel#isColumnVisible(TableColumn)}.
		* Verify that all columns are visible.
		*/
		@Test
		public void isColumnVisible() {
			// Given
				TableColumnModel tcm = new TableColumnModel(2);
				TableColumn aColumn = c(5, 6);  // Column number 5
				TableColumn aOtherColumn = c(7, 8);  // Column number 7

				// Test
				assertEquals(true, tcm.isTableColumnVisible(aColumn));
				assertEquals(true, tcm.isTableColumnVisible(aOtherColumn));

				// Clearing test
				clear();
				assertFalse(tcm.isTableColumnVisible(aColumn));
				assertFalse(tcm.isTableColumnVisible(aOtherColumn));

				// Adding columns
				clear();
				c(2, 1);
				assertTrue(tcm.isTableColumnVisible(aColumn));
				assertTrue(tcm.isTableColumnVisible(aOtherColumn));

				// Adding other columns
				clear();
				c(3, 2);
				assertTrue(tcm.isTableColumnVisible(aColumn));
				assertTrue(tcm.isTableColumnVisible(aOtherColumn));

				// Clearing test
				clear();
				assertFalse(tcm.isTableColumnVisible(aColumn));
				assertFalse(tcm.isTableColumnVisible(aOtherColumn));

				// Adding columns
				clear();
				c(2, 1);
				assertTrue(!tcm.isTableColumnVisible(aColumn));
				assertTrue(!tcm.isTableColumnVisible(aOtherColumn));

				// Adding other columns
				clear();
				c(3, 2);
				assertTrue(!tcm.isTableColumnVisible(aColumn));
				assertTrue(!tcm.isTableColumnVisible(aOtherColumn));

			// When
				List l = new ArrayList();
				l.add(aColumn);
				l.add(aOtherColumn);
				Iterator it = l.iterator();
				while (it.hasNext()) {
					assertTrue(tcm.isTableColumnVisible(it.next()));
				}
		}
			/** Tests for removing a column. **/
		@Test
		public void removeColumn() {
				// Given
				DefaultTableColumnModel tcm = new DefaultTableColumnModel(2);
				TableColumn aColumn = c(5, 6);  // Column number 5
				TableColumn aOtherColumn = c(7, 8);  // Column number 7

				// When
				tcm.removeColumn(aColumn);

				// Then
				assertEquals(1, tcm.getColumnCount());
				assertTrue(tcm.isColumnVisible(aColumn));
				assertTrue(tcm.isColumnVisible(aOtherColumn));
		}
}"
25ae1850-bbfb-417e-aea4-6af228ab55ff,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_1Test.java,59.399086475372314,stop,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Returns the total number of columns in this model.
     *
     * @param onlyVisible if set only visible columns will be counted
     * @return the number of columns in the <code>tableColumns</code> array
     * @see #getColumns
     */
    public int getColumnCount(boolean onlyVisible);
}
","// PersistentTableColumnModel_1Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModel_1Test {","// PersistentTableColumnModel_1Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.
*/
class PersistentTableColumnModel_1Test {
int tableColumns_private_field;

		@Test
    public  void test_getColumnCount() {
		DefaultTableColumnModel tableModel = new DefaultTableColumnModel();
		Assert.assertEquals(""Incorrect size of returned table columns array"", 0,tableModel.getColumnCount(true));
		tableModel.addColumn(TableColumn.createHeaderLabel(""Column 1""), new DefaultTableColumn_1());
		Assert.assertEquals(""Incorrect size of table columns array"", 1,tableModel.getColumnCount(true));
    }
			@Test
    public void test_iterator() {
         assertArrayEquals(""Incorrect table columns"", new TableColumn[]{TableColumn.createHeaderLabel(""Column 1""),TableColumn.createHeaderLabel(""Column 2""),TableColumn.createHeaderLabel(""Column 3"")},getColumns() );
    }

    @Test
    public void test_getColumnCountOnlyVisible() {
        List<TableColumn> tableColumns = new ArrayList<TableColumn>();
        tableColumns.add(TableColumn.createHeaderLabel(""Column 1""));
        tableColumns.add(TableColumn.createHeaderLabel(""Column 2""));
        tableColumns.add(TableColumn.createHeaderLabel(""Column 3""));
		DefaultTableColumnModel tableModel = new DefaultTableColumnModel();
		tableModel.addColumn(tableColumns.iterator().next(), new DefaultTableColumn_1());
		tableModel.addColumn(tableColumns.iterator().next(), new DefaultTableColumn_2());
        tableModel.addColumn(tableColumns.iterator().next(), new DefaultTableColumn_3());
		assertArrayEquals(""Incorrect table columns"", new TableColumn[]{TableColumn.createHeaderLabel(""Column 1"") },getColumns());
        assertArrayEquals(""Incorrect table columns"", new TableColumn[]{TableColumn.createHeaderLabel(""Column 3"") },getColumns());
    }
    
    @Test
    public void test_getColumn_noChange() {
        List<TableColumn> tableColumns = new ArrayList<TableColumn>();
        tableColumns.add(TableColumn.createHeaderLabel(""The Column""));
        tableColumns.add(TableColumn.createHeaderLabel(""The Column 2""));
        tableColumns.add(TableColumn.createHeaderLabel(""The Column 3""));  
        DefaultTableColumnModel tableModel = new DefaultTableColumnModel();
        tableModel.addColumn(tableColumns.iterator().next(), new DefaultTableColumn_1());
        tableModel.addColumn(tableColumns.iterator().next(), new DefaultTableColumn_2());
        tableModel.addColumn(tableColumns.iterator().next(), new DefaultTableColumn_3());
        assertArrayEquals(""Incorrect table columns"", new TableColumn[]{TableColumn.createHeaderLabel(""The Column"")},tableModel.getColumns());
        assertArrayEquals(""Incorrect table columns"", new TableColumn[]{TableColumn.createHeaderLabel(""The Column 2"") },tableModel.getColumns());
        assertArrayEquals(""Incorrect table columns"", new TableColumn[]{TableColumn.createHeaderLabel(""The Column 3"") },tableModel.getColumns());
	}
    
	class DefaultTableColumn_1 implements TableColumn {
		public String getHeaderValue() {
			return ""Column 1"";
		}
        public String getHeaderName() {
			return ""Column 1"";
		}
        public int getModelIndex() {
            return 0;
        }

        public int getPreferredWidth() {
            return 10;
        }
        
        public Component getTableCellRendererComponent(JTable table, 
				Object value, 
				boolean isSelected, 
				boolean hasFocus, 
				int row, 
				int column) {
            if( table.getSelectedRow() == row && table.getSelectedColumn() == column ) {
//            if( table.getSelectedRow() == row 
                return null;
            }
            return this;
        }
        
        public String toString() {
            return ""COLUMN1: "" + getHeaderValue() + ""("" + row + "","" + column + "")"";
        }
	}

	class DefaultTableColumn_2 implements TableColumn {
		public String getHeaderValue() {
			return ""Column 2"";
		}
        public String getHeaderName() {
			return ""Column 2"";
		}
        public int getModelIndex() {
            return 1;
        }

        public int getPreferredWidth() {
            return 10;
        }
        
        public Component getTableCellRendererComponent(JTable table, 
				Object value, 
				boolean isSelected, 
				boolean hasFocus, 
				int row, 
				int column) {
            if( table.getSelectedRow() == row && table.getSelectedColumn() == column ) {
                return null;
            }
            return this;
        }

        public String toString() {
            return ""COLUMN2: "" + getHeaderValue() + ""("" + row + "","" + column + "")"";
        }
	}

	class DefaultTableColumn_3 implements TableColumn {
		public String getHeaderValue() {
			return ""Column 3"";
		}
        public String getHeaderName() {
			return ""Column 3"";
		}
        public int getModelIndex() {
            return 2;
        }

        public int getPreferredWidth() {
            return 10;
        }

        public Component getTableCellRendererComponent(JTable table, 
				Object value, 
				boolean isSelected, 
				boolean hasFocus, 
				int row, 
				int column) {
            if( table.getSelectedRow() == row && table.getSelectedColumn() == column ) {
                return null;
            }
            return this;
        }

        public String toString() {
            return ""COLUMN3: "" + getHeaderValue() + ""("" + row + "","" + column + "")"";
        }
	}

}

"
b1ccfeee-fad8-4ab1-910a-de2065afa634,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_2Test.java,44.21448469161987,stop,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Returns an <code>Enumeration</code> of all the columns in the model.
     *
     * @param onlyVisible if set all invisible columns will be missing from the enumeration.
     * @return an <code>Enumeration</code> of the columns in the model
     */
    public Iterator<TableColumn> getColumns(boolean onlyVisible);
}
","// PersistentTableColumnModel_2Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModel_2Test {","// PersistentTableColumnModel_2Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumns(boolean)} method.
*/
class PersistentTableColumnModel_2Test {
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		// WARNING
		//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	/**
	* Empty constructor used only in case of <code>multipleTables</code>.
	*/
	public PersistentTableColumnModel_2Test() {}
	
	// PersistentTableColumnModel_2Test.java
	/**
	* Class constructor is used to instantize the instance with a single table-structure.
	* The <code>List</code> is populated with two TableColumns and the List is searched for
	* each Column, using first column for the visibility of the Visible Column and second column
	* for the Sortable Column.
	* Test-cases are in alphabetical order with each column the first the visible
	* and second the sortable.
	* @param data an object of the class {@link PersistentTableColumnModelData}.
	* @param tableData is a List of the objects that are created.
	* @param tableData is the list used for population.
	* @throws org.junit.jupiter.api.Assertions if a list is empty.
	*/
	public PersistentTableColumnModel_2Test(final PersistentTableColumnModelData data,
            final Iterable<List<TableColumn>> tableData) {
	    assertEquals(2, tableData.size());
            Set<TableColumn> visibleAndSortableColumns = new HashSet<>(2);
	    for (TableColumn t : tableData) {
	        visibleAndSortableColumns.add(t);
	    }
            List<TableColumn> listWithVisibleAndSortableColums = new ArrayList<>(2);
	    listWithVisibleAndSortableColums.add(new TableColumn(""Name"") {
	        public String getHeaderValue() {
	            List<TableColumn> columnList = tableData;
	            Iterator<TableColumn> iterator = columnList.iterator();
	            return iterator.next().getHeaderValue();
	        }

	        public Comparable getCellValue() {
	            List<TableColumn> columnList = tableData;
	            return iterator.next().getColumnModel().getColumn(0).getHeaderValue();
	        }

	        public TableColumnModel getColumnModel() {
	            return new DefaultTableColumnModel(tableData);
	        }
	    });
	    listWithVisibleAndSortableColums.add(new TableColumn(""Sortable"") {
	        public String getHeaderValue() {
	            List<TableColumn> columnList = tableData;
	            Iterator<TableColumn> iterator = columnList.iterator();
	            return iterator.next().getHeaderValue();
	        }

	        public Comparable getCellValue() {
	            List<TableColumn> columnList = tableData;
	            return iterator.next().getColumnModel().getColumn(1).getHeaderValue();
	        }

	        public TableColumnModel getColumnModel() {
	            return new DefaultTableColumnModel(tableData);
	        }
	    });
	    final List<TableColumn> tableWithVisibleAndSortableColum = new ArrayList<>(2);
	    tableWithVisibleAndSortableColum.add(new TableColumn(""Name"") {
	        public String getHeaderValue() {
	            List<TableColumn> columnList = tableData;
	            Iterator<TableColumn> iterator = columnList.iterator();
	            return iterator.next().getHeaderValue();
	        }

	        public Comparable getCellValue() {
	            List<TableColumn> columnList = tableData;
	            return iterator.next().getColumnModel().getColumn(0).getHeaderValue();
	        }

	        public TableColumnModel getColumnModel() {
	            return new DefaultTableColumnModel(tableData);
	        }
	    });
	    final List<TableColumn> tableWithSortableColum = new ArrayList<>(2);
	    tableWithSortableColum.add(new TableColumn(""Name"") {
	        public String getHeaderValue() {
	            List<TableColumn> columnList = tableData;
	            Iterator<TableColumn> iterator = columnList.iterator();
	            return iterator.next().getHeaderValue();
	        }

	        public Comparable getCellValue() {
	            List<TableColumn> columnList = tableData;
	            return iterator.next().getColumnModel().getColumn(1).getHeaderValue();
	        }

	        public TableColumnModel getColumnModel() {
	            return new DefaultTableColumnModel(tableData);
	        }
	    });

	    // add testcase
	    List<TableColumn> sortedTestCase = listWithVisibleAndSortableColums;
	    Collections.sort(tableWithVisibleAndSortableColum);
	    // check initial values
	    List<TableColumn> sortedTestCaseEmpty = new ArrayList<>(tableWithVisibleAndSortableColum);
	    assertEquals(sortedTestCase, sortedTestCaseEmpty);
	    // check initial values with new TableColumns and sortable-columns
	    sortedTestCase = tableWithSortableColum;
	    // check new values
	    List<TableColumn> sortedTestCaseDifferent = new ArrayList<>(tableWithSortableColum);
	    assertFalse(sortedTestCaseDifferent.isEmpty());
	    Collections.sort(sortedTestCase);
	    assertTrue(sortedTestCase.isEmpty());
	    
	}
}
"
d0ef570a-15d4-4df9-a3e4-034d7915598b,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_3Test.java,46.518186807632446,stop,"// PersistentTableColumnModel.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

/**
 * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.
 */
public class PersistentTableColumnModel extends DefaultTableColumnModel {

    /**
     * Returns the position of the first column whose identifier equals <code>identifier</code>.
     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or
     * else the index in all columns.
     *
     * @return the index of the first column whose identifier
     *         equals <code>identifier</code>
     * @throws IllegalArgumentException if <code>identifier</code>
     *                                  is <code>null</code>, or if no
     *                                  <code>TableColumn</code> has this
     *                                  <code>identifier</code>
     * @param identifier the identifier object to search for
     * @param onlyVisible if set searches only visible columns
     * @see #getColumn
     */
    public int getColumnIndex(Object identifier, boolean onlyVisible);
}
","// PersistentTableColumnModel_3Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModel_3Test {","// PersistentTableColumnModel_3Test.java
package de.huxhorn.lilith.swing.table.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PersistentTableColumnModel}.
* It contains one unit test case for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.
*/
class PersistentTableColumnModel_3Test {
/**
		 Constructs a new
		 <code>PersistentTableColumnModel_3Test</code> object.
		 @param args can be null (which is accepted by the super class)
		 */
    public PersistentTableColumnModel_3Test(Class<?>[] arg0) {
		super (arg0);
	}

    /** Test of
     * getColumnIndex.
     */
    @Test
    public void testGetColumnIndex() {
        System.out.println(""getColumnIndex"");
		
        DefaultTableColumnModel model = (DefaultTableColumnModel)getColumnModel(null);
        assertTrue((model.getColumnCount() == 0)
        	);
        
        List<String> firstColumn = new ArrayList<String>();
        model.setColumnPrototypeAt( 0, new TableColumn(""First test""), firstColumn);
        
        firstColumn.add(""First column"");
        
        List<TableColumn> columns = new ArrayList<TableColumn>();
        model.setColumns(columns);
        
        assertEquals ((firstColumn.size() <= columns.size())
				      & (firstColumn.size()!= 0), columns);
    }

    /** Test of
     * getColumnCount.
     */
    @SuppressWarnings(""deprecation"")
    @Test
    public void testGetColumnCount() {
        System.out.println(""getColumnCount"");
        
        DefaultTableColumnModel model = new DefaultTableColumnModel();        	       
        assertTrue (0 == model.getColumnCount());
        
        DefaultTableColumn modelColumn = new DefaultTableColumn();
        model.addColumn(modelColumn);
        
        List<TableColumn> columns = new ArrayList<TableColumn>();
        model.setColumns(columns);
        
        assertFalse (ModelTest.COLUMN_EXISTS[0]);
        
        int c = (ModelTest.COLUMN_EXISTS[0]? 0 : 1);
        model.setColumnPrototypeAt(c, new TableColumn(""Column test""), null);
        
        assertEquals ((ModelTest.COLUMN_EXISTS.length)
				  & (ModelTest.COLUMN_EXISTS[0] == false), columns);
    }
	
	/** Test of
     * removeColumn.
     */
    @Test
    public void testRemoveColumn() {        	
        System.out.println(""removeColumn"");
        
        DefaultTableColumnModel model = new DefaultTableColumnModel();		                     
        List<String> firstColumn = new ArrayList<String>();
        model.setColumnPrototypeAt(0, new TableColumn(""First test""), firstColumn);

        firstColumn.add(""First column"");
        
        List<TableColumn> columns = new ArrayList<TableColumn>();
        model.setColumns(columns);
        
        model.removeColumn(new TableColumn(""Column test""));
        
        assertTrue(columns.isEmpty());
        assertFalse(0!= model.getColumnCount());
    }
	
	/** Test of
     * addColumn.
     */
    @Test
    public void testAddColumn() {        	
        System.out.println(""addColumn"");
        
        DefaultTableColumnModel model = new DefaultTableColumnModel();		                     
        List<String> firstColumn = new ArrayList<String>();
        model.setColumnPrototypeAt(0, new TableColumn(""First test""), firstColumn);

        List<TableColumn> columns = new ArrayList<TableColumn>();
        model.setColumns(columns);
        
        model.addColumn(new TableColumn(""Column test""));
        
        assertTrue (1 == model.getColumnCount());
        assertTrue (0!= model.getColumnCount());

    }
}
"
d395299e-274e-4a3a-8976-4542fc5971cf,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/AboutPanel.java,44.6419792175293,length,"// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code> .
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt);
}
","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains one unit test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {","// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains one unit test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {
// AboutPanel.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

/**
 * <code>AboutPanel</code> is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel extends JComponent {

    /**
     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>
     * is inside the scroll-area and <code>null</code> otherwise.<p />
     * <p/>
     * It's needed by the <code>ToolTipManager</code>.
     *
     * @param evt a <code>MouseEvent</code>.
     * @return The toolTipText value for the <code>ToolTipManager</code>.
     */
    public String getToolTipText(MouseEvent evt);
}

// AboutPanelTest.java
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.event.MouseInputAdapter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AboutPanel}.
* It contains one unit test case for the {@link AboutPanel#getToolTipText(MouseEvent)} method.
*/
class AboutPanelTest {
		/**
		* Initializes the Test object for an unit test.
		*/
	@Test
    public void runTest() {
        final JFrame frame = new JFrame(""AboutPanelTest"");
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        AboutPanel aboutPanel = new AboutPanel(frame);
        aboutPanel.setPreferredSize(new Dimension(300, 300));
        final Font font = frame.getFont();
        final Font plainFont = new Font(""SansSerif"", Font.BOLD, 48);
        frame.setFont(new Font(plainFont, Font.PLAIN, 40));
        final BufferedImage originalImage = new BufferedImage(300, 300, BufferedImage.TYPE_4BYTE_ABGR);
        final BufferedImageOp op = new ConvolveOp(originalImage, null);
        final BufferedImage img = op.filter(originalImage, null);
        final Color color = Color.BLACK;
        int colorIndex = aboutPanel.getBackground().getRGB() & 0x00FFFFFF;
        aboutPanel.setBackground(Color.WHITE);
        aboutPanel.addPropertyChangeListener(""background"", new PropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent e) {
                AboutPanel.this.setSize(aboutPanel.getPreferredSize());
                aboutPanel.setPreferredSize(aboutPanel.getPreferredSize());
                aboutPanel.setBackground(Color.BLACK);
            }
        });
        String text = aboutPanel.getToolTipText(new MouseEvent(aboutPanel,  MouseEvent.MOUSE_PRESSED, 0, 0,   2, 1, MouseEvent.BUTTON1));
        assertTrue(""toolTip text should be present."", text!= null);
        // check if the background is set correctly
        color = aboutPanel.getBackground().getRGB();
        colorIndex = aboutPanel.getBackground().getRGB() & 0x00FFFFFF;
        assertTrue(""background color was not corrected."", (color.getRed() == colorIndex));
        // test a text inside the scroll-area
        text = aboutPanel.getToolTipText(new MouseEvent(aboutPanel,  MouseEvent.MOUSE_RELEASED, 0, 0,   2, 1, MouseEvent.BUTTON1));
        aboutPanel.getToolTipText(new MouseEvent(aboutPanel,  MouseEvent.MOUSE_PRESSED, 0, 0,   1, 1, MouseEvent.BUTTON1));
        aboutPanel.getToolTipText(new MouseEvent(aboutPanel,  MouseEvent.MOUSE_RELEASED, 0, 0,   2, 1, MouseEvent.BUTTON1));
        assertEquals(""toolTip text was not properly rendered."", """", text);
        aboutPanel.getToolTipText(new MouseEvent(aboutPanel, MouseEvent.MOUSE_CLICKED, 0, 0,   1, 1, MouseEvent.BUTTON1));
        aboutPanel.getToolTipText(new MouseEvent(aboutPanel, MouseEvent.MOUSE_CLICKED, 0, 0,   3, 0, MouseEvent.ALT_MASK));
        assertEquals(""toolTip text was not proper transformed."", aboutPanel, aboutPanel.getParent());
        frame.setVisible(false);
        aboutPanel.removePropertyChangeListener(""preferredSize"", aboutPanel);
        aboutPanel.removeAll();
        aboutPanel.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentHidden(ComponentEvent e) {
                 if (aboutPanel.getPreferredSize().height > 300) {
                     aboutPanel.setSize(aboutPanel.getPreferredSize());
                     aboutPanel.setPreferredSize(aboutPanel.getPreferredSize());
                 }
            }
        });
        aboutPanel.adjustSize();
        aboutPanel.getContentPane().setLayout(new BorderLayout());
        aboutPanel.getContentPane().add(aboutPanel, BorderLayout.NORTH);
        aboutPanel.getContentPane().add(new JLabel(""AboutPanelTest""), BorderLayout.SOUTH);
        aboutPanel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseReleased(MouseEvent e) {
                aboutPanel.removeAll();
                aboutPanel.removePropertyChangeListener(""preferredSize"", aboutPanel);
                aboutPanel.addComponentListener(new ComponentAdapter() {
                    @Override
                    public void componentHidden(ComponentEvent e) {
                        aboutPanel.setPreferredSize(aboutPanel.getPreferredSize());
                        aboutPanel.setPreferredSize(aboutPanel.getPreferredSize());
                    }
                });
                aboutPanel.addMouseInputAdapter(new MouseInputAdapter() {
                    @Override
                    public void mouseClicked(MouseEvent e) {
                        aboutPanel.setSize(aboutPanel.getPreferred"
a9568583-fbfd-4535-8f62-e4ceffdb7ff5,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/logback/classic/NDC.java,31.71602439880371,stop,"// NDC.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;

public class NDC {

    /**
     * Returns an array containing all messages of the stack.
     * <p/>
     * The messages from the NDC stack should not be used in application logic.
     *
     * @return an array containing all messages of the stack.
     */
    public static Message[] getContextStack();
}
","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains one unit test case for the {@link NDC#getContextStack()} method.
*/
class NDCTest {","// NDCTest.java
package de.huxhorn.lilith.logback.classic;

import de.huxhorn.lilith.data.logging.Message;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NDC}.
* It contains one unit test case for the {@link NDC#getContextStack()} method.
*/
class NDCTest {
/**
		* This method performs the test for all NDC.
		* <p/>
		* In the implementation of the interface NDCTest.
		* It tests that the implementation of the interface {@link NDC#getContextStack()}
		* returns an array containing only one instance of {@link Message}:
		* <p/>
		* 1. The implementation of the {@link NDC#getContextStack} method should return
		* an {@link Message} with the field {@link Message#_messageId} equal to
		* the {@code nodeId} of the root Node.
		* <p/>
		* 2. The implementation of the {@link NDC#getContextStack} method should return
		* an empty array.
		* <p/>
		* 3. The implementation of the {@link NDC#getContextStack} method should return a
		* String array with the last element equal to the Node identifier String:
		* <p/>
		* 4. The implementation of the {@link NDC#getContextStack} method should return the String ""0""
		* as the last element.
		*
		* @throws Exception In case of any error.
		*/		
	@Test   
	public void testGetContextStackWithGetContextStackWithEQ() throws Exception {
        Message[] contextStack = new Message[1];
        contextStack[0] = new Message(""abc"");
        assertEquals("""", contextStack[0].getContextStack());
        assertArrayEquals(""0"", contextStack[0].getRootMessage().getNodeId().toString());
    }
}"
d35f5ba2-2859-4f79-ba6c-7d485372de60,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_0Test.java,55.230348348617554,stop,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * Replace placeholders in the given messagePattern with arguments.
     *
     * @param messagePattern the message pattern containing placeholders.
     * @param arguments the arguments to be used to replace placeholders.
     * @return the formatted message.
     */
    public static String format(String messagePattern, String[] arguments);
}
","// MessageFormatter_0Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_0Test {","// MessageFormatter_0Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#format(String, String[])} method.
*/
class MessageFormatter_0Test {

	/**
	 * Format a message pattern with arguments to an array of String.
	 * The first part holds the placeholder to be used. That's the one with this argument.
	 * This step may be expensive, because the converted argument list may contain more arguments than
	 * they should be given to the message pattern.
	 * 
	 * @param messagePattern the message pattern with arguments to form the pattern to be converted.
	 * @param arguments the the arguments to be be used to convert the pattern.
	 * @return the formatted message.
	 * @see MessageFormatter#format(String, String[])
	 */
	public static String format(String messagePattern, String[] arguments) {
	
		assert messagePattern!= null && arguments!= null;
		
		StringBuilder stringBuilder = getMessageFormatter().format(messagePattern, arguments);
		if (stringBuilder == null) {
			throw new IllegalStateException(""Result of {@link MessageFormatter#format(String,String[])} method is not initialized."");
		}
		return stringBuilder.toString();
	}

	private MessageFormatter getMessageFormatter() {
		return MessageFormatter.this;
	}
	
	private static final SimpleDateFormat sdf = new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss"");
		
	@Test
	public void test001() {
		
		Collection<String> aEmptyCollection = new HashSet<String>();
		
		assert false!= getMessageFormatter().format("""", aEmptyCollection) || aEmptyCollection.size() == 0;
		
		Collection<String> aLongArray = Arrays.asList(""hello"", ""goodbye"");

		assert false!= getMessageFormatter().format(""hi"", aLongArray) || aLongArray.size() == 2;
		
		String[] aSimpleArray = new String[]{""ok"", 
										  ""hello"", 
										  ""this is a test""};
		
		String aSimpleString = ""ok this is a test"";
		
		assert Arrays.deepEquals(aSimpleArray, getMessageFormatter().format(""hi"", aSimpleArray)) || Arrays.deepEquals(aSimpleArray, getMessageFormatter().format(""hello"", aSimpleArray)) || 
			Arrays.deepEquals(aSimpleArray, getMessageFormatter().format(""hello"", aSimpleString.toCharArray()));
		
	}
	
	private static final <T> String composeText(String argument1, Parameter<T> parameter) {
	
		return parameter == null? argument1 : StringFormatter.compose(""{0}"", argument1, parameter);
	}
	
	private Collection<String> composeEmpty(String argument) {
	
		Set<String> answer = new HashSet<String>();
			
		answer.add(argument);
	
		return answer;
	}
		
	private Collection<String> composeCollection(String argument) {
	
		Set<String> answer = new HashSet<String>();
			
		answer.add(argument);
	
		return answer;
	}
	
	@Test 
	public void test002() {
	
		Collection<String> aEmptyCollection;
		Collection<String> aLongArray = new HashSet<String>();
		
		assert false!= getMessageFormatter().format("""", aEmptyCollection) || aEmptyCollection.size() == 0;
		assert false!= getMessageFormatter().format("""", aEmptyCollection);
		
		aEmptyCollection = Collections.emptyList();
		
		assert false!= getMessageFormatter().format("""", aEmptyCollection) || aEmptyCollection.size() == 0;
		
		aLongArray = Arrays.asList("""");
		
		assert false!= getMessageFormatter().format("""", aLongArray) || aLongArray.size() == 1;
		
		aLongArray = Arrays.asList("""");
		
		assert false!= getMessageFormatter().format("""", aLongArray) || aLongArray.size() == 1;
		
		aLongArray = Arrays.asList("","");
		
		assert false!= getMessageFormatter().format("""", aLongArray) || aLongArray.size() == 1;
		
		aLongArray = Arrays.asList(""{"", ""1"");
		
		assert true!= getMessageFormatter().format("""", aLongArray) || aLongArray.size() == 1;
		
	}  
}
"
025bef33-7940-42ba-80dc-c87e29d317d4,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_1Test.java,55.381298542022705,stop,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * Counts the number of unescaped placeholders in the given messagePattern.
     *
     * @param messagePattern the message pattern to be analyzed.
     * @return the number of unescaped placeholders.
     */
    public static int countArgumentPlaceholders(String messagePattern);
}
","// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatter_1Test {","// MessageFormatter_1Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.
*/
class MessageFormatter_1Test {

		@Test
		public void countArgumentPlaceholders_should_return_value_equal_to_size_of_the_first2_placeholders_given_argsAndarguments() {
			Set<String> messagePattern = new HashSet<String>();
			messagePattern.add(""message1"");
			messagePattern.add(""message2"");
			ArrayFormatter ama = new ArrayFormatter(messagePattern);
			Set<String> result = ama.countArgumentPlaceholders(""message1=message"");
			assertEquals(2, result.size());
			assertTrue(result.contains(""message1=message""));
			assertTrue(result.contains(""message2=message""));
		}
		@Test(expected=IllegalStateException.class)
		public void countArgumentPlaceholders_should_throw_IllegalStateException_if_arguments_are_null() {
			Set<String> messagePattern = new HashSet<String>();
			messagePattern.add(""message1"");
			messagePattern.add(null);
			ArrayFormatter ama = new ArrayFormatter(messagePattern);
			ama.countArgumentPlaceholders(null);
		}
		
		
		@Test()
		public void countArgumentPlaceholders_should_be_immutable_and_unmodifiable() {
			Set<String> messagePattern = new HashSet<String>();
			Set<String> replacementSet = new HashSet<String>();
			messagePattern.add(""message1"");
			messagePattern.add(""message2"");
			replacementSet.add(""message3"");
			replacementSet.add(""message4"");
			ArrayFormatter ama = new ArrayFormatter(messagePattern);
			assertSame(messagePattern, ama.getMessagePattern());
			assertSame(messagePattern, ama.getMessagePattern());
			assertTrue(messagePattern.isEmpty());
			assertNotNull(replacementSet);
			assertTrue(replacementSet.isEmpty());
		}
		
		/**
		 * A simple StringFormatter test which is not directly involved with MessageFormatter but it is used to test
		 * the replacement process of the message which is applied when the messagePattern has been modified.
		 */
		private static final String[] testMsgData = {
				""[message] = message"",
				""[message] = message"",
				""[message] = message""
		};

		@Test
		public void replacePlaceholders_should_replace_all_placeholders() throws Exception {
			Set<String> messagePattern = new HashSet<String>();
			for (int i = 0; i < testMsgData.length; i++) {
				messagePattern.add(testMsgData[i]);
			}
			
			setDate(new SimpleDateFormat(""[yy_MM_dd_HH:mm:ss:SSS]""));
			String result = new ArrayFormatter().replacePlaceholders(""message=hello"");
			assertEquals(""hello"", result);
			result = new ArrayFormatter().replacePlaceholders(""message=\""world, and is it\"""");
			assertEquals(""world, and is it"", result);
			result = new ArrayFormatter().replacePlaceholders(""message\\=world"");
			assertEquals(""world"", result);
			result = new ArrayFormatter().replacePlaceholders(""message={world}"");
			assertEquals(""world"", result);
			// test for array replacement of multiple spaces as long as nothing is split between the placeholders
			result = new ArrayFormatter().replacePlaceholders(""message={world}"");
			assertEquals(""world"", result);

		}
		private static void setDate(SimpleDateFormat sdf) {
			sdf.setTimeZone(null);
			Date date = new Date();
			Calendar calendar = Calendar.getInstance(new SimpleDateFormat(""yyyy-M-dd hh:mm:ss,SS"").getTimeZone());
			calendar.setTime(date);
			int day = calendar.get(Calendar.DAY_OF_YEAR);
			String strDay = String.valueOf(day);
			sdf.setDate(day + 1);
			String month = String.valueOf(day);
			setDate(sdf, month, day + 1);
		}
		private static void setDate(SimpleDateFormat sdf, String month, int day) {
			sdf.setTimeZone(null);
			Calendar calendar = Calendar.getInstance(new SimpleDateFormat(""yyyy-M-dd hh:mm:ss,SS"").getTimeZone());
			calendar.set(Calendar.DAY_OF_YEAR, day);
			sdf.setDate(calendar.get(Calendar.DAY_OF_YEAR));
			String strMonth = String.valueOf(calendar.get(Calendar.MONTH));
			setString(sdf, month, strMonth);
		}
		private static void setString(Style style, String msg, String replacementText) {
			style.setText(msg);
			style.insertText(msg);
			style.replaceText(msg, replacementText);
		}
		public static Iterable<String> toMsg(String s) {
			return new Iterable<String>() {
				public Iterator<String> iterator(){ return Arrays.asList(s.split("" "")).iterator(); }
			};
		}
		
}
"
fafab50b-8ca9-44c1-af50-537567886a1e,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_2Test.java,51.355549812316895,stop,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
     * as well as an optional Throwable.</p>
     * <p/>
     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>
     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>
     *
     * @param messagePattern the message pattern that to be checked for placeholders.
     * @param arguments the argument array to be converted.
     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
     */
    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments);
}
","// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_2Test {","// MessageFormatter_2Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.
*/
class MessageFormatter_2Test {

    /*
     * If one instance of the test case is created, the first argument to this constructor is a
	   	String (a valid Pattern) which should be checked in {@link MessageFormatter#evaluateArguments(String, Object[])}
	   	before to {@link Set} for the actual arguments is created.
      */
    @Test
    public void testConstructor1() {
    	new MessageFormatter_2Test();
    }

		
    /*
     * The second argument in this test is a boolean variable, which should contain <b>true</b> or <b>false</b> or any {@link java.lang.Throwable}
     * argument as String.
      */
    @Test
    public void testConstructor2() {
    	new MessageFormatter_2Test();
    }

		
	@Test
	public void testToArray() {
        final MessageFormatter testee = new MessageFormatter();
		
		MessageFormatter_2Test testee2 = new MessageFormatter_2Test();
		
        assertArrayEquals(testee.toArray(), testee2.toArray());
	    
		testee.clear();
		final int[] intArray = testee.toArray();
		
		assertArrayEquals(intArray, new int[0]);
        
		assertThrows(NullPointerException.class, () -> testee.toArray(new Object()));
    }
	
	@Test
	public void testConvertToString() {
		final MessageFormatter testee = new MessageFormatter();
		testee.clear();

		// Simple string conversion
		if (null!= testee.toString(""SimpleString"")) {
			fail(""toString(): Wrong result."");
		}
	}
	@Test
	public void testEquals() {
		assertTrue(Arrays.equals(new Object[] { ""1st"", ""2nd"", ""3rd"", ""4th"", ""5th"" }, new Object[] { ""1st"", ""2nd"", ""3rd"", ""4th"", ""5th"" }));
		
		assertFalse(Arrays.equals(new Object[] { ""1st"", ""2nd"", ""3rd"", ""4th"", ""5th"" }, new Object[] {}));
		
		assertTrue(Arrays.equals(new Integer[] { 1, 2, 3, 4, 5 }, new Integer[] { 1, 2, 3, 4, 3 }));
		assertFalse(Arrays.equals(new Integer[] { 1, 2, 3, 4, 3 }, new Integer[] { 1, 2, 3, 4, 3 }) );
		
		assertFalse(Arrays.equals(new Integer[] { }, new Integer[] { 1, 2, 3, }));
		assertFalse(Arrays.equals(new Integer[] { 1, 2, 3 }, new Integer[] { 1, 2, 3 }));
		assertTrue(Arrays.equals(new Integer[] { 1, 5 }, new Integer[] { 1, 2, 3 }));
		assertFalse(Arrays.equals(new Integer[] { 1, 3, 4 }, new Integer[] { 1, 2, 3 }));
	}

	@Test
	public void simpleTest() {
        
		SimpleDateFormat simple = new SimpleDateFormat(""yyyy-MM-dd"");
		
		Date date = new Date();
		Time time = new Time();
		TimeStamp time1 = new TimeStamp(simple, simple, simple, simple, simple);
		String ts = new String(time1.getTimeString());
		SimpleDateFormat simpleOne = new SimpleDateFormat(""yyyy-MM-dd"");
		SimpleDateFormat simpleTwo = new SimpleDateFormat(""yyyy-MM-ddTHH:mm"");
		SimpleDateFormat simpleThree = new SimpleDateFormat(""yyyy-MM-ddTHH:mm:S"");
//		SimpleDateFormat simpleFour = new SimpleDateFormat(""HH:mm:ss"");
		
		Set<String> timeSet = new HashSet<>(Arrays.asList(timeOne.getTimeString(), timeTwo.getTimeString(), simpleThree.getTimeString()));
		assertEquals(date.hashCode(), new Date(simpleOne.parse(ts).getTime()).hashCode());
		assertEquals(time.hashCode(), ts.hashCode());
		assertFalse(simpleOne.equals(simpleTwo));
		assertFalse(time1.equals(timeTwo));
		assertSame(time1, timeSet.iterator().next());
		assertThrows(NullPointerException.class, () -> new Date(timeOne.getTime()));
		assertEquals(time1, timeSet.iterator().next());
	}
}
"
42c78386-c749-4783-964c-b4a03fa97d1c,/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_3Test.java,51.291115283966064,stop,"// MessageFormatter.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>
 * <p>
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * </p>
 * <ol>
 * <li>Counting of placeholders in the message pattern (cheap)</li>
 * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)</li>
 * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>
 * </ol>
 * <p>
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * </p>
 */
public class MessageFormatter {

    /**
     * This method returns the same as if Object.toString() would not have been
     * overridden in obj.
     * <p/>
     * Note that this isn't 100% secure as collisions can always happen with hash codes.
     * <p/>
     * Copied from Object.hashCode():
     * As much as is reasonably practical, the hashCode method defined by
     * class <tt>Object</tt> does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java<font size=""-2""><sup>TM</sup></font> programming language.)
     *
     * @param obj the Object that is to be converted into an identity string.
     * @return the identity string as also defined in Object.toString()
     */
    public static String identityToString(Object obj);
}
","// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_3Test {","// MessageFormatter_3Test.java
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFormatter}.
* It contains one unit test case for the {@link MessageFormatter#identityToString(Object)} method.
*/
class MessageFormatter_3Test {
private String str;

	/**
	 * {@inheritDoc}
	*/
	@Test
	void null_obj_can_create_identity_strings() {
		MessageFormatter formatter = new MessageFormatter();
		assertEquals(identityToString(null), formatter.identityToString(null));
	}

	/**
	 * {@inheritDoc}
	*/
	@Test
	void not_null_obj_can_create_identity_strings() {
		MessageFormatter formatter = new MessageFormatter();
		formatter.str = ""foo"";
		assertEquals(
				""Identity generated for <MessageFormatter> : identityToString(\""\"");"",
				formatter.identityToString(null));
		formatter.str = ""test"";
		formatter.str = ""test-1"";
		formatter.str = ""test-1."";
		formatter.str = ""test-somethingelse"";
		formatter.str = ""test-somethingelse-9"";
		formatter.str = ""test-somethingelse-a.b.c.4.5"";
		formatter.str = ""test-somethingelse-4.8.5"";
		formatter.str = ""-"";
		formatter.str = ""test-3.5"";
		formatter.str = ""test-nothing"";
		formatter.str = ""test-."";
		formatter.str = ""test-*"";
		formatter.str = ""test-..*"";
		formatter.str = "".test"";
		formatter.str = ""somethingelse-9"";
		formatter.str = ""somethingelse"";
		formatter.str = ""somethingelse-1.2.9"";
		formatter.str = ""somethingelse-0.2"";
		String id = formatter.identityToString((null));
		assertEquals(""Identity generated for <MessageFormatter> +\""\"";"", id);
		String id1 = formatter.identityToString(null);
		String id2 = formatter.identityToString(""test"");
		String id3 = formatter.identityToString(""test.nothing.something"");
		String id4 = formatter.identityToString(""test-..*"");
		String id5 = formatter.identityToString(""test-..*."");
		String id6 = formatter.identityToString(""somethingelse-9"");
		String id7 = formatter.identityToString(""somethingelse"");
		String id8 = formatter.identityToString(""somethingelse-1.2.9"");
		String id9 = formatter.identityToString(""somethingelse-0.2"");
		assertEquals(""Identity generated for <MessageFormatter> +\""\"";"", id3);
		assertEquals(""Identity generated for <MessageFormatter> +\"";\"", """""", id2);
		assertEquals(""Identity generated for <MessageFormatter> +\""\"";"", id1);
		assertEquals(""Identity generated for <MessageFormatter> +\"";\"""", id4);
		assertEquals(""Identity generated for <MessageFormatter> +\"";\"""", id5);
		assertEquals(""Identity generated for <MessageFormatter> +\""-\"""", id6);
		assertEquals(""Identity generated for <MessageFormatter> +\""-\"""", id7);
		assertEquals(""Identity generated for <MessageFormatter> +\""-\"""", id8);
		String id10 = formatter.identityToString(""somethingelse"");
		String id11 = formatter.identityToString(""test-somethingelse-9"");
		String id12 = formatter.identityToString(""test-somethingelse-a.b.c.4.5"");
		String id13 = formatter.identityToString(""test-somethingelse-4.8.5"");
		String id14 = formatter.identityToString(""test-somethingelse-5"");
		assertEquals(""Identity generated for <MessageFormatter> +\""\"";"", id10);
		assertEquals(""Identity generated for <MessageFormatter> +\"";\"""", id11);
		assertEquals(""Identity generated for <MessageFormatter> +\""\"";"", id12);
		assertEquals(""Identity generated for <MessageFormatter> +\"";\"""", id13);
		assertEquals(""Identity generated for <MessageFormatter> +\"";\"""", id14);
	}

	/**
	 * {@inheritDoc}
	*/
	@Test
	void no_obj_can_create_identity_strings() {
		MessageFormatter formatter = new MessageFormatter();
		Set<String> values = new HashSet<>(Arrays.asList(formatter.identityToString(""""), formatter
				.identityToString(null)));
		assertEquals(Arrays.asList("""", """"), values);
		values.remove("""");
		assertEquals(Arrays.asList("""", """"), values);
		values.retainAll(Arrays.asList("""", """"));
		assertEquals(Arrays.asList("""", """"), values);
	}
}
"
