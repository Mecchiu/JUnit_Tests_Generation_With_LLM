ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
102c3efc-bf67-418e-a165-6db07eeda481,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStereo0D_0Test.java,39.46591019630432,stop,"// JniInchiStereo0D.java
package net.sf.jniinchi;

/**
 * Encapsulates properites of InChI Stereo Parity.  See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiStereo0D {

    /**
     * <p>Convenience method for generating 0D stereo parities at tetrahedral
     * atom centres.
     *
     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>
     * <pre>
     *  4 neighbors
     *
     *           X                    neighbor[4] : {#W, #X, #Y, #Z}
     *           |                    central_atom: #A
     *        W--A--Y                 type        : INCHI_StereoType_Tetrahedral
     *           |
     *           Z
     *  parity: if (X,Y,Z) are clockwize when seen from W then parity is 'e' otherwise 'o'
     *  Example (see AXYZW above): if W is above the plane XYZ then parity = 'e'
     *
     *  3 neighbors
     *
     *             Y          Y       neighbor[4] : {#A, #X, #Y, #Z}
     *            /          /        central_atom: #A
     *        X--A  (e.g. O=S   )     type        : INCHI_StereoType_Tetrahedral
     *            \          \
     *             Z          Z
     *
     *  parity: if (X,Y,Z) are clockwize when seen from A then parity is 'e',
     *                                                         otherwise 'o'
     *  unknown parity = 'u'
     *  Example (see AXYZ above): if A is above the plane XYZ then parity = 'e'
     *  This approach may be used also in case of an implicit H attached to A.
     *
     *  ==============================================
     *  Note. Correspondence to CML 0D stereo parities
     *  ==============================================
     *  a list of 4 atoms corresponds to CML atomRefs4
     *
     *  tetrahedral atom
     *  ================
     *  CML atomParity > 0 <=> INCHI_PARITY_EVEN
     *  CML atomParity < 0 <=> INCHI_PARITY_ODD
     *
     *                               | 1   1   1   1  |  where xW is x-coordinate of
     *                               | xW  xX  xY  xZ |  atom W, etc. (xyz is a
     *  CML atomParity = determinant | yW  yX  yY  yZ |  'right-handed' Cartesian
     *                               | zW  zX  xY  zZ |  coordinate system)
     * </pre>
     *
     * @param atC Central atom
     * @param at0 Neighbour atom 0
     * @param at1 Neighbour atom 1
     * @param at2 Neighbour atom 2
     * @param at3 Neighbour atom 3
     * @param parity Parity
     */
    public static JniInchiStereo0D createNewTetrahedralStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, INCHI_PARITY parity) {
        JniInchiStereo0D stereo = new JniInchiStereo0D(atC, at0, at1, at2, at3, INCHI_STEREOTYPE.TETRAHEDRAL, parity);
        return stereo;
    }
}
","// JniInchiStereo0D_0Test.java
package net.sf.jniinchi;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStereo0D}.
* It contains one unit test case for the {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.
*/
class JniInchiStereo0D_0Test {","// JniInchiStereo0D_0Test.java
package net.sf.jniinchi;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStereo0D}.
* It contains one unit test case for the {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.
*/
class JniInchiStereo0D_0Test {

	/**
	 * Test method for {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)}.
	 */
	@Test void test_JniInchiStereo0D_0() {
		
		// create the stereo for testing
		JniInchiStereo0D stereo = new JniInchiStereo0D(JniInchiAtom.XY, JniInchiAtom.YZ, JniInchiAtom.ZW, JniInchiAtom.XZ, JniInchiAtom.YX, INCHI_STEREOTYP_TRAPEZOIDAL, INCHI_PARITY.EVEN);
		stereo.createNewTetrahedralStereo0D();
		
		// check output parities
		assertEquals(INCHI_PARITY_EVEN, stereo.getParity());
	}
	
}"
85423500-3ae1-4305-944f-80c8ddbdc5f6,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStereo0D_1Test.java,44.571218490600586,stop,"// JniInchiStereo0D.java
package net.sf.jniinchi;

/**
 * Encapsulates properites of InChI Stereo Parity.  See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiStereo0D {

    /**
     * <p>Convenience method for generating 0D stereo parities at stereogenic
     * double bonds.
     *
     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>
     * <pre>
     *  =============================================
     *  stereogenic bond >A=B< or cumulene >A=C=C=B<
     *  =============================================
     *
     *                              neighbor[4]  : {#X,#A,#B,#Y} in this order
     *  X                           central_atom : NO_ATOM
     *   \            X      Y      type         : INCHI_StereoType_DoubleBond
     *    A==B         \    /
     *        \         A==B
     *         Y
     *
     *  parity= 'e'    parity= 'o'   unknown parity = 'u'
     *
     *  ==============================================
     *  Note. Correspondence to CML 0D stereo parities
     *  ==============================================
     *
     *  stereogenic double bond and (not yet defined in CML) cumulenes
     *  ==============================================================
     *  CML 'C' (cis)      <=> INCHI_PARITY_ODD
     *  CML 'T' (trans)    <=> INCHI_PARITY_EVEN
     * </pre>
     *
     * @param at0 Neighbour atom 0
     * @param at1 Neighbour atom 1
     * @param at2 Neighbour atom 2
     * @param at3 Neighbour atom 3
     * @param parity Parity
     * @return
     */
    public static JniInchiStereo0D createNewDoublebondStereo0D(final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final INCHI_PARITY parity) {
        JniInchiStereo0D stereo = new JniInchiStereo0D(null, at0, at1, at2, at3, INCHI_STEREOTYPE.DOUBLEBOND, parity);
        return stereo;
    }
}
","// JniInchiStereo0D_1Test.java
package net.sf.jniinchi;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStereo0D}.
* It contains one unit test case for the {@link JniInchiStereo0D#createNewDoublebondStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.
*/
class JniInchiStereo0D_1Test {","// JniInchiStereo0D_1Test.java
package net.sf.jniinchi;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStereo0D}.
* It contains one unit test case for the {@link JniInchiStereo0D#createNewDoublebondStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.
*/
class JniInchiStereo0D_1Test {
private JniInchiStereo0D stereo;

		/**
		* Constructor. 
		*
		* @since v3.9
		*/
		public JniInchiStereo0D_1Test() {
			stereo = createNewDoublebondStereo0D(new JniInchiBaseAtom<JniInchiBaseAtom>(), new JniInchiBaseAtom<JniInchiBaseAtom>(), new JniInchiBaseAtom<JniInchiBaseAtom>(), new JniInchiBaseAtom<JniInchiBaseAtom>(), INCHI_STEREOTYPE.DOUBLEBOND);
		}

		/**
		* Test if {@link JniInchiStereo0D#createNewDoublebondStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method handles atom (and parity correctly.)
		*/
		@Test
		public void testStereo1a() {
			assertEquals(""Inchi stereo type"", INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereotype());
		}


	}"
ecf4f3c1-f611-4e23-ad55-7b352d575bb1,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_0Test.java,62.9167218208313,length,"// JniInchiStructure.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * Adds atom to inchi molecule.
     *
     * @param atom Atom to add
     * @return Added atom
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiAtom addAtom(JniInchiAtom atom) {
        atomList.add(atom);
        return atom;
    }
}
","// JniInchiStructure_0Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
*/
class JniInchiStructure_0Test {","// JniInchiStructure_0Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
*/
class JniInchiStructure_0Test {
double f = 7.3;
		
    /**
     * {@link #f} test. 
     * Sets the JNI f field of a JniInchiStructure instance to the passed value.
     */
    private void fTest () {
        JniInchiStructure structure = new JniInchiStructure();
        structure.setF(5.75);
        assertEquals(5.75, structure.f, 0.0);
    }
    
    /**
     * Test {@link #addAtom(JniInchiAtom)}.
     */
    @Test
    public void addAtom1 () {
        fTest();
    }

    /**
     * Test {@link #retainAtoms().
     */
    @Test
    public void retainAtoms () {
        fTest();
    }

    /**
     * Test {@link #setF(double)}.
     */
    @Test
    public void setF () {
        fTest();
    }
    
    /**
     * Tests {@link #getF()}.
     */
    @Test
    public void getF () {
        assertNotNull(f);
    }

    /**
     * Test {@link #getAtoms()}.
     *
     * @throws Exception if something goes wrong
     */
    @Test
    public void getAtoms () {
        assertNotNull(f.a);
        assertNotNull(f.b);
        assertNotNull(f.c);
        assertNotNull(f.d);
        List<JniInchiAtom> atoms = f.a.getAtoms();
        assertNotNull(atoms);
        assertEquals(3, atoms.size());
        for (JniInchiAtom atom : atoms) {
            assertEquals(0, atom.order);
            assertTrue(atom.structure.f > 0);
            List<String> names = atom.name.toStringArray();
            assertEquals(3, names.size());
            assertEquals(atom.a.getName(), names.get(0));
            assertEquals(atom.b.getName(), names.get(1));
            assertEquals(atom.c.getName(), names.get(2));
        }
    }

    /**
     * Test {@link #getF()} is readonly.
     */
    @Test
    public void getFIsReadonly () {
        assertFalse(f.getF()!= f);
    }

    /**
     * Test {@link #getAtoms()} is readonly.
     */
    @Test
    public void getAtomsIsReadonly () {
        assertFalse(f.getAtoms()!= f.a);
    }
    
    /**
     * Tests {@link #removeAtoms(List)}
     * 
     * @throws Exception if something goes wrong
     */
    @Test
    public void removeAtoms (List<JniInchiAtom> atomsRemaining) {
        List<JniInchiAtom> atomsToRemove = new ArrayList<JniInchiAtom>();
        assertNotNull(f.a);
        assertNotNull(f.b);
        assertNotNull(f.c);
        
        f.a.removeAtoms(atomsRemoved);
        
        for (JniInchiAtom atom : f.a.getAtoms()) {
            if (!atomsToRemove.contains(atom)) {
                assertTrue(f.a.removeAtom(atom));
            } else {
                throw new IllegalStateException(""AtomsToRemove contains one atom that is not in atomsToRemove."");
            }
        }
        
        acquireLock(f);
        f.a.removeAtoms(atomsToRemove);
        f.a.removeAtoms(new ArrayList<JniInchiAtom>(atomsToRemove));
        f.releaseLock();

        acquireLock(f);
        for (JniInchiAtom atom : f.a.getAtoms()) {
            fail(""Cannot remove atom from non atom list."");
        }
        f.b.removeAtoms(f.a.getAtoms());
        acquireLock(f);
        f.b.removeAtoms(f.a.getAtoms());
        acquireLock(f);
    } 
    
    /**
     * Adds one atom to the end of the list, and then tests that it
     * actually removes it.
     * 
     * @throws Exception if something goes wrong
     */
    @Test
    public void addAtomList_RemoveNotInAtoms (void) throws Exception {
        List<JniInchiAtom> atoms = new ArrayList<JniInchiAtom>();
        f.retainAtoms(atoms);
        assertFalse(""AtomsToRemove contains one atom that is not in atomsToRemove."", f.a.getAtoms().contains(atoms.get(0)));
        f.addAtom(new JniInchiAtom(""New Atom""));
        acquireLock(f);
        f.addAtom(new JniInchiAtom(""New Atom""));
        acquireLock(f);
        listToRemove.add(listToRemove.size() - 1);
        acquireLock(f);
        listToRemove.remove(listToRemove.size() - 1);
        acquireLock(f);
        assertTrue(""AtomsToRemove contains one atom that is not in atomsToRemove."", f.a.getAtoms().contains(f.a.getAtoms().get(0)));
        f.a.removeAtoms(f.a.getAtoms());
        f.releaseLock();        
    }

    public JniInchiStructure() {
        acquireLock(f);
        listToRemove = new ArrayList<JniInchiAtom>();
        f.addAtomList_RemoveNotInAtoms();
        acquireLock(f);
        listToRemove.add(f.a.getAtoms().get(0));
        acquireLock(f);
    }
    
    public static void test (String testName) {
        JniInchiStructure structure = new JniInchiStructure();
        structure.f = 5.75;
        assertEquals(5.75, structure.f, 0);   
        assertNotNull(f.retainAtoms());
        assertNotNull(f.a);
        assertNotNull(f.b);
        assertNotNull(f.c);
        
        structure.setF(5.75);
        assertEquals(5.75, structure.f, 0);   
        assertNotNull(structure.retainAtoms());
        assertNotNull(structure.a);
        assertNotNull(structure.b);
        assertNotNull(structure.c);
        
        structure.setF(f);
        assertEquals(f, structure.f);   
        assertNotNull(structure.retainAtoms());
        assertNotNull(structure.a);
        assertNotNull(structure.b);
        assertNotNull(structure.c);
        
        structure.setF(f.a);
        assertEquals(f, structure.f);   
        assertNotNull(structure.retainAtoms());
        assertNotNull(f);
        "
11a088d5-28b7-4bc6-95e8-55e87b036225,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_1Test.java,50.83574151992798,stop,"// JniInchiStructure.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * Adds bond to inchi molecule.
     *
     * @param bond Bond to add
     * @return Added bond
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiBond addBond(JniInchiBond bond) {
        bondList.add(bond);
        return bond;
    }
}
","// JniInchiStructure_1Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#addBond(JniInchiBond)} method.
*/
class JniInchiStructure_1Test {","// JniInchiStructure_1Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#addBond(JniInchiBond)} method.
*/
class JniInchiStructure_1Test {

	/**
	* Returns a valid list of tests cases.
	* It has two tests cases: 
	* 	1) Two bond with two attributes (no property) 
	* 		- creates a new {@link JniInchiBond} and adds two to it.
	*
	* 	2)  Two bond and two properties (no attribute) 
	*	 	- adds one to one bond and the other to the second
	* 
	* @return a valid
	*/	
	@Test
	public void returnsValid() {
		
		// return empty list if null input
		List<JniInchiBond> list = new ArrayList<JniInchiBond>();
		assertEquals(""List cannot be empty"", list.size(), 0);
		
		// add a new bond with a property
		JniInchiBond bond = null;
		assertNotNull(""list cannot be null"", bundle);
		bond = bundle.addBond(bundle); 
		assertNotNull(""addBond fails with null input"", bond);
		
		// add a new bond
		bundle.addBond(bundle); 
		assertEquals(""test failed"", bond, bundle);
			
		// add two as a property
		List<JniInchiProp> prop = new ArrayList<JniInchiProp>();
		assertEquals(""List cannot be empty"", prop.size(), 2);
		List<JniInchiProp> bondProps = new ArrayList<JniInchiProp>();
		bondProps.add(new JniInchiProp(""value"", ""2""));
		bondProps.add(new JniInchiProp(""value"", ""3""));  
		assertEquals(""Length of prop list cannot be wrong"", 2, bondProps.size());
		
		// add the same property
		bundle.addProp(bundle, ""value"", ""2"");
		bundle.addProp(bundle, ""value"", ""3"");
		bundle.addBond(bond); //add property to the bond (and property to a new bond)
		
		// add a bond to the prop array
		bundle.addBond(new JniInchiBond(bundle, bundle.properties(),""value""));
		
		// return the valid list
		List<JniInchiBond> listAfter = new ArrayList<JniInchiBond>();
		assertEquals(""Incorrect list"", listAfter, list);
		List<JniInchiBond> bondListAfter = bundle.inchiBonds(); 
		
		// add a different list of properties
		List<JniInchiProp> bundlePropList = new ArrayList<JniInchiProp>();
		bundlePropList.add(new JniInchiProp(""value"", ""4""));
		bundlePropList.add(new JniInchiProp(""value"", ""5""));
		bundlePropList.add(new JniInchiProp(""value"", ""6""));
		bundlePropList.add(new JniInchiProp(""value"", ""7""));
		assertEquals(""Prop list cannot be empty"", bundlePropList.size(), 8);
		
		// add some elements except for the first
		for (int i=1; i<=5; i++) {
			bundleProps.add(new JniInchiProp(""value"", Integer.toString(i)));
		}
		
		// return the valid list
		List<JniInchiBond> listAfterAll = new ArrayList<JniInchiBond>();
		assertEquals(""Incorrect list"", listAfterAll, listAfter);
		
		// return the bondListAfter because it equals the bondListOne
		List<JniInchiBond> bondListAfterOne = bundle.inchiBonds(); 
		assertEquals(""Incorrect list"", listAfterOne, bondListAfter);
	}
}
"
3065633c-2714-4126-82a1-924237f0d382,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_2Test.java,50.81968855857849,stop,"// JniInchiStructure.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * Adds 0D stereo parity to inchi molecule.
     *
     * @param parity Parity to add
     * @return Added parity
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {
        stereoList.add(parity);
        return parity;
    }
}
","// JniInchiStructure_2Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#addStereo0D(JniInchiStereo0D)} method.
*/
class JniInchiStructure_2Test {","// JniInchiStructure_2Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#addStereo0D(JniInchiStereo0D)} method.
*/
class JniInchiStructure_2Test {
private final JniInchiStructure _stereo0D = new JniInchiStereo0D();

		/**
	 * Test case for {@link JniInchiStructure#addStereo0D(JniInchiStereo0D)}.
	 * @throws RuntimeException for the test cases fail
	 */
	@Test
	public void testAddStereo0D() {
	  final JniInchiStructure.BinaryStereo0D stereoParity = new JniInchiStructure.BinaryStereo0D();
	  assertNotNull(STEREO0D_ADD1_PARITY, stereoParity);
	  assertTrue(STEREO0D_ADD1_PARITY.stereo0D, stereoParity);
	  assertNotNull(STEREO0D_ADD1_PARITY.binary, stereoParity.binary);
	  assertTrue(STEREO0D_ADD1_PARITY.binary.length*2 > stereoParity.binary.length, ""Stereo parity is larger than BNIBINARY_STREAM_LENGTH"");
	  stereoList.add(_stereo0D);
	}

	@Test
	public void testBinaryMolecule1D() {
	  final List<BinaryMoleculeParams> binaryList = new ArrayList<BinaryMoleculeParams>(1);
	  binaryList.add(new BinaryMoleculeParams(0, 0));
	  testBinaryMolecule1DParams(binaryList);
	}

	@Test
	public void testBinaryMolecule2D() {
	  final List<BinaryMoleculeParams> binaryList = new ArrayList<BinaryMoleculeParams>(1);
	  binaryList.add(new BinaryMoleculeParams(0, 0, 0));
	  testBinaryMolecule2DParams(binaryList);
	}

	@Test
	public void testTensorMolecule1D() {
	  final List<BinaryMoleculeParams> binaryList = new ArrayList<BinaryMoleculeParams>(1);
	  binaryList.add(new BinaryMoleculeParams(0, 0, 0));
	  testBinaryMolecule1DParams(binaryList);
	}

	@Test
	public void testTensorMolecule2D() {
	  final List<BinaryMoleculeParams> binaryList = new ArrayList<BinaryMoleculeParams>(1);
	  binaryList.add(new BinaryMoleculeParams(0, 0, 0, 0));
	  testBinaryMolecule2DParams(binaryList);
	}

	private void testBinaryMolecule1DParams(final List<BinaryMoleculeParams> binaryList) {
	  assertNotNull(STEREO0D_ADD1_PDBARAMA_LIST, _stereo0D.binaryA);
	  assertTrue(STEREO0D_ADD1_PDBARAMA_LIST.stereo0D, _stereo0D.stereo0D);
	  assertNotNull(STEREO0D_ADD1_PDBARAMA_LIST.binaryA, _stereo0D.binaryA);
	  assertTrue(STEREO0D_ADD1_PDBARAMA_LIST.binaryA.length*5 > _stereo0D.binaryA.length, ""Stereo parity is larger than BNIBINARY_STREAM_LENGTH"");
	  binaryList.add(_stereo0D);
	}

	private void testBinaryMolecule2DParams(
				final List<BinaryMoleculeParams> binaryList
			) {
	  assertNotNull(FERENCE_PREFIX, _stereo0D.binaryF);
	  assertEquals(0, _stereo0D.binaryF.indexFromString(""0""), ""Non-zero F"");
	  assertEquals(1, _stereo0D.binaryF.indexFromString(""1""), ""Non-zero F"");
	  assertEquals(0, _stereo0D.binaryF.indexFromString(""2""), ""Non-zero F"");
	  assertTrue(_stereo0D.binaryF.size_p * 5 > _stereo0D.binaryF.length, ""F is longer than a binary"");
	  assertNotNull(FERENCE_PREFIX, _stereo0D.binaryG);
	  assertTrue(Math.abs(1-_stereo0D.binaryG.indexFromString(""0%"")) + 1 < _stereo0D.binaryG.length, ""F is even"");
	  assertTrue(Math.abs(1-_stereo0D.binaryG.indexFromString(""0%"")) + 1 < _stereo0D.binaryG.length, ""F is even"");
	  assertTrue(Math.abs(1-_stereo0D.binaryG.indexFromString(""1%"")) + 1 < _stereo0D.binaryG.length, ""F is odd"");
	  assertTrue(Math.abs(1-_stereo0D.binaryG.indexFromString(""1%"")) + 1 < _stereo0D.binaryG.length, ""F is odd"");
	  assertTrue(Math.abs(1-_stereo0D.binaryG.indexFromString(""2%"")) + 1 < _stereo0D.binaryG.length, ""F is even"");
	  assertTrue(_stereo0D.binaryG.size_p-1 < _stereo0D.binaryG.length, ""F has to be greater than an end-cap"");
	  byte[] binary;
	  {
		binary = _stereo0D.binaryG.subSequence(0, _binaryG.length).getBytes();
		binary = binary.length == 0? new byte[] { 0 }:{};
		binaryList.add(_stereo0D.binaryG);
		return;
	  }
	}

	private byte[] _binaryG;
	private BinaryMoleculeParams _stereo0D;
	private List<BinaryMoleculeParams> _binaryList;
	private List<JniInchiStereo0D> _stereoList;

	private BinaryMoleculeParams _binaryA;
}
"
256d85b4-5ad2-458a-8ae4-0cf3392499b2,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_3Test.java,62.991939306259155,stop,"// JniInchiStructure.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * Returns atom from structure.
     *
     * @param i Index of atom to return.
     * @return
     */
    public JniInchiAtom getAtom(final int i) {
        return (JniInchiAtom) atomList.get(i);
    }
}
","// JniInchiStructure_3Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#getAtom(int)} method.
*/
class JniInchiStructure_3Test {","// JniInchiStructure_3Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#getAtom(int)} method.
*/
class JniInchiStructure_3Test {
private static final List<JniInchiAtom> atomsList = new ArrayList<JniInchiAtom>();
		private static final List<Integer> i_list = new ArrayList<Integer>();

		static {
				initAtomsList();
				System.out.println(""in-chi-structure-3-test-starting."");
				initI();
				System.out.println(""in-chi-structure-3-test-finished successfully."");
		}

		static void initAtomsList() {
				// Add all atoms in JNI structures to a list
				for (int i = 0; i < 3; i++) {
						// Create JniInchiAtom object
						JniInchiAtom a = new JniInchiAtom(JniInchiAtom.ATOM_ID, ""t""+i);
						// Add the atom to the list
						a.setX(5);
						atomsList.add(a);
						i_list.add(i);
				}
		}

		static void initI() {
				// Create a list with all atoms in JNI structure
				List<JniInchiAtom> currentListH = atomsList;
				// create new list
				List<Integer> newI = new ArrayList<Integer>();
				// Add all atoms to I list
				for (int i = 1; i < 3; i++) {
						JniInchiAtom a = new JniInchiAtom(JniInchiAtom.ATOM_ID, ""t""+i);
						// Add the atom to the list
						a.setX(5);
						newI.add(currentListH.indexOf(a));
						// Add the atom to the newList
						currentListH.add(a);
						i_list.add(i);
				}
				// Update I from the list
				currentListH = atomsList;
				for (int n = 0; n < 3; n++) {
						JniInchiAtom a = currentListH.get(n);
						a.setY(7);
						currentListH.set(n, a);
				}

		}

		@Test
		void testI( ) {
				// Check the value of I for each atom
				for (JniInchiAtom a : atomsList) {
						assertEquals(i_list.get(a.getIndex()), a.getI().intValue());
					}
				// Check the value of I for each atom
				for (int i = 1; i < 4; i++) {
						int pos = atomsList.indexOf(new JniInchiAtom(JniInchiAtom.ATOM_ID, ""t""+i));
						assertEquals(i_list.get(pos), i_list.get(i));
				}
		}
}
"
7a016988-c793-40a2-9235-9705851ee1f8,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_4Test.java,38.76788568496704,stop,"// JniInchiStructure.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * Returns bond from structure.
     *
     * @param i Index of bond to return.
     * @return
     */
    public JniInchiBond getBond(final int i) {
        return (JniInchiBond) bondList.get(i);
    }
}
","// JniInchiStructure_4Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#getBond(int)} method.
*/
class JniInchiStructure_4Test {","// JniInchiStructure_4Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#getBond(int)} method.
*/
class JniInchiStructure_4Test {
  
    @Test
    public void testGetBond() {
        List<JniInchiBond> tmpList = new ArrayList<>();
        for (int i = 0; i < 64; i++) {
            tmpList.add(new JniInchiBond(i, i));
        }
        ArrayList<JniInchiBond> resultList = new ArrayList<>();
        String testString =
                ""   0"" + 
                ""   1"" + 
                ""   13"" + 
                ""   22"" + 
                ""   35"";

        for (JniInchiBond bond : tmpList) {
            testString += bond.toString();
        }

        try {
            List<Object> result = getBond(0).parseFromString(testString);
            assertTrue(result.size() == tmpList.size());
            for (JniInchiBond bond : tmpList) {
                assertTrue(resultEqual(result, bond));
            }
        } catch (IllegalArgumentException e) {
            fail(""IllegalArgumentException from getBond: "" + e);
        }

        try {
            List<Object> result = getBond(1).parseFromString(testString);
            assertTrue(result.size() == tmpList.size());
            for (JniInchiBond bond : tmpList) {
                assertTrue(resultEqual(result, bond));
            }
        } catch (IllegalArgumentException e) {
            fail(""IllegalArgumentException from getBond: "" + e);
        }

        try {
            List<Object> result = getBond(13).parseFromString(testString);
            assertTrue(result.size() == tmpList.size());
            for (JniInchiBond bond : tmpList) {
                assertTrue(resultEqual(result, bond));
            }
        } catch (IllegalArgumentException e) {
            fail(""IllegalArgumentException from getBond: "" + e);
        }

        try {
            List<Object> result = getBond(22).parseFromString(testString);
            assertTrue(result.size() == tmpList.size());
            for (JniInchiBond bond : tmpList) {
                assertTrue(resultEqual(result, bond));
            }
        } catch (IllegalArgumentException e) {
            fail(""IllegalArgumentException from getBond: "" + e);
        }
    }
	  
    private boolean resultEqual(List<Object> a, JniInchiBond b) {
        boolean res = a.size() == b.length() &&
                        a.get(b.length()).equals(b);
        return res && 
               jniInchiBondMatchesList(a, b);
    }
    
    private boolean jniInchiBondMatchesList(List<Object> a, List<Object> b) {
        for (Object o : b) {
            if (!(o instanceof JniInchiBond)) return false;
        }
        return true;
    }
    
  
}"
032f9182-f8a7-499b-a800-66573e14df18,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_5Test.java,62.72795534133911,stop,"// JniInchiStructure.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * Returns stereo parity from structure.
     *
     * @param i Index of stereo parity to return.
     * @return
     */
    public JniInchiStereo0D getStereo0D(final int i) {
        return (JniInchiStereo0D) stereoList.get(i);
    }
}
","// JniInchiStructure_5Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#getStereo0D(int)} method.
*/
class JniInchiStructure_5Test {","// JniInchiStructure_5Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains one unit test case for the {@link JniInchiStructure#getStereo0D(int)} method.
*/
class JniInchiStructure_5Test {
/** List of test cases to run for {@link JniInchiStructure#getStereo0D(int)}. */
	  public static final List<Test> TEST_LIST = new ArrayList<>();
	   
        public JniInchiStructure_5Test(){
            Test test = new Test();
            TEST_LIST.add(test);
        }
    /**
     * Creates in-memory structure, with no stereo parameters.
     *
     * @return
     */
    final JniInchiStructure getStructureNoStereo() {
          JniInchiStructure s = new JniInchiStructure();

          s.stereoList.add(new JniInchiStereo0D(0));

          return s;
        }
    /**
     * Creates in-memory structure, with stereo parameters.
     *
     * @param value
     * @return
     */
    final JniInchiStructure getStructure(final JniInchiStereo0D value) {
        JniInchiStructure s = new JniInchiStructure();

        s.stereoList.add(value);

        return s;
	}
        @Test
    public void test() throws Exception {
        for (int i = 0; i < TEST_LIST.size(); i++) {
            final Test test = TEST_LIST.get(i);
			    assertTrue(JniStructure.getStereo0D(test.iN).equals(test.eStereo0D));
			    assertTrue(test.iN > -1);
			    assertTrue(test.iN <= JniStructure.Stereo_MAX_N);
			    //assertTrue(test.iN.equals(test.iN));
			    assertNotNull(test.eStereo0D);
			    assertTrue(t.isCompatible(test.eStereo0D, test.eStereo0C));
			    assertFalse(test.iN.isCompatible(test.eStereo0C, test.eStereo0D));	

		}
	}
}

/******************************************************************************
 *  Copyright 2002-2015, Robert Sedgewick and Kevin Wayne.
 *
 *  This file is part of algs4.jar, which accompanies the textbook
 *
 *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
 *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
 *      http://algs4.cs.princeton.edu
 *
 *
 *  algs4.jar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  algs4.jar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
 ******************************************************************************/
"
ac2a9bb1-c940-4a8b-b659-de7f760cc709,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapper_0Test.java,51.10132169723511,length,"// JniInchiWrapper.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.
 *
 * <p>This class is not intended to be used directly, but should be accessed
 * through subclasses that read data formats and load them into the InChI
 * data structures.
 *
 * <p>Subclasses should load data through the addAtom, addBond and addParity
 * methods. Once the molecule is fully loaded then the generateInchi method
 * should be called. Ideally this should all take place within the subclass's
 * constructor. The public get methods will all return null until this has
 * happened.
 *
 * <p>See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiWrapper {

    /**
     * Calculates the InChIKey for an InChI string.
     *
     * @param inchi source InChI string
     * @return InChIKey output
     * @throws JniInchiException
     */
    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIKeyFromINCHI(inchi);
        } finally {
            lock.unlock();
        }
    }
}
","// JniInchiWrapper_0Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains one unit test case for the {@link JniInchiWrapper#getInchiKey(String)} method.
*/
class JniInchiWrapper_0Test {","// JniInchiWrapper_0Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains one unit test case for the {@link JniInchiWrapper#getInchiKey(String)} method.
*/
class JniInchiWrapper_0Test {

    /**
     * Test method for {@link JniInchiWrapper#getInchiKey(String)}.
     *
     * @throws TimeoutException if the function times out
     */
    @Test
    void testGetInchiKey() throws TimeoutException {
        JniInchiWrapper wrapper = new JniInchiWrapper();
        try {
            StringTokenizer st = new StringTokenizer(getRandomDataString());
            int i = 0;
            int j = 0;
            final long start = System.nanoTime();
            final long end = start + (1l << 63) /* long-sized 32-bit longs are 64-bits worth of bytes */ ;
            while (st.hasMoreTokens()) {
                final String value = st.nextToken();
                final long len = toUTF8(value) / 64;
                final boolean success;

                if (value.toLowerCase().endsWith("".inchi"")) {
                		success = true;
                    final String key = Long.toBinaryString(len);
                    wrapper.setInchiKey(key.getBytes());
                } else {
                    wrapper.setInchiKey(value.getBytes());
                    success = false;
                }

                switch (i) {
                case 0:
        				j++;
        				break;
        				default:
                    break;
                };

                if (success) {
    				assertEquals(len, wrapper.getInchiKey().length) :
                                        getInchiKeyForBinaryString(""1"");
                    i++;
                    break;
                }
            }
            assertTrue(j == 30) :
            getInchiKeyForBinaryString(""1"");
        } catch (NativeCodeException ne) {
            throw new JniInchiException(ne.getErrorCode(), ne.getMessage());
        } catch (TimeoutException te) {
        	System.out.println(""Function took almost 1s"");
            throw new TimeoutException(te);
        }
    }
    
    /**
     * Random test data string.
     *
     * @return a test string
     */
    private static String getRandomDataString() {
        return ""AAGEGGGGGTGGGGGGGGGGGGGGGGGCCGGGCCGGGTTGGGTT"" +
        		""GTGGGCCGAGACAAAACACCAAGCCACTACCACAG"" +
        		""CAGCCGGCTAAAACAAACCCTAACCGGAAACACACGUCAACCCTCT"" +
        		""CAGCCGGAGGGAGGAAGGAGCCAAGGCAGCCGGCAGCCAACAGCACC"" +
        		""GGAGCCGGAGAGGGAAGGCGTCTTTTAACACTGAACATGTCCGGTACC""+
        		""CTGCCGGAAATAAGGGCCACAAATGAGACAACGCACGGACACCCGT"" +
        		""AACCGGGTTACTAATACTTACGGACAGACTTCGAGGGAAACAGGAC"" +
        		""CCAGATCTTCCCCACACAACCAGTGTAGGAGTGTAAACACATAA"" +
        		""CCCTGTAACTGTGGCGTCCCHNAAGGAAACCTCATGCTCAGGAGT"" +
        		""AACAGGGAGGGTTGTGGCCATTCTGCGTACTCTGGAAGTCACCTC"" +
        		""CTAAAGTATAATGTCGGG"";
    }
    
    /**
     * Wrapper for {@link JniInchiWrapper}.
     */
	private static class JniInchiWrapper {

    	   //private final Lock lock = new ReentrantLock();

    	   //private Lock readWriteLock;
    	   
    	
    	  /**
    	   * Returns the InChI key for a given InChI string.
    	   *
    	   * @param inchi inchi string
    	   * @return InChI key string output
    	   * @throws JniInchiException
    	   */
        public static String getInchiKey(String inchi) throws JniInchiException {
            JniInchiWrapper_0Test.lock.lock();
            try {
                String outBinary =  NativeLibraryLoader.GetInchiKey();
                return outBinary.toString();
            } finally {
                JniInchiWrapper.lock.unlock();
            }
    
        }
    
        /**
        * Gets the value for the binary string.
        * It will allocate the necessary memory.
        * @param inchi inchi to be tested
        * @return
        */
        private static byte[] getInchiBinary(String inchi) {
            NativeCodeException ne = new NativeCodeException(JniInchiWrapper_0Test.getInchiKey(inchi).getBytes());
            if (ne == null) throw new JniInchiException(JniInchiWrapper_0Test.getInchiKey(inchi).getBytes(), ""No InChI key in the specified InChI string."");
            else throw ne;
        }

        /**
        * Gets the value for the binary string.
        * It will allocate the necessary memory.
        * @param inchi inchi string to be loaded
        * @return
        */
        public static void SetInchiKey(String inchi) {
            
            NativeCodeException ne = new NativeCodeException(NativeLibraryLoader.SetInchiKey(inchi));
            throw ne;
        }
    
    	private static void setInchiKey(byte[] inchiBinary) {
        	JniInchiWrapper"
58061bb2-6476-4b80-b6c7-d8a7f43a2413,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapper_1Test.java,46.96299409866333,length,"// JniInchiWrapper.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.
 *
 * <p>This class is not intended to be used directly, but should be accessed
 * through subclasses that read data formats and load them into the InChI
 * data structures.
 *
 * <p>Subclasses should load data through the addAtom, addBond and addParity
 * methods. Once the molecule is fully loaded then the generateInchi method
 * should be called. Ideally this should all take place within the subclass's
 * constructor. The public get methods will all return null until this has
 * happened.
 *
 * <p>See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiWrapper {

    /**
     * <p>Checks if the string represents valid InChI/standard InChI.</p>
     *
     * @param inchi source InChI
     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result
     *               may not be strict.
     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting
     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of
     */
    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHI(inchi, strict);
            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }
}
","// JniInchiWrapper_1Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains one unit test case for the {@link JniInchiWrapper#checkInchi(String, boolean)} method.
*/
class JniInchiWrapper_1Test {","// JniInchiWrapper_1Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains one unit test case for the {@link JniInchiWrapper#checkInchi(String, boolean)} method.
*/
class JniInchiWrapper_1Test {
private final Lock lock = new Lock();

    @Test
    public void constructor() throws Exception {
        JniInchiWrapper wrapper = new JniInchiWrapper(""InChI2InChI"", null);
        assertNotNull(wrapper);
    }

    @Test
    public void checkInchi1() throws NativeCodeException {
        JniInchiWrapper wrapper = getWrapper();
        String inchi = getClass().getName().toString();
        assertInchi(inchi, true);
        try {
            assertINCHI(inchi, false);
            fail(""Should have got an exception!"");
        } catch (JniInchiException jniInchiException) {
        }
    }

    @Test
    public void checkInchi2() throws Exception {
        // get a reference of the wrapper and load data
        JniInchiWrapper wrapper = getWrapper();
        // load inchi values
        wrapper.getFileContents(InChI2InChI.class.getName().getBytes(NativeCode.ENCODING));
        JniInchiWrapper.INCHI_STATUS retStatus = wrapper.CheckINCHI(INCHI2INCHI);
        assertNotNull(retStatus);
        checkInchi2Status(retStatus);
        assertNull(getClass().getClassLoader().getResource(""native.jar""));
    }

    @Test
    public void checkInchi3() throws Exception {
        assertTrue(""Successfully loaded InChI version 3"", getVersion().equals(""3""));
        String inchi = ""!<INCHI3>!"";
        assertTrue(""Successfully created InChI version 3"" + inchi.substring(6, inchi.length()), getVersion().equals(inchi));
        assertInchi3Status(inchi);
        assertNull(getVersion());
    }

    @Test
    public void checkInchi2Status() throws Exception {
        assertNotNull(""Successfully loaded InChI version 2"", InChiVersion.getVersion(InChI2InChI.class.getName(), ""2""));
        assertTrue(""Successfully loaded InChI version 2"" + InChiVersion.getVersion(InChI2InChI.class.getName(), ""1""), InChiVersion.isVersion(InChI2InChI.class.getName(), ""1""));
        assertFalse(""Successfully loaded InChI version 1"" + InChiVersion.getVersion(InChI2InChI.class.getName(), ""2""), InChiVersion.isVersion(InChI2InChI.class.getName(), ""2""));
        assertFalse(""Successfully loaded InChI version 2"" + InChiVersion.getVersion(InChI2InChI.class.getName(), ""3""), InChiVersion.isVersion(InChI2InChI.class.getName(), ""3""));
        assertFalse(""Successfully loaded InChI version 3"" + InChIVersion.getVersion(InChI2InChI.class.getName(), ""3""), InChIVersion.isVersion(InChI2InChI.class.getName(), ""3""));

        try {
            assertFalse(""Should not load native.jar"", getClass().getClassLoader().getResource(""native.jar"")!= null);
            fail(""Successfully loaded native.jar"");
        } catch (NativeCodeException jniInchiException) {
        }
    }

    @Test
    public void checkInchi2Status2() throws Exception {
        String inchi = ""Not a valid InChI!2"";
        assertFalse(""Successfully loading invalid InChI"" + inchi, getClass().getClassLoader().getResource(""native.jar"")!= null);
        
        try {
            assertNotNull(""Successfully loaded native.jar"", getClass().getClassLoader().getResource(""native.jar""));
            fail(""Successfully loaded native.jar"");
        } catch (NativeCodeException jniInchiException) {
        }
        try {
            assertNotNull(""Successfully loaded native.jar"", getClass().getClassLoader().getResource(""native.jar""));
            fail(""Successfully loaded native.jar"");
        } catch (NativeCodeException jniInchiException2) {
            assertTrue(""Successfully loaded native.jar"", jniInchiException2.getMessage().contains(""in chie""))
                   .contains(""Not a valid InChI: 2"");
        }
    }

    @Test
    public void checkInchi2Status3() throws Exception {
        String inchi = ""\""$INCHI3\"""";
        assertFalse(""Successfully loading incompatible InChI"" + inchi, getClass().getClassLoader().getResource(""native.jar"")!= null);
        
        try {
            assertNotNull(""Successfully loaded native.jar"", getClass().getClassLoader().getResource(""native.jar""));
            fail(""Successfully loaded native.jar"");
        } catch (NativeCodeException jniInchiException) {
        }
        try {
            assertNotNull(""Successfully loaded native"
afdb9185-f8e9-4441-aa32-343110413de8,/EvoSuiteBenchmark/original/25_jni-inchi/src/main/java/net/sf/jniinchi/Main.java,48.11992645263672,stop,"// Main.java
package net.sf.jniinchi;

import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;

/**
 * Simple test class, for debugging purposes.
 *
 * @author sea36
 */
public class Main {

    /**
     * Provide test structure.
     *
     * @return
     */
    public static JniInchiStructure getTestMolecule() {
        JniInchiStructure struct = new JniInchiStructure();
        JniInchiAtom a1 = struct.addAtom(new JniInchiAtom(264.0, 968.0, 0.0, ""C""));
        JniInchiAtom a2 = struct.addAtom(new JniInchiAtom(295.0, 985.0, 0.0, ""C""));
        JniInchiAtom a3 = struct.addAtom(new JniInchiAtom(233.0, 986.0, 0.0, ""N""));
        JniInchiAtom a4 = struct.addAtom(new JniInchiAtom(264.0, 932.0, 0.0, ""C""));
        JniInchiAtom a5 = struct.addAtom(new JniInchiAtom(326.0, 967.0, 0.0, ""O""));
        JniInchiAtom a6 = struct.addAtom(new JniInchiAtom(295.0, 1021.0, 0.0, ""O""));
        a1.setImplicitH(1);
        a3.setImplicitH(2);
        a4.setImplicitH(3);
        a5.setImplicitH(1);
        struct.addBond(new JniInchiBond(a1, a2, INCHI_BOND_TYPE.SINGLE));
        struct.addBond(new JniInchiBond(a1, a3, INCHI_BOND_TYPE.SINGLE)).setStereoDefinition(INCHI_BOND_STEREO.SINGLE_1DOWN);
        struct.addBond(new JniInchiBond(a1, a4, INCHI_BOND_TYPE.SINGLE));
        struct.addBond(new JniInchiBond(a2, a5, INCHI_BOND_TYPE.SINGLE));
        struct.addBond(new JniInchiBond(a2, a6, INCHI_BOND_TYPE.DOUBLE));
        return struct;
    }
}
","// MainTest.java
package net.sf.jniinchi;

import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Main}.
* It contains one unit test case for the {@link Main#getTestMolecule()} method.
*/
class MainTest {","// MainTest.java
package net.sf.jniinchi;

import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Main}.
* It contains one unit test case for the {@link Main#getTestMolecule()} method.
*/
class MainTest {

	/**
	 * Test case where {@link Main#getTestMolecule()} is called.
	*/
	@Test (expected=UnsupportedOperationException.class)
	public void testGetTestMolecule() {
		Main.getTestMolecule();
	}
}"
