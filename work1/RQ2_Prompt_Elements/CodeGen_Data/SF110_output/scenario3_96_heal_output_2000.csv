ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
50f5b4ba-f167-4bea-b2ee-778bd7456695,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/approver/ModifyApprovalQueueEntryAction.java,59.126524925231934,stop,"// ModifyApprovalQueueEntryAction.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Modifies an approval queue entry.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
public class ModifyApprovalQueueEntryAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ModifyApprovalQueueEntryActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyApprovalQueueEntryAction}.
* It contains one unit test case for the {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyApprovalQueueEntryActionTest {","// ModifyApprovalQueueEntryActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyApprovalQueueEntryAction}.
* It contains one unit test case for the {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyApprovalQueueEntryActionTest {

/**
* Tests the functionality of the {@link ModifyApprovalQueueEntryAction}
* class.
*/
@Test
public void testIt() {
	
	final ModifyApprovalQueueEntryAction action = new ModifyApprovalQueueEntryAction(QueueDAO.class);
	
	action.run();
	
}

	/**
* Tests the functionality of the {@link ModifyApprovalQueueEntryAction}
* class.
*/
@Test
public void testIt2() throws Exception {
	
	final ModifyApprovalQueueEntryAction action = new ModifyApprovalQueueEntryAction(QueueDAO.class);
	
	action.run();
	action.run2();
	assertTrue(true);
}

    /**
 * Modifies an approval queue entry.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
final class ModifyApprovalQueueEntryAction extends HttpServlet {	
    
	/**
* Tests the functionality of the {@link ModifyApprovalQueueEntryAction}
* class.
*/
	@Override
	public void doGet(HttpServletRequest reqy, HttpServletResponse respy) throws ServletException, IOException {
    
	   String newApprovalQueueEntry = reqy.getParameter(""newApprovalQueueEntry"");
	  
	   QueuedRecordBean queuedRecord = QueuedRecordBean.create(newApprovalQueueEntry + ""modifyApprovalQueueEntry"", ""test"");
	   queueService.updateQueue(queuedRecord);
	   
	   assertNotNull(queuedRecord);
	 
		respy.getWriter().write(""Modify queue success."");
		respy.getWriter().flush();
		
		respy.getWriter().close();

	}

}
"
a903b0f2-249c-4799-8c1f-e29106192564,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/approver/ShowApprovalQueueAction.java,56.876720905303955,stop,"// ShowApprovalQueueAction.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * An {@link org.heal.servlet.Action} which fetches the information needed to
 * display the approval queue.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
public class ShowApprovalQueueAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ShowApprovalQueueActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowApprovalQueueAction}.
* It contains one unit test case for the {@link ShowApprovalQueueAction#actionRequiresLogin()} method.
*/
class ShowApprovalQueueActionTest {","// ShowApprovalQueueActionTest.java
package org.heal.servlet.approver;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowApprovalQueueAction}.
* It contains one unit test case for the {@link ShowApprovalQueueAction#actionRequiresLogin()} method.
*/
class ShowApprovalQueueActionTest {

	@Test
    public void test() throws Exception {
    	
    	HttpServletRequest request = new MockHttpServletRequest();
    	HttpServletResponse response = new MockHttpServletResponse();

    	// Get a mock catalog dao
    	QueueDAO dao = QueueDAO.init();

    	// Check that ""none"" is shown in the queue
    	request.setAttribute(""_type"", ""none"");
    	request.setAttribute(""_id"", ""none"");
    	request.setAttribute(""_count"", ""1"");
    	request.setAttribute(""_total"", ""1"");
    	
    	assertEquals(""_type"", ""none"", QueueDAO.getStatus(request));
    	assertEquals(""_id"", ""none"", QueueDAO.getId(request));
    	assertEquals(""_count"", ""1"", QueueDAO.getCount(request));
    	assertEquals(""_total"", ""1"", QueueDAO.getTotal(request));
    	
    	// Verify that the queue with ""none"" was shown in the queue details
    	assertNotEquals(""_type"", ""none"", QueueDAO.getStatus(request));
    	assertEquals(""_id"", ""none"", QueueDAO.getId(request));
    	assertEquals(""_count"", ""1"", QueueDAO.getCount(request));
    	assertEquals(""_total"", ""1"", QueueDAO.getTotal(request));
    	
    	// Fetch only the approval queue details
    	request.setAttribute(""_type"", ""approving"");
    	request.setAttribute(""_id"", ""approving"");
    	request.setAttribute(""_count"", ""2"");
    	request.setAttribute(""_total"", ""1"");
    	
    	List<QueueDetails> queueDetails = QueueDAO.fetchDetails(request, true);
    	assertEquals(""_count"", ""2"", queueDetails.size());
    	QueueDetails approvedQueueDetails = queueDetails.get(0);
    	assertEquals(""_total"", ""1"", approvedQueueDetails.getTotal());
    	assertEquals(""_type"", ""approving"", approvedQueueDetails.getType());
    	assertNotEquals(""_id"", ""approving"", approvedQueueDetails.getItem());
    	assertNotEquals(""_item"", ""approving"", QueueDAO.getItem(request));
    	
    	List<QueueDetails> rejectedQueueDetails = queueDetails.get(1);
    	assertEquals(""_count"", ""2"", rejectedQueueDetails.size());
    	rejectedQueueDetails.get(0).setItem(""rejected"");
    	assertEquals(""_type"", ""rejected"", rejectedQueueDetails.get(0).getType());
    	assertEquals(""_id"", ""rejected"", rejectedQueueDetails.get(0).getItem());
    	
    }
}

"
3d168b06-8914-42a5-8d7b-5b3d4e5b9231,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditContextURLAction.java,57.08399796485901,stop,"// EditContextURLAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Context URL.  If
 * there isn't an existing Context URL which can be found to edit,
 * we assume that a new Context URL should be edited.
 */
public class EditContextURLAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditContextURLActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContextURLAction}.
* It contains one unit test case for the {@link EditContextURLAction#actionRequiresLogin()} method.
*/
class EditContextURLActionTest {","// EditContextURLActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContextURLAction}.
* It contains one unit test case for the {@link EditContextURLAction#actionRequiresLogin()} method.
*/
class EditContextURLActionTest {

    EditContextURLAction(CompleteMetadataBean metadata) {
		//...
    }

	@Test
    public void testWithNonExistingContext() throws ServletException, IOException {
        // Given
        MetadataContextURLGenerator generator = new MetadataContextURLGenerator(metadata, ""test"");

        // When
        new EditContextURLAction(metadata);    
    }
    
    @Test
    public void testWithNonExistingContextExists() throws ServletException, IOException {
        // Given
        HttpServlet servlet = new EditContextURLAction(metadata);
        MetadataContextURLGenerator generator = new MetadataContextURLGenerator(metadata, ""test"");

        // When
        RequestDispatcher dispatcher = servlet.getServletContext().getRequestDispatcher(""/edit.jsp"");
        // Then
        assertTrue(!generator.isNonExistingContext(servlet.getRequest()),
                ""The resource should not exist in the context."");
        assertTrue(!generator.isNonValidContext(servlet.getRequest()),
                ""The resource should not exist in the context."");
    }

    @Test
    public void testWithNonExistingContextAndNotAdmin() throws ServletException, IOException {
        // Given
        HttpServlet servlet = new EditContextURLAction(metadata);

        // When/Then
        RequestDispatcher dispatcher = servlet.getServletContext().getRequestDispatcher(""/edit.jsp"");
        assertTrue(!generator.isNonExistingContext(servlet.getRequest()),
                ""The resource should not exist in the context."");
        assertTrue(!generator.isNonValidContext(servlet.getRequest()),
                ""The resource should not exist in the context."");
        assertTrue(!generator.isNonAdminRole(servlet.getServletRequest()),
                ""The resource should not exist in the context."");

    }
}

/**
 *
 * 		 @author mnf
 *
 */
class EditContextURLActionTestImpl extends EditContextURLAction {

    public final static String BEAN_MESSAGE_KEY = ""bean.message"";
    
    public final static String BEAN_CONTENT_VARIABLE_NAME = ""content."" + BEAN_MESSAGE_KEY;

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean actionRequiresLogin() {
        return true;
    }
 
    /**
     * {@inheritDoc}
     */
    @Override
    public void prepareBean(RequestDispatcher dispatcher) {
        // Set the content variables for this BEAN
        String content = BEAN_MESSAGE_KEY;
        ContextURLBean urlBean = (ContextURLBean) dispatcher.getRequest().getAttribute(ContextURLBean.CONTEXT_URL_ATTRIBUTE_NAME);
        
        // Set the content variable in the bean
        dispatcher.getRequest().setAttribute(BEAN_MESSAGE_KEY,content);
        dispatcher.getRequest().setAttribute(""CONTENT_VARIABLE"", BEAN_CONTENT_VARIABLE_NAME);
        
//        dispatcher.getRequest().setAttribute(""PATH"", ""context."" + CONTEXT_PATH_ATTRIBUTE_NAME);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void executeAction() {
//        ContextURLBean contextURLBean = (ContextURLBean) dispatcher.getRequest().getAttribute(ContextURLBean.CONTEXT_URL_ATTRIBUTE_NAME);
//
//        String context = contextURLBean.getContent();
//        assertTrue(context.startsWith(CONTENT_VARIABLE),
//                String.format(""Expected <%s> to start with <%s>"", BEAN_CONTENT_VARIABLE_NAME, CONTENT_VARIABLE));
        
//        String current = contextURLBean.getUrl();
//        assertTrue(!current.startsWith(BEAN_URL_ATTRIBUTE_NAME),
//                String.format(""Expected <%s> to NOT start with <%s>"", BEAN_URL_ATTRIBUTE_NAME, BEAN_URL_ATTRIBUTE_NAME));
    }
}
"
25698f2c-e05f-4664-86a9-e3089f7d7c85,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyMetadataAction.java,51.9378707408905,length,"// ModifyMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>An {@link Action} that saves the metadata from a form into
 * the session's {@link CompleteMetadataBean} by mapping {@link MetadataModifier}s
 * to forms.  The {@link MetadataModifier} which matches the form determines
 * the next {@link Action} to execute.</p>
 *
 * <p>The mapping is currently defined as:</p>
 *
 * <ul><li>'metadata' : {@link MetadataRecordModifier}
 * <li>'contextURL' : {@link ContextURLRecordModifier}
 * <li>'contributor' : {@link ContributorRecordModifier}
 * <li>'copyrightHolder' : {@link CopyrightHolderRecordModifier}
 * <li>'controlledVocabulary' : {@link ControlledVocabularyRecordModifier}
 * <li>'requirement' : {@link RequirementRecordModifier}
 * </ul>
 */
public class ModifyMetadataAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ModifyMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyMetadataAction}.
* It contains one unit test case for the {@link ModifyMetadataAction#actionRequiresLogin()} method.
*/
class ModifyMetadataActionTest {","// ModifyMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyMetadataAction}.
* It contains one unit test case for the {@link ModifyMetadataAction#actionRequiresLogin()} method.
*/
class ModifyMetadataActionTest {

	/**
	 * Test to ensure that the implementation of {@link ModifyMetadataAction}
	 * has the correct parameters from {@code MetadataRecorder} passed to the {@link Action}
	 * as a {@code parameterMap}.
	 */
	@Test
	public void testModifyMetadata() {

        String data = ""data="" +
            ""metadata="" +
            ""metadata_contributor="" +
            ""metadata_copyrightHolder="" +
            ""metadata_controlledVocabulary="" +
            ""metadata_requirement="" +
            ""metadata_requirements="" +
            ""metadata_contributor_license_holder="";

        CompleteMetadataBean expectedMetadata = new CompleteMetadataBean(
            ""metadata"",
        createMap(data),
        ""metadata_contributor"",
        ""metadata_copyrightHolder"",
        ""metadata_controlledVocabulary"",
        ""metadata_requirement"",
        ""metadata_requirements"",
        ""metadata_contributor_license_holder""
            );
		
        CompleteMetadataBean modifiedMetadata = ModifyMetadataAction.actionRequiresLogin()?
            new CompleteMetadataBean(
                ""metadata"",
                createMap(""data="" +
                    ""metadata="" +
                    ""metadata_contributor="" +
                    ""metadata_copyrightHolder="" +
                    ""metadata_controlledVocabulary="" +
                    ""metadata_requirement="" +
                ""metadata_requirements=""),
                ""metadata_contributor"",
                ""metadata_copyrightHolder"",
                ""metadata_controlledVocabulary"",
                ""metadata_requirement"",
                ""metadata_requirements"",
                ""metadata_contributor_license_holder""
                ) :
            expectedMetadata;

        Map<String, Object> parameterMap = new HashMap<String, Object>();

        assertEquals(""data=metadata=metadata_contributor=\""metadata_copyrightHolder=metadata_controlledVocabulary=metadata_requirement=metadata_requirements=metadata_contributor_license_holder=metadata_contributor_license_holder\"""",
                    AuthenticationTools.getRequestParameterMapString(
                        parameterMap,
                    createRequest(),
                    createResponse()));

        assertEquals(expectedMetadata, modifiedMetadata);
        // assertEquals(expectedMetadata, modifiedMetadata);

	}

	/**
	 * Create a {@link Map} containing the data from the {@code request} to be passed as parameters 
	 * to {@code createRequest}.
	 *
	 * @return the {@link Map} created by {@code createRequest}
	 * @throws ServletException   if the request is unsuccessfull
	 * @throws IOException        if the request fails to be made
	 */
	private Map<String, Object> createMap(String data) throws ServletException, IOException {

        return Collections.singletonMap(""request"", data);
	}

	/**
	 * Creates a {@link HttpServletRequest} with the {@code expectedParameters} and returns it.
	 *
	 * @return the {@link HttpServletRequest} created by {@code createRequest}
	 */
	private HttpServletRequest createRequest() {

        return Config.getInstance().newRequest();
	}

	/**
	 * Creates a {@link HttpServletResponse} with the {@code expectedParameters} and returns it.
	 *
	 * @return the {@link HttpServletResponse} created by {@code createResponse}
	 */
	private HttpServletResponse createResponse() {

        return Config.getInstance().newResponse();
	}

	/**
	 * Creates a {@link ServletException} and returns it.
	 *
	 * @return the {@link ServletException} created by {@code createException}
	 */
	private ServletException createException() {

        return Config.getInstance().newException();
	}

	/**
	 * Create a {@link CompleteMetadataBean} from the {@code testParameters}.
	 *
	 * @param testParameters an additional {@code Map} of the {@code request} parameters
	 *                 as an {@code Entry} of type {@code String}
	 * @return a {@link CompleteMetadataBean} constructed from {@code testParameters}
	 */
	private static CompleteMetadataBean createMetadataBean(Map<String, Object> testParameters) {

        CompleteMetadataBean metadata = new CompleteMetadataBean(
                ""metadata"",
                createMap(makeData(testParameters)),
                ""metadata_contributor"",
                ""metadata_copyrightHolder"",
                ""metadata_controlledVocabulary"",
                ""metadata_requirement"",
                ""metadata_requirements"",
                ""metadata_contributor_license_holder""
                );
        log.debug(metadata);
        return metadata;
	}
	
	/**
	 * @return a {@link Map} of the test cases parameters.
	 */
	private static Map<String,Object> makeData(Map<String, Object> parameters) {
	
		Map<String, Object> modifiedParameters = new HashMap<String, Object>();
		
		modifiedParameters.put(""metadata"", parameters.get(""metadata""));
		modifiedParameters.put(""metadata_contributor"", parameters.get(""metadata_contributor""));
		modifiedParameters.put(""metadata_copyrightHolder"", parameters.get(""metadata_copyrightHolder""));
		modifiedParameters.put(""metadata_controlledVocabulary"", parameters.get(""metadata_controlledVocabulary""));
		modifiedParameters.put(""metadata_requirement"", parameters.get(""metadata_requirement""));
		modifiedParameters.put(""metadata_requirements"", parameters.get(""metadata_requirements"")"
4b607f29-1e25-44d8-9296-a75dce3871d6,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/SaveMetadataAction.java,47.317811012268066,stop,"// SaveMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Iterator;

/**
 * An {@link org.heal.servlet.Action Action} used to save metadata
 * records.
 */
public class SaveMetadataAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// SaveMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SaveMetadataAction}.
* It contains one unit test case for the {@link SaveMetadataAction#actionRequiresLogin()} method.
*/
class SaveMetadataActionTest {","// SaveMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SaveMetadataAction}.
* It contains one unit test case for the {@link SaveMetadataAction#actionRequiresLogin()} method.
*/
class SaveMetadataActionTest {

    /**
     * @return The {@link SaveMetadataAction} instance created by this test.
     */
    public static SaveMetadataAction buildInstance() {
            return new SaveMetadataAction();
    }
    
    /**
     * @throws ServletException
     * @throws IOException
     */
    @Test
    public void testSaveMetadataAction() throws ServletException, IOException {	

		SaveMetadataAction saM = new SaveMetadataAction();
		
		// Check the set up
		assertNotNull(saM.context);
		assertNotNull(saM.taxonPathBean);

		// Start it
		saM.doGet( new HttpServletRequest( ""/saveMetadata.action"" ) );
		
		// Wait for the completion
		while (saM.getIsDone()) {
			QueueDAO.clear();
			
			try { Thread.sleep(1000); } catch (InterruptedException ie) { }
		}

		// Check it
		assertTrue( saM.getStatus() == 200 );

        // Check the values of the expected values
        //
		String taxonPath = saM.taxonPathBean.getTaxonPath();
		if (taxonPath.length() == 0) saM.taxonPathBean.setTaxonPath(null);
		String contextURL = saM.context.getContextURL();
		if (contextURL.length() == 0) saM.context.setContextURL(null);
		String copyrightHolderName = saM.context.getCopyrightHolderName();
		if (copyrightHolderName.length() == 0) saM.context.setCopyrightHolderName(null);
		String copyrightHolderURL = saM.context.getCopyrightHolderURL();
		if (copyrightHolderURL.length() == 0) saM.context.setCopyrightHolderURL(null);
		String contributorName = saM.context.getContributorName();
		if (contributorName.length() == 0) saM.context.setContributorName(null);
		String contributorURL = saM.context.getContributorURL();
		if (contributorURL.length() == 0) saM.context.setContributorURL(null);
		String copyrightHolderURL = saM.context.getCopyrightHolderURL();
		if (copyrightHolderURL.length() == 0) saM.context.setCopyrightHolderURL(null);

		assertNotNull(saM.taxonPathBean.getTaxonPath());
        assertNotNull(saM.context.getContextURL());
        assertNotNull(saM.context.getCopyrightHolderURL());
        assertNotNull(saM.context.getContributorName());
    
        assertNotNull(saM.taxonPathBean.getTaxonPath());
		assertNotNull(saM.context.getContributorURL());
		assertNotNull(saM.context.getCopyrightHolderURL());
			
	}
	
}
"
9814e86a-980e-4c4b-affd-b4cd6e88b870,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/CreateMetadataAction.java,51.44250178337097,length,"// CreateMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * An {@link Action} which creates a new metadata record to edit,
 * puts it into the session, and then directs the user to the editing
 * page.
 */
public class CreateMetadataAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// CreateMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CreateMetadataAction}.
* It contains one unit test case for the {@link CreateMetadataAction#actionRequiresLogin()} method.
*/
class CreateMetadataActionTest {","// CreateMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CreateMetadataAction}.
* It contains one unit test case for the {@link CreateMetadataAction#actionRequiresLogin()} method.
*/
class CreateMetadataActionTest {

	static final String RESOURCE_DIRECTORY 		= ""/WEB-INF/""



		+ ""cataloger/"";
	static final String INITIAL_NAME 				= ""InitialName"";
	static final String NAME 						= ""name"";
	static final String FULL_PATH 					= ""FullPath"";
	static final String FULL_NAME 					= ""FullName"";
	static final String LATITUDE 					= ""Latitude"";
	static final String LONGITUDE 					= ""Longitude"";
	static final String LOST 						= ""Lost"";
	static final String PROBABILITIES 				= ""Probabilities"";
	static final String START_DATE 				= ""StartDate"";
	static final String END_DATE 					= ""EndDate"";
	static final String YEAR 						= ""Year"";
	static final String TIME_ZONE 					= ""TimeZone"";
	static final String STREET 					= ""Street"";
          static final String CITY  					= ""City"";
          static final String STATE_PROVINCE 			= ""StateProvince"";
          static final String CITY 						= ""City"";
          static final String STATE_CODE 				= ""State"";

  static final Map<String,String> FORM_PARAMETERS 	= new HashMap<String,String>();
  static final Map<String,List<String>> FORM_PARAMETERS_SINGLE_VALUE = new HashMap<String,List<String>>();
  static final String FORM_PARAMETER_STRING 	= ""value"";
  static final String FORM_PARAMETER_BOOLEAN  = ""boolean"";
  static final String FORM_PARAMETER_MAP	= ""parameters"";
  static final String FORM_PARAMETER_ARRAY	= ""array"";

  static final Map<String,String> POST_PARAMETERS 	= new HashMap<String,String>();
  static final Map<String,List<String>> POST_PARAMETERS_SINGLE_VALUE = new HashMap<String,List<String>>();
  static final String POST_PARAMETER_STRING 	= ""value"";
  static final String POST_PARAMETER_BOOLEAN  = ""boolean"";
  static final String POST_PARAMETER_MAP	= ""parameters"";
  static final String POST_PARAMETER_ARRAY	= ""array"";


  /**
	 * Create empty metadata record.
	 * 
	 * @postcondition  Check if metadata record is not found
	 */
	public void fillMetadataRecordWithEmptyData() {
		List<CompletionBean> result = MetaDataDAO.getMetadataRecordFromResource
			(this.getClass().getName()
			, ResourceType.MetadataRecord);
		assertNotNull(
			""Resource does not contain this record: ""+this.getClass().getName(),
			result);
		assertTrue(
			""Resource does not contain this record"",
			result.size() == 0);
	}

	/**
	 * Fill metadata record with data from POST parameter.
	 * 
	 * @param recordId 				String id of the metadata record
	 * @param fields 					Map of field values
	 * @param POST_PARAMETERS_SINGLE_VALUE  - POST parameter for individual field value 
	 * @return  				List of completion beans
	 * @throws NameNotFoundException 	If record found but resource does not exist
	 * @throws SQLException 			If database is not available
	 * @throws ClassNotFoundException 	If resource classnot found
	 * @throws Exception					If some other unexpected exception occured
	 */
	public List<CompletionBean> fillMetadataRecordWithPostParamters (
		int recordId,
		Map<String, String> fields,
		Map<String, List<String>> POST_PARAMETERS_SINGLE_VALUE ) 
			throws ClassNotFoundException, NameNotFoundException, SQLException,
			ClassNotFoundException, Exception {
		List<String> values = POST_PARAMETERS_SINGLE_VALUE.get(String.valueOf(recordId));
		List<CompletionBean> result = new ArrayList<CompletionBean>(values.size());
		for (String v : values) {
		  CompletionBean bean = new CompletionBean();
		  bean.setName(v);
		  bean.setResource(this.getClass().getName());
		  bean.setResourceID(recordId);
		  try {
		    bean.setType(this.getClass().getName());
		  }
		  catch (ClassNotFoundException e) {
		    e.printStackTrace();
		  }
		  try {
		    bean.setValue(v);
		  }
		  catch (ClassNotFoundException e) {
		    e.printStackTrace();
		  }
		  if (StringUtils.isNotEmpty(this.getClass().getName())) {
			try {
				bean.setParameter(this.getClass().getName(), fields);
			}
			catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
		  }
		  result.add(bean);
		}
		return result;
	}

  /**
	 * Test creating metadata record from POST parameter, which matches the POST_PARAMETERS_SINGLE_VALUE map with fields: {0} as values.
	 * 
	 * @throws NameNotFoundException 	If resource found but no metadata record found
	 * @"
49694792-3901-49b3-96c6-86313f082658,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyCatalogQueueEntryAction.java,50.482197284698486,stop,"// ModifyCatalogQueueEntryAction.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.FileLocator;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.sql.SQLException;

/**
 * An {@link org.heal.servlet.Action Action} which is called in order to edit a metadata item which is in
 * the catalog queue.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @version 1.0
 */
public class ModifyCatalogQueueEntryAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ModifyCatalogQueueEntryActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.FileLocator;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.sql.SQLException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyCatalogQueueEntryAction}.
* It contains one unit test case for the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyCatalogQueueEntryActionTest {","// ModifyCatalogQueueEntryActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.module.catalog.QueuedRecordBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.FileLocator;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.sql.SQLException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModifyCatalogQueueEntryAction}.
* It contains one unit test case for the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.
*/
class ModifyCatalogQueueEntryActionTest {

		/**
			* Test method for {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()}. 
			* This method tests if a required login key is provided and, if so, it throws an exception.
			*/
		@Test
		public final void testActionRequiresLoginWithRequiredKey() {
					
			final File temp = File.createTempFile(""Temp"", ""txt"");
			final FileOutputStream out = new FileOutputStream(temp);
			final FileChannel in = new FileInputStream(temp.getAbsolutePath());
			(new FileLocator()).read(in,out);			
			in.close();
			assertFalse(AuthenticationTools.hasRequiredLoginKey());
		}
		
		/**
		* Test method for {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()}. 
		* This method tests if a required login was provided on a login page, the user could be logged in using that key
		*/
		@Test
		public final void testActionRequiresLoginWithGivenKey() {
			
			final File temp = File.createTempFile(""Temp"", ""txt"");
			final FileOutputStream out = new FileOutputStream(temp);
			final FileChannel in = new FileInputStream(temp.getAbsolutePath());
			(new FileLocator()).read(in,out);			
			in.close();
			final String login = AuthenticationTools.hasRequiredLoginKey()? ""/catalog/addNewMetadata"" : null;
			in.close();			
			final HttpServletRequest req = new JSPBuilder().build(login);
			
			try {
				final ModifyCatalogQueueEntryAction action = new ModifyCatalogQueueEntryAction();
				
				boolean failed = false;
				try {
					action.doPost(req); /* call the action servlet */
				} catch (final ServletException|Exception e) {
					failed = true;
				}
				assertTrue(failed);	
				
			} catch (final Exception e) {
				assertEquals(401,e.getErrorCode());
			
				// expected this cause, the metadata bean gets removed after the modifies are added
				final Long modifiedTimestamp = new Long(temp.lastModified());
				final Long metadataKey = new Long(temp.hashCode());
									
				final String logMessage = ""ModifyCatalogQueueEntryAction did not throw UnsupportedOperationException for requiredLoginKey."";
				final HttpServletResponse res = new HttpServletResponse();
				res.setStatus(403);
				res.setContentType(""text/html;charset=utf-8"");
				res.addHeader(""Content-Type"", ""text/html;charset=utf-8"");
				res.addHeader(""Cache-Control"",""no-cache"");
				res.sendError(403,logMessage);
			
				try {
					FileOutputStream out = new FileOutputStream(temp);
					(new FileLocator()).read(in,out);			
					in.close();
					
					final File catalog = File.createTempFile(""catalog"", null);
					(new FileLocator()).write(catalog.getAbsolutePath());
					try {
					in.close();
					out.close();
					} catch (final IOException e) {
						fail(""unable to write expected stream"");
					}
				} catch (final SQLException e) {
					fail(""unable to write expected stream"");
				}
			}
		}
				
}
"
e505d261-8235-42be-aa8c-37f26284834f,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/RelationRecordModifier.java,55.13759994506836,stop,"// RelationRecordModifier.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.CompleteMetadataBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;

/**
 * Saves changes to a {@link RelationBean} and acts as
 * an {@link Action} which is called to edit a Relation.  If
 * there isn't an existing Relation which can be found to edit,
 * we assume that a new Relation should be edited.
 */
public class RelationRecordModifier implements Action, MetadataModifier {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// RelationRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.CompleteMetadataBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RelationRecordModifier}.
* It contains one unit test case for the {@link RelationRecordModifier#actionRequiresLogin()} method.
*/
class RelationRecordModifierTest {","// RelationRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.CompleteMetadataBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RelationRecordModifier}.
* It contains one unit test case for the {@link RelationRecordModifier#actionRequiresLogin()} method.
*/
class RelationRecordModifierTest {
RelationRecordModifierTest() {
	}

	/**
 * Test method for {@link RelationRecordModifier#actionRequiresLogin()}.
 */
	@Test
	void actionRequiresLogin_Test()  {
		boolean result = true;
				
		// test without login: this will do nothing
		result = actionRequiresLogin();
		assertTrue(result);
	}

	@Test
    void testRelationNotExists() throws Exception {
        // create a relation
        RelationBean relation = new RelationBean();
        // should fail
        if (relation.getID() == 9) {
            fail(""CWWKZ0002E"");
        }
        // create new relation
        if (relation.getID() == 10) {
            // should fail
            if (relation.getRelation() == null) {
                fail(""CWWKZ0002E"");
            }
        }
        // edit the relation
        relation.setRelation(""myRelation"");
        // should success
        relation.setID(11);
        // test
        relation.setTitle(""title"");
        relation.setDescription(""description"");
        result = relation.isModified();
        assertFalse(result); // not modify it for an existing relation
        // test
        if (relation.getID() == 11) {
            // should fail
            if (relation.getRelation() == null) {
                fail(""CWWKZ0002D"");
            }
        }
    }

	@Test
    public void testGet() throws Exception {
        // test without login: this will do nothing
        CompleteMetadataBean completeMetadataBean = new CompleteMetadataBean();
        if (completeMetadataBean.isModified()) {
            fail(""CWWKZ0014E"");
        }
        if (completeMetadataBean.getMetadata().isModified()) {
            fail(""CWWKZ0015E"");
        }
        if (completeMetadataBean.getRelationBean().getRelatedRelations().isModified(""Relation"")) {
            fail(""CWWKZ0016E"");
        }
        
        CompleteMetadataBean completeMetadataBean1 = new CompleteMetadataBean();
        completeMetadataBean1.setRelationBean(new CompleteMetadataBean());
        List<CompleteMetadataBean> list = completeMetadataBean.getMetadata().addAll(completeMetadataBean1.getMetadata());
        assertEquals(1, list.size());
		CompleteMetadataBean meta = completeMetadataBean.getMetadata().get(0);
		CompleteMetadataBean completeMetadataBean2 = completeMetadataBean1.getMetadata().get(0);
		assertEquals(""title"", meta.getValue());
		assertEquals(""description"", completeMetadataBean2.getValue());
		assertEquals(""myRelation"", meta.getRelation().getID());
        // test
        CompleteMetadataBean completeMetadataBean3 = new CompleteMetadataBean();
        list = completeMetadataBean.getMetadata().addAll(completeMetadataBean3.getMetadata());
        assertEquals(2, list.size());
		CompleteMetadataBean meta2 = completeMetadataBean.getMetadata().get(1);
		CompleteMetadataBean completeMetadataBean4 = completeMetadataBean3.getMetadata().get(0);
		assertEquals(""title"", meta2.getValue());
		assertEquals(""description"", completeMetadataBean4.getValue());
		assertEquals(""myRelation"", completeMetadataBean4.getRelation().getID());
    }

    @Test
    public void testEdit() throws Exception {
        // test without login: this will do nothing
        CompleteMetadataBean completeMetadataBean = new CompleteMetadataBean();
        String editedTitle = ""titleEdit"";
        completeMetadataBean.setTitle(editedTitle);
        String editedDescription = ""descriptionEdit"";
        completeMetadataBean.setDescription(editedDescription);
        String editedRelation = ""RelationEdit"";
        CompleteMetadataBean completeMetadataBean6 = new CompleteMetadataBean();
        completeMetadataBean6.setRelationBean(new CompleteMetadataBean());
        completeMetadataBean6.getRelationBean().setID(""RelationEdit"");
        completeMetadataBean6.getRelationBean().getRelatedRelations().add(new CompleteMetadataBean(1,1));
        completeMetadataBean6.getMetadata().addAll(completeMetadataBean.getMetadata());
        completeMetadataBean6.getMetadata().get(0).setValue(completeMetadataBean.getMetadata().get(0).getValue());
        CompleteMetadataBean completeMetadataBean7 = completeMetadataBean.getMetadata().get(0);
        list = completeMetadataBean.getMetadata().addAll(completeMetadataBean7.getMetadata());
        int pos = list.indexOf(completeMetadataBean7);
        list.set(pos, completeMetadataBean6);
        list.addAll(list, completeMetadataBean5.getMetadata());
        pos = list.lastIndexOf(completeMetadataBean7);
        list.set(pos, list.remove(pos, 1));
        list.addAll(list, completeMetadataBean.getMetadata());
    }

}"
c8281784-592a-431e-83bf-5cb423ff360d,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/CancelEditMetadataAction.java,58.345444440841675,stop,"// CancelEditMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;

/**
 * A simple {@link Action} which clears the session variable used
 * for editing metadata.
 */
public class CancelEditMetadataAction implements Action {

    /**
     * @return <code>false</code>
     */
    public boolean actionRequiresLogin();
}
","// CancelEditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CancelEditMetadataAction}.
* It contains one unit test case for the {@link CancelEditMetadataAction#actionRequiresLogin()} method.
*/
class CancelEditMetadataActionTest {","// CancelEditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CancelEditMetadataAction}.
* It contains one unit test case for the {@link CancelEditMetadataAction#actionRequiresLogin()} method.
*/
class CancelEditMetadataActionTest {

	@Test
    void testActionRequiresLogin() throws Exception {
    	assertFalse(CancelEditMetadataAction.actionRequiresLogin());
    }

    
    @Test
    void testAction() throws Exception {
    	
       //
       // Set-Up Test Class.
       //

       // Set-Up Test Class.
       //
		/*
		Object response = null;
		try {
			response = RequestDispatcher
				.getInstance(""/Cat"")
				.forward(RequestDispatcher.getRequestDispatcher(""/Cat.jsp""), request);
			fail();
		}
		catch (Exception e) {
			// This is OK. We'll exit here.
		}

		*/


    	//
	    // A simple GET Request without parameters.
	    //
	    HttpServletRequest request = null;

	    try {
			request = RequestDispatcher
				.getInstance(""/Cat"")
				.forward(null, request);
			fail();
		}
		catch (Exception e) {
			// This is OK. We'll exit here.
		}

		
			//
		// A simple get Request with multiple parameters.
	    //
		String[] params = {""Cat"", ""1"", ""1"", ""1"", """"};

		HttpServletRequest request = null;

		try {
			request = RequestDispatcher
				.getInstance(""/Cat"")
				.forward(request, params);
			fail();
		}
		catch (Exception e) {
			// This is OK. We'll exit here.
		}

		//
		// A simple get Request containing an empty string. This should fail, as
		// this should return a 401.
	    //
		String[] params = {""Cat"", """", """"};

		request = RequestDispatcher
			.getInstance(""/Cat"")
			.forward(request, this.params);


		//
		// This should also fail, as a null value for the Parameter Map.
		//
		request = RequestDispatcher
			.getInstance(""/Cat"")
			.forward(request, null);

		//
		// Set-Up Test Class.
		//
	    //
        // Set-Up Test Class.
        //
		HttpServletResponse response = null;

        try {
			response = RequestDispatcher
				.getInstance(""/Cat"")
				.forward(response, request);
			fail();
		}
		catch (ServletException e) {
			// This is OK. We'll exit here.
		}
        catch (IOException e) {
        	fail(""An IOException should have occurred"");
        }
        
		/**
		 * Test successful access to catalog.
		 */
		HttpServletResponse response = null;
	    try {
			response = RequestDispatcher
				.getInstance(""/catalogcatalog"")
				.forward(null, request);
			fail();
		}
		catch (Exception e) {
		    // This is OK. We'll exit here.
		}

		/**
		 * Test successful access to catalog.
		 */
		try {
			response = RequestDispatcher
				.getInstance(""/catalogcatalog"")
				.forward(null, request);
		}
		catch (ServletException e) {
			// This is OK. We'll exit here.
		}
	}

			private String params[];
}
"
e361c4ba-d6cb-44d1-8f77-edb8518746f9,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditControlledVocabularyAction.java,55.49447441101074,stop,"// EditControlledVocabularyAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Controlled Vocabulary item.  If
 * there isn't an existing Controlled Vocabulary item which can be found to edit,
 * we assume that a new Controlled Vocabulary entry should be edited.
 */
public class EditControlledVocabularyAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditControlledVocabularyActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditControlledVocabularyAction}.
* It contains one unit test case for the {@link EditControlledVocabularyAction#actionRequiresLogin()} method.
*/
class EditControlledVocabularyActionTest {","// EditControlledVocabularyActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditControlledVocabularyAction}.
* It contains one unit test case for the {@link EditControlledVocabularyAction#actionRequiresLogin()} method.
*/
class EditControlledVocabularyActionTest {
/**
		 * Unit test case for actionRequiresLogin().
		 * First action is tested with http://localhost:8080/admin/metadata/taxons/1/
		 * Second action is tested with http://localhost:8080/admin/metadata/taxons/2/
		 * Second action is returned with empty metadata object.
		 */
@Test
public class EditControlledVocabularyActionTest
{
	/**
	 * Test if action requires login for editing a controlled vocabulary if configured by the user.
	 */
	@Test
	public void testActionRequiresLogin() {
		final HttpServletRequest req = new HttpServletRequest();
		final HttpServletResponse resp = new HttpServletResponse();
		final RequestDispatcher rd = req.getRequestDispatcher(""/metadata/taxons/1/cataloger/catalogerEditControlVocabulary.jsp"");	//jsp /Catalogs/Catalogs/metadata/taxons/ID/editContentFromTaxonomicon
		final CompleteMetadataBean mbe = new CompleteMetadataBean();
		String response = rd.forward(req, resp);
		assertTrue(""This should be an edit:"", response.contains(""CONTENT""));
	}

	/**
* Test if returns empty metadata object for a controlled vocabulary if configured by the user.
*/
	@Test
	public void testDoesntAcceptUserRequestBecauseNoPermissions() throws ServletException {
		final HttpServletRequest req = new HttpServletRequest();
		final HttpServletResponse resp = new HttpServletResponse();
		final RequestDispatcher rd = req.getRequestDispatcher(""/metadata/taxons/1/cataloger/catalogerEditControlVocabulary.jsp"");	//jsp /Catalogs/Catalogs/metadata/taxons/ID/editContentFromTaxonomicon
		final CompleteMetadataBean mbe = new CompleteMetadataBean();
		rd.include(req, resp);	// forward to /admin/metadata/taxons/
		final Iterator<Iterator<TaxonBean>> it = mbe.getTaxons().iterator();

		Iterator<Iterator<TaxonBean>> it2 = mbe.getIncludeedItems().iterator();
		while (it.hasNext()) {
			if(!it2.next().hasNext()) {
				it.next().next().completeMetadataBean(); // this item isn't included in the catalog
				it.remove();
			}
		}
		// Check that the metadata includes everything
		assertTrue(""metadata contains nothing"", it.hasNext()); // not included in catalog metadata
		assertTrue(""metadata contains no taxonomies"", it2.hasNext());

		// Finally, we add some taxonomies
		doAddTaxonomies(it);
		it2 = mbe.getIncludeedItems().iterator();
		while (it.hasNext()) {
			it.next().next().completeMetadataBean(); // this item isn't included in the catalog
			if(!it2.hasNext()) {
				it.next().next().completeMetadataBean(); // this item isn't included in the catalog
				it.remove();
			}
		}
		doAddTaxonomies(it);
	}
private void doAddTaxonomies(Iterator<Iterator<TaxonBean>> it) throws ServletException {
		// get the taxonomies again
		Iterator<TaxonBean> it2 = it.next();
		Iterator<TaxonPathBean> it3 = it2.next();

		while (it2.hasNext()) {
			it2.next().next().delete();
		}

		// add and add taxonomies
		while(it3.hasNext()) {
			it3.next().next().completeMetadataBean(); // this item isn't included in the catalog
			it3.remove();
		}

		// now add again, this time including taxonomies
		for(int i = 0; i < 10; i++) {
			if(it2.hasNext()) {
				it2.next().next().completeMetadataBean(); // this item isn't included in the catalog
				it2.remove();
			}
		}
	}
		/**
	 * Unit test case for actionRequiresLogin.
	 * First action is tested with http://localhost:8080/admin/metadata/taxons/1/
	 * Second action is tested with http://localhost:8080/admin/metadata/taxons/2/
	 * Second action is returned with empty metadata object.
	 */
}
"
34dbf789-8006-4e51-8770-045a992120e9,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/MetadataRecordModifier.java,37.803629875183105,length,"// MetadataRecordModifier.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.CopyrightTextBean;
import org.heal.module.metadata.DiseaseDiagnosisBean;
import org.heal.module.metadata.FormatBean;
import org.heal.module.metadata.KeywordBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.ThumbnailBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.servlet.Action;
import org.heal.util.DateTools;
import javax.servlet.ServletRequest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * <p>A {@link MetadataModifier} which fills the basic metadata information
 * from a <code>ServletRequest</code> into a {@link CompleteMetadataBean}.</p>
 */
public class MetadataRecordModifier implements MetadataModifier {

    /**
     * @param request Used to get the parameter <code>""nextAction""</code>, which
     * 		determines what the next {@link Action} to take will be.  If no
     * 		<code>""nextAction""</code> exists, a valid {@link Action} will still
     * 		be returned.
     * @return The next {@link Action} to take after saving the metadata from
     * 		the form.
     */
    public Action getNextAction(ServletRequest request);
}
","// MetadataRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.CopyrightTextBean;
import org.heal.module.metadata.DiseaseDiagnosisBean;
import org.heal.module.metadata.FormatBean;
import org.heal.module.metadata.KeywordBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.ThumbnailBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.servlet.Action;
import org.heal.util.DateTools;
import javax.servlet.ServletRequest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MetadataRecordModifier}.
* It contains one unit test case for the {@link MetadataRecordModifier#getNextAction(ServletRequest)} method.
*/
class MetadataRecordModifierTest {","// MetadataRecordModifierTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContextURLBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.module.metadata.CopyrightTextBean;
import org.heal.module.metadata.DiseaseDiagnosisBean;
import org.heal.module.metadata.FormatBean;
import org.heal.module.metadata.KeywordBean;
import org.heal.module.metadata.RelationBean;
import org.heal.module.metadata.RequirementBean;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.TaxonBean;
import org.heal.module.metadata.TaxonPathBean;
import org.heal.module.metadata.ThumbnailBean;
import org.heal.module.metadata.MetametadataIdentifierBean;
import org.heal.module.metadata.MetametadataContributorBean;
import org.heal.servlet.Action;
import org.heal.util.DateTools;
import javax.servlet.ServletRequest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MetadataRecordModifier}.
* It contains one unit test case for the {@link MetadataRecordModifier#getNextAction(ServletRequest)} method.
*/
class MetadataRecordModifierTest {
/**
		 * @return A blank, valid, test method so the {@link MetadataModifier}
		 *		returns the initial contents.
		 */
		@Test
		public void testInitialMetadata() {
			assertTrue(CompleteMetadataBean.getInstance().isEmpty());
		}
		
		/**
		 * Test method for
		 * {@link MetadataRecordModifier#getNextAction(ServletRequest) getNextAction}
		 * with null servlet request. 
		 */
		@Test
		public void testGetNextActionNoRequest(){
			MetadataRecordModifier modifiers = new MetadataRecordModifier();
			assertNull(modifiers.getNextAction(null));
		}
		/**
		 * Test method for
		 * {@link MetadataRecordModifier#getNextActionNoRequest() getNextActionNoRequest}
		 * with null servlet request. 
		 */
		@Test
		public void testGetNextActionNoRequestWithRequest(){
			ServletRequest request = new ServletRequest();
			assertNull(request.getParameter(""*""));
			request.setCharacterEncoding(""utf8""); // request.getParameter(""%26"") should be returned without the trailing '%26'
			assertNull(request.getParameter(""%26""));
			request.request = request;
			List<String> nextActionKeys = new  ArrayList<String>();
			nextActionKeys.add(""NextAction"");
			Map<String,List<String>> nextActionMap = new  HashMap<String,List<String>>();
			nextActionMap.put(""NextAction"", nextActionKeys);
			assertEquals(request.getParameter(""NEXTACTION""), request.getParameter(nextActionKeys.iterator().next().toString()));
			Iterator<String> nextActionIterator = request.getParameterNames().iterator();
			nextActionIterator.next();
			while(nextActionIterator.hasNext()){
				String actionKey = nextActionIterator.next().toString();
				assertTrue(request.getParameterNames().contains(actionKey));
				List<String> actionKeys = nextActionMap.get(actionKey);
				assertFalse(actionKeys.isEmpty());
				boolean found = false;
				for(String item : actionKeys){
					boolean foundItem = false;
					Iterator<Object> valueIterator = request.getParameterValues(item+"""").iterator();
					valueIterator.next();
					while(valueIterator.hasNext() &&!foundItem){
						foundItem = checkStringValues(valueIterator.next());
					}
					nextActionIterator.remove();
					found = found && foundItem;
				}
				if(!found){
					nextActionIterator.remove();
				}
			}
		}
		
		/**
		 * Test method for
		 * {@link MetadataRecordModifier#getNextActionNoRequest() getNextActionNoRequest}
		 * with empty servlet request. 
		 */
		@Test
		public void testGetNextActionNoRequestWithEmptyRequest(){
			ServletRequest request = new ServletRequest();
			assertEquals(request.getParameter(""NEXTACTION""), """");
			request.setCharacterEncoding(""UTF8"");
			assertEquals(request.getParameter(""NEXTACTION""), """");
			Iterator<String> nextActionIterator = request.getParameterNames().iterator();
			while(nextActionIterator.hasNext()){
				String actionKey = nextActionIterator.next().toString();
				assertTrue(request.getParameterNames().contains(actionKey));
				List<String> actionKeys = nextActionMap.get(actionKey);
				assertFalse(actionKeys.isEmpty());
				expected = request.getParameterValues(actionKey+"""");
				expected.removeAll(Collections.emptyList());
				assertTrue(expected.isEmpty());
			}
		}
		
		/**
		 * A set of data that will be compared"
e8ac6769-50ce-48f7-972e-142d7a62d4a8,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditMetadataAction.java,49.802711725234985,stop,"// EditMetadataAction.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.VCardBean;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

/**
 * An {@link org.heal.servlet.Action Action} used to edit metadata
 * records.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @version 1.0
 */
public class EditMetadataAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.VCardBean;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditMetadataAction}.
* It contains one unit test case for the {@link EditMetadataAction#actionRequiresLogin()} method.
*/
class EditMetadataActionTest {","// EditMetadataActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.module.metadata.TargetUserGroupBean;
import org.heal.module.metadata.ContributorBean;
import org.heal.module.metadata.CopyrightHolderBean;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import org.heal.util.VCardBean;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditMetadataAction}.
* It contains one unit test case for the {@link EditMetadataAction#actionRequiresLogin()} method.
*/
class EditMetadataActionTest {

	@Test
    public void testAction() {
		assertEquals(""wrong value"", AuthenticationTools.UserType.COMMUNITY_USER, AuthenticationTools.UserType.fromInt(AuthenticationTools.UserType.COMMUNITY_USER));
		assertEquals(""wrong value"", TargetUserGroupBean.USERS_COMMONS, TargetUserGroupBean.fromInt(TargetUserGroupBean.USERS_COMMONS));
		assertEquals(""wrong value"", ContributorBean.USERS_ALLOCATION_PRIVATE, ContributorBean.fromInt(ContributorBean.USERS_ALLOCATION_PRIVATE));
		String testString = ""Test123"";
		assertEquals(""wrong value"", ""Test"", testString);
		assertEquals(""wrong value"", ""Test"", testString);
        assertEquals(""wrong value"", ""Test"", testString);
		assertEquals(""wrong value"", ""Test123"", testString);
        assertEquals(""wrong value"", ""Test123"", testString);
		assertEquals(""wrong value"", ""Test123"", testString);
        assertEquals(""wrong value"", ""Test123"", testString);
		assertEquals(""wrong value"", ""test123"", testString);
        assertEquals(""wrong value"", ""test123"", testString);
		assertEquals(""wrong value"", ""Test123"", testString);
        assertEquals(""wrong value"", ""test123"", testString);
		assertEquals(""wrong value"", ""test123"", testString);
		assertEquals(""wrong value"", ""test123"", testString);
        assertEquals(""wrong value"", ""test123"", testString);
		assertEquals(""wrong value"", ""test123"", testString);
        assertEquals(""wrong value"", ""test123"", testString);
        assertEquals(""wrong value"", ""test123"", testString);
		assertEquals(""wrong value"", ""testtesttest"", testString);
        assertEquals(""wrong value"", ""testtesttest"", testString);
		assertEquals(""wrong value"", ""testtesttest"", testString);
		assertEquals(""wrong value"", ""testtesttest"", testString);
        assertEquals(""wrong value"", ""testtesttest"", testString);
		assertEquals(""wrong value"", ""testtesttest"", testString);
		assertEquals(""wrong value"", ""testtatesttest"", testString);
        assertEquals(""wrong value"", ""testtatoesttest"", testString);
        assertEquals(""wrong value"", ""testtatesttest"", testString);
        assertEquals(""wrong value"", ""testtatoesttest"", testString);
        assertEquals(""wrong value"", ""testtatesttest"", testString);
        assertEquals(""wrong value"", ""testtatesttest"", testString);
        assertEquals(""wrong value"", ""testtatesttest"", testString);
        assertEquals(""wrong value"", ""testtatesttest"", testString);
        assertEquals(""wrong value"", ""testtatesttest"", testString);
        assertEquals(""wrong value"", ""testtatesttest"", testString);
        assertEquals(""wrong value"", ""testtatesttest"", testString);
	}
    
	
}
"
e0ae327d-01c5-43ab-8450-4a49c75c4c1d,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditContributorAction.java,57.094606161117554,stop,"// EditContributorAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContributorBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Contributor.  If
 * there isn't an existing Contributor which can be found to edit,
 * we assume that a new Contributor should be edited.
 */
public class EditContributorAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditContributorActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContributorBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContributorAction}.
* It contains one unit test case for the {@link EditContributorAction#actionRequiresLogin()} method.
*/
class EditContributorActionTest {","// EditContributorActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.ContributorBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditContributorAction}.
* It contains one unit test case for the {@link EditContributorAction#actionRequiresLogin()} method.
*/
class EditContributorActionTest {

	/**
* @throws ServletException
*/
	@Test
	public void test() throws ServletException {

		String basePath = EditContributorAction.class.getProtectionDomain().getCodeSource().getLocation().toString() + ""/"";
		
		HttpServlet servlet = EditContributorActionNew.servlet(basePath);
		TestUtils.validate(servlet);
		
	} 
}"
8be489a5-c939-46b3-8b0b-a2a11a77997f,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ShowCatalogQueueAction.java,56.56992030143738,stop,"// ShowCatalogQueueAction.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * An {@link org.heal.servlet.Action} which fetches the information needed to
 * display the catalog queue.
 *
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 */
public class ShowCatalogQueueAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// ShowCatalogQueueActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowCatalogQueueAction}.
* It contains one unit test case for the {@link ShowCatalogQueueAction#actionRequiresLogin()} method.
*/
class ShowCatalogQueueActionTest {","// ShowCatalogQueueActionTest.java
package org.heal.servlet.cataloger;

import org.heal.module.catalog.QueueDAO;
import org.heal.servlet.Action;
import org.heal.util.AuthenticationTools;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ShowCatalogQueueAction}.
* It contains one unit test case for the {@link ShowCatalogQueueAction#actionRequiresLogin()} method.
*/
class ShowCatalogQueueActionTest {

	/**
	 * Test the action with a HttpServlet request.
	 *
	 * @param request HttpServlet request.
	 * @return <code>true</code> to indicate the request is expected.
	 * @throws IOException if the operation could not be executed.
	 * @throws ServletException if a servlet exception occurred.
	 */
	@Test
	public boolean actionRequiresLogin(HttpServletRequest request)
			throws IOException, ServletException {
		return request.getParameter(""username"")!= null;
	}

	/**
	 * Test the action with a List containing Queues.
	 *
	 * @param request HttpServlet request.
	 * @param response HttpServlet response.
	 * @param queues List containing Queues.
	 * @return <code>true</code> to indicate the operation is expected.
	 * @throws IOException if the operation could not be executed.
	 * @throws ServletException if a servlet exception occurred.
	 */
	@Test
	public boolean operationDoesNotRequireLogin(HttpServletRequest request,
			HttpServletResponse response, List<QueueDAO.QueueEntry> queues)
			throws IOException, ServletException {
		// Check the operation requires a username.
		return!queues.stream().anyMatch(request::getParameter(""username""));
	}

	/**
	 * Test the action with an empty list.
	 *
	 * @param request HttpServlet request.
	 * @param response HttpServlet response.
	 * @return <code>true</code> to indicate the operation is expected.
	 * @throws IOException if the operation could not be executed.
	 * @throws ServletException if a servlet exception occurred.
	 */
	@Test
	public boolean operationDoesNotRequireLogin(HttpServletRequest request,
			HttpServletResponse response)
			throws IOException, ServletException {
		// Check the operation requires a username.
		return!request.getParameter(""username"").equals("""");
	}
}
/*
* End ShowCatalogQueueActionTest.java
*/"
b3ac9f91-ff54-4d03-a129-f602ed538c92,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditCopyrightHolderAction.java,56.87201261520386,stop,"// EditCopyrightHolderAction.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.CopyrightHolderBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;

/**
 * An {@link Action} which is called to edit a Copyright Holder.  If
 * there isn't an existing Copyright Holder which can be found to edit,
 * we assume that a new Copyright Holder should be edited.
 */
public class EditCopyrightHolderAction implements Action {

    /**
     * @return <code>true</code>
     */
    public boolean actionRequiresLogin();
}
","// EditCopyrightHolderActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.CopyrightHolderBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditCopyrightHolderAction}.
* It contains one unit test case for the {@link EditCopyrightHolderAction#actionRequiresLogin()} method.
*/
class EditCopyrightHolderActionTest {","// EditCopyrightHolderActionTest.java
package org.heal.servlet.cataloger;

import org.heal.servlet.Action;
import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.CopyrightHolderBean;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.IOException;
import java.util.Iterator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EditCopyrightHolderAction}.
* It contains one unit test case for the {@link EditCopyrightHolderAction#actionRequiresLogin()} method.
*/
class EditCopyrightHolderActionTest {

	/**
	 * The ""doCancelEdit"" request parameter is sent to the action
	 */
	@Test
	public void doCancelEdit() throws ServletException, IOException {
		
		try {

			HttpServletRequest req = new HttpServletRequest(""http://localhost:8080/cataloger/CatalogPage/edit/myCopyrightHolder?action=edit"");

			CompleteMetadataBean complete = new CompleteMetadataBean();

			final String[] parameters = 
				{""user-id"", ""author-id"", ""text-description"", ""source"", ""source-version"", ""mimetype"", ""url"", ""copyrightholderId"", ""copyrightholderId-list"", ""copyRight"", ""copyrightHolders"", ""copyrightHoldersId"", ""copyrightHolderName"", ""copyrightholderName"", ""copyrightholder"", ""copyrightholder-id"", ""copyrightholder-id-list"", ""createdAt"", ""copyrightholder-id-list"", ""copyrightholder-id-list-copyrightholder"", ""lastmod"", ""copyrightholder-group"", ""copyrightholder-group-id"", ""copyrightholder-groupid"", ""copyrightType"", ""copyrightType-list"", ""creatorName"", ""copyrightName"", ""copyrightName"", ""copyrightName"", ""copyrightName"", ""copyrightTypeName"", ""copyrightTypeName"", ""copyrightValue""};

			req.setParameterValues(parameters);
			HttpServletResponse resp = new HttpServletResponse(""text/plain"");
			RequestDispatcher rd = req.getRequestDispatcher(""/WEB-INF/jsp/cataloger/edit/myCopyrightHolder.jsp"");
			rd.forward(req, resp);
			assertNotNull(resp);

		} catch (ServletException e) {
			fail(e.getMessage());
		} catch (IOException e) {
			fail(e.getMessage());
		}
	}
	
	/**
	 * We just make sure that it gets called at the end of the processing
	 */
	@Test
	public void postProcessed() throws ServletException, IOException {

	}
	
	/**
	 * The ""myCopyrightHolder"" request parameter is sent to the action
	 */
	@Test
	public void doPost() throws ServletException, IOException {

		try {

			HttpServletRequest req = new HttpServletRequest(""http://localhost:8080/cataloger/CatalogPage/edit/myCopyrightHolder?action=edit"");
			CompleteMetadataBean complete = new CompleteMetadataBean();

			final String[] parameters = 
				{""user-id"", ""author-id"", ""text-description"", ""source"", ""source-version"", ""mimetype"", ""url"", ""copyrightholderId"", ""copyrightholderId-list"", ""copyRight"", ""copyrightHolders"", ""copyrightHoldersId"", ""copyrightHolderName"", ""copyrightholderName"", ""copyrightholder"", ""copyrightholder-id"", ""copyrightholder-id-list"", ""cancel"", ""cancel-1"", ""cancel-2"", ""cancel-copyrightholder""};
			
			req.setParameterValues(parameters);

			HttpServletResponse resp = new HttpServletResponse(""text/plain"");
			WebResult r = req.process();
			Iterator it = r.getResult();
			while(it.hasNext()) {
				assertTrue(it.next() instanceof CompleteMetadataBean);
			}
			resp.setContentType(""text/plain"");
			resp.getWriter().write(""<html><head><title>edited copyright holder</title></head><body>"");
			resp.getWriter().write(r.getResult().toString());
			resp.getWriter().write(""</body></html>"");
			req.setContentType(""text/html"");
			req.getRequestDispatcher(""/WEB-INF/jsp/cataloger/doCancelEdit.jsp"").forward(req, resp);
			assertNotNull(r.getResult(), ""result was null"");
			assertNotNull(it.next(), ""next iterator wasn't null"");

			// make sure it gets called back from doPost
			Iterator it2 = r.getResult().iterator();
			while(it2.hasNext()) {
				assertTrue(it2.next() instanceof CompleteMetadataBean);
			}
			
			r.getResult().clear();

		} catch (ServletException e) {
			fail(e.getMessage());
		} catch (IOException e) {
			fail(e.getMessage());
		}

	}

	/**
	 * The ""myCopyrightHolder"" controller parameter is sent to the action
	 */
	@Test
	public void doGet() throws ServletException, IOException {

		assertFalse(ActionTestController.isDone());

	}

}
"
d7c8b389-0be4-409c-a0b3-2e5125ad73ee,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/upload/AlphanumericFileRenamePolicy.java,39.126118898391724,stop,"// AlphanumericFileRenamePolicy.java
package org.heal.servlet.upload;

import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;
import java.io.File;

/**
 * A FileRenamePolicy that strips non-alphanumeric characters.
 */
public class AlphanumericFileRenamePolicy extends DefaultFileRenamePolicy {

    /**
     * Eliminates non-alphanumeric characters from filenames.  Exceptions
     * include <code>' '</code>, <code>'.'</code> and <code>'_'</code>
     *
     * @param original Original file reference.
     * @return File reference stripped of non-alphanumeric characters.
     */
    public File rename(File original);
}
","// AlphanumericFileRenamePolicyTest.java
package org.heal.servlet.upload;

import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;
import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AlphanumericFileRenamePolicy}.
* It contains one unit test case for the {@link AlphanumericFileRenamePolicy#rename(File)} method.
*/
class AlphanumericFileRenamePolicyTest {","// AlphanumericFileRenamePolicyTest.java
package org.heal.servlet.upload;

import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;
import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AlphanumericFileRenamePolicy}.
* It contains one unit test case for the {@link AlphanumericFileRenamePolicy#rename(File)} method.
*/
class AlphanumericFileRenamePolicyTest {
/**
		 * Test default constructor.
		 */
	@Test
    public void create_no_arguments() {
        assertNull(AlphanumericFileRenamePolicy.defaultRenamePolicy);
    }

    /**
     * Test construction with file paths.
     */
    @Test
    public void construct_file_paths1() {
        final File path1 = new File(""Path1, File1"");
        AlphanumericFileRenamePolicy p1 = new AlphanumericFileRenamePolicy();                        
        File[] path2Arr = {path1, path1};

        // Test constructors of file policies with File objects.
        assertNotNull(p1.defaultRenamePolicy);
        assertNotNull(p1.concatRenameHandler);
        assertNotNull(p1.concatSepRenameHandler);

        assertEquals(p1, p1.defaultRenamePolicy);
        assertEquals(p1, p1.concatRenameHandler);
        assertEquals(p1, p1.concatSepRenameHandler);
        
        assertNotNull(p1.rename(path1));
        assertNotNull(p1.rename(path2Arr[0]));
        assertNull(p1.rename(path2Arr[1]));
        
        assertNull(p1.rename(new File(path1, ""File1"")));
        assertNotNull(p1.rename(null));

        // Note that p1 does not create a File object when the ""concat"" method
        // is invoked.  This means that a File object will be thrown at
        // runtime when the file does not already exist, but will be treated
        // as an argument for the concat (if the ""concat"" parameter is false)
    }

    /**
     * Test construction with path objects.
     */
    @Test
    public void construct_path1() {
        final File path1 = new File(""Path1, File1"");
        AlphanumericFileRenamePolicy p1 = new AlphanumericFileRenamePolicy();                        
        File[] path2Arr = {path1, path1};

        // Test constructors of file policies with files objects.
        assertNotNull(p1.defaultRenamePolicy);
        assertNotNull(p1.concatRenameHandler);
        assertNotNull(p1.concatSepRenameHandler);

        assertNotNull(p1.rename(path1));
        assertNotNull(p1.rename(path2Arr[0]));
        assertNotNull(p1.rename(path2Arr[1]));
        
        assertNull(p1.rename(new File(path1, ""File1"")));
        assertNotNull(p1.rename(null));

        // Here the path objects contain a null entry, so this test does not
        // assert(p1.defaultRenamePolicy.rename(null) == null);

        assertNull(p1.rename(new String(""Path1"")));
        assertNotNull(p1.rename(new String(null)));

        // Note that p1 does not create a File object when the ""concat"" method
        // is invoked.  This means that a File object will be thrown at
        // runtime when the file does not already exist, but will be treated
        // as an argument for the concat (if the ""concat"" parameter is false)
    }

}
"
6dd2a92b-a074-490a-9e6a-8b50c5a21708,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_0Test.java,19.157893180847168,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    /**
     * @param date A {@link Date} to format.
     * @return A String representation of the date parameter in
     * 		the {@link #DEFAULT_DATE_FORMAT default format}.
     */
    public static String format(Date date);
}
","// DateTools_0Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date)} method.
*/
class DateTools_0Test {","// DateTools_0Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date)} method.
*/
class DateTools_0Test {

	/**
	 * Test of format method, of class org.heal.util.DateTools.
	 */
	@Test
    public void test_format() {
                
        assertEquals(null, format(null));
        assertEquals(null, format(Long.valueOf(0)));
        assertEquals("""", format(null, DEFAULT_DATE_FORMAT));
        assertEquals("""", format(new Date(0), DEFAULT_DATE_FORMAT));
                
        assertEquals(""12/15/2014"", format(new Date(11L*1000L*60L*60L*24L*3L), DEFAULT_DATE_FORMAT));
        assertEquals(""11/15/2014"", format(new Date(11L*1000L*60L*60L*24L*3L), DEFAULT_DATE_FORMAT));

        
	}
	/**
	 * Test of the {@link DateTools#parse(String) parse method}.
	 */
	@Test
    public void test_Parse() {
        
        String string = ""12/19/2014"";
        Date date = null;
        try {
            Date date1 = dateTools.parse(string);
        } catch (ParseException pe) {
            pe.printStackTrace();
        }

        assertTrue(! string.startsWith(""0000""));
        // string starts with ""0000""
        // 0 is the day of the first day
        // 12/19 is the day of the first day of each month
        assertEquals(parse(""12/19/2014""), date);
        assertEquals(parse(""11/15/2014""), date);
        assertEquals(parse(""11/15/2014""), date);
        try {
            date = dateTools.parse(string);
            fail(""should throw exception."");
        } catch (ParseException pe) {
            // expected
        }

        assertTrue(dateTools.parse(string).equals(parse(""0000""+(1+22142857.0/60+(1+22142857.0/60)*60)*60)));
        assertTrue(dateTools.parse(string).equals(parse(""12/19/2014"")));
        assertTrue(dateTools.parse(string).equals(parse(""11/15/2014"")));
        assertTrue(dateTools.parse(string).equals(parse(""11/15/2014"")));
        try {
            date = dateTools.parse(string);
            fail(""should throw exception."");
        } catch (ParseException pe) {
            // expected
        }

        assertTrue(string.length() == 10);
	}


	/**
	 * 
	 */
	private DateTools() {
	}
}



"
1bfd43dd-2a9e-4b97-b001-9fa3111c67b9,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_1Test.java,62.25978350639343,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    /**
     * @param date A {@link Date} to format.
     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)
     * 		to convert the date to.
     * @return A String representation of the date parameter in the
     * 		specified format, or null if the given date is null.
     */
    public static String format(Date date, String format);
}
","// DateTools_1Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date, String)} method.
*/
class DateTools_1Test {","// DateTools_1Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#format(Date, String)} method.
*/
class DateTools_1Test {

    /**
     * Tests the format method, which takes a string in the given format.
     */
    @Test
    public void testFormat() {
        final Date date1 = new Date(2007,3,15);
        final Date date2 = new Date(2010,10,5);
        final String format = ""yyyy-MM-dd"";

        assertEquals(
            ""The formatter doesn't return the input."",
            null,
            DateTools.format(date1, format)); 			

        assertEquals(
            ""The formatter returns null."",
            null,
            DateTools.format(date2, format)
        ); 			
    }
    
    /**
     * Tests the parse method, which takes a string in the given format.
     */
    @Test
    public void testParse() {
        Date date = null;
        
        try {
            date = DateTools.parse(""20010104"", ""yyyy-MM-dd"");
        } catch (ParseException e) {
            fail(e.getMessage());
        } 
        
        assertEquals(
            ""The parse method doesn't return a valid date."",
            date1,
            date); 			

        date = DateTools.parse(""2007-03-15"", ""yyyy-MM-dd"");
        assertEquals(
            ""The parse method doesn't return a valid date."",
            date1,
            date); 			
    }
}"
8f628776-ebca-4d50-bf5c-8ec0119b794f,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_2Test.java,55.11668276786804,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed.
     */
    public static Date parse(String dateString);
}
","// DateTools_2Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String)} method.
*/
class DateTools_2Test {","// DateTools_2Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String)} method.
*/
class DateTools_2Test {

    /**
     * Tests for the {@link DateTools#parse(String)} method.
     *
	 * @throws ParseException Thrown when the {@link Date} cannot be parsed correctly.
	 * @throws IllegalStateException Thrown when the {@link Date} cannot be parsed due to an unsupported
	 * 		  character.
     */
    @Test
    void test(SimpleDateFormat format) throws ParseException {
	//System.out.println(""Test of Parse"");
	final String dateStr1 = ""1801-05-08"";
	final Date start = parse(format.parse(dateStr1));
	final Date d1 = new Date();
	final String d2 = format.format(d1);
        assertEquals(""The date '"" + d2 + ""' cannot be parsed correctly ""
		""due to an unsupported character"", format.parse(dateStr1), start, null);
    }
}
// DateTools_2Test.java"
41eb098d-86ca-4a7f-a391-50cdc4b24674,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_3Test.java,40.75404906272888,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    /**
     * @param dateString A String to parse into a {@link Date} object.
     * @param format A format to use to parse the date parameter with.
     * @return A {@link Date} representation of the String when possible,
     * 		or <code>null</code> if the date cannot be parsed with the
     * 		given format.
     */
    public static Date parse(String dateString, String format);
}
","// DateTools_3Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String, String)} method.
*/
class DateTools_3Test {","// DateTools_3Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#parse(String, String)} method.
*/
class DateTools_3Test {

}

"
83f6095a-79de-467a-a8d2-83fac60e39b6,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_4Test.java,48.30987215042114,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String, or <code>false</code> otherwise.
     * @see #parse(String dateString)
     */
    public static boolean isValidDate(String dateString);
}
","// DateTools_4Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String)} method.
*/
class DateTools_4Test {","// DateTools_4Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String)} method.
*/
class DateTools_4Test {
/**
		 * @throws ParseException if String does not represent a
		 * 		{@link Date} that can be parsed.
		 */
        @Test
    public void parseTest() throws ParseException {
        String dateString = ""2011/03/22/17:00:00.000000"";
        dateString = ""2011/03/22/17:00:00.000000"";
        dateString = ""2011/03/22/17%0.01"";
        dateString = ""2011/03/22/17.000000"";
        dateString = ""2011/03/22.1700"";
        dateString = ""2011/03/22.2345"";
        dateString = ""2011/03/22/17.000000"";
        dateString = ""2011/03/02/07 01:00"";;
        dateString = ""2011/03/22/-04-07 01:00"";;
        dateString = ""2011/03/22/16:03 -04"";;
    }

    /**
     * @throws ParseException if String does not represent a
     * 		{@link Date} that can be parsed.
     */
    @Test
    public void parseTest_3() throws ParseException {
        String dateString = ""15.09.2010 00:00:00"";;
        dateString = ""19.02.2010 00:00:"";
        dateString = ""-7.02.2010 00:00:00"";;
        dateString = ""-9.08.2010 00:00:00"";;
        dateString = ""8.09.2010 00:00:00"";
        dateString = ""-8.08.2010 9:00:00"";
        dateString = ""-8.02.2010"";
        dateString = ""9.02.2010 9:00:00"";
        dateString = ""15.04.2010 3:00:00"";
        dateString = ""16.0.2010"";;
    }

    /**
     * Test that a {@link Date} is parsed correctly.
     */
    @Test
    public void parseTest_2() throws ParseException {
        String date = ""2014-07-02 12:23:57.123"";
        Date parsedDate = parse(date);
        assertEquals(new Date(2014, 4, 2, 12, 23, 57), parsedDate);

        date = ""-12:27:17"";
        parsedDate = parse(date);
        assertEquals(new Date(2012, 6, 14, 19, 17), parsedDate);
        
        date = ""-30:42:50"";
        parsedDate = parse(date);
        assertEquals(new Date(2010, 11, 1, 3, 20, 50), parsedDate);
    }

	/**
	 * Test that a {@link Date} can be parsed even if the start of the string
	 * is an illegal character.
	 */
	@Test
	public void testStartOfIllegalCharacter() throws ParseException {
		String date = ""-3:22:50"";
		Date parsed = parse(date);
		assertEquals(new Date(2010, 11, 1, 3, 22, 50), parsed);
	}

	/**
	 * Check that a {@link Date} can be parsed even if the end of the string
	 * is an illegal character.
	 */
	@Test
	public void testEndOfIllegalCharacter() throws ParseException {
		String date = ""-3:22:50"";
		Date parsed = parse(date);
		assertEquals(new Date(2010, 11, 1, 3, 22, 50), parsed);
	}

	@Test
	public void compareEqual() throws ParseException {
		Date date1 = new SimpleDateFormat(""yyyy/MM/dd"").parse(
					""2011/03/22/17:00:00.000000"");
		Date date2 = new SimpleDateFormat(""yyyy/MM/dd"").parse(
				""2011/03/22/17:00:00.000000"");
    }

	@Test
	public void compareDifferent() throws ParseException {
		Date date1 = new SimpleDateFormat(""yyyy/MM/dd"").parse(""2011/10/21"");
		Date date2 = new SimpleDateFormat(""yyyy/MM/dd"").parse(""2011/06/11"");
    }
}
"
c640e664-4c65-41b9-aec7-0ecaab8d7fc6,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_5Test.java,57.77637243270874,stop,"// DateTools.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A general utility class for dealing with dates.
 */
public class DateTools {

    /**
     * @param dateString A String that may or may not represent a
     * 		{@link Date} that can be parsed with the given format.
     * @param format A format to use to check if the String can
     * 		be parsed into a {@link Date}.
     * @return <code>true</code> if a {@link Date} can be parsed from
     * 		the String in the given format, or <code>false</code>
     * 		otherwise.
     * @see #parse(String dateString, String format)
     */
    public static boolean isValidDate(String dateString, String format);
}
","// DateTools_5Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String, String)} method.
*/
class DateTools_5Test {","// DateTools_5Test.java
package org.heal.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DateTools}.
* It contains one unit test case for the {@link DateTools#isValidDate(String, String)} method.
*/
class DateTools_5Test {

    /**
     * Test of isValidDate method, of class DateTools.
     * The test method is supposed to return {@link Boolean#TRUE}
     * if the given {@link Date} and the given {@link String}
     * are valid dates, else returns {@link Boolean#FALSE}
     * @throws ParseException
     */
    @Test
    public void isValidDate_1() throws ParseException {
        BOOLEAN = true;
        date(""2002-11-29"");
        boolean b = date(""2002-11-29"").isValid();
        assertTrue(""isValidDate(\""2002-11-29\"" "" + datePattern(""2002-11-29""), datePattern(""2002-11-29""));
    }


    /**
     * Test of isValidDate method, of class DateTools.
     * The test method is supposed to return {@link Boolean#FALSE}
     * if the given {@link Date} and the given {@link String}
     * are not valid dates, else returns {@link Boolean#TRUE}
     * @throws ParseException
     */
    @Test
    public void isValidDate_2() throws ParseException {
        BOOLEAN = false;
        date(""2002-11-29"");
        boolean b = date(""2002-11-29"").isValid();
        assertTrue(""isValidDate(\""2002-11-29\"" "" + datePattern(""2002-11-29""), datePattern(""2002-11-29""));
    }



    /**
	 * @param dateString The {@link Date}
	 * @param format The format string to use when parsing
     * 			the {@link Date}
	 * @return A {@link Date} or <code>null</code> if the {@link Date} cannot
     * 			be parsed into the format given
	 */
	public static Date date(String dateString, String format) {
		String s = dateString;
        if (format == null){
        	s = SimpleDateFormat.getDateInstance(SimpleDateFormat.DEFAULT).format(date(true, s));
        } else {
        	s = SimpleDateFormat.getDateInstance(SimpleDateFormat.LONG).format(date(true, s));
        }

        assertNotNull(s);
		return s;
    }

	private static String datePattern(String str) {
		return ""\\"" + datePattern(str, null);
	}

	private static String datePattern(String str, String pat) {
		if (pat == null){
			return str;
		}
		if (str.toLowerCase().startsWith(pat.toLowerCase() + "" "")){
			return str.substring(pat.length() + 1);
		}

		return """";
	}

	private static boolean bool(String s) {
		return!!(s.length() >= 1 && '1' <= s.charAt(0)) &&
			s.length() <= 1 && s.charAt(s.length() - 1) == 'y';
	}
}
"
60465976-8533-4b3b-a36c-b758b1e31498,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/catalog/QueueDAO_0Test.java,56.94089698791504,stop,"// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    /**
     * @param type The type of QueuedRecordBeans to get.
     * @return A List of QueuedRecordBeans.
     */
    public List<QueuedRecordBean> getQueueByType(final String type);
}
","// QueueDAO_0Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#getQueueByType(String)} method.
*/
class QueueDAO_0Test {","// QueueDAO_0Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#getQueueByType(String)} method.
*/
class QueueDAO_0Test {
private QueueDAO queueDAO = new QueueDAO();
	/**
	 * This method tests method {@link QueueDAO#getQueueByType(String)}
	 * @throws SQLException 
	 */
	@Test
	public void testgetQueueByType(){
		assertNotNull(queueDAO.getQueueByType(""daoTest""));
	}

		/**
	 * This method tests method {@link QueueDAO#getQueueByType(String)}
	 * @throws SQLException 
	 * @throws java.sql.Types
	 * @throws java.lang.Exception 
	 */
	@Test
	public void testaddOneRecord(){
		List<QueuedRecordBean> list = new ArrayList<List<QueuedRecordBean>>();
		try (Connection con = CommonDAO.connect(""jdbc/queueDAO_0"");
				PreparedStatement pst = con.prepareStatement(""insert into catmaid_queue (id, name, queue_title, created_time, deleted_time, type, status, creator_id, created_by, updated_by, updated_time) values(?,?,?,?,?,?,?,?,?,?)""
		));
		) {
			pst.setString(1, ""foo"");
			pst.setString(2, """");
			pst.setString(3, """");
			pst.setString(4, """");
			pst.setString(5, """");
			pst.setString(6, ""catmaid"");
			pst.setString(7, """"); // queue_title
			pst.setString(8, """"); // status
			pst.setString(9, """"); // creator_id
			pst.setString(10, """"); // created_by
			pst.setString(11, """"); // updated_by
			pst.setString(12, """");
			pst.execute();
			ResultSet rs=pst.getGeneratedKeys();
			assertNotNull(rs.next());
			QueuedRecordBean queueBean = new QueuedRecordBean();
			queueBean.setKey(Integer.parseInt(rs.getString(1)));
			queueBean.setType(""test"");
			queueBean.setName(""test"");
			queueBean.setQueueTitle(""test"");
			queueBean.setState(QueueRecordState.UNDEFINED.toString());
			queueBean.setUpdatedTime(new Date());
			queueBean.setDeletedTime(new Date());
			list.add(queueBean);
			
			pst.setString(1, """");
			pst.setString(2, queueBean.getQueueTitle());
			pst.setString(3, queueBean.getState().toString());
			pst.setString(4, queueBean.getKey());
			pst.setString(5, queueBean.getKey());
			pst.setString(6, queueBean.getKey());
			pst.setString(7, queueBean.getName());
			pst.setString(8, queueBean.getName());
			pst.setString(9, queueBean.getQueueTitle());
			pst.setDate(10, new Timestamp(queueBean.getUpdatedTime().getTime()));
			pst.setString(11, """");
			pst.setString(12, """");
			pst.execute();
			rs = pst.getGeneratedKeys();
			assertNotNull(rs.next());
			Integer newQueueID = Integer.parseInt(rs.getString(1));
			pst.close();
			con.close();
			
			assertEquals(queueBean.getQueueID(), newQueueID);
			assertEquals(queueBean.getName(), newQueueID);
			
			assertNull(list.get(0));
			assertNull(queueBean.getQueueID());
			assertNull(queueBean.getName());
			assertNull(queueBean.getState());
			assertNull(queueBean.getCreated_by());
			assertNull(queueBean.getUpdated_by());
			
			assertNull(list.get(1));
			assertNull(queueBean.getQueueTitle());
			assertNull(queueBean.getState());
			assertNull(queueBean.getCreated_time());
			assertNull(queueBean.getDeleted_time());
		}
		catch (SQLException exception) {
			fail(""Failed to create db conenction : "");
			exception.printStackTrace();
			assertEquals(
					""Error 1: DB connection Error when creating PreparedStatement.\n"" +
					""Message : Unable to load all the data associated with the Queue data \n"" +
					""Message : Cannot get the Connection for the DB connection."",
					exception.getMessage());
		}
		finally {
			con.close();
		}
	}
}"
024060e1-82a3-42c0-991b-c70c66388154,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/catalog/QueueDAO_1Test.java,55.98837065696716,stop,"// QueueDAO.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * A DAO for managing queues stored in the database
 */
public class QueueDAO implements Serializable {

    /**
     * Saves a {@link QueuedRecordBean} to the database.
     *
     * @param queuedRecord A non-null QueuedRecordBean to save.
     * @return <code>true</code> if the save is successful, false otherwise.
     */
    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord);
}
","// QueueDAO_1Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
*/
class QueueDAO_1Test {","// QueueDAO_1Test.java
package org.heal.module.catalog;

import org.heal.module.metadata.CompleteMetadataBean;
import org.heal.module.metadata.MetadataDAO;
import org.heal.util.CommonDAO;
import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QueueDAO}.
* It contains one unit test case for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
*/
class QueueDAO_1Test {

    /**
     * Unit test for {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
     */
    @Test
    public void testSaveEmptyQueuedRecord() {
        queuedRecord = null;
        QueueDAO.saveQueuedRecord(queuedRecord);
        assertNull(queuedRecord.getId());
    }

    /**
     * Unit test for {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.
     */
    @Test
    public void testSaveQueuedRecord() {
        queuedRecord = new QueuedRecordBean();
        queuedRecord.setQueueDate(new Timestamp(new Date().getTime()));
        queuedRecord.setName(""test"");
        List<Queue> queues = new ArrayList<>();
        queue = new Queue(""queue1"");
        queues.add(queue);
        queues.add(queue);
        queues.add(queue);
        Integer count = CommonDAO.updateInDatabase("""", ""update_queued_records"",
            new List[] {
                queuedRecord },
            queues,
            null);

        queuedRecord = null;
        queues = new ArrayList<>();
        queues.clear();
        queues.add(queue);
        queues.add(queue);
        queues.add(queue);
        count = CommonDAO.updateInDatabase("""", ""delete_queued_records"",
            queues,
            null);

        assertEquals(1, count);
    }

    /**
     * Gets the complete metadata associated with the queue
     * @return complete metadata associated with the queue and an empty result set if the queue is not yet saved.
     */
    public CompleteMetadataBean getCompleteMetadata() {
        CompleteMetadataBean qmd = new CompleteMetadataBean();
        try (DataSource source = CommonDAO.openDataSource()) {
            Connection con = null;
            boolean res = false;
            try {
                con = source.getConnection();
                res = (this.getCompleteMetadata(con)!= null);
            } finally {
                CommonDAO.closeConnection(source, con);
            }
            if (res) {
                qmd = this.getCompleteMetadata(con);
            }
            return qmd;
        }
    }

    /**
     * Gets the complete metadata associated with the queue
     * @return complete metadata associated with the queue and an empty result set if the queue is not yet saved.
     *
     * @return the complete metadata associated with the queue, <null> if the queue is not yet saved.
     */
    private CompleteMetadataBean getCompleteMetadata(Connection con) {
        ResultSet rs = null;
        PreparedStatement qfQmd = null;
        try {
            qfQmd = con.prepareStatement(""SELECT metadata from metadata WHERE metadata_data =?"");
            qfQmd.setString(1, new Timestamp(new Date().getTime()).toString());
            rs = qfQmd.executeQuery();
            if (rs.next()) {
                return this.getCompleteMetadata(rs);
            } else {
                return null;
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            this.releaseConnection(con, rs, qfQmd);
        }
    }

    /**
     * Gets the complete metadata associated with the queue (no need for database)
     * @return the complete metadata associated with the queue and an empty result set if the queue is not yet saved.
     *
     * @return the complete metadata associated with the queue, <null> if the queue is not yet saved.
     */
    private CompleteMetadataBean getCompleteMetadata() {
        CompleteMetadataBean qmd = new CompleteMetadataBean();
        try (DataSource source = CommonDAO.openDataSource()) {
            Connection con = null;
            boolean res = false;
            try {
                con = source.getConnection();
                res = (this.getCompleteMetadata(con)!= null);
            } finally {
                CommonDAO.closeConnection(source, con);
            }
            if (res) {
                qmd = this.getCompleteMetadata(con);
            }
            return qmd;
        }
    }

    public List<Queue> getQueues() {
        QueueList ql = new QueueList("""");
        int qs = this.getNumberOfQueues();
        if (qs > 0) {
            for (int i = 0; i < qs; i++) {
                ql.add(this.getQueue(""q"" + i));
            }
        }
        return ql;
    }

    /**
     * Gets number of non-queued records
     * @return number of non-queued records
     */
   	public int getNumberOfQueues() {
   	    PreparedStatement stmt = null;
   	    Connection con = null;
   	    ResultSet rs = null;
   	    try {
   	        con = this.getConnection();
   	
   	        stmt = con.prepareStatement(""SELECT count(*) FROM queues"");
   	        rs = stmt.executeQuery();
   	        if (rs.next()) {
   	            return rs.getInt(""count(*)"");
   	        } else {
   	            rs = null;
   	        }
   	    } catch (SQLException ex) {
   	        ex.printStackTrace();
   	    } finally {
   	        this.releaseConnection(con, rs, stmt);
   	    }
   	    return 0;
   	}
}

"
6a7761b8-e1ba-4960-a635-8217b58b8cca,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/search/ParameterBean.java,39.79467821121216,stop,"// ParameterBean.java
package org.heal.module.search;

import java.util.*;

public class ParameterBean {

    /**
     * Accessor method, returns the searchParameter size
     *
     * @return int
     */
    public int size();
}
","// ParameterBeanTest.java
package org.heal.module.search;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParameterBean}.
* It contains one unit test case for the {@link ParameterBean#size()} method.
*/
class ParameterBeanTest {","// ParameterBeanTest.java
package org.heal.module.search;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParameterBean}.
* It contains one unit test case for the {@link ParameterBean#size()} method.
*/
class ParameterBeanTest {
/**
		 * Test calling the {@link String#trim()} method.
		 *
		 * @throws Exception if the method fails.
		 *
		 * @see {@link ParameterBean#TRIM} for the test description
		 */
		@Test
		void trimTest() {
			List<String> list = new ArrayList<String>(0);
			ParameterBean bean = new ParameterBean();
			bean.trim();
			assertTrue( ""List contains elements as expected."",
						list.isEmpty());
		}

        
		/**
		 * Test calling the {@link String#trim()} method.
		 *
		 * @throws Exception if the method fails.
		 *
		 * @see {@link ParameterBean#TRIM} for the test description
		 */
		@Test
		void trim2Test() {
			ParameterBean bean = new ParameterBean();
			List<String> list = new ArrayList<String>(0);
			list.add( bean.TRIM.get(0)+"""");

			System.out.println(""List: "" + list);
			bean.trim();
			assertTrue( ""List contains elements as expected."",
						list.isEmpty());
		}
}"
e9517c35-f780-47e7-bd2a-2fdbb5e34724,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/download/DownloadQueueBean_0Test.java,29.252487421035767,stop,"// DownloadQueueBean.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;

/**
 * Stores a list of contentIds and a package file location and url.
 *
 * @author Seth Wright
 * @version 0.1
 */
public class DownloadQueueBean implements Serializable {

    /**
     * Removes all metadata id from the list of content to include in the
     * package generated for this queue.
     */
    public boolean removeAllFromQueue();
}
","// DownloadQueueBean_0Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#removeAllFromQueue()} method.
*/
class DownloadQueueBean_0Test {","// DownloadQueueBean_0Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#removeAllFromQueue()} method.
*/
class DownloadQueueBean_0Test {

	private static final String PACKAGE = ""org.heal"";
    // private static final String PACKAGE = ""test.org.heal"";
	private static final Collection<String> ITEMS = new TreeSet<>();
	
	private static final String DOWNLOAD_FILE = ""test.txt"";
	private static final String FILE_NOT_FOUND = ""foo.txt"";

	String getDownloadFile() {
		return DOWNLOAD_FILE;
	}
	
	String getFileNotFound() {
		return FILE_NOT_FOUND;
	}
	
    @Test
    public void testRemoveAllFromQueue() throws Exception {
    	DownloadQueueBean bean = new DownloadQueueBean();
    	bean.downloadFile = getDownloadFile();
    	bean.fileNotFound = getFileNotFound();
        bean.removeAllFromQueue();
        
        assertTrue(bean.downloadFile == getDownloadFile());
        assertTrue(bean.fileNotFound == getFileNotFound());
        assertTrue(bean.removeAllFromQueue());
	}
}"
3664c36c-59be-4865-9932-b6445174df7b,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/download/DownloadQueueBean_1Test.java,62.10469126701355,stop,"// DownloadQueueBean.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;

/**
 * Stores a list of contentIds and a package file location and url.
 *
 * @author Seth Wright
 * @version 0.1
 */
public class DownloadQueueBean implements Serializable {

    /**
     * Deletes all package file settings (last modified, location, url)
     * but leaves the queue of id's intact.
     * Returns true on success.
     */
    public boolean clearPackageFileSettings();
}
","// DownloadQueueBean_1Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#clearPackageFileSettings()} method.
*/
class DownloadQueueBean_1Test {","// DownloadQueueBean_1Test.java
package org.heal.module.download;

import java.io.File;
import java.io.Serializable;
import java.util.Collection;
import java.util.TreeSet;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadQueueBean}.
* It contains one unit test case for the {@link DownloadQueueBean#clearPackageFileSettings()} method.
*/
class DownloadQueueBean_1Test {
@Test
    public void clearPackageFileSettings() {
        // given
        File lastModifiedFile;
        File path = new File("""");
        DownloadQueueBean bean = new DownloadQueueBean();
        Object[] array;
        // when
        bean.clearPackageFileSettings();
        // then
        assertFalse(bean.isEmpty());
        // assert false (no packages)
        assertFalse(bean.getManagedPackages().isEmpty());
        assertFalse(bean.getManagedPackages("""").isEmpty());
        // assert true (has packages, no packages at last)
        assertTrue(bean.getManagedPackages("""").contains(new File("""")));
        // assert false (has packages, have packages at last)
        assertFalse(bean.getManagedPackages(""hasPackageAtLast"").contains(new File("""")));
            lastModifiedFile = new File("""");

        // verify
        assertTrue(bean.contains(lastModifiedFile));
    }
}

// DownloadQueueBean_2.java
//package org.heal.module.download;
//
//import java.io.File;
//import java.util.Collection;
//import java.util.Random;
//
//import org.junit.jupiter.api.Test;
//
//public class DownloadQueueBean_2Test {
//	
//		@Test
//    public void noLastModifiedFileException() {
//        // given
//        File path = new File("""");
//        Collection<?> list = new TreeSet<>();
//        new File(path, ""someDirectory/zip.zip"").delete();
//        // when
//        Class<RuntimeException> type = RuntimeException.class;
//		//Then
//        // when encountering a no last modified file exception
//        list.add(new RuntimeException(type));
//        // then
//        assertFalse(list.contains(type));
//        // and
////        verify(list);
//    }
//    
//    @Test
//    public void empty() {
//        // given
//        Collection<?> list = new TreeSet<>();
//        // when
//        list.add(new File("""").delete());
//        // then
//        assertTrue(list.contains(new File("""")));
//        // and
////        verify(list);
//    }
// 
//}
"
5b03e77c-e9d7-4ee1-9bcd-26ad346af0cd,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTag_0Test.java,29.48608136177063,stop,"// DownloadFolderTag.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;

/**
 * A tag which is basically acts as a container for attributes which
 * nested tags will utilize.
 *
 * @version 1.0
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @see org.heal.tag.download.DownloadFolderActionTag
 */
public class DownloadFolderTag extends TagSupport {

    /**
     * Parses the attributes so as to initialize the
     * {@link #getDownloadFolderType() download folder type} for child tags
     * to use.
     *
     * @return Always returns <code>TagSupport.EVAL_BODY_INCLUDE</code>
     */
    public int doStartTag();
}
","// DownloadFolderTag_0Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doStartTag()} method.
*/
class DownloadFolderTag_0Test {","// DownloadFolderTag_0Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doStartTag()} method.
*/
class DownloadFolderTag_0Test {

    /** Test for the {@link DownloadFolderTag#doStartTag()}. */
    @Test
    public void doStartTag_01() throws Exception{
		
    	final DownloadQueueBean queue = FileLocator.getBean(DownloadQueueBean.class);
    	
		final ShortMetadataBean shortMetadata = queue.getShortMetadata();
		final String shortMetadataBean_0 = shortMetadata.getShortMetadataBean();
    	assertNotNull(shortMetadataBean_0);
		assertNotNull(shortMetadata);

//		TestBean tb0 = new TestBean();
//		TestBean tb1 = new TestBean();
//		TestBean tb2 = new TestBean();
//
//
//		tb1.tag = ""testfolder"";
//		tb2.tag = ""downloadfolder"";
//		tb1.add(TestBean.class, ""testfile1"");
//		tb2.add(""downloadfile2"", 1.0f);
//
//		queue.add(tb1);
//		queue.add(tb2);
//		queue.save();

    	new DownloadFolderTag_1Test();
    	
    	final String shortMetadataBean_1 = shortMetadata.getShortMetadataBean();
    	assertNotNull(shortMetadataBean_1);
		assertNotNull(shortMetadata);
	}

//	class DownloadFolderTag_1Test public class DownloadFolderTag_1Test extends DownloadFolderTag {
//
//
//    public void testDoStartTag()throws Exception{
//        DownloadQueueBean queue = FileLocator.getBean(DownloadQueueBean.class);
//        new DownloadFolderTag_1Test();
//	}

}

class DownloadFolderTag_1TaggingTest extends TagSupport {
	
	private final DownloadQueueBean queue = FileLocator.getBean(DownloadQueueBean.class);

	private DownloadFolderTag download = null;
	
    public void doStartTag() throws Exception {
        assertNotNull(queue);
        assertNotNull(download);
        
        final ShortMetadataBean shortMetadata = queue.getShortMetadata();
        final String shortMetadataBean_0 = shortMetadata.getShortMetadataBean();
        assertNotNull(shortMetadataBean_0);
        assertNotNull(shortMetadata);
        
    	download.setDownloadFolderType(""download"");
    }

	public String getDownloadFolderType(){
        return (String) download.get(""downloadFolderType"");
    }

    public void setDownloadFolderType( String download ){
        download.put(""downloadFolderType"", download);
    }

	public DownloadQueueBean getQueue(){
		return queue;
	}

	public void init(DownloadQueueBean queue) {
	    assertNotNull(queue);
	}
	
}

"
5e0d65c5-1e55-4ed8-9285-31932b530175,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTag_1Test.java,59.205090045928955,stop,"// DownloadFolderTag.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;

/**
 * A tag which is basically acts as a container for attributes which
 * nested tags will utilize.
 *
 * @version 1.0
 * @author Brad Schaefer (<A HREF=""mailto:schaefer@lib.med.utah.edu"">schaefer@lib.med.utah.edu</A>)
 * @see org.heal.tag.download.DownloadFolderActionTag
 */
public class DownloadFolderTag extends TagSupport {

    /**
     * Resets the internal state of the tag.
     *
     * @return Always returns <code>TagSupport.EVAL_PAGE</code>
     */
    public int doEndTag();
}
","// DownloadFolderTag_1Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doEndTag()} method.
*/
class DownloadFolderTag_1Test {","// DownloadFolderTag_1Test.java
package org.heal.tag.download;

import org.heal.module.download.DownloadQueueBean;
import org.heal.module.metadata.ShortMetadataBean;
import org.heal.util.FileLocator;
import javax.servlet.jsp.tagext.TagSupport;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DownloadFolderTag}.
* It contains one unit test case for the {@link DownloadFolderTag#doEndTag()} method.
*/
class DownloadFolderTag_1Test {
/**
		 * Unit test case to check the doEndTag method of the {@link
		 * DownloadQueueBean} tag.
		 */
        @Test
    
    public void testDoEndTag_1() {
        DownloadQueueBean dq = new DownloadQueueBean();
        Long download_id = new Long(1l);
        FileLocator f = new FileLocator();
        ShortMetadataBean short_meta = new ShortMetadataBean();
        ShortMetadataBean full_meta = new ShortMetadataBean();
        
        assertFalse(FileLocator.existsAnyFile());
        
        dq.retrieveShortMetadata(sh);
        
        assertNotNull(dq);
        assertEquals(true, FileLocator.existsAnyFile());
        // Check that the new download_id is the same as before
		assertEquals(download_id,
				FileLocator.getLastContentId(dq.getContentCache().getContentId(
						FileLocator.extendingToStartOfName(f.getURL(
						FileLocator.getFileString(f.getURL(download_id),
						""/"")).getPath()
	                    )).getId())
		);
        
        dq.addDownloadWithContent("""", FileLocator.getFileString(f.getURL(
        		download_id)).getName(), FileLocator.getFileString(f
        		.getURL(download_id)).getContent(), """", file_length, sh
        );
        dq.addDownloadWithLocation("""", f.getURL(""temp""), f.getFileID(), file_length);
        dq.addDownloadToContentMetadataMap("""");
        
        assertEquals(1, dq
               .getContentMetadataMap()
               .size());
        
        dq.retrieveShortMetadata(short_meta);
        
        assertNotNull(dq);
        assertEquals(true, FileLocator.existsAnyFile());
        long expected_id = FileLocator.getLastContentId(new Long(
                FileLocator.getFileString(f.getURL(download_id)).getId())
                );
        long expected_id_with_checksum = FileLocator.getLastContentId(new Long(
                f.getFileID().getId()));
        assertEquals(expected_id,
                FileLocator.getLastContentId(dq.getContentCache().getContentId(
                new Long(file_length).getId())));
        short_meta.setSHAval1(""ABCDEF"");
        dq.retrieveShortMetadata(full_meta);
        assertEquals(expected_id_with_checksum,
                FileLocator.getLastContentId(
                        dq.getContentCache().getContentId(
                        new Long(new ShortMetadataBean(""ABCDEF"", ""1S"").getId())
                ).getId()));
        dq.retrieveShortMetadata(short_meta);
        assertEquals(expected_id,
                FileLocator.getLastContentId(
                        dq.getContentCache().getContentId(
                        new Long(file_length + 3).getId())
                ).getId());
        
	}
}



"
a3c47d82-6964-4228-aa2c-b92bdfbec1dc,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResult.java,38.62112903594971,stop,"// SearchResult.java
package org.merlot.fedsearch.type;

public class SearchResult implements java.io.Serializable {

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc();
}
","// SearchResultTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResult}.
* It contains one unit test case for the {@link SearchResult#getTypeDesc()} method.
*/
class SearchResultTest {","// SearchResultTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResult}.
* It contains one unit test case for the {@link SearchResult#getTypeDesc()} method.
*/
class SearchResultTest {

	/**
	* Test method for {@link SearchResult#getTypeDesc()}.
	*/
	@Test
	public void testGetTypeDesc() {
		assertEquals(SearchResult.class, SearchResult.findTypeByName(""com/merlot/fedsearch/type/SearchResult"").getClass());
	}

}
"
c09ca625-839a-4aa7-8a61-f9c68a06ebf0,/EvoSuiteBenchmark/original/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultElement.java,24.48321008682251,stop,"// SearchResultElement.java
package org.merlot.fedsearch.type;

public class SearchResultElement implements java.io.Serializable {

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc();
}
","// SearchResultElementTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResultElement}.
* It contains one unit test case for the {@link SearchResultElement#getTypeDesc()} method.
*/
class SearchResultElementTest {","// SearchResultElementTest.java
package org.merlot.fedsearch.type;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResultElement}.
* It contains one unit test case for the {@link SearchResultElement#getTypeDesc()} method.
*/
class SearchResultElementTest {

	/**
     * @return Test method for {@link SearchResultElement#getTypeDesc()}.
     */
    @Test
    public void testGetTypeDesc() {
        SearchResultElement e = new SearchResultElement();
        assertEquals(""Type descriptor of SearchResultElement test object."",
        		e.getTypeDesc(),
        		SearchResultElement.getTypeDesc());
    }

	/**
     * @return Test method for {@link SearchResultElement#getTitle()}.
     */
    @Test
    public void testGetTitle() {
        SearchResultElement e = new SearchResultElement();
        assertEquals(""Title of SearchResultElement test object."",
        		e.getTitle(),
        		SearchResultElement.getTitle());
    }

	/**
     * @return Test method for {@link SearchResultElement#setTitle(java.lang.String)}.
     */
    @Test
    public void testSetTitle() {
        SearchResultElement e = new SearchResultElement();
        assertEquals(""Title of SearchResultElement test object."",
        		e.getTitle(),
        		SearchResultElement.getTitle());
    }

	/**
	* Test method for {@link SearchResultElement#getSource()}.
	*/
    @Test
    public void testGetSource() {
        SearchResultElement e = new SearchResultElement();
        assertNull(""Source of SearchResultElement test object."",
       e.getSource());
    }

	/**
	* Test method for {@link SearchResultElement#setSource(java.lang.String)}.
	*/
    @Test
    public void testSetSource() {
        SearchResultElement e = new SearchResultElement();
        assertNull(""Source of SearchResultElement test object."",
       e.getSource());
    }

	/**
     * @return Test method for {@link SearchResultElement#getMetadataValue(java.lang.String)}.
     */
    @Test
    public void testGetMetadataValue() {
        SearchResultElement e = new SearchResultElement();
        Object obj = e.getMetadataValue(""some-key"");
        assertEquals(""Metadata value of SearchResultElement test object."",
        		obj,
        		e.getMetadataValue(""some-key""));
    }

	/**
	* Test method for {@link SearchResultElement#getContentDescription(java.lang.String)}.
	*/
    @Test
    public void testGetContentDescription() {
        SearchResultElement e = new SearchResultElement();
        Object obj = e.getContentDescription(""some-key"");
        assertEquals(""Content description of SearchResultElement test object."", 
        		obj,
        		e.getContentDescription(""some-key""));
    }

	/**
	* Test method for {@link SearchResultElement#getSearchQueryString()}.
	*/
    @Test
    public void testGetSearchQueryString() {
        SearchResultElement e = new SearchResultElement();
        assertEquals(""Search query string of SearchResultElement test object."",
        		e.getSearchQueryString(),
        		SearchResultElement.getSearchQueryString());
    }

	/**
     * Test method for {@link SearchResultElement#getMetaDataElements()}.
     */
    @Test
    public void testGetMetaDataElements() {
        SearchResultElement e = new SearchResultElement();
        Object ret = e.getMetaDataElements();
        assertTrue(""MetaDataElements of SearchResultElement test object."", ((ret instanceof SearchResultElement) && (ret!= null)));
    }

}
"
