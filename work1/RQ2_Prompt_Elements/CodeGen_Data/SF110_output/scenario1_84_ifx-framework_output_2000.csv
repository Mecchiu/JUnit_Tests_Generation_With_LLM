ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
0c102b05-6aa0-46c5-80c3-20dc5967b1be,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_0Test.java,65.68037819862366,stop,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    public boolean hasInterface() {
        return (this.getInterface() != null);
    }
}
","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {
// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    public boolean hasInterface() {
        return (this.getInterface()!= null);
    }
}

// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {
		/**
		 * Some basic checks for compliance of generated test case.
		 */
		private final String TOSTRING_VALUE =
			""Hello, World!\n""
			+ ""this is a test string\n""
			+ ""This value should be printed as a 'Hello, World!,\n""
			+ ""this is a test string\n""
			+ ""This value should be printed with a newline\n"";
		/*
         * Main entry point of the test case.
         */
		@junit.jupiter.Disabled(""Disabled to improve the usability of this test"")
		@Test
        void test() {
			list = list!= null
				? list
				: new ArrayList();
			try {
					// get the list of interfaces included by the class
					List ifc_ref = getIncludes();
					// iterate over all interfaces in the class
					Iterator interfaces = ifc_ref.iterator();
					// if present, append the list of interfaces to a given list
					if ( ifc_ref.size() > 0 ) {
						list.addAll(ifc_ref.iterator());
					}
					list = list!= null? new ArrayList(list) : null;
					// if present, check for empty list
					if ( list == null ) {
						System.err.println(
						""\nNo interfaces found by this class.\n""
						+ ""This test should fail only if there is no interface.\n"" );
					}
					// get the list of interfaces declared in the class
					List ifc_declaration = getDeclaredInterfaces();
					int i = -1; // index to check
					// iterate over all interfaces declared by the class
					Iterator interfaceIterator = ifc_declaration.iterator();
					while ( interfaceIterator.hasNext() ) {
						i++; // i is the index to next iterator
						// if the interface has already been checked, it is OK to continue
						if (! ifc_declaration.contains(interfaceIterator.next()) ) {
							System.out.println(
								""Interface "" + i +
								"" marked for inclusion by the class has already been used.\n""
								+ ""The test will not be passed. "");
							break;
						}
					}
					if ( ifc_declaration.size() == 0
							&& ifc_ref.size() > 0 ) {
						// if possible, check the interfaces of the first class
						int i0 = 0;
						Iterator j1 = ifc_ref.iterator().next().iterator();
						while ( j1.hasNext() ) {
							i0++;
							j1.next();
						}
						if ( i0 > 0 ) {
							System.out.println(
								""There is at least one interface from which to include an interface for this class.\n""
								+ ""The test will not be passed. "");
							break;
						}
					}
				}
                catch (RuntimeException e) {
                        e.printStackTrace();
                        fail(""Exception in this class : "" + e.getMessage());
                }
        }
		/**
		 * List containing the contents of the class file to be
		 * printed. To add a new element, put it into the
		 * list or replace it using the replace() method.
		 * @return the list containing the methods, classes and interfaces
		 */
		private List list;

		/**
		 * Helper class to iterate the list of included classes. It
		 * uses the iterator to get the element that would be returned
		 * when the iterate() method of the interface called.
		 * @type T element
		 */
		private final class ListIterator implements Iterator {
				/**
				 * The element to return.
				 */
				Iterator elem;
				/**
				 * The index to keep track of which element we are
				 * currently returning.
				 */
				int index = 0;

				/**
				 * Constructor for ListIterator.
				 */
				ListIterator() {
						// init iterator
							elem = list!= null? list.iterator() : null;
						}
				/**
				 * Return the elements currently in the list.
				 */
				@junit.jupiter.Async
				public Object next() throws Exception {
						do {
								// get the next element of list
								elem = ( list!= null )
									? (( List ) list).iterator()
									: null;
						}
						while ( doNext() );
						return ((Object) elem.next()).toString();
				}
				/**
				 * Remove the element and return the previous
				 * element that was returned by the iterator.
				 * @return an element to be returned by the iterator
				 */
				@junit.jupiter.Async
				public Object remove() throws Exception {
						// get the previous element of the list
						elem = ((List ) list).remove(index--);
						// return the element
						return ((Object) elem.next()).toString();
				}
				/**
				 * Skip the next element of the list, call
				 * remove() and return the skipped element.
				 * @return the next SKIPPED element from the list
				 * @see java.util.Iterator#hasNext()
				 */
				private boolean doNext() {
						while (index < list.size()) {
								// get the next element of the list
								elem = ((List ) list).remove(index--);
								// return the element
								return ((Object) elem.next()).toString();
						}
						return false;
				}
		}
}
"
6e0c33d3-34fa-4b3c-a495-c9212b1134fd,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_1Test.java,63.1694655418396,stop,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    public boolean hasSuperClass() {
        return (this.getSuperClass() != null);
    }
}
","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {
// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    public boolean hasSuperClass() {
        return (this.getSuperClass()!= null);
    }
}

// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {
		 
    final static private String[][]  PARAMETER_SAMPLES = new String[][] {
        { """", """"},
        {""class A {"", """"},
        {""void test(int a, int b, a) {}""}, {""""},
        {""class B {"", "" class A {""}
    };

	       
    final static private String[][]  CLASS_PARAMETER_SAMPLES = new String[][] {
        { """", """"},
        {""class A {"", """"},
        {""class B"", """"},
        {""void test(int a, int b, class A::A)"", """"},
        {""class B {"", "" class A {""}
    };

    final static private String[][]  EMPTY = new String[][] {
        { ""class A {} class B {}"", """"} 
    };

	       
    final static private String[][]  HELP = new String[][] {
        // { """", """"},
        { """"},
        { ""class A {"", "" class A""}
    };

	       
    final static private String[][] DESC
    ///////////////////////////////////////////////////////////////////
        { HELP, HELP, END
        };

    final static private int          PARAMETER_SAMPLE_COUNT =
                                    DESC.length;

    final static private int          CLASS_PARAMETUM_SAMPLE_COUNT =
                                           HELP.length;
    
    public boolean hasSuperClass(String newSuperClass) {
        return (this.getSuperClass().equals(newSuperClass));
    }

    public List<String> getParameterSamples() {
        return this.getParameters(PARAMETER_SAMPLE_COUNT);
    }

    public List<String> getClassParametersSamples() {
        return this.getClassParametersSamples(CLASS_PARAMETER_SAMPLE_COUNT);
    }

    public List<String> getEmptySamples() {
        return this.emptySamples(this.PARAMETER_SAMPLE_COUNT);
    }

    public List<String> getHelpSamples() {
        return this.helpSamples(this.CLASS_PARAMETER_SAMPLE_COUNT);
    }

    public List<String> getDescSamples() {
        return this.helpSamples(this.CLASS_PARAMETER_SAMPLE_COUNT);
    }

    public long getParameterSampleCount() {
        return Integer.parseInt(
                    this.getParameterSamples().get(PARAMETER_SAMPLE_COUNT - 4).trim());
    }

    public long getClassParameterSampleCount() {
        return Integer.parseInt(
                    this.getClassParametersSamples().get(CLASS_PARAMETER_SAMPLE_COUNT - 4).trim());
    }

    protected List<String> helpSamples(int sampleCount) {
        ArrayList<String> list = new ArrayList<String>();
		Iterator<String> iter = helpSamples(
                                        this.describeSamples(this.DESC), sampleCount);
		while (iter.hasNext()) { list.add(iter.next()); }
        list.add(this.getHelpSamples());
        return list;
    }

    private List<String> helperSamples(String sample, int sampleCount) {
		Iterator<String> iter = this.helpSamples(this.SAMPLE, sampleCount);
		int i = 1;
		while (iter.hasNext()) {
                String newSample = iter.next();
                newSample = newSample.replace(""${"" + sample + ""}"", """");
                newSample = this.getHelperSamples().get(i);
                newSample = String.format(""        %s."", newSample);
                newSample = newSample.trim();
                iter.remove();
                iter.add(newSample);
                i++;
        }  
        return this.helpSamples(this.helperSamples(sample, sampleCount), sampleCount);
    }

    /**
     * Returns the list of samples.
     */
    private List<String> describeSamples(String[] descript, int count) {
        List<String> list = new ArrayList<String>();
		int i = 1;
		while (i < count) {
            String newSample = descript[i];
            newSample = newSample.replace(""${"" + count + ""}"", """");
            list.add(newSample);
            i++;
        }
        return list;
    }

    private Iterator<String> helpSamples(String[] samples, int sampleCount) {
          Iterator<String> iter = samples.iterator();
          return iter.hasNext()? iter.next(): iter.hasNext();
    }

    private Iterator<String> helpSamples(
                                 String[] samplings, int sampleCount) {
        return ((String[])samplings.clone()).iterator();
    }
	            
	    public String getClassName() {
            return this.getSuperClass().replaceAll(""\\.class"", """");
        }
		
	    public Class getSuperClass() {
            return (this.getClassName().replaceAll(""\\."", "".""));
        }

        public int getParameterSampleCount() {
            return this.getParameterSamples().size();
        }


    public int getClassParameterSampleCount() {
               return this.getClassParametersSamples().size();
    }


    public boolean hasEmptySample(String newSuperClass) {
        return (this.getSuperClass().equals(newSuperClass));
        
    }

	    public String getClassDescription(String newSuperClass) {
        if ((this.getSuperClass().contains("".""))) {
            newSuperClass = newSuperClass.replaceAll(""."", ""*"");
        }
        String newName = this.getSuperClass().replaceAll(""\\."", ""*"");
		String newBaseType = this.baseTypeOf(newSuperClass);
		newBaseType = newBaseType.split(""."")[0];
        return (String.format(""%s %s %s (%s)"", 
			newName.replaceAll(""\\."", "".""),
			newBaseType.replaceAll(""\\."", "".""), 
			newSuperClass.replaceAll(""\\."", "".""), 
			this.getClassName()));
        //return newName;
    }

    String baseTypeOf(String className) {
           String baseType = ""java.lang.Object"";
		StringTokenizer t = new StringTokenizer(className, ""-"");
		while (t.hasMoreTokens()) {
            baseType = t.nextToken();
			StringTokenizer t1 = new StringTokenizer(baseType, ""."");
			if (t1.hasMoreTokens()) {
				String className1 = t1.nextToken();
				if (className1.contains(""."")) {
					baseType = className1.replaceAll(""\\."", ""."");
				}
				else {
					baseType = className1;
				}
			}
		}
		return baseType;
    }
}
"
db46ad00-cc89-4c4e-b280-56393a6a422c,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDecoder.java,36.82136917114258,length,"// IFXDecoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;

/**
 * Decodes an IFX XML String to its equivalent Framework bean.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXDecoder {

    public IFXObject decode(Element element) throws IFXException {
        try {
            String id = element.getAttributeValue(""Id"");
            String beanClassName = getBeanClassName(element);
            IFXObject obj = (IFXObject) Class.forName(beanClassName).newInstance();
            List children = element.getChildren();
            if (children.size() == 0) {
                String text = element.getText();
                if (text != null && text.trim().length() > 0) {
                    if (!(obj instanceof IBaseType)) {
                        throw new IFXException(""Leaf node not an instance of IBaseType: "" + obj.getClass().getName());
                    } else {
                        ((IBaseType) obj).setString(text);
                        return obj;
                    }
                } else {
                    // return the empty object
                    return obj;
                }
            } else {
                Iterator childIter = children.iterator();
                while (childIter.hasNext()) {
                    Element childElement = (Element) childIter.next();
                    IFXObject childObj = decode(childElement);
                    // run corresponding accessor method to see if the
                    // result is an array
                    Method accessorMethod = getAccessor(obj, childElement);
                    Object retValObj = accessorMethod.invoke(obj, null);
                    boolean isArray = accessorMethod.getReturnType().isArray();
                    // then get the mutator method and invoke it
                    Method mutatorMethod = getMutator(obj, childElement);
                    if (isArray) {
                        // if result is an array, build a new array with
                        // size = returned array size + 1, and stuff this
                        // object at the end of the array
                        IFXObject[] childObjs = null;
                        if (retValObj != null) {
                            int oldLen = Array.getLength(retValObj);
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { oldLen + 1 });
                            IFXObject[] retValObjs = (IFXObject[]) retValObj;
                            System.arraycopy(retValObj, 0, childObjs, 0, oldLen);
                            childObjs[oldLen] = childObj;
                        } else {
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { 1 });
                            childObjs[0] = childObj;
                        }
                        mutatorMethod.invoke(obj, new Object[] { childObjs });
                    } else {
                        mutatorMethod.invoke(obj, new Object[] { childObj });
                    }
                }
                // if Id attribute is specified, populate it
                if (id != null) {
                    Method mutatorMethod = getMutator(obj, ""Id"");
                    IFXString idObj = new IFXString();
                    idObj.setString(id);
                    mutatorMethod.invoke(obj, new Object[] { idObj });
                }
                return obj;
            }
        } catch (Exception e) {
            throw new IFXException(""Error decoding "" + element.getName(), e);
        }
    }
}
","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {
// IFXDecoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;

/**
 * Decodes an IFX XML String to its equivalent Framework bean.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXDecoder {

    public IFXObject decode(Element element) throws IFXException {
        try {
            String id = element.getAttributeValue(""Id"");
            String beanClassName = getBeanClassName(element);
            IFXObject obj = (IFXObject) Class.forName(beanClassName).newInstance();
            List children = element.getChildren();
            if (children.size() == 0) {
                String text = element.getText();
                if (text!= null && text.trim().length() > 0) {
                    if (!(obj instanceof IBaseType)) {
                        throw new IFXException(""Leaf node not an instance of IBaseType: "" + obj.getClass().getName());
                    } else {
                        ((IBaseType) obj).setString(text);
                        return obj;
                    }
                } else {
                    // return the empty object
                    return obj;
                }
            } else {
                Iterator childIter = children.iterator();
                while (childIter.hasNext()) {
                    Element childElement = (Element) childIter.next();
                    IFXObject childObj = decode(childElement);
                    // run corresponding accessor method to see if the
                    // result is an array
                    Method accessorMethod = getAccessor(obj, childElement);
                    Object retValObj = accessorMethod.invoke(obj, null);
                    boolean isArray = accessorMethod.getReturnType().isArray();
                    // then get the mutator method and invoke it
                    Method mutatorMethod = getMutator(obj, childElement);
                    if (isArray) {
                        // if result is an array, build a new array with
                        // size = returned array size + 1, and stuff this
                        // object at the end of the array
                        IFXObject[] childObjs = null;
                        if (retValObj!= null) {
                            int oldLen = Array.getLength(retValObj);
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { oldLen + 1 });
                            IFXObject[] retValObjs = (IFXObject[]) retValObj;
                            System.arraycopy(retValObj, 0, childObjs, 0, oldLen);
                            childObjs[oldLen] = childObj;
                        } else {
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { 1 });
                            childObjs[0] = childObj;
                        }
                        mutatorMethod.invoke(obj, new Object[] { childObjs });
                    } else {
                        mutatorMethod.invoke(obj, new Object[] { childObj });
                    }
                }
                // if Id attribute is specified, populate it
                if (id!= null) {
                    Method mutatorMethod = getMutator(obj, ""Id"");
                    IFXString idObj = new IFXString();
                    idObj.setString(id);
                    mutatorMethod.invoke(obj, new Object[] { idObj });
                }
                return obj;
            }
        } catch (Exception e) {
            throw new IFXException(""Error decoding "" + element.getName(), e);
        }
    }
}

// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {
		/**
		 * Test case.
		* Loads a non-exceptionally nested tree
		* containing all methods of
		* class and its inner classes.
		*/
    @Test
    public void decodeTest() {
        IFXDecoder decoder = new IFXDecoder();
        List children = decoder.decode(null);
        // check that no exception
        Iterator iterator = children.iterator();
        IFXObject object = (IFXObject) iterator.next();
        assertNotNull(object);
        while (iterator.hasNext()) {
            object = (IFXObject) iterator.next();
            if (object.getClass().getDeclaredMethods().length!= 1) {
                fail();
            }
        }
        // check that no exceptions
        if (object.getClass().getDeclaredMethods().length!= 1) {
            fail();
        }
        // check that nothing throws
        String error = """";
        Method m = new IFXMethod(""get"", IFXString.class);
        Object retObj = decoder.getByRef(object, m);
        assertNotNull(retObj);
        assertTrue(retObj.getClass() == object.getClass());
        int retLen = Array.getLength(retObj);
        Iterator iteratorRet = retObj.getClass().getMethods();
        while (iteratorRet.hasNext()) {
            IFXMethod mObj = (IFXMethod) iteratorRet.next();
            // check which method
            Class<?> method = mObj.getClass();
            if (mObj.getName().equals(""get"") &&
                    method.getDeclaredMethod(""getString"")!= null) {
                m = method.getDeclaredMethod(""getString"");
                mObj = (IFXMethod) mObj.getCallContext();
            }
            Object argsObj = decoder.getArgs(object, m);
            assertNotNull(argsObj);
            IFXObject argsObjRet = (IFXObject) argsObj;
            int argLen = Array.getLength(argsObjRet);
            if (arraySameLength(retObj, argsObjRet)) {
                assertEquals(retLen, argLen);
            }
            // if we see a method, look for
            // a method named getString
            if (m.getName().equals(""getString"")) {
                m = ifxMethodObject;
            }
        }


    }

    public IFXMethod ifxMethodObject;

    /**
     * Build IObject with default parameters for
     * the class to be tested.
     *
     */
    public static class IObject extends IFXObject {
        public IObject() {
            super();
            this.id = null;
            methodId = IFXObject.noId;
            elementName = null;
        }

        /**
         * Get the element
         * @return the element
         */
        public Element getElement() {
            return element.getFirstChild();
        }

        public IObject(String id, String elementName, int size) {
            super(size);
            this.id = id;
            this.elementName = elementName;
        }

        /**
         * Get the ID of this object and its
         * corresponding element.
         *
         * @return the ID
         */
        public String getId() {
            return id;
        }

        public void setId(String id) {
            if (this.id!= null &&!this.id.equals(id)) {
                IFXObject[] objs = ((IFXObject[]) elements.toArray(new IFXObject[0]));
                IFXString newId = new IFXString();
                newId.setString("
d730684c-147a-4274-a1cf-a5154a83d655,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXEncoder.java,40.93360662460327,length,"// IFXEncoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;

/**
 * Encodes an IFXObject to its equivalent IFX XML Element.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXEncoder {

    public Element encode(IFXObject obj) throws IFXException {
        try {
            Element element = new Element(getElementName(obj), namespace);
            List accessorList = getAccessors(obj);
            Iterator accessorIter = accessorList.iterator();
            while (accessorIter.hasNext()) {
                Method accessorMethod = (Method) accessorIter.next();
                if (accessorMethod.getName().equals(""getClass"")) {
                    continue;
                }
                Object retValObj = accessorMethod.invoke(obj, null);
                if (retValObj == null) {
                    continue;
                }
                IFXObject[] retVals = new IFXObject[1];
                if (retValObj.getClass().isArray()) {
                    retVals = (IFXObject[]) retValObj;
                } else {
                    retVals[0] = (IFXObject) retValObj;
                }
                for (int i = 0; i < retVals.length; i++) {
                    IFXObject retVal = retVals[i];
                    if (retVal instanceof IBaseType) {
                        String value = ((IBaseType) retVal).getString();
                        if (accessorMethod.getName().equals(""getId"")) {
                            element.setAttribute(""Id"", value);
                        } else {
                            Element baseElement = new Element(getElementName(retVal), namespace);
                            baseElement.setText(value);
                            element.addContent(baseElement);
                        }
                    } else {
                        element.addContent(encode(retVal));
                    }
                }
            }
            return element;
        } catch (Exception e) {
            throw new IFXException(""Error encoding "" + obj.getClass().getName(), e);
        }
    }
}
","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains one unit test case for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains one unit test case for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {
public static final String nsURI = """", nsPrefix = """",
				encodedPrefix =""test_encodedPrefix"";
		private final ResourceBundle bundle;

    public IFXEncoderTest() {
        this.bundle = ResourceBundle.getBundle(encodedPrefix);
    }

	@Test public void setElementAndObject() throws MissingResourceException {
		Element element = new Element(encode(new IFXObject()));

		Element elementToTest = new Element(encode(new IFXObject()), nsURI);
		elementToTest = encode(element);

		IFXObject objOne = new IFXObject();
		objOne.setClassAttributeValue(getElementName(objOne), namespace);
		Object resObjOne = objOne;

		Map namespacesAndPrefixes = new HashMap();
		namespacesAndPrefixes.put(nsURI, encode(objOne));
		namespacesAndPrefixes.put(nsPrefix, namespace);
		IFXObject oneWithoutEncoding = encode(objOne, namespace, null, true);

		IFXObject objTwo = new IFXObject();
		objTwo.setClassAttributeValue(getElementName(objTwo), namespace);
		Object resObjTwo = objTwo;

		IFXObject twoWithoutEncoding = encode(objTwo, namespace, null, true);


		assertTrue(ObjectsEqual.compareObjectsEquals(element, elementToTest, false, true));
		assertTrue(ObjectsEqual.compareObjectsEquals(resObjOne, oneWithoutEncoding, false, true));
		assertTrue(ObjectsEqual.compareObjectsEquals(resObjTwo, twoWithoutEncoding, false, true));
		assertTrue(ObjectsEqual.compareObjectsEquals(objOne, twoWithoutEncoding, false, false));
	}

	@Test public void setElementAndObjectWithNull() throws MissingResourceException {
		Element element = new Element(encode(new IFXObject()));

		Element elementToTest = new Element(encode(new IFXObject()), nsURI);
		elementToTest = encode(element);

		IFXObject objOne = new IFXObject();
		objOne.setClassAttributeValue(getElementName(objOne), namespace);
		Object resObjOne = objOne;

		Map namespacesAndPrefixes = new HashMap();
		namespacesAndPrefixes.put(nsURI, encode(objOne));
		IFXObject oneWithoutEncoding = encode(objOne, namespace, null, true);

		IFXObject objTwo = new IFXObject();
		IFXObject oneWithoutEncoding = encode(objTwo, namespace, null, true);

		IFXObject twoWithoutEncoding = encode(objTwo, namespace, null, true);

		assertTrue(ObjectsEqual.compareObjectsEquals(element, elementToTest, false, true));
		assertTrue(ObjectsEqual.compareObjectsEquals(resObjOne, oneWithoutEncoding, false, true));
		assertTrue(ObjectsEqual.compareObjectsEquals(resObjTwo, twoWithoutEncoding, false, true));
		assertTrue(ObjectsEqual.compareObjectsEquals(objOne, twoWithoutEncoding, false, false));
	}

	@Test public void setElementAndObjectWithEnum() throws MissingResourceException {
		Element element = new Element(encode(new IFXObject()));

		Element elementToTest = new Element(encode(new IFXObject()), nsURI);
		elementToTest = encode(element);

		Enum<IFXObject> enumObjectOne = Enum.valueOf(""org.sourceforge"", ""test_enumEnumOne"");
		Object resObjOne = enumObjectOne;

		Map namespacesAndPrefixes = new HashMap();
		namespacesAndPrefixes.put(nsURI, encode(enumObjectOne));
		IFXObject oneWithoutEncoding = encode(enumObjectOne, namespace, null, true);

		IFXObject objTwo = new IFXObject();
		IFXObject oneWithoutEncoding = encode(objTwo, namespace, null, true);

		IFXObject twoWithoutEncoding = encode(objTwo, namespace, null, true);

		assertTrue(ObjectsEqual."
0247602e-ff48-405f-9605-c758e6a53c10,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_0Test.java,55.517099142074585,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException {
        IFXEncoder encoder = null;
        if (namespaceURI != null) {
            encoder = new IFXEncoder(namespacePrefix, namespaceURI);
        } else {
            encoder = new IFXEncoder();
        }
        Element element = encoder.encode(obj);
        Document doc = new Document(element);
        return doc;
    }
}
","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {
// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException {
        IFXEncoder encoder = null;
        if (namespaceURI!= null) {
            encoder = new IFXEncoder(namespacePrefix, namespaceURI);
        } else {
            encoder = new IFXEncoder();
        }
        Element element = encoder.encode(obj);
        Document doc = new Document(element);
        return doc;
    }
}

// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {
		
	/**
	 * This is a dummy test case that simply calls build(Element, String, String) that
	 * returns a Document.
	 */
	@Test
	public void test_0() throws IOException, IllegalArgumentException {
		IFXDocumentHandler.build(Document.class, (String) null, (String) null);
		if (IFXDocumentWriter_0.IFXDOCUMENT_PREFIX.equals(""doc"")) {
		    fail(""Should not initialize an IFXDocumentWriter while a Document is not created"");
		}
	}
}

// IFXDocumentHandler.java

class IFXEncoder implements IFXObject
{
	IFXEncoder(String prefix, String uri) {
		this.prefix = prefix;
		this.uri = uri;
	}

	private String prefix;
	private String uri;

	/**
	 * @see IFXObject#toXML()
	 * @return XML representation of the object.
	 */
	public String toXML() {
		return XMLOutputter.toString(this);
	}

	/**
	 * Convert the XML representation of the object into an IFXObject.
	 * If the object has an XML representation, the corresponding IFXObject will
	 * be returned, otherwise just the string representation will be returned.
	 * @return
	 */
	public IFXObject toIFXObject() {
		SAXBuilder parser = new SAXBuilder();
		parser.setValidation(false);
		parser.build(new InputStream(IFXEncoder_0.IFXDOCUMENT_URI_1), IFXEncoder_0.IFXDOCUMENT_PREFIX_1, IFXEncoder_0.IFXDOCUMENT_URI_0);
		return parser.getDocument();
	}

	/**
	 * Convert the object into a IFXObject representation.
	 * This is not a complete test method.
	 * @return
	 */
	public IFXObject toIFXObject(Map<String, String> prefixes, Map<String, String> uriPatterns) {
		SAXBuilder parser = new SAXBuilder();
		parser.setProperty(Namespace.ALIAS_RESOLVER, IFXNAMESPACE_ALIASRESOLVER);
		parser.setProperty(IFXMarshallingUtils.PRESERVE_VALUES, ""true"");
		parser.setProperty(IFXMarshallingUtils.NAMESPACE_PREFIXES, prefixes);
		parser.setProperty(IFXMarshallingUtils.NAMESPACE_NAMESPACES, uriPatterns);
		Document document = parser.build(new InputStream(IFXEncoder_0.IFXDOCUMENT_URI_1), IFXEncoder_0.IFXDOCUMENT_PREFIX_1,
				IFXEncoder_0.IFXDOCUMENT_URI_0);

		Element element = document.getRootElement();
		assertNotNull(element);
		assertEquals(IFXEncoder.IFXDOCUMENT_PREFIX_0, element.getNamespaceURI().toString());
		assertEquals(""ifxDocument"", element.getName());
		Namespace elementNS = element.getNamespace();
		assertEquals(""ifxDocument"", elementNS.getURI());

		Element containerTypeElement = document.getRootElement().getChild(Namespace.DEFAULT_PREFIX, Namespace.CONTENT_MODEL);
		assertNotNull(containerTypeElement);
		assertEquals(Namespace.DEFAULT_PREFIX, containerTypeElement.getNamespaceURI().toString());
		assertEquals(""containerType"", XMLUtil.getChildText(containerTypeElement, Namespace.CONTENT_MODEL));
		return document.getRootElement();
	}

	@Override
	public boolean getIsCompressedOutput() {
		return true;
	}
	
	@Override
	public void unset() {
		
	}

	@Override
	public String getName() {
		return ""IFXEncoder"";
	}

	private final String prefix;
	private final String uri;
	
	private IFXEncoder(String prefix, String uri) {
		this.prefix = prefix;
		this.uri = uri;
	}
}

// IFilterDocumentHandler.java

"
649e99ad-bfc5-47d6-aafa-86f786c673b9,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_1Test.java,57.36701488494873,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    public static IFXObject parse(Document doc) throws IFXException {
        Element element = doc.getRootElement();
        IFXDecoder decoder = new IFXDecoder();
        return decoder.decode(element);
    }
}
","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {
private static final int MAX_CHARS = 64 * 1024;// 128;// 64k;
		private static final String TEXT = ""This is some text, text"";
		
        @Test
		public void testParse() throws IOException, IFXException {
			// Parses the document into two IFXObject's.
			// The first one is the text, and should thus have a single IFXObject
			// which has a single IFXObject as its content.
			IFXObject documentText = parse(new SAXBuilder()).getFileContent();

			// The second one should exist with content in twoIFXObjects: one which has a
			// single IFXObject, and another which has three IFXObjects.
			IFXObject documentText2 = parse(new SAXBuilder()).getFileContent();

			// If an IFXObject is added, the third one should exist with content in only oneIFXObject.
			IFXObject documentText3 = parse(new SAXBuilder()).getFileContent();
			assertNotNull(documentText3);
		}

        @Test
		public void testFormat() throws IOException, IFXException {
			// The result of the parse is written to the XML output.
			IFXObject documentText = parse(new SAXBuilder()).getFileContent();
			IFXObject documentText2 = parse(new SAXBuilder()).getFileContent();
			IFXObject documentText3 = parse(new SAXBuilder()).getFileContent();

			// The result of a human would be the XMLOutputter class which writes the XML in XMLEncoder(XHTML).
			String result = XMLOutputter.getInstance().outputString(documentText.getFileContent().get());
		}

        @Test
		public void testSave() throws IOException {
			Element element = new Element(""testSave"");
			Namespace prefix = new Namespace(""testPrefix"", ""testPrefix"", ""testNamespace"");

			// Creates the first three IFXObjects.
			Element documentText = element.addContent(IFXObject._create(TEXT, prefix));
			Element documentText2 = element.addContent(IFXObject._create(TEXT, prefix));
			Element documentText3 = element.addContent(IFXObject._create(TEXT, prefix));

			OutputStream output = System.out;
			output.write(documentText.toString().getBytes(IFXObject._ENCODING));
			output.write(documentText2.toString().getBytes(IFXObject._ENCODING));
			output.write(documentText3.toString().getBytes(IFXObject._ENCODING));
			output.close();

			// Gets the outputstream using an SAX builder.
			SAXBuilder builder = new SAXBuilder();
			InputStream is = System.in;
			try {
				is = new InputStream() {
					@Override
					public int read() throws IOException {
						return is.read();
					}
				};

				Document document = builder.build(is);

				assertNotNull(document);

				// Gets the filecontent for the document text element using DocumentBuilder
				Document documentText = document.getRootElement();

				// Gets the filecontent for the document text element using DocumentBuilder
				Document text = documentText.getDocumentElement();

				// Gets the filecontent for the document text element using DocumentBuilder
				Document text2 = text.getDocumentElement();

				// Gets the filecontent for the document text element using DocumentBuilder
				Document text3 = text2.getDocumentElement();

			} catch (Exception e) {
				e.printStackTrace();
			}
		}

        @Test
		public void testLoad() throws IOException {
			// The result of the parse is written to the XML output.
			// Parses the document into two IFXObject's.
			IFXObject documentText = parse(new SAXBuilder()).getFileContent();
			IFXObject documentText2 = parse(new SAXBuilder()).getFileContent();
			IFXObject documentText3 = parse(new SAXBuilder()).getFileContent();

			System.out.println(documentText.validate());
			assertTrue(documentText.validate());
			assertFalse(documentText2.validate());
			assertFalse(documentText3.validate());

			System.out.println(documentText.getIFXObject());
			System.out.println(documentText2.getIFXObject());
			System.out.println(documentText3.getIFXObject());

		}

        @Test
		public void testAddObject() throws IOException {
			// Parses the document into two IfXObjects.
			IFXObject documentText1 = parse(new SAXBuilder()).getFileContent();
			IFXObject documentText2 = parse(new SAXBuilder()).getFileContent();

			// Creates an element in the document and adds this element.
			Element documentTextElement = documentText1.addChild(IFXObject._create(new Text(TEXT, 1, 0), new Namespace(""TEXT"", new String(""1""), null)));
			documentText2.addChild(documentTextElement);

			IFXObject documentText3 = parse(new SAXBuilder()).getFileContent();
		}
}
"
f1aaa0db-b80d-4bf7-989d-c9e0dc3af9cc,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_2Test.java,49.45856738090515,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException {
        SAXBuilder builder = null;
        if (validate) {
            builder = new SAXBuilder(""org.apache.xerces.parsers.SAXParser"", true);
            builder.setFeature(""http://apache.org/xml/features/validation/schema"", true);
            if (validationProperties != null) {
                Iterator propIter = validationProperties.keySet().iterator();
                StringBuffer buf = new StringBuffer();
                int i = 0;
                while (propIter.hasNext()) {
                    String key = (String) propIter.next();
                    String value = (String) validationProperties.get(key);
                    if (i > 0) {
                        buf.append("" "");
                    }
                    buf.append(key).append("" "").append(value);
                    i++;
                }
                builder.setProperty(""http://apache.org/xml/properties/schema/external-schemaLocation"", buf.toString());
            }
        } else {
            builder = new SAXBuilder();
        }
        Document doc = null;
        try {
            doc = builder.build(istream);
        } catch (Exception e) {
            throw new IFXException(""Error reading Document"", e);
        }
        return doc;
    }
}
","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {
// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException {
        SAXBuilder builder = null;
        if (validate) {
            builder = new SAXBuilder(""org.apache.xerces.parsers.SAXParser"", true);
            builder.setFeature(""http://apache.org/xml/features/validation/schema"", true);
            if (validationProperties!= null) {
                Iterator propIter = validationProperties.keySet().iterator();
                StringBuffer buf = new StringBuffer();
                int i = 0;
                while (propIter.hasNext()) {
                    String key = (String) propIter.next();
                    String value = (String) validationProperties.get(key);
                    if (i > 0) {
                        buf.append("" "");
                    }
                    buf.append(key).append("" "").append(value);
                    i++;
                }
                builder.setProperty(""http://apache.org/xml/properties/schema/external-schemaLocation"", buf.toString());
            }
        } else {
            builder = new SAXBuilder();
        }
        Document doc = null;
        try {
            doc = builder.build(istream);
        } catch (Exception e) {
            throw new IFXException(""Error reading Document"", e);
        }
        return doc;
    }
}

// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {
		private static String BASE_VERSION = Configuration.BASE_VERSION;
		
		@Test
		public void readXML() throws IOException {
			if (Configuration.IS_VERSION_2) {
				Configuration.isVersion(2);
				Configuration.SCHEMA_LOCATION = Configuration.SCHEMA_URL;
				assertEquals(BASE_VERSION, Configuration.getBaseVersion());
			}
			InputStream irstream = Configuration.class.getResourceAsStream(""IFXschema_1.0_schema.xsd"");
			Document document = read(irstream);
			XMLOutputter docOut = new XMLOutputter();
			OutputStream dostream = Configuration.class.getResourceAsStream(""IFXschema_1.0_doc.xml"");
			try {
				docOut.write(document, dostream);
			} catch (IOException e) {
				dostream.close();
				assertTrue(false);
			}
		}
	}
}"
