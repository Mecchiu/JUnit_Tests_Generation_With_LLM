ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
6c7a8c2d-0b30-40df-ae8a-34c5545f6097,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/FieldInfo_0Test.java,10.4399995803833,stop,"// FieldInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a Field as defined by the FIX specification.
 *
 * @author jramoyo
 */
public class FieldInfo implements FixInfo {

    private int tagNumber;

    private String name;

    private String dataType;

    private String description;

    private String abbreviation;

    private String overrideXmlName;

    private String baseCategory;

    private String baseCategoryXmlName;

    private String unionDataType;

    private String usesEnumFromTag;

    private String comments;

    private int length;

    private boolean isNotRequiredXml;

    private String deprecatingVersion;

    private List<ComponentInfo> requiringComponents;

    private TreeMap<String, ValueInfo> validValues;

    /**
     * Returns the tagNumber
     *
     * @return the tagNumber
     */
    public int getTagNumber();

    /**
     * Modifies the tagNumber
     *
     * @param tagNumber - the tagNumber to set
     */
    public void setTagNumber(int tagNumber);

    /**
     * Returns the fieldName
     *
     * @return the fieldName
     */
    public String getName();

    /**
     * Modifies the fieldName
     *
     * @param name - the fieldName to set
     */
    public void setName(String name);

    /**
     * Returns the dataType
     *
     * @return the dataType
     */
    public String getDataType();

    /**
     * Modifies the dataType
     *
     * @param dataType - the dataType to set
     */
    public void setDataType(String dataType);

    /**
     * Returns the description
     *
     * @return the description
     */
    public String getDescription();

    /**
     * Modifies the description
     *
     * @param description - the description to set
     */
    public void setDescription(String description);

    /**
     * Returns the comments
     *
     * @return the comments
     */
    public String getComments();

    /**
     * Modifies the comments
     *
     * @param comments - the comments to set
     */
    public void setComments(String comments);

    /**
     * Returns the abbreviation
     *
     * @return the abbreviation
     */
    public String getAbbreviation();

    /**
     * Modifies the abbreviation
     *
     * @param abbreviation - the abbreviation to set
     */
    public void setAbbreviation(String abbreviation);

    /**
     * Returns the overrideXmlName
     *
     * @return the overrideXmlName
     */
    public String getOverrideXmlName();

    /**
     * Modifies the overrideXmlName
     *
     * @param overrideXmlName - the overrideXmlName to set
     */
    public void setOverrideXmlName(String overrideXmlName);

    /**
     * Returns the baseCategory
     *
     * @return the baseCategory
     */
    public String getBaseCategory();

    /**
     * Modifies the baseCategory
     *
     * @param baseCategory - the baseCategory to set
     */
    public void setBaseCategory(String baseCategory);

    /**
     * Returns the baseCategoryXmlName
     *
     * @return the baseCategoryXmlName
     */
    public String getBaseCategoryXmlName();

    /**
     * Modifies the baseCategoryXmlName
     *
     * @param baseCategoryXmlName - the baseCategoryXmlName to set
     */
    public void setBaseCategoryXmlName(String baseCategoryXmlName);

    /**
     * Returns the unionDataType
     *
     * @return the unionDataType
     */
    public String getUnionDataType();

    /**
     * Modifies the unionDataType
     *
     * @param unionDataType - the unionDataType to set
     */
    public void setUnionDataType(String unionDataType);

    /**
     * Returns the usesEnumFromTag
     *
     * @return the usesEnumFromTag
     */
    public String getUsesEnumFromTag();

    /**
     * Modifies the usesEnumFromTag
     *
     * @param usesEnumFromTag - the usesEnumFromTag to set
     */
    public void setUsesEnumFromTag(String usesEnumFromTag);

    /**
     * Returns the length
     *
     * @return the length
     */
    public int getLength();

    /**
     * Modifies the length
     *
     * @param length - the length to set
     */
    public void setLength(int length);

    /**
     * Returns the isNotRequiredXml
     *
     * @return the isNotRequiredXml
     */
    public boolean isNotRequiredXml();

    /**
     * Modifies the isNotRequiredXml
     *
     * @param isNotRequiredXml - the isNotRequiredXml to set
     */
    public void setNotRequiredXml(boolean isNotRequiredXml);

    /**
     * Returns the deprecatingVersion
     *
     * @return the deprecatingVersion
     */
    public String getDeprecatingVersion();

    /**
     * Modifies the deprecatingVersion
     *
     * @param deprecatingVersion - the deprecatingVersion to set
     */
    public void setDeprecatingVersion(String deprecatingVersion);

    /**
     * Returns the requiringComponents
     *
     * @return the requiringComponents
     */
    public List<ComponentInfo> getRequiringComponents();

    /**
     * Add a requiringComponent
     *
     * @param component - a requiringComponent
     */
    public void addRequiringComponent(ComponentInfo component);

    /**
     * Modifies the requiringComponents
     *
     * @param requiringComponents - the requiringComponent to set
     */
    protected void setRequiringComponents(List<ComponentInfo> requiringComponents);

    /**
     * Returns whether this field is required in the specified component
     *
     * @param component - a component
     * @return whether this field is required in the specified component
     */
    public boolean isRequiredInComponent(ComponentInfo component);

    /**
     * Returns the validValues
     *
     * @return the validValues
     */
    public List<ValueInfo> getValidValues();

    /**
     * Adds a value
     *
     * @param value - a value
     */
    public void addValidValue(ValueInfo value);

    /**
     * Returns whether a given value is valid
     *
     * @param value - a value
     * @return whether a given value is valid
     */
    public boolean isValidValue(String value);

    /**
     * Modifies the validValues
     *
     * @param validValues - the validValues to set
     */
    protected void setValidValues(TreeMap<String, ValueInfo> validValues);

    /**
     * Returns the validValues Map
     *
     * @return the validValues Map
     */
    protected TreeMap<String, ValueInfo> getValidValuesMap();
}
","// FieldInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isRequiredInComponent(ComponentInfo)} method.
*/
class FieldInfo_0Test {","// FieldInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isRequiredInComponent(ComponentInfo)} method.
*/
class FieldInfo_0Test {

	@Test
	void test_isRequiredInComponent_1_0_0(){
		FieldInfo fieldInfo = new FieldInfo();
		assertFalse(fieldInfo.isRequiredInComponent(""Component2""));
	}
	@Test
	void test_isRequiredInComponent_1_0_1(){
		List<ComponentInfo> componentInfos = new ArrayList<>();
		componentInfos.add(new ComponentInfo(""Component1""));
		assertTrue(fieldInfo.isRequiredInComponent(componentInfos));
	}
	
}
		

// FieldInfo_0Xml.java
"
b7c79298-3f68-4be2-b21a-fd1c09b98946,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/FieldInfo_1Test.java,10.427953481674194,length,"// FieldInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a Field as defined by the FIX specification.
 *
 * @author jramoyo
 */
public class FieldInfo implements FixInfo {

    private int tagNumber;

    private String name;

    private String dataType;

    private String description;

    private String abbreviation;

    private String overrideXmlName;

    private String baseCategory;

    private String baseCategoryXmlName;

    private String unionDataType;

    private String usesEnumFromTag;

    private String comments;

    private int length;

    private boolean isNotRequiredXml;

    private String deprecatingVersion;

    private List<ComponentInfo> requiringComponents;

    private TreeMap<String, ValueInfo> validValues;

    /**
     * Returns the tagNumber
     *
     * @return the tagNumber
     */
    public int getTagNumber();

    /**
     * Modifies the tagNumber
     *
     * @param tagNumber - the tagNumber to set
     */
    public void setTagNumber(int tagNumber);

    /**
     * Returns the fieldName
     *
     * @return the fieldName
     */
    public String getName();

    /**
     * Modifies the fieldName
     *
     * @param name - the fieldName to set
     */
    public void setName(String name);

    /**
     * Returns the dataType
     *
     * @return the dataType
     */
    public String getDataType();

    /**
     * Modifies the dataType
     *
     * @param dataType - the dataType to set
     */
    public void setDataType(String dataType);

    /**
     * Returns the description
     *
     * @return the description
     */
    public String getDescription();

    /**
     * Modifies the description
     *
     * @param description - the description to set
     */
    public void setDescription(String description);

    /**
     * Returns the comments
     *
     * @return the comments
     */
    public String getComments();

    /**
     * Modifies the comments
     *
     * @param comments - the comments to set
     */
    public void setComments(String comments);

    /**
     * Returns the abbreviation
     *
     * @return the abbreviation
     */
    public String getAbbreviation();

    /**
     * Modifies the abbreviation
     *
     * @param abbreviation - the abbreviation to set
     */
    public void setAbbreviation(String abbreviation);

    /**
     * Returns the overrideXmlName
     *
     * @return the overrideXmlName
     */
    public String getOverrideXmlName();

    /**
     * Modifies the overrideXmlName
     *
     * @param overrideXmlName - the overrideXmlName to set
     */
    public void setOverrideXmlName(String overrideXmlName);

    /**
     * Returns the baseCategory
     *
     * @return the baseCategory
     */
    public String getBaseCategory();

    /**
     * Modifies the baseCategory
     *
     * @param baseCategory - the baseCategory to set
     */
    public void setBaseCategory(String baseCategory);

    /**
     * Returns the baseCategoryXmlName
     *
     * @return the baseCategoryXmlName
     */
    public String getBaseCategoryXmlName();

    /**
     * Modifies the baseCategoryXmlName
     *
     * @param baseCategoryXmlName - the baseCategoryXmlName to set
     */
    public void setBaseCategoryXmlName(String baseCategoryXmlName);

    /**
     * Returns the unionDataType
     *
     * @return the unionDataType
     */
    public String getUnionDataType();

    /**
     * Modifies the unionDataType
     *
     * @param unionDataType - the unionDataType to set
     */
    public void setUnionDataType(String unionDataType);

    /**
     * Returns the usesEnumFromTag
     *
     * @return the usesEnumFromTag
     */
    public String getUsesEnumFromTag();

    /**
     * Modifies the usesEnumFromTag
     *
     * @param usesEnumFromTag - the usesEnumFromTag to set
     */
    public void setUsesEnumFromTag(String usesEnumFromTag);

    /**
     * Returns the length
     *
     * @return the length
     */
    public int getLength();

    /**
     * Modifies the length
     *
     * @param length - the length to set
     */
    public void setLength(int length);

    /**
     * Returns the isNotRequiredXml
     *
     * @return the isNotRequiredXml
     */
    public boolean isNotRequiredXml();

    /**
     * Modifies the isNotRequiredXml
     *
     * @param isNotRequiredXml - the isNotRequiredXml to set
     */
    public void setNotRequiredXml(boolean isNotRequiredXml);

    /**
     * Returns the deprecatingVersion
     *
     * @return the deprecatingVersion
     */
    public String getDeprecatingVersion();

    /**
     * Modifies the deprecatingVersion
     *
     * @param deprecatingVersion - the deprecatingVersion to set
     */
    public void setDeprecatingVersion(String deprecatingVersion);

    /**
     * Returns the requiringComponents
     *
     * @return the requiringComponents
     */
    public List<ComponentInfo> getRequiringComponents();

    /**
     * Add a requiringComponent
     *
     * @param component - a requiringComponent
     */
    public void addRequiringComponent(ComponentInfo component);

    /**
     * Modifies the requiringComponents
     *
     * @param requiringComponents - the requiringComponent to set
     */
    protected void setRequiringComponents(List<ComponentInfo> requiringComponents);

    /**
     * Returns whether this field is required in the specified component
     *
     * @param component - a component
     * @return whether this field is required in the specified component
     */
    public boolean isRequiredInComponent(ComponentInfo component);

    /**
     * Returns the validValues
     *
     * @return the validValues
     */
    public List<ValueInfo> getValidValues();

    /**
     * Adds a value
     *
     * @param value - a value
     */
    public void addValidValue(ValueInfo value);

    /**
     * Returns whether a given value is valid
     *
     * @param value - a value
     * @return whether a given value is valid
     */
    public boolean isValidValue(String value);

    /**
     * Modifies the validValues
     *
     * @param validValues - the validValues to set
     */
    protected void setValidValues(TreeMap<String, ValueInfo> validValues);

    /**
     * Returns the validValues Map
     *
     * @return the validValues Map
     */
    protected TreeMap<String, ValueInfo> getValidValuesMap();
}
","// FieldInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isValidValue(String)} method.
*/
class FieldInfo_1Test {","// FieldInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isValidValue(String)} method.
*/
class FieldInfo_1Test {
/**
		* Test method.
		*/
	@SuppressWarnings(""static-method"")
	@Test
	public void isValidValue() {
		FieldInfo _1 = new FieldInfo.FieldInfo() {
			@Override
			public boolean isValidValue(String value) {
				String _1;
//				boolean _1=false;
				_1 = value;
				if(!(value.isEmpty())) {
					/*
					 * if(value.isEmpty())
					 * check();
					 */
					return true;
				}
				return false;
			}
		
		};
		System.out.println(_1.isValidValue(""one""));
		assertEquals(true, _1.isValidValue"
ae5104ad-4589-4eb8-a663-8254509b533c,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_0Test.java,40.850844860076904,stop,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields();

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber);

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name);

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field);

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents();

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id);

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name);

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component);

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group);

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id);

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name);

    public List<MessageInfo> getMessages();

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message);

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion();

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version);

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount();

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded();
}
","// DictionaryInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(int)} method.
*/
class DictionaryInfo_0Test {","// DictionaryInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(int)} method.
*/
class DictionaryInfo_0Test {

	String version;
	
	int loadCount;
	
	
	public DictionaryInfo_0Test() {
	}
	
	public DictionaryInfo_0Test(String version) {
		this.version = version;
	}
	
	@Test
	public void test() {

        TreeMap<String, MessageInfo> infoTable = new TreeMap<String, MessageInfo>();

        for (int i = 1; i <= 3; i++) {
            String name = ""f"" + i;
            infoTable.put(name, new MessageInfo(MessageInfo.FIX_ID, name.toLowerCase(), 0, 0));
        }
        // load info table
        DictionaryInfo.parseVersion(version, infoTable);

        for (int i = 1; i <= 3; i++) {
            String name = ""f"" + i;
            MessageInfo message = infoTable.get(name);
            assertEquals(i, message.getID());
            assertEquals(name.toLowerCase(), message.getName());
            assertEquals(0, message.getLoadIndex());
            assertEquals(0, message.getMsgType());
        }
	}
}
"
f209dbd0-b96a-47b5-a7f1-817218e380f4,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_1Test.java,40.60072946548462,stop,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields();

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber);

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name);

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field);

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents();

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id);

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name);

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component);

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group);

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id);

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name);

    public List<MessageInfo> getMessages();

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message);

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion();

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version);

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount();

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded();
}
","// DictionaryInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(String)} method.
*/
class DictionaryInfo_1Test {","// DictionaryInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(String)} method.
*/
class DictionaryInfo_1Test {
/**
		 * Test class of {@link DictionaryInfo_1Test}.
		 * It contains one unit test case for the single-tag case.
		 */
		class TestClass_1Tests {
				@Test
		    public void testSingleTag() {
		        TestClass_1 t = new TestClass_1();
		        t.testField1(t.getChildTag());
		        t.testField2(t.getChildTag());
		        assertEquals(1, t.getChildTag().length());
		        assertEquals(""A Field"", t.getChildTag());
		        assertArrayEquals(new String[] {}, t.getChildTags());
		    }
			}
	}

// DictionaryInfo_2Test.java
"
605de3bb-c0d4-4e2a-9a44-b8411f8621d6,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_2Test.java,40.410340785980225,stop,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields();

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber);

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name);

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field);

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents();

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id);

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name);

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component);

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group);

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id);

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name);

    public List<MessageInfo> getMessages();

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message);

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion();

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version);

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount();

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded();
}
","// DictionaryInfo_2Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(int)} method.
*/
class DictionaryInfo_2Test {","// DictionaryInfo_2Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(int)} method.
*/
class DictionaryInfo_2Test {
@Test
		void test1() {
			int messageCount = 10;
			String name = ""name"";
			int loadCount = 10000;
			DictionaryInfo info = new DictionaryInfo(name, messageCount, loadCount,
					messageCount, messageCount, loadCount);

			checkMapping(1, messageCount, ""name"", new MessageInfo(""test""),
					messageCount);
			checkMapping(100, messageCount, ""name"", new MessageInfo(""test""),
					messageCount);
			checkMapping(1000000, messageCount, ""name"", new MessageInfo(""test""),
					messageCount);
			checkMapping(2000000000, messageCount, ""name"", new MessageInfo(""test""),
					messageCount);
		}
		private static void checkMapping(int count, int messageCount, String expectedName,
			MessageInfo expectedMessage, int expectedLoadCount) {

			List<FieldInfo> fieldList = new ArrayList<>();
			fieldList.add(expectedMessage.getFields().iterator().next());

			MessageInfo messageInfo = new MessageInfo(expectedName, messageCount, expectedLoadCount,
					fieldList, messageCount,
					messageCount);

			TreeMap<Integer, ComponentInfo> components = new TreeMap<>();

			components.put(expectedMessage.getComponents().iterator().next(),
				expectedMessage.getComponents().iterator().next());

			ComponentInfo info = expectedMessage.getComponent(expectedMessage.getComponentTag(0).getNumber());
			int componentTag = 0;

			FieldInfo field = expectedMessage.getFields().iterator().next();

			// getField
			List<FieldInfo> fieldList2 = new ArrayList<FieldInfo>();

			fieldList2.add(field);

			// getField
			FieldInfo field2 = expectedMessage.getField(fieldList2.iterator().next().getNumber());

			// fieldsByTag
			int[] tagNumber = new int[fieldList.size()];

			fieldList.forEach(f -> field2.getTagNumber(f.getName()));

			field2.getFieldsByTag(tagNumber);

			assertArrayEquals(fieldsByTagNumber.entrySet().toArray(),
					new TreeMap<>(field2.getValuesByTag(tagNumber)).entrySet().toArray());

			int[] tagNumber2 = new int[fieldList2.size()];

			fieldList2.forEach(f -> tagNumber2[f.getNumber()] = 0);

			field2.getTagNumber(expectedName);

			// fieldsByTag
			field2.getFieldsByTag(tagNumber2);

			assertArrayEquals(fieldsByTagNumber
					.entries().toArray(),
					new TreeMap<>(field2.getValuesByTag(tagNumber2)).entries().toArray());
		}
}
"
f9c9b84f-d6f7-4962-8236-92766d0fb25b,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_3Test.java,40.396546840667725,length,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields();

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber);

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name);

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field);

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents();

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id);

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name);

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component);

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group);

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id);

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name);

    public List<MessageInfo> getMessages();

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message);

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion();

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version);

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount();

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded();
}
","// DictionaryInfo_3Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(String)} method.
*/
class DictionaryInfo_3Test {","// DictionaryInfo_3Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(String)} method.
*/
class DictionaryInfo_3Test {

    TestDictionaryInfo_3() {
    }

    @Test
    void testInitialConditions_4() {
        
        // Test basic conditions
        List<MessageInfo> messages = new ArrayList<>();
        messages.add(new MessageInfo(""test.test.A""));
        messages.add(new MessageInfo(""test.A.B.C""));
        messages.add(new MessageInfo(""test.test.ATAGN"", 'A', '0', '0', '1', '1', '1', '2', 0, 0, 2));
        MessageInfo messageInfo = DictionaryInfoDAOImpl.getInstance().getMessage(messages, '2');
        assertNotNull(messageInfo);
        assertFalse(messageInfo.isValid());

        // Test if we have a field with a given name
        // (there can be both a group and no group, as no group allows it)
        List<Integer> tags = new ArrayList<>();
        tags.add(1);
        // Tag is ""A""
        TagInfo tagInfo = new TagInfo(""A"");
        TagName tagName = new TagName(""A"");
        FieldInfo fieldInfo = new FieldInfo(""test.test.E"", ""TEST"", tags, tagInfo, new String[]{""A"", ""B"", ""C""}, 0, 0, 0);
        List<FieldInfo> fields = new ArrayList<>(1);
        fields.add(fieldInfo);
        List<ComponentInfo> components = new ArrayList<>(1);
        components.add(new ComponentInfo(""test""));
        List<ComponentInfo> componentsById = new ArrayList<>(1);
        componentsById.add(new ComponentInfo(""cid"", ""cid"", 0, 2, 5, 1, null, true, false));
        List<GroupInfo> groups = new ArrayList<>();
        groups.add(new GroupInfo(tagName));
        fieldInfo = new FieldInfo(""test.A.B.C"", ""B"", 1, 1, 0, 1, tags, 0, false, true, 1, false, 0, null, null, 1, 0, 0, 1, 0, false, 1, 0, 0, 1);
        fieldInfo = new FieldInfo(""test.ATAGN"", 'A', 0, 1, -1, 1, 2, 5, 1, 0, false, 0, 0, false, 2, 0, 0, -3, 1, -1, 1);
        componentsById.add(new ComponentInfo(""A"", Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), 1, new ListWrapper(1), fieldsById, 1, -1, -1, -1, 1));
        componentsById.add(new ComponentInfo(""ATAGN"", 'A', 0, -1, -2, 1, new ListWrapper(1), new ListWrapper(1), new ListWrapper(1), 1, new ListWrapper(0), fieldsById, 0, -1, -1, 0, 0, 1));
        componentsById.add(new ComponentInfo(""A"", Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), 2, new ListWrapper(1), fieldsById, 1, -1, -1, -1, 1));
        componentsById.add(new ComponentInfo(""ATAGN"", 'A', 0, -1, -2, 1, new ListWrapper(1), new ListWrapper(1), new ListWrapper(1), 1, new ListWrapper(0), fieldsById, 0, -1, -1, 0, 0, 1));
        componentsById.add(new ComponentInfo(""A"", Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(1), 2, new ListWrapper(1), fieldsById, 1, -1, -1, -1, 1));
        components"
592b0c62-d478-4724-88b9-e1da7b1f945a,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_4Test.java,40.37932729721069,length,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields();

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber);

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name);

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field);

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents();

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id);

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name);

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component);

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group);

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id);

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name);

    public List<MessageInfo> getMessages();

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message);

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion();

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version);

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount();

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded();
}
","// DictionaryInfo_4Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(int)} method.
*/
class DictionaryInfo_4Test {","// DictionaryInfo_4Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(int)} method.
*/
class DictionaryInfo_4Test {

    private static final String[] messages = {""FixSuite/message/FIX54/FIX54-00051-0_0.txt"",""FixSuite/message/FIX54/FIX54-020325-0_0.txt""};
    private static final String[] components = {""comp1"", ""comp2"", ""comp3"", ""comp4""};
	
    private final static int MAX_MESSAGES=4;
    private final static int MAX_COMPONENTS=2;
	
    private static List<MessageInfo> _loadMessages=new ArrayList<MessageInfo>(500);
    private static List<ComponentInfo> _loadComponents=new ArrayList<ComponentInfo>(500);

    public void loadMessages(String[] msgArray){
        // Set the number of messages
        _loadMessages.clear();
        _loadMessages.addAll(Arrays.asList(msgArray));
	
        // Set how many messages we have
        int i = 0;
        for (String message : _loadMessages) {
            
            // Create a message info
            MessageInfo msgInfo = new MessageInfo(message);

            i++;
            
      // Find the message info
            for(FieldInfo fieldInfo:msgInfo.getFields()) {
                if(fieldInfo.isGroup() && fieldInfo.getTagNumber()==FieldInfo.PICTURE_TAG){
                        continue;
                }

               // If we have a tag number
                 if(fieldInfo.getTagNumber()>FieldInfo.PICTURE_TAG){
                   // Find the message info
                           for(ComponentInfo componentInfo:msgInfo.getComponents()) {
                                if (componentInfo.getId()==fieldInfo.getTagNumber()){
                                    return;
                                }
                           }
                }
        }
        
        fail(""ERROR!! The number of messages: "" + i + "" not found!"");
    }

    public void loadComponents(String[] compArray){
       // Set the number of components
        _loadComponents.clear();
        _loadComponents.addAll(Arrays.asList(compArray));
	
        // Set how many components we have
        int i = 0;
        for (String comp:_loadComponents) {
            // Find the component info
            for(FieldInfo fieldInfo:comp.split("":"")) {
                if(fieldInfo.getTagNumber()==FieldInfo.COMPONENT_TAG){
                    continue;
                }

               // If we have a tag number
                 if(fieldInfo.getTagNumber()>FieldInfo.PICTURE_TAG) {
                   // Find the message info
                       for(MessageInfo messageInfo:_loadMessages) {
                           if (messageInfo.getComponent(compArray[i])!= null) {
                               return;
                           }
                       }
                }
        }
        
        fail(""ERROR!! The number of components: "" + i + "" not found!"");
    }	

    public void testLoadMessages(String[] data) {
        // Load messages with number of messages
        loadMessages(data);
        
        // Check we have the expected number of messages
        int max = MSG_SIZE-1;
        for(MessageInfo messageInfo : _loadMessages) {
        	if(MAX_MESSAGES > messageInfo.getMessage().length()) {
        		assertNotNull(messageInfo.getMessage());
        		continue;
        	}
        	for(FieldInfo fieldInfo:messageInfo.getFields()) {
        		if(MAX_COMPONENTS > fieldInfo.getComponents().length()) {
        			assertNotNull(messageInfo.getComponents());
        			continue;
        		}
        		assertEquals(fieldInfo.getTagNumber(), Integer.parseInt(fieldInfo.getTagNumber().getItem()));
            }
        }

        // Load components
        loadComponents(data);
        
        // Check we have the expected number of components
        int max_comp=MAX_COMPONENTS;
        for(ComponentInfo componentInfo : _loadComponents) {
        	for(FieldInfo fieldInfo:componentInfo.getFields()) {
        		if(MAX_MESSAGES > fieldInfo.getMessage"
1c679d3d-7c11-4b58-8090-beb4c41f620a,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_5Test.java,40.3806791305542,length,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields();

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber);

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name);

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field);

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents();

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id);

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name);

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component);

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group);

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id);

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name);

    public List<MessageInfo> getMessages();

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message);

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion();

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version);

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount();

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded();
}
","// DictionaryInfo_5Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(String)} method.
*/
class DictionaryInfo_5Test {","// DictionaryInfo_5Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(String)} method.
*/
class DictionaryInfo_5Test {
int loadCount;

		DictionaryInfo dictionaryInfo;

		public DictionaryInfo_5Test(DictionaryInfo dictionaryInfo, int loadCount) {
			this.dictionaryInfo = dictionaryInfo;
			this.loadCount = loadCount;
		}

		/**
		 * Test the {@link DictionaryInfo#getMessage(String)} method.
		 * Load and retrieve a message from a dictionary information.
		 * The dictionaryInfo should contain two values
		 * 1. A dictionary information with a Message number of the expected value
		 * 2. A list of messages with a Message number of the expected value
		 * @throws Exception is there is a problem with a method call
		 */
		@Test
		void getMessage() throws Exception {
			assertEquals(dictionaryInfo.getMessage(0), 1);
			assertEquals(dictionaryInfo.getMessagesByName()
					.values().stream().mapToInt(f -> ((int[])f)[0]).min().get(), 1);
			assertEquals(dictionaryInfo.getMessagesByName().values()
					.stream().mapToInt(f -> ((int[])f)[0]).min().get(), 2);
		}

		/**
		 * Test the {@link DictionaryInfo#getMessage(String, int)} method.
		 * Load and retrieve that message from a dictionary information.
		 * The dictionaryInfo should contain a single message
		 * 1. A message with a message id
		 * 2. A field with a Message number of the expected value
		 * 3. A field with a message id
		 * 4. A field with a Message number of the expected value
		 * @throws Exception is there is a problem with a method call
		 */
		@Test
		void getMessageAsField() throws Exception {
			assertEquals(dictionaryInfo.getMessage(0, 1), 1);
			assertEquals(dictionaryInfo.getMessagesByName().get(1).get(0), 1);
			assertEquals(dictionaryInfo.getMessagesByName().get(2).get(0), 1);
			assertEquals(dictionaryInfo.getMessagesByName().get(3).get(0), 1);
		}

		/**
		 * Test the {@link DictionaryInfo#getMessageAsField(String)} method for a field.
		 * Load and retrieve that message from a dictionary information.
		 * The dictionaryInfo should contain a field with a Message number of the expected value
		 * 1. A message with a message id
		 * 2. A field with a Message number of the expected value
		 * 3. A field with a message id
		 * 4. A field with a Message number of the expected value
		 * @throws Exception is there is a problem with a method call
		 */

		@Test
		void getMessageAsFieldAsField() throws Exception {
			assertEquals(dictionaryInfo.getMessageAsFieldAsField(1), 1);
			assertEquals(dictionaryInfo.getMessagesByName().get(1).get(0).get(""name""), 1);
			assertEquals(dictionaryInfo.getMessagesByName().get(2).get(0).get(""name""), 1);
			assertEquals(dictionaryInfo.getMessagesByName().get(3).get(0).get(""name""), 1);
		}


		/**
		 * Test the {@link DictionaryInfo#getMessages()} method and set and retrieve messages as
		 * a list of MessageInfo objects using a list of dictionaries information.
		 * The dictionaryInfo should contain two dictionaries with a message number of the expected value
		 * 1. A dictionary with a Message number of the expected value
		 * 2. A list of dictionary with a Message number of the expected value
		 * @throws Exception is there is a problem with a method call
		 */

		@Test
		void getMessagesByName() throws Exception {
			List<MessageInfo> list = new ArrayList<>();
			list.add(dictionaryInfo.getMessagesByName().get(1).get(0));
			list.add(dictionaryInfo.getMessagesByName().get(2).get(0));
			assertEquals(dictionaryInfo.getMessagesByName().size(), list.size());
			assertTrue(list.contains(dictionaryInfo"
