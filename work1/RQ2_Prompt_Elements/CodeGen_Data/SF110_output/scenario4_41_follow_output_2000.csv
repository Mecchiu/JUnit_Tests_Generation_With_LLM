ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
5e19c2e8-7496-42e4-a781-65ca43d4ecb1,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/config/EnumeratedProperties.java,59.395583629608154,stop,"// EnumeratedProperties.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * Extension of {@link java.util.Properties} which allows one to specify property values which are
 * Lists of Strings.
 *
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class EnumeratedProperties extends Properties {

    /**
     * Returns the List value of the property with the supplied key. Note that one can call
     * getEnumeratedProperty() for a given key successfully if and only if setEnumeratedProperty()
     * for that key was called some time beforehand. All members of the list returned will be
     * Strings.
     *
     * @param key
     *            lookup of the enumerated property to be retrieved.
     * @return list containing String values
     */
    public List<String> getEnumeratedProperty(String key);

    /**
     * Assigns the supplied array of String values to the supplied key.
     *
     * @param key
     *            property lookup
     * @param values
     *            values to be associated with the property lookup
     */
    public void setEnumeratedProperty(String key, List<String> values);

    /**
     * Delimiter between property name & list member index
     */
    protected static char delimiter = '.';
}
","// EnumeratedPropertiesTest.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EnumeratedProperties}.
* It contains one unit test case for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
*/
class EnumeratedPropertiesTest {","// EnumeratedPropertiesTest.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EnumeratedProperties}.
* It contains one unit test case for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
*/
class EnumeratedPropertiesTest {

	@Test
	public void test() {
		
		String[] keys = {""a"", ""b""};
		List<String> values = new ArrayList<>();
		EnumeratedProperties.setEnumeratedProperty(keys[0], values);
		for (int i = 1 ; i < keys.length;i++) {
			EnumeratedProperties.setEnumeratedProperty(keys[i], values);
		}
		List<String> actual = new ArrayList<>(EnumeratedProperties.getEnumeratedProperty(keys[0]));

		assertEquals(keys.length, actual.size());
		
		for (int i = 0; i < keys.length;i++) {
			assertEquals(""Key mismatch"", actual.get(i), expectedValues.get(keys[i]));
		}
		
	}
}
"
861c028b-d780-4a31-9a76-19a912add5f7,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextPaneDestination.java,50.644779920578,stop,"// JTextPaneDestination.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;

/**
 * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextPane}.
 *
 * @see OutputDestination
 * @see JTextPane
 * @author <a href=""mailto:carl.hall@gmail.com"">Carl Hall</a>
 */
public class JTextPaneDestination implements OutputDestination {

    private Logger log = Logger.getLogger(JTextPaneDestination.class.getName());

    protected JTextPane jTextPane;

    protected boolean autoPositionCaret;

    /**
     * Construct a new JTextPaneDestination.
     *
     * @param jTextPane
     *            text will be appended to this text area
     * @param autoPositionCaret
     *            if true, caret will be automatically moved to the bottom of the text area when
     *            text is appended
     */
    public JTextPaneDestination(JTextPane jTextPane, boolean autoPositionCaret) {
    }

    public JTextPane getJTextPane();

    public void setJTextArea(JTextPane jTextPane);

    /**
     * Add a filtered view to this destination. Filtered views show only a subset of the total
     * output based on filter conditions.
     *
     * @since 1.8.0
     */
    public void addFilteredView();

    /**
     * Remove a filtered view
     *
     * @since 1.8.0
     */
    public void removeFilteredView();

    /**
     * @return whether caret will be automatically moved to the bottom of the text area when text is
     *         appended
     */
    public boolean autoPositionCaret();

    /**
     * @param autoPositionCaret
     *            if true, caret will be automatically moved to the bottom of the text area when
     *            text is appended
     */
    public void setAutoPositionCaret(boolean autoPositionCaret);

    public void print(String s);

    public void clear();
}
","// JTextPaneDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextPaneDestination}.
* It contains one unit test case for the {@link JTextPaneDestination#autoPositionCaret()} method.
*/
class JTextPaneDestinationTest {","// JTextPaneDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextPaneDestination}.
* It contains one unit test case for the {@link JTextPaneDestination#autoPositionCaret()} method.
*/
class JTextPaneDestinationTest {
private JTextPane p;

		@BeforeAll
		public static void init() {
				initLogger();
		}
		
		@Test
		public void test() {
				assertNotNull(p);
				
				p.print(""Hello World"");
				
				assertEquals(new Integer((int) p.getText().indexOf(""Hello World"")), new Integer((int) p.getDocument().getNumOfUncachedChars()));
				
				p.clear();
				
				assertEquals(String.valueOf(p.getText()).length(), 0);
				
				assertFalse(p.getText().contains(""?""));
				
				p.print(null);
				
				p.clear();
				
				assertEquals(String.valueOf(p.getText()).length(), 0);
				
				assertTrue(p.getText().indexOf(""Hello World"")!= 0);
				
				
		}
	private void initLogger() {
		final Logger logger = Logger.getLogger(""hm.follow.io"");
		
		logger.setLevel(Level.INFO);
		
		autoPositionCaret = true;
		
		p = new JTextPane(""Test JTextPaneDestinationTest"");
		
	}
}// end of class JTextPaneDestinationTest
"
b59c7a96-bd40-419e-b162-630a9a503edb,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextComponentDestination.java,51.004451274871826,stop,"// JTextComponentDestination.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;

/**
 * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextComponent}.
 *
 * @see OutputDestination
 * @see JTextCompnent
 * @author <a href=""mailto:carl.hall@gmail.com"">Carl Hall</a>
 */
public class JTextComponentDestination extends FilterableOutputDestination {

    private static final Logger LOG = Logger.getLogger(JTextComponentDestination.class.getName());

    protected JTextComponent comp;

    protected boolean autoPositionCaret;

    /**
     * Construct a new JTextCompnentDestination.
     *
     * @param jTextPane
     *            text will be appended to this text area
     * @param autoPositionCaret
     *            if true, caret will be automatically moved to the bottom of the text area when
     *            text is appended
     */
    public JTextComponentDestination(JTextComponent comp, boolean autoPositionCaret) {
    }

    public JTextComponent getJTextComponent();

    public void setJTextComponent(JTextComponent comp);

    /**
     * Add a filtered view to this destination. Filtered views show only a subset of the total
     * output based on filter conditions.
     *
     * @since 1.8.0
     */
    public void addFilteredView();

    /**
     * Remove a filtered view
     *
     * @since 1.8.0
     */
    public void removeFilteredView();

    /**
     * @return whether caret will be automatically moved to the bottom of the text area when text is
     *         appended
     */
    public boolean autoPositionCaret();

    /**
     * @param autoPositionCaret
     *            if true, caret will be automatically moved to the bottom of the text area when
     *            text is appended
     */
    public void setAutoPositionCaret(boolean autoPositionCaret);

    public void handlePrint(String s);

    public void clear();
}
","// JTextComponentDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextComponentDestination}.
* It contains one unit test case for the {@link JTextComponentDestination#autoPositionCaret()} method.
*/
class JTextComponentDestinationTest {","// JTextComponentDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextComponentDestination}.
* It contains one unit test case for the {@link JTextComponentDestination#autoPositionCaret()} method.
*/
class JTextComponentDestinationTest {

    @Test
    public void createInputPaneDestination() {
        try {
            final JTextComponentDestination destination = new JTextComponentDestination(new JTextComponent(
                ""hello, world!""), false);
            assertNotNull(destination);
            destination.clear();
            destination.addFilteredView();
            destination.removeFilteredView();
            destination.clear();
            assertTrue(destination.isFiltered());
            destination.autoPositionCaret();
            assertFalse(destination.isFiltered());
        } catch (BadLocationException e) {
            this.error(""BadLocationException"", e);
        }
    }

    @Test
    public final void createOutputPaneDestination() {
           Object destination = null;
           try {
               JTextComponent destination = new JTextComponentDestination(new JTextComponent(""hello, world!""));
               assertNotNull(destination);
               destination.clear();
               destination.addFilteredView();
               destination.removeFilteredView();
               destination.clear();
               assertFalse(destination.isFiltered());

               destination.setCaretPosition(1);
               destination.insertString(0, ""hello, world!"", 1);
               assertTrue(destination.isSelectionStart());
               destination.setSelectionStart(3);
               destination.insertString(3, ""o"", 3);
               assertTrue(destination.isSelectionStart());
               destination.setSelectionEnd(2);
               destination.insertString(2, ""o"", 2);
               assertTrue(destination.isSelectionStart());
               destination.setSelectionEnd(2);
               destination.insertString(6, ""ow"", 6);
               destination.insertString(7, ""la"", 7);
               try {
                   destination.insertString(1, ""l"", 1);
               } catch(BadLocationException e) {
               }
            assertTrue(destination.isSelectionStart());
            assertTrue(destination.isSelectionEnd());
            assertEquals(""h"", destination.getSelectedText());
            assertEquals(3, destination.getCaretPosition());
            assertEquals(2, destination.getSelectionEnd());

               assertEquals(""hello, world!"", destination.getText(3, 3));

            destination.setCaretPositionUnsafe(3);
              destination.insertString(3, ""o"", 4);
              assertTrue(destination.isSelectionStart());
        } catch (BadLocationException e) {
            this.error(""BadLocationException"", e);
        }
    }

    @Test
    public final void testError() {
        LOG.log(Level.SEVERE, ""Test Error"", new Throwable(""Failed to create destination.""));
        assertFalse(true);
    }
    @Test
    public final void testUnsupportedOperationException() {
        LOG.log(Level.WARNING, ""Cannot convert to String"");
        assertFalse(true);
    }
    @Test
    public final void testClosedBug() {
        LOG.log(Level.INFO, ""JTextComponentDestinationTest.testClosedBug()"");
        try {
            assertTrue(""JTextComponent should be closed."", jTextPane.isDisposed());
        }
        catch (java.awt.InvalidAttemptException e) {
            this.error(e);
        }
    }
}
"
e415912d-3325-45cd-9f84-7a98f599579a,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_0Test.java,37.14075756072998,length,"// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    private Logger log = Logger.getLogger(SearchableTextPane.class.getName());

    private int lastSearchPos = -1;

    private String lastSearchTerm;

    private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);

    public SearchableTextPane(Font font, int tabSize) {
    }

    /**
     * Override this to keep the text from wrapping and to make the viewable area as wide as the
     * tabbed pane
     */
    public boolean getScrollableTracksViewportWidth();

    /**
     * Highlight <code>term</code> wherever it is found in the view. Also highlights the entire
     * line on which the term is found.
     *
     * @param term
     * @param caseSensitive
     * @param useRegularExpression
     * @return
     */
    public List<LineResult> highlight(String term, int flags);

    /**
     * Highlight a piece of text in the document
     *
     * @param start
     * @param wordEnd
     * @param highlighter
     */
    private void addHighlight(int start, int length) throws BadLocationException;

    /**
     * Removes highlights from text area
     */
    public void removeHighlights();

    /**
     * Searches for a term. If the term provided matches the last searched term, the last found
     * position is used as a starting point.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term);

    /**
     * Searches for a term at the given starting position.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @param startPos
     *            Where to start.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term, int startPos);

    /**
     * Converts word results from search into line results
     *
     * @param words
     * @return
     */
    private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException;

    /**
     * Adds word result to line result and updates line information
     *
     * @param wordResult
     * @param lineResult
     */
    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException;
}
","// SearchableTextPane_0Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String)} method.
*/
class SearchableTextPane_0Test {","// SearchableTextPane_0Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String)} method.
*/
class SearchableTextPane_0Test {

    @Test
    void testSearch_String() {
        defaultHighlighter.setFont(new Font(""Tahoma"", Font.PLAIN, 12));
        final DefaultHighlighter defaultHighlighter = DefaultHighlighter.defaultHighlighter;
        List<DefaultHighlight> highlights = new ArrayList<>();
        highlights.add(new LineHighlight(Color.MAGENTA, Color.GRAY, 100));
        defaultHighlighter.setTokenMarker(highlights);

        final List<WordResult> words = new ArrayList<>();
        words.add(new WordResult(""Hello"", -1, Color.GREEN, new DefaultHighlightPainter(Color.BLACK)));
        words.add(new WordResult(""World"", 3, Color.GREEN, new DefaultHighlightPainter(Color.GRAY.darker())));
        words.add(new WordResult(""Welt"", -2, Color.RED, wordPainter));

        Document doc = new DefaultMutableDocument();
        Element rootElement = doc.getDefaultRootElement();
        Element searchableTextElement = Utilities.findFirstElement(rootElement, ""searchable"");

        // test case with null string & empty text
        SearchableTextPane searchableTextPane = new SearchableTextPane(new Font(""Tahomoto"", Font.PLAIN, 12), 10);
        searchableTextPane.setText(""Nothing"");
        searchableTextPane.document.insertString(0, searchableTextPane.text, searchableTextPane.getDocument().getLength(), null);
        assertTrue(searchableTextPane.document.getLength()!= 0);
        assertTrue(searchableTextPane.getSelectedText().equals(""Nothing""));
        searchableTextPane.clear();

        // test case with empty string & selected text
        searchableTextPane.setText(StringUtils.EMPTY);
        assertTrue(searchableTextPane.document.getLength() == 0);
        assertTrue(searchableTextPane.getSelectedText().equals(StringUtils.EMPTY));

        // test case with words only
        DefaultHighlighter.DefaultHighlightPainter defaultHighlighter3 = new DefaultHighlighter.DefaultHighlightPainter(Color.GREEN.darker());
        searchableTextPane.setHighlighters(defaultHighlighter3);
        searchableTextPane.text = ""There, I'm on the fly!"";
        assertTrue(searchableTextPane.document.getLength() == 14);
        assertTrue(searchableTextPane.getSelectedText().equals(""There, I'm on the fly!""));

        // test case 1 to add the whole word
        DefaultHighlighter.DefaultHighlightPainter defaultHighlighter4 = new DefaultHighlighter.DefaultHighlightPainter(Color.MAGENTA);
        defaultHighlighter3.setTokenMarker(defaultHighlighter4);
        DefaultHighlighter.DefaultHighlightPainter defaultHighlighter5 = new DefaultHighlighter.DefaultHighlightPainter(Color.GREEN.darker());
        searchableTextPane.setHighlighters(defaultHighlighter3, defaultHighlighter4, defaultHighlighter5);
        searchableTextPane.text = ""No."";
        assertTrue(searchableTextPane.document.getLength() == 14);
        assertTrue(searchableTextPane.getSelectedText().equals(""No.""));

        // test case 2
        searchableTextPane.text = ""I'm on the fly."";
        searchableTextPane.setHighlighters(null, defaultHighlighter2);
        searchableTextPane.setHighlighters(null, defaultHighlighter5);
        searchableTextPane.setHighlighters(null, defaultHighlighter5);"
9e1bf0c5-bce4-49a4-8cd9-006536604dcf,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_1Test.java,37.59880471229553,length,"// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    private Logger log = Logger.getLogger(SearchableTextPane.class.getName());

    private int lastSearchPos = -1;

    private String lastSearchTerm;

    private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);

    public SearchableTextPane(Font font, int tabSize) {
    }

    /**
     * Override this to keep the text from wrapping and to make the viewable area as wide as the
     * tabbed pane
     */
    public boolean getScrollableTracksViewportWidth();

    /**
     * Highlight <code>term</code> wherever it is found in the view. Also highlights the entire
     * line on which the term is found.
     *
     * @param term
     * @param caseSensitive
     * @param useRegularExpression
     * @return
     */
    public List<LineResult> highlight(String term, int flags);

    /**
     * Highlight a piece of text in the document
     *
     * @param start
     * @param wordEnd
     * @param highlighter
     */
    private void addHighlight(int start, int length) throws BadLocationException;

    /**
     * Removes highlights from text area
     */
    public void removeHighlights();

    /**
     * Searches for a term. If the term provided matches the last searched term, the last found
     * position is used as a starting point.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term);

    /**
     * Searches for a term at the given starting position.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @param startPos
     *            Where to start.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term, int startPos);

    /**
     * Converts word results from search into line results
     *
     * @param words
     * @return
     */
    private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException;

    /**
     * Adds word result to line result and updates line information
     *
     * @param wordResult
     * @param lineResult
     */
    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException;
}
","// SearchableTextPane_1Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String, int)} method.
*/
class SearchableTextPane_1Test {","// SearchableTextPane_1Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String, int)} method.
*/
class SearchableTextPane_1Test {

    //@Test
    void test1Highlight() {

        String text = ""The quick brown fox jumps over the lazy dog."";
        DefaultHighlightPainter wordpainter;
        DefaultHighlighter.DefaultHighlightPainter wordpainter2;

        try {
            // Get the UI for the line
            WordResult w = new WordResult(text);
            DefaultHighlighter defaultHighlighter = w.getDefaultHighlighter();
            wordpainter = defaultHighlighter.getWordPaint();
            wordpainter2 = defaultHighlighter.getWordHighlightPainter();

            Element element = w.getElement();

            // Get the text inside the text area.
            String text2 = element.getText();

            // Check the text inside the line.
            log.finest(""The word found ("" + text2 + "") in the text area. The new line should contain the word"");
            assertEquals(""The word found ("" + text2 + "") in the text area. "", ""The quick brown fox jumps over the lazy dog."", text2);

            // Now check the highlight of the text inside the text.
            List<LineResult> lineText = new ArrayList<>();

            text2 = Utilities.fillWord(text2, new char[]{ (char) 0x0009, (char) 0x000c, (char) 0x001b }, new int[]{ 0, 0, 0 });
            int endPos = 10;

            // The endPos is the start position of the word in the text area.
            while (endPos < text2.length()) {
                endPos = Utilities.searchNext(text2, endPos, wordpainter, wordpainter2);
            }

            // the endPos is at the end of the text from text2
            while (endPos < text2.length()) {
                endPos = Utilities.searchNext(text2, endPos, wordpainter, wordpainter2);
            }

            // the endPos is at the end of the text in the text area.
            while (endPos < text2.length()) {
                endPos = Utilities.searchNext(text2, endPos, wordpainter2, wordpainter);
            }

            List<LineResult> textResults = new ArrayList<>();

            textResults.add(new LineResult(""The word found ("" + text2 + "") at index 0"", null, null, element));
			textResults.add(new LineResult(""The word found ("" + text2 + "") at index 1"", null, null, element));
			textResults.add(new LineResult(""The word found ("" + text2 + "") at index 2"", null, null, element));
    
    		text2 = Utilities.fillWord(text2, new char[]{ (char) 0x000b, (char) 0x000c, (char) 0x001b }, new int[]{ 0, 0, 0 });
			endPos = 10;
	
    		textResults.add(new LineResult(""The word found ("" + text2 + "") at index 1"", null, null, element));
			textResults.add(new LineResult(""The word found ("" + text2 + "") at index 2"", null, null, element));
			text2 = utilities.fillTextIfNeeded(text2, new char[]{ (char) 0x000b, (char) 0x000c, (char) 0x001b }, new Rectangle(0, 5, 2, 10, 2));
	
    		// the endPos is at the end of the text from text2
            while (endPos < text2.length()) {
                endPos = Utilities.searchNext(text2, endPos, wordpainter, wordpainter2);
            }
    		endPos = utilities.searchNext(text2, text2.length(), wordpainter, wordpainter2);
	
    "
9dcfb6f4-ec72-43b1-bab4-136cfe520a2c,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/gui/FileFollowingPane.java,30.891318798065186,stop,"// FileFollowingPane.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;

/**
 * A component which allows one to view a text file to which information is being asynchronously
 * appended.
 *
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollowingPane extends JScrollPane {

    private Logger log = Logger.getLogger(FileFollowingPane.class.getName());

    /**
     * FileFollower used to print to this component
     */
    protected FileFollower fileFollower;

    /**
     * Text area into which followed file's contents are printed
     */
    protected SearchableTextPane textArea;

    /**
     * OutputDestination used w/FileFollower
     */
    protected JTextComponentDestination destination;

    /**
     * @param file
     *            text file to be followed
     * @param bufferSize
     *            size of the character buffer inside the FileFollower used to follow the supplied
     *            file
     * @param latency
     *            latency of the FileFollower used to follow the supplied file
     */
    public FileFollowingPane(File file, int bufferSize, int latency, boolean autoPositionCaret, Font font, int tabSize) {
    }

    /**
     * Returns the text area to which the followed file's contents are being printed.
     *
     * @return text area containing followed file's contents
     */
    public SearchableTextPane getTextPane();

    /**
     * Returns whether caret is automatically repositioned to the end of the text area when text is
     * appended to the followed file
     *
     * @return whether caret is automatically repositioned on append
     */
    public boolean autoPositionCaret();

    /**
     * Sets whether caret is automatically repositioned to the end of the text area when text is
     * appended to the followed file
     *
     * @param value
     *            whether caret is automatically repositioned on append
     */
    public void setAutoPositionCaret(boolean value);

    /**
     * Returns the FileFollower which is being used to print information in this component.
     *
     * @return FileFollower used by this component
     */
    public FileFollower getFileFollower();

    /**
     * Convenience method; equivalent to calling getFileFollower().getFollowedFile()
     */
    public File getFollowedFile();

    /**
     * Convenience method; equivalent to calling getFileFollower().start()
     */
    public void startFollowing();

    /**
     * Convenience method; equivalent to calling getFileFollower().stop()
     */
    public void stopFollowing();

    /**
     * Convenience method; equivalent to calling getFileFollower().restart()
     */
    public void restartFollowing();

    /**
     * Convenience method; equivalent to calling getFileFollower().pause()
     */
    public void pauseFollowing();

    /**
     * Convenience method; equivalent to calling getFileFollower().unpause()
     */
    public void unpauseFollowing();

    /**
     * Convenience method; equivalent to calling getFileFollower().isPaused()
     *
     * @return
     */
    public boolean isFollowingPaused();

    /**
     * Convenience method; equivalent to calling getFileFollower().stopAndWait()
     */
    public void stopFollowingAndWait() throws InterruptedException;

    /**
     * Convenience method; equivalent to called getFileFollower().isBeingFollowed()
     *
     * @return
     */
    public boolean isFollowing();

    /**
     * Clears the contents of this FileFollowingPane synchronously.
     */
    public void clear() throws IOException;
}
","// FileFollowingPaneTest.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollowingPane}.
* It contains one unit test case for the {@link FileFollowingPane#autoPositionCaret()} method.
*/
class FileFollowingPaneTest {","// FileFollowingPaneTest.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollowingPane}.
* It contains one unit test case for the {@link FileFollowingPane#autoPositionCaret()} method.
*/
class FileFollowingPaneTest {

    /**
      * Initializes the test.
      */
    public FileFollowingPaneTest() {

    }

    @Test
    public void testSimpleRead() throws BadLocationException, Throwable {
	String contents = ""This is a simple test of FileFOingPane."";
	fileFollower.append(contents.getBytes(""UTF-8""), destination, fileFollower);
	assertTrue(""Got incorrect number of contents"", contents.length() > 0);
	assertTrue(""Contents did not contain '"" + contents + ""'"", contents.contains((new StringBuilder()).append(contents).append(""\n"").toString()));
    }

    @Test
    public void testReadingBack() throws Throwable {
	Document doc = new Document(0, 0, 0);
	try {
	    doc.insertString(0, ""This is a simple test of FileFOingPane."", new char[] {' '});
	    fileFollower.appendText(new StringBuilder(), doc, destination, fileFollower);
	    assertTrue(""Got incorrect number of contents"", contents.length() > 0);
	    assertTrue(""Contents did not contain '"" + contents + ""'"", contents.contains((new StringBuilder()).append(contents).append(""\n"").toString()));
    } catch (Throwable t) {
	fail(t.getMessage());
    }
    }
}


/*************************************************************************
*                                                                        *
*                   ConsoleWriter for TestScript                       *
*                                                                        *
*************************************************************************/

class ConsoleOutputStream extends OutputDestination {
    public ConsoleOutputStream(File destFile, BufferedOutputStream dest) {
	super(destFile, dest);
    }

    public void write(Object o) {
	try {
	    textArea.addLine(o);
	} catch (BadLocationException bl) {
	}
    }
}
"
42b17889-fdb4-4268-9c92-1ff1a4c7ebec,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FileFollower.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Instances of this class 'follow' a particular text file, assmebling that
 * file's characters into Strings and sending them to instances of
 * {@link OutputDestination}. The name and behavior of this class are inspired
 * by the '-f' (follow) flag of the UNIX command 'tail'.
 *
 * @see OutputDestination
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollower {

    /**
     * Constructs a new FileFollower; invoking this constructor does
     * <em>not</em> cause the new object to begin following the supplied file.
     * In order to begin following, one must call {@link #start()}.
     *
     * @param file
     *            file to be followed
     * @param bufferSize
     *            number of chars to be read each time the file is accessed
     * @param latency
     *            each time a FileFollower's running thread encounters the end
     *            of the file in its stream, it will rest for this many
     *            milliseconds before checking to see if there are any more
     *            bytes in the file
     * @param initialOutputDestinations
     *            an initial array of OutputDestinations which will be used when
     *            printing the contents of the file (this array may be
     *            <tt>null</tt>)
     */
    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {
    }

    /**
     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},
     * except that a default buffer size (32,768 characters) and latency (1000
     * milliseconds) are used.
     *
     * @see #FileFollower(File, int, int, OutputDestination[])
     */
    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {
    }

    /**
     * Cause this FileFollower to spawn a thread which will follow the file
     * supplied in the constructor and send its contents to all of the
     * FileFollower's OutputDestinations.<br>
     * <br>
     * If this FileFollower is running but paused, this method equates to
     * calling unpause().
     */
    public synchronized void start();

    public synchronized void pause();

    public synchronized void unpause();

    public synchronized void restart();

    /**
     * Cause this FileFollower to stop following the file supplied in the
     * constructor after it flushes the characters it's currently reading to all
     * its OutputDestinations.
     */
    public synchronized void stop();

    /**
     * Like {@link #stop()}, but this method will not exit until the thread
     * which is following the file has finished executing (i.e., stop
     * synchronously).
     */
    public synchronized void stopAndWait() throws InterruptedException;

    /**
     * Send the supplied string to all OutputDestinations
     *
     * @param s
     */
    private synchronized void print(String s);

    /**
     * Clear all OutputDestinations
     */
    private synchronized void clear();

    /**
     * Add another OutputDestination to which the followed file's contents
     * should be printed.
     *
     * @param outputDestination
     *            OutputDestination to be added
     */
    public boolean addOutputDestination(OutputDestination outputDestination);

    /**
     * Remove the supplied OutputDestination from the list of OutputDestinations
     * to which the followed file's contents should be printed.
     *
     * @param outputDestination
     *            OutputDestination to be removed
     */
    public boolean removeOutputDestination(OutputDestination outputDestination);

    /**
     * Returns the List which maintains all OutputDestinations for this
     * FileFollower.
     *
     * @return contains all OutputDestinations for this FileFollower
     */
    public List<OutputDestination> getOutputDestinations();

    /**
     * Returns the file which is being followed by this FileFollower
     *
     * @return file being followed
     */
    public File getFollowedFile();

    /**
     * Returns the following state of a file
     *
     * @return true if being followed, false if not being followed
     */
    public boolean isBeingFollowed();

    /**
     * Returns the pause state of the follower.
     *
     * @return true if paused, false otherwise
     */
    public boolean isPaused();

    /**
     * Returns the size of the character buffer used to read characters from the
     * followed file. Each time the file is accessed, this buffer is filled.
     *
     * @return size of the character buffer
     */
    public int getBufferSize();

    /**
     * Sets the size of the character buffer used to read characters from the
     * followed file. Increasing buffer size will improve efficiency but
     * increase the amount of memory used by the FileFollower.<br>
     * <em>NOTE:</em> Setting this value will <em>not</em> cause a running
     * FileFollower to immediately begin reading characters into a buffer of the
     * newly specified size. You must stop & restart the FileFollower in order
     * for changes to take effect.
     *
     * @param bufferSize
     *            size of the character buffer
     */
    public void setBufferSize(int bufferSize);

    /**
     * Returns the time (in milliseconds) which a FileFollower spends sleeping
     * each time it encounters the end of the followed file.
     *
     * @return latency, in milliseconds
     */
    public int getLatency();

    /**
     * Sets the time (in milliseconds) which a FileFollower spends sleeping each
     * time it encounters the end of the followed file. Note that extremely low
     * latency values may cause thrashing between the FileFollower's running
     * thread and other threads in an application. A change in this value will
     * be reflected the next time the FileFollower's running thread sleeps.
     *
     * @param latency
     *            latency, in milliseconds
     */
    public void setLatency(int latency);

    protected int bufferSize;

    protected int latency;

    protected File file;

    protected List<OutputDestination> outputDestinations;

    protected boolean continueRunning;

    protected boolean needsRestart;

    protected Thread runnerThread;

    protected boolean paused;

    /**
     * Instances of this class are used to run a thread which follows a
     * FileFollower's file and sends prints its contents to OutputDestinations.
     * This class should only handle the gathering of data from the followed
     * file. Actually writing to the output destinations is handled by the outer
     * class (FileFollower).
     */
    class Runner implements Runnable {

        private Logger log = Logger.getLogger(Runner.class.getName());

        public void run() {
            log.finer(""entering FileFollower.run()"");
            while (continueRunning) {
                runAction();
            }
            log.finer(""exiting FileFollower.run()"");
        }

        protected void runAction() {
            try {
                clear();
                long fileSize = file.length();
                byte[] byteArray = new byte[bufferSize];
                int numBytesRead;
                long lastActivityTime = file.lastModified();
                // create some stream readers to handle the file
                FileInputStream fis = new FileInputStream(file);
                BufferedInputStream bis = new BufferedInputStream(fis);
                // start at the beginning of the file
                long startingPoint = 0;
                // if the file size is bigger than the buffer size, skip to the
                // end of the file if not performing a restart
                if (fileSize > bufferSize) {
                    startingPoint = fileSize - bufferSize;
                }
                // reset the restart flag
                needsRestart = false;
                log.finer(""Starting point: "" + startingPoint + ""; Last activity: "" + lastActivityTime);
                bis.skip(startingPoint);
                while (continueRunning && !needsRestart) {
                    if (!paused) {
                        lastActivityTime = System.currentTimeMillis();
                        numBytesRead = bis.read(byteArray, 0, byteArray.length);
                        boolean dataWasFound = (numBytesRead > 0);
                        log.finer(""Bytes read: "" + numBytesRead + ""; dataWasFound: "" + dataWasFound);
                        // if data was found, print it and log activity time
                        if (dataWasFound) {
                            String output = new String(byteArray, 0, numBytesRead);
                            // print the output to the listeners
                            print(output);
                        } else // no data found so check the file and restart if needed
                        {
                            // check if the file handle has become stale (file
                            // was modified, but no data was read).
                            boolean fileExists = file.exists();
                            // removed check for 0 length because a file could
                            // change by being cleared out
                            // && (file_.length() > 0);
                            boolean fileHasChanged = file.lastModified() > lastActivityTime;
                            if (fileExists && fileHasChanged) {
                                log.finer(""Needs restart [fileExists="" + fileExists + ""; fileHasChanged="" + fileHasChanged + ""]"");
                                needsRestart = true;
                            }
                        }
                        boolean allDataRead = (numBytesRead < byteArray.length);
                        if (allDataRead && !needsRestart) {
                            log.finer(""Sleeping for "" + latency + ""ms [allDataRead:"" + allDataRead + ""; needsRestart:"" + needsRestart + ""]"");
                            sleep();
                        }
                    } else {
                        log.finer(""Runner paused."");
                        sleep();
                    }
                }
                log.finer(""exiting Runner.runAction [continueRunning="" + continueRunning + ""; needsRestart="" + needsRestart + ""]"");
                bis.close();
                fis.close();
            } catch (IOException e) {
                log.log(Level.SEVERE, ""IOException while following file"", e);
            }
        }

        private void sleep() {
            try {
                Thread.sleep(latency);
            } catch (InterruptedException e) {
                // Interrupt may be thrown manually by stop()
                log.finer(""DIED IN MY SLEEP"");
            }
        }
    }

    /**
     * Line separator, retrieved from System properties & stored statically.
     */
    protected static final String lineSeparator = System.getProperty(""line.separator"");
}
","// FileFollower_0Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#addOutputDestination(OutputDestination)} method.
*/
class FileFollower_0Test {","// FileFollower_0Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#addOutputDestination(OutputDestination)} method.
*/
class FileFollower_0Test {
"
d73e7d87-cbd8-4092-98b3-39e9366c4e39,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FileFollower.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Instances of this class 'follow' a particular text file, assmebling that
 * file's characters into Strings and sending them to instances of
 * {@link OutputDestination}. The name and behavior of this class are inspired
 * by the '-f' (follow) flag of the UNIX command 'tail'.
 *
 * @see OutputDestination
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollower {

    /**
     * Constructs a new FileFollower; invoking this constructor does
     * <em>not</em> cause the new object to begin following the supplied file.
     * In order to begin following, one must call {@link #start()}.
     *
     * @param file
     *            file to be followed
     * @param bufferSize
     *            number of chars to be read each time the file is accessed
     * @param latency
     *            each time a FileFollower's running thread encounters the end
     *            of the file in its stream, it will rest for this many
     *            milliseconds before checking to see if there are any more
     *            bytes in the file
     * @param initialOutputDestinations
     *            an initial array of OutputDestinations which will be used when
     *            printing the contents of the file (this array may be
     *            <tt>null</tt>)
     */
    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {
    }

    /**
     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},
     * except that a default buffer size (32,768 characters) and latency (1000
     * milliseconds) are used.
     *
     * @see #FileFollower(File, int, int, OutputDestination[])
     */
    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {
    }

    /**
     * Cause this FileFollower to spawn a thread which will follow the file
     * supplied in the constructor and send its contents to all of the
     * FileFollower's OutputDestinations.<br>
     * <br>
     * If this FileFollower is running but paused, this method equates to
     * calling unpause().
     */
    public synchronized void start();

    public synchronized void pause();

    public synchronized void unpause();

    public synchronized void restart();

    /**
     * Cause this FileFollower to stop following the file supplied in the
     * constructor after it flushes the characters it's currently reading to all
     * its OutputDestinations.
     */
    public synchronized void stop();

    /**
     * Like {@link #stop()}, but this method will not exit until the thread
     * which is following the file has finished executing (i.e., stop
     * synchronously).
     */
    public synchronized void stopAndWait() throws InterruptedException;

    /**
     * Send the supplied string to all OutputDestinations
     *
     * @param s
     */
    private synchronized void print(String s);

    /**
     * Clear all OutputDestinations
     */
    private synchronized void clear();

    /**
     * Add another OutputDestination to which the followed file's contents
     * should be printed.
     *
     * @param outputDestination
     *            OutputDestination to be added
     */
    public boolean addOutputDestination(OutputDestination outputDestination);

    /**
     * Remove the supplied OutputDestination from the list of OutputDestinations
     * to which the followed file's contents should be printed.
     *
     * @param outputDestination
     *            OutputDestination to be removed
     */
    public boolean removeOutputDestination(OutputDestination outputDestination);

    /**
     * Returns the List which maintains all OutputDestinations for this
     * FileFollower.
     *
     * @return contains all OutputDestinations for this FileFollower
     */
    public List<OutputDestination> getOutputDestinations();

    /**
     * Returns the file which is being followed by this FileFollower
     *
     * @return file being followed
     */
    public File getFollowedFile();

    /**
     * Returns the following state of a file
     *
     * @return true if being followed, false if not being followed
     */
    public boolean isBeingFollowed();

    /**
     * Returns the pause state of the follower.
     *
     * @return true if paused, false otherwise
     */
    public boolean isPaused();

    /**
     * Returns the size of the character buffer used to read characters from the
     * followed file. Each time the file is accessed, this buffer is filled.
     *
     * @return size of the character buffer
     */
    public int getBufferSize();

    /**
     * Sets the size of the character buffer used to read characters from the
     * followed file. Increasing buffer size will improve efficiency but
     * increase the amount of memory used by the FileFollower.<br>
     * <em>NOTE:</em> Setting this value will <em>not</em> cause a running
     * FileFollower to immediately begin reading characters into a buffer of the
     * newly specified size. You must stop & restart the FileFollower in order
     * for changes to take effect.
     *
     * @param bufferSize
     *            size of the character buffer
     */
    public void setBufferSize(int bufferSize);

    /**
     * Returns the time (in milliseconds) which a FileFollower spends sleeping
     * each time it encounters the end of the followed file.
     *
     * @return latency, in milliseconds
     */
    public int getLatency();

    /**
     * Sets the time (in milliseconds) which a FileFollower spends sleeping each
     * time it encounters the end of the followed file. Note that extremely low
     * latency values may cause thrashing between the FileFollower's running
     * thread and other threads in an application. A change in this value will
     * be reflected the next time the FileFollower's running thread sleeps.
     *
     * @param latency
     *            latency, in milliseconds
     */
    public void setLatency(int latency);

    protected int bufferSize;

    protected int latency;

    protected File file;

    protected List<OutputDestination> outputDestinations;

    protected boolean continueRunning;

    protected boolean needsRestart;

    protected Thread runnerThread;

    protected boolean paused;

    /**
     * Instances of this class are used to run a thread which follows a
     * FileFollower's file and sends prints its contents to OutputDestinations.
     * This class should only handle the gathering of data from the followed
     * file. Actually writing to the output destinations is handled by the outer
     * class (FileFollower).
     */
    class Runner implements Runnable {

        private Logger log = Logger.getLogger(Runner.class.getName());

        public void run() {
            log.finer(""entering FileFollower.run()"");
            while (continueRunning) {
                runAction();
            }
            log.finer(""exiting FileFollower.run()"");
        }

        protected void runAction() {
            try {
                clear();
                long fileSize = file.length();
                byte[] byteArray = new byte[bufferSize];
                int numBytesRead;
                long lastActivityTime = file.lastModified();
                // create some stream readers to handle the file
                FileInputStream fis = new FileInputStream(file);
                BufferedInputStream bis = new BufferedInputStream(fis);
                // start at the beginning of the file
                long startingPoint = 0;
                // if the file size is bigger than the buffer size, skip to the
                // end of the file if not performing a restart
                if (fileSize > bufferSize) {
                    startingPoint = fileSize - bufferSize;
                }
                // reset the restart flag
                needsRestart = false;
                log.finer(""Starting point: "" + startingPoint + ""; Last activity: "" + lastActivityTime);
                bis.skip(startingPoint);
                while (continueRunning && !needsRestart) {
                    if (!paused) {
                        lastActivityTime = System.currentTimeMillis();
                        numBytesRead = bis.read(byteArray, 0, byteArray.length);
                        boolean dataWasFound = (numBytesRead > 0);
                        log.finer(""Bytes read: "" + numBytesRead + ""; dataWasFound: "" + dataWasFound);
                        // if data was found, print it and log activity time
                        if (dataWasFound) {
                            String output = new String(byteArray, 0, numBytesRead);
                            // print the output to the listeners
                            print(output);
                        } else // no data found so check the file and restart if needed
                        {
                            // check if the file handle has become stale (file
                            // was modified, but no data was read).
                            boolean fileExists = file.exists();
                            // removed check for 0 length because a file could
                            // change by being cleared out
                            // && (file_.length() > 0);
                            boolean fileHasChanged = file.lastModified() > lastActivityTime;
                            if (fileExists && fileHasChanged) {
                                log.finer(""Needs restart [fileExists="" + fileExists + ""; fileHasChanged="" + fileHasChanged + ""]"");
                                needsRestart = true;
                            }
                        }
                        boolean allDataRead = (numBytesRead < byteArray.length);
                        if (allDataRead && !needsRestart) {
                            log.finer(""Sleeping for "" + latency + ""ms [allDataRead:"" + allDataRead + ""; needsRestart:"" + needsRestart + ""]"");
                            sleep();
                        }
                    } else {
                        log.finer(""Runner paused."");
                        sleep();
                    }
                }
                log.finer(""exiting Runner.runAction [continueRunning="" + continueRunning + ""; needsRestart="" + needsRestart + ""]"");
                bis.close();
                fis.close();
            } catch (IOException e) {
                log.log(Level.SEVERE, ""IOException while following file"", e);
            }
        }

        private void sleep() {
            try {
                Thread.sleep(latency);
            } catch (InterruptedException e) {
                // Interrupt may be thrown manually by stop()
                log.finer(""DIED IN MY SLEEP"");
            }
        }
    }

    /**
     * Line separator, retrieved from System properties & stored statically.
     */
    protected static final String lineSeparator = System.getProperty(""line.separator"");
}
","// FileFollower_1Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.
*/
class FileFollower_1Test {","// FileFollower_1Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.
*/
class FileFollower_1Test {
"
76d007bf-1c7f-47ab-b39a-65fb1b571bbd,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FollowApp.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FollowApp.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This class' main() method is the entry point into the Follow application.
 *
 * @see #main(String[])
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FollowApp {

    public static final String FILE_SEPARATOR = System.getProperty(""file.separator"");

    public static final String MESSAGE_LINE_SEPARATOR = ""\n"";

    public static final boolean DEBUG = Boolean.getBoolean(""follow.debug"");

    public static boolean HAS_SOLARIS_BUG = false;

    private static Logger LOG = Logger.getLogger(FollowApp.class.getName());

    private int currentCursor = Cursor.DEFAULT_CURSOR;

    private Cursor defaultCursor;

    private Cursor waitCursor;

    private Map<File, FileFollowingPane> fileToFollowingPaneMap = new HashMap<File, FileFollowingPane>();

    private JTabbedPane tabbedPane;

    private ToolBar toolBar;

    private PopupMenu popupMenu;

    private Menu recentFilesMenu;

    private MouseListener rightClickListener;

    private HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();

    private SystemInterface systemInterface;

    private StartupStatus startupStatus;

    private FollowAppAttributes attributes;

    private static FollowApp instance;

    private static ResourceBundle resources = ResourceBundle.getBundle(""ghm.follow.FollowAppResourceBundle"");

    private JFrame frame;

    // We should remove this hack once JDK 1.4 gets wide adoption on Solaris.
    static {
    }

    /**
     * @param fileNames
     *            names of files to be opened
     */
    FollowApp(List<String> fileNames) throws IOException, InterruptedException, InvocationTargetException {
    }

    FollowApp(List<String> filenames, File propertyFile) throws IOException, InterruptedException, InvocationTargetException {
    }

    /**
     * Close the current tab
     */
    public void closeFile();

    /**
     * Get a string from the resource bundle. Convenience method to shorten and
     * centralize this common call
     *
     * @param key
     * @return The value of key in the resource bundle. null if the key is not
     *         found.
     */
    public static String getResourceString(String key);

    /**
     * Gets an image icon from the resource path.
     *
     * @param clazz
     *            The class to use as an entry point to the resource path. Image
     *            path should be relative to this class.
     * @param iconNameKey
     *            The resource key name where the image is defined.
     * @return An image icon based on the URL generated from the value of
     *         iconNameKey. null if no URL can be found.
     */
    public static ImageIcon getIcon(Class<?> clazz, String iconNameKey);

    /**
     * Loads the actions used in the application
     *
     * @throws IOException
     */
    private void loadActions() throws IOException;

    /**
     * @param jMenuBar
     */
    private void initFrame(JMenuBar jMenuBar);

    public void show();

    public FollowAppAction getAction(String name);

    /**
     * Get all actions associated to the application
     *
     * @return
     */
    public HashMap<String, FollowAppAction> getActions();

    /**
     * Set an action to the action map of the application.
     *
     * @param name
     *            The key to set the action to.
     * @param action
     *            The action to create an association for.
     */
    public void putAction(String name, FollowAppAction action);

    public void openFile(File file) throws FileNotFoundException;

    /**
     * Warning: This method should be called only from (1) the FollowApp
     * initializer (before any components are realized) or (2) from the event
     * dispatching thread.
     */
    void openFile(File file, boolean startFollowing) throws FileNotFoundException;

    private void updateActions();

    /**
     * Warning: This method should be called only from the event dispatching
     * thread.
     *
     * @param cursorType
     *            may be Cursor.DEFAULT_CURSOR or Cursor.WAIT_CURSOR
     */
    public void setCursor(int cursorType);

    // Lazy initializer for the right-click listener which invokes a popup menu
    private MouseListener getRightClickListener();

    public void enableDragAndDrop(Component c);

    public void disableDragAndDrop(Component c);

    public FileFollowingPane getSelectedFileFollowingPane();

    public List<FileFollowingPane> getAllFileFollowingPanes();

    public FollowAppAttributes getAttributes();

    public Map<File, FileFollowingPane> getFileToFollowingPaneMap();

    public JFrame getFrame();

    public static FollowApp getInstance();

    public SystemInterface getSystemInterface();

    public void setSystemInterface(SystemInterface systemInterface);

    public JTabbedPane getTabbedPane();

    public static void centerWindowInScreen(Window window);

    /**
     * Invoke this method to start the Follow application. If any command-line
     * arguments are passed in, they are assume to be filenames and are opened
     * in the Follow application
     *
     * @param args
     *            files to be opened
     */
    public static void main(String[] args);

    private class RecentFileListener implements PropertyChangeListener {

        public void propertyChange(PropertyChangeEvent evt) {
            if (recentFilesMenu != null) {
                recentFilesMenu.removeAll();
                List<File> recentFiles = attributes.getRecentFiles();
                // descend down the list to order files by last opened
                for (int i = recentFiles.size() - 1; i >= 0; i--) {
                    // have to use FollowApp.this because 'this' is now the
                    // context of
                    // the inner class
                    recentFilesMenu.add(new Open(FollowApp.this, recentFiles.get(i)));
                }
            }
        }
    }
}
","// FollowAppTest.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains one unit test case for the {@link FollowApp#getIcon(Class, String)} method.
*/
class FollowAppTest {","// FollowAppTest.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains one unit test case for the {@link FollowApp#getIcon(Class, String)} method.
*/
class FollowAppTest {
"
