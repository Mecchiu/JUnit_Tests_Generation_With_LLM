[
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\tstatic final  Logger _logger = Logger.getLogger( \"OldChat\" );\n\t\tstatic final  Level _logLevel = Level.WARNING;\n\t\t\n\t/**\n\t * Gets the logger object.\n\t * @return a logger object\n\t */\n\tprivate static Logger getLogger() {\n\t\treturn _logger;\n\t}\n\t/**\n\t * @return an enum object\n\t */\n\tprivate static StringEncrypter getEncrypter() {\n\t\tStringEncrypter _encrypter = null;\n\t\ttry {\n\t\t\t_encrypter = new StringEncrypter( \"ASCII\" );\n\t\t}\n        catch ( Exception _ex ) {\n            //logger.log(Level.WARNING, \"Could not generate an encrypter\",\n            //        _ex );\n        }\n\t\t\n\t\treturn _encrypter;\n\t}\n\t/**\n\t * Checks the correctness of the getLogger().\n\t */\n\t@Test\n\tpublic void getLogger() {\n\t\tStringEncrypter _encrypter = getEncrypter();\n\t\t\n\t\tassertNotNull( \"getLogger() failed\", _logger );\n\t\tif (_encrypter == null) {\n        logger.log(Level.WARNING, \"You must enable security, to see log-output\", null);\n\t\t\tthrow new RuntimeException( \"Fail to enable security in RemoteAdmin\" );\n\t\t}\n\t\t\n\t}\n\t/**\n\t * This test will ping and check if the ping success. It is very good to compare the server.\n\t * @throws RemoteException\n\t */\n    @Test\n\tpublic void pingTest(){\n                \n\t\t_logger.log(Level.WARNING, \"This test was introduced\", null);\n\t\t_logger.log(Level.INFO, \"Pong \" + new java.util.Date().toString(), null);\n\t\t_logger.log(Level.INFO, \"Ping\", null);\n\t}\n\t/**\n\t * Test of start.\n\t * @throws RemoteException\n\t */\n\t@Test\n\tpublic void testStart() throws RemoteException{\n\t\t_logger.log(Level.WARNING, \"This test was introduced\", null);\n\t\t\n\t\tStringEncrypter _encrypter = getEncrypter();\n\t\tString _test = \"testing\";\n\n\t\tString _timeStamp = Calendar.getInstance().getTimeInMillis() + _test;\n\t\t_logger.log(Level.INFO, \"Pong test \"+_timeStamp, null);\n\t\t_logger.log(Level.INFO, \"Ping test\", null);\n\t\t_logger.log(Level.WARNING, \"Done\", null);\n\t}\n\t/**\n\t * Test of getUsers.\n\t */\n\t@Test\n\tpublic void testGetUsers() {\n\t\tStringEncrypter _encrypter = getEncrypter();\n\t\tString _test = \"/Users/\" + new java.util.Date().toString() + \"?key=\" + IConstant.KEY;\n\t\tlogger.log(Level.INFO, \"Requesting list of users with key=\" + IConstant.KEY + \"...\");\n\t\tVector<User> _users = new Vector<User>();\n\t\tint _usersSize = 0;\n\t\twhile (_usersSize < 4) {\n\t\t\ttry {\n\t\t\t\tString _userName = UsersBD.getUsers().findUserByKey( IConstant.KEY );\n\t\t\t\tlogger.log(Level.INFO, \"Found user - key=\" + IConstant.KEY + \" - UserName = \" + _userName);\n\t\t\t\tVector<User> temp = UsersBD.getUsers().findUserByName(_userName.substring(0, _userName.length()-1), \"\");\n\t\t\t\tif (((temp!= null) && (temp.getClass().isArray()))) {\n\t\t\t\t\tVector _array = new Vector(temp);\n\t\t\t\t\tEnumeration _elements = _array.elements();\n\t\t\t\t\twhile (_elements.hasMoreElements()) {\n\t\t\t\t\t\t_users.add( (User) _elements.next",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\t\n    /**\n     * @throws java.lang.Exception if the test fails\n     */\n    @Test\n    public void testGetLogger() throws Exception {\n        logger.addAppender(new Logger.Level(\"INFO\"));// to get level setted to ERROR for info purpose\n        \n    Vector<String> users = new Vector<>();\n    users.add(\"Alice<a@b.c>\");\n    users.add(\"Bob\");\n    users.add(\"Charlie\");\n    \n    User u = UsersBD.createUser(\"Alice\", \"Bob\");\n    u.setId(42);\n    u = UsersBD.setPassword(u, new StringEncoder64(), \"1234567890\");\n    u.setName(\"Alice\");\n    String text = \"Hello Alice Alice Bob Charlie\";\n    \n    String textToLogin = \"Hello Alice Charlie\";\n    String textToRefresh = \"Hello Bob Charlie\";\n    String textToLogout = \"Logout\";\n    \n    TextMessage tm = new TextMessage();\n        tm.addText(textToLogin);\n        tm.addText(textToRefresh);\n        tm.addText(textToLogout);\n    \n    tm = UsersBD.createTextMessage(\"Alice\");\n    tm.send();\n    // tm.send2();\n        \n    MessageBean mb3 = new MessageBean();\n        mb3.addContent(textToLogout);\n       // mb3.addContent(textToRefresh);\n    \n    mb3.setLogin(u);\n    \n    MessageBean mb7 = new MessageBean();\n        mb7.addContent(textToLogout);\n        mb7.addContent(textToRefresh);\n               \n    mb7.addContent(tm);\n    \n    \n    MessageBean mb = new MessageBean();\n    mb.addText(tm);\n        \n    \n        \n    MessageBean mb2 = new MessageBean();\n        mb2.addText(tm);\n        \n    \n        \n        \n    User ud = new User();\n    ud.addContent(mb);\n    \n    ud = UsersBD.createUser(\"Charlie\", null);\n    ud.setId(42);\n    ud = UsersBD.setPassword(ud, new StringEncoder64(), \"1234567890\");\n    ud = UsersBD.createRoom(\"Room\", null, ud);\n    // ud.addContent(mb);\n    \n    ud = UsersBD.createRoom(\"Room\", \"Room 2\", ud);\n    // ud.addContent(mb);\n        \n    String password = new StringEncoder64().getString(new StringEncrypter.UserPassword());\n    \n    String password1 = new StringEncoder64().getString(new StringEncrypter.UserPassword());\n    \n        \n    String username = new StringEncoder64().getString(new StringEncrypter.Password());\n    \n    ClientInterface ch = UsersBD.getClientInterfaceForUser(username);\n    \n    \n    //ClientInterface ch= null;\n   \n    \n    String host = \"localhost\";\n    int port = 9911;\n    int timeout = 15000;\n    int interval = 200; \n    \n    \n    ClientInterface ch1 = null;\n    \n    String myMessage =  \"Hello there, Bob, Charlie\" +\n    \t\t\"Hello Alice, Jane, John\" +\n    \t\t\"Hello Bob, Alice, Charlie\" +\n    \t\t\"Hello Alice, Charlie, Jane\" +\n    \t\t\"Login successful!\";\n    \n    \n    \n    //ClientInterface ch= new ClientInterface();\n    //ch.addUser(ch1, null, \"127.0.0.1\", portNumber, username, \"localhost\" );\n\n    \n     \n    \n    UsersBD.login(\"Alice\", null, \"1234567890\", username, password, host, String.valueOf(port), String.valueOf(interval));\n    UsersBD.login(\"",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\tprivate final Logger logger = Logger.getLogger(\"test_log\");\n\n    /**\n     * Run the test for the {@link ServerSettingBean#server_setting_flag()} to get if the server is running or not.\n     */\n    @Test\n    void getLogger_0( ) throws Exception {\n        StringEncoder64 enc = new StringEncrypter(\"test_enc\");\n\n        ServerSettingBean serverSetting = new ServerSettingBean(\n                null,\n                null,\n                new Hashtable<>(\n                    new String[][]{\n                        new String[]{\"0_0\", \"1_1\", \"7_7\", \"8_8\", enc.encode(\"7_7\")},\n                        new String[]{\"11_2\", \"3_3\", \"9_3\", \"9_2\", enc.encode(\"9_3\")}\n                       ,\n                        new String[][]{\n                            new String[]{\"4_5\", \"1_1\", \"6_6\", \"8_8\", enc.encode(\"6_6\")},\n                            new String[]{\"6_4\", \"9_2\", \"10_1\", \"10_0\", enc.encode(\"10_0\")},\n                            new String[]{\"4_4\", \"3_3\", \"11_1\", \"11_0\", enc.encode(\"11_0\")}\n                        }\n                    ),\n                    \"7_7\"\n                )\n        );\n\n        logger.debug(StringEncoder64.removeCaps(enc.encode(\"7_7\", \":\", \":\", \":\", \":\")).substring(0, 50));\n        logger.trace(StringEncoder64.removeCaps(enc.encode(\"11_1\")).substring(0, 50));\n\n        boolean res = (ServerSettingBean.server_setting_flag() == 0 || ServerSettingBean.server_setting_flag() == 1 || ServerSettingBean.server_setting_flag() == 3 || ServerSettingBean.server_setting_flag() == 5 || ServerSettingBean.server_setting_flag() == 7)? true : false;\n\n        if (res) {\n            assertEquals(\n                    Logger.getLogger(IConstant.SERVER_LOGGER_CLASS_0),\n                    getLogger()\n            );\n        } else {\n            fail(\"The test 'ServerSettingBean.server_setting_flag() == 0, ServerSettingBean.server_setting_flag() == 1, ServerSettingBean.server_setting_flag() == 3, ServerSettingBean.server_setting_flag() == 5, ServerSettingBean.server_setting_flag() == 7' return false. But the test'res == true' return false.\", res);\n        }\n        assertEquals(\n                Logger.getLogger(IConstant.SERVER_LOGGER_CLASS_0),\n                getLogger()\n        );\n\n    }\n\n\n    /**\n     * Run the test for the {@link User#getBinaryMessages()} method.\n     */\n    @Test\n    void getBinaryMessages_1( ) throws Exception {\n        Vector<BinaryMessage> res = UsersBD.getBinaryMessages();\n\n        assertNotNull(res);\n        assertEquals(5, res.size());\n\n        for (int i = 0; i < res.size(); i++) {\n            assertEquals(\n                    5,\n                    res.get(i).getDataLength()\n            );\n        }\n\n        // TODO: to assert is a test case for this test should be fixed\n        assertTrue(res.get(4).getData()[3] >= 0.1);\n    }\n\n\n    /**\n     * Run the test for the {@link User#getContactData()} method.\n     */\n    @Test\n    void getContactData_1( ) throws Exception {\n        Vector<String> res = UsersBD.getContactData();\n        ResultBean resultBean = UsersBD.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\t\n\n\tprivate SimpleFormatter simpleFormat = new SimpleFormatter();\n    private ServerInterface serverInterface;\n\n\t/**\n\t * @throws java.lang.Exception\n\t */\n    @Test\n    public void testGetLogger() throws Exception {\n    \tgetLogger();\n    \n    }\n\n    \n        /**\n\t * @throws java.lang.Exception\n\t */\n    @Test\n    public void testConnection() throws Exception {\n    \tLogger logger = ServerInterface.getLogger();\n\t\tlogger.entering(this.getClass(), \"testConnection\");    \n    \n    \tlogger.info(\"Hello from the server\");\n    \n    \tLogger.getLogger(\"\").setLevel(Level.SEVERE);\n    \tLogger.getLogger(\"\").setLevel(Level.ALL);\t\n\t}\n    \n\t\n\n\t/**\n\t * @throws java.lang.Exception\n\t */\n    @Test\n    public void testLogger() throws Exception {\n        try {\n        \tLogger logger = getLogger();\n        \tlogger.log(\"Hello from the Logger!\");\t\n        \tunexpectedExceptionThrown = false;\n        \tif (unexpectedExceptionThrown)\n                throw new Exception(\"TESTRUNC\");\n        } catch(IllegalArgumentException | IllegalAccessException e) {\n        \tunexpectedExceptionThrown = true;\n        \te.printStackTrace();\n        }\n\n    }\n\n    \n        /**\n\t * @throws java.lang.Exception\n\t */\n    @Test\n    public void testSendRoomList() throws Exception {\n        System.out.println(\"TestSendRoomList()\");\n    \ttry {\n\t\t\tString roomListString = \n                    StringEncrypter.makeString (System.getProperty(\"user\") + \":::\" + \n                        System.getProperty(\"client\") + \n                        EConstant.SPACE + \n                        EConstant.ENDS + \n                        \"## ::::\" + \n                        System.getProperty(\"user\"), \n                        EConstant.SPACE, \n                        EConstant.ENDS);\n\t\t\tServerSettingBean settingBeanSend = new ServerSettingBean();\n\t\t\tsettingBeanSend.setSetting1( StringEncoder64.encode((System.getProperty(\"user\") + \":::\" + \n\t\t\t\t\tSystem.getProperty(\"client\")))) ;\n\t\t\tsettingBeanSend.setSetting2(\"Hello\");\n\t\t\tServerSettingBean settingBean1 = new ServerSettingBean();\n\t\t\tsettingBean1.setSetting1(\"Hello\");\n\t\t\tsettingBean1.setSetting2(\"\");\n\n\t\t\t\n\t\t\tsettingBeanSend.setUserList(new String[2]);\n\t\t\tsettingBeanSend.getUserList()[0] = settingBeanSend.getUserList()[0] + \"_\" + \n                \"1  \";\n\t\t\tsettingBeanSend.getUserList()[1] = settingBeanSend.getUserList()[1] + \"_\" + \n                \"1  \";\n\t\t\tsettingBeanSend.setServerSetting(settingBeanSend);\n\t\t\tsettingBeanSend.setClientSetting(settingBean1);\n\t\t\ttry (ServerSettingBean settingBeanSend2 = \n\t\t\t\t\tServerInterfaceServer.getInstance().doRemoteConnection(\"\", settingBeanSend).getServerSetting()) {\n        \t\tBinaryMessage msg = new BinaryMessage ();\n        \t\tVector<TextMessage> sentMsg = new Vector<TextMessage>();\n          \n        \t\ttry {\n\t\t    \t\t\tif(! settingBeanSend2.login(settingBeanSend) ) {\n\t\t    \t\t\t\tsendMessageErrorAndExit(\"Server server has error!Please check the connection parameters.\", \"error\");\n\t\t    \t\t\t}\n\t\t    \t\t\tencode = new StringEncoder64( settingBeanSend2.encodedUser, (int) settingBeanSend2.encodedCty, true);\n\t\t    \t\t} catch(Exception e1) {\n\t\t    \t\t\tsendMessageErrorAndExit(\"Server connection is failed or has illegal connection parameters",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\tprivate static final Logger logger = Logger.getLogger();\n\n\t\t@Test\n\t\tvoid getLogger() {\n\t\t\tlogger.info(\"This is a test\");\n\t\t\tlogger.info(new StringEncrypter(\".abc\"));\n\t\t\tLocale.setDefault(Locale.JAPANESE);\n            ServerSettingBean setting = new ServerSettingBean();\n            setting.setMaxConnections(\"100\");\n            setting.setMaxUsers(\"50\");\n            setting.setMaxRoom(\"300\");\n            setting.setUsernamePattern(\"^.*[^@]+@\");\n            setting.setPasswordPattern(\"^.*[^@]+$\");\n            ServerSettingBean.saveSettings();\n\n\t\t\tlogger.info(\"This is the logger\");\n\n\t\t\tLogger.getGlobal().addHandler(new FileHandler(\"logfile\"));\n\t\t\tLogger.getGlobal().setLevel(Level.FINE);\n\n\t\t\tlogger.info(\"This is the logger\");\n\n            JOptionPane.showMessageDialog(null, \"Hello World\", \"Hello World\", JOptionPane.PLAIN_MESSAGE, null);\n\n\t\t\tlogger.info(\"This is the logger\");\n\n                StringEncrypter encrypted = new StringEncrypter(\".abcx\");\n                String encrypted = String.valueOf(encrypted.encrypt(ServerSettingBean.getSettingsPassword().getPassword()));\n                logger.info(\"The server has \" + encrypted + \" encrypted password.\");\n            \tlogger.info(encrypted);\n            \tLogger.getGlobal().removeHandler(new FileHandler(\"logfile\"));\n\n            logger.info(\"This is the logger\");\n\n\t\t\tlogger.error(\"ERROR\");\n\t\t\tlogger.fatal(\"FATAL\", new RemoteException(\"FATAL ERROR\"));\n\t\t\tlogger.error(\"\");\n\t\t}\n\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\tpublic final String message = \"Hello, World !\";\n\n\t\t/**\n\t\t * @return the logger\n\t\t */\n\t\tpublic static Logger logger2 = Logger.getLogger(\"\");\n\n\t\t/**\n\t\t * @return the logName2\n\t\t */\n\t\tpublic static Logger getLogName2() {\n\t\t\treturn logger2;\n\t\t}\n\n\t\tClassLoader classLoader2 = new ClassLoader(\"\", \"\");\n\n\t\tClassLoader classLoader1 = null;\n\n\t\t@Test\n\t\tvoid getLogName() {\n\n\t\t\ttry {\n\t\t\t\tclassLoader1 = new ClassLoader(\"\", \"\");\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tfail(classLoader1.toString());\n\t\t\t}\n\t\t}\n\n\t\t@Test\n\t\tvoid runPing() {\n\n\t\t\tfinal String msg = StringDecoder64.decode(getLogName(), message);\n\t\t\tlogger.trace(\"message = \" + msg);\n\n\t\t\ttry {\n\t\t\t\tRunnable runnable = new Runnable() {\n\t\t\t\t\tfinal String threadName = \"Ping-Thread\";\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tThread thr = Thread.currentThread();\n\t\t\t\t\t\tif (thr.getName().equals(threadName)) {\n\t\t\t\t\t\t\tlogger.trace(\"Ping-Thread is run\");\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tboolean pingCompleted = ((User)Naming.lookup(\n\t\t\t\t\t\t\t\t\t\t\"/\" + \"Ping-Thread\" + \"/\")).pingComplete();\n\t\t\t\t\t\t\t\tassertTrue(\"User's ping state shall be completed\", pingCompleted);\n\t\t\t\t\t\t\t} catch (Exception e2) {\n\t\t\t\t\t\t\t\te2.printStackTrace();\n\t\t\t\t\t\t\t\tfail(e2.getMessage());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmsg = \"My ping!\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfail(\"This is not the thread run\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tThread t = new SendPingThread(runnable);\n\t\t\t\tt.start();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tt.printStackTrace();\n\t\t\t}\n\t\t}\n}\n\n// ModernChatServer_0ServerThread.java\n\ninterface ChatInterface {\n\tIConstant _I_CONSTANT = IConstant.Constant_IMPL_LOST_PING;\n\n\tvoid _SERVER_NOT_LOST_PING(Room r) throws RemoteException;\n\n\tvoid _SERVER_NOT_LOST_CONFERENCE(Room r) throws RemoteException;\n\n\tvoid _SERVER_LOST_PING(String sMsg) throws RemoteException;\n\n\tvoid _SERVER_LOST_CONFERENCE(String sMsg) throws RemoteException;\n\n\tString _SERVER_NOT_LOST_DISCONNECT(String nMsg) throws RemoteException;\n\n\tvoid _SERVER_NOT_LOST_DISCONNECT(String nMsg) throws RemoteException;\n\n\tvoid _SERVER_LOST_DISCONNECT(String nMsg) throws RemoteException;\n\n\tString _SERVER_NOT_LOST_UNCONNECT(String nMsg) throws RemoteException;\n\n\tvoid _SERVER_LOST_UNCONNECTED(String nMsg) throws RemoteException;\n\n\tVector<String> _SEND_UNKNOWN_REQ_MSG(String mMsg, Object res){\n\t\tVector<String> res = new Vector<String>();\n\t\tres.addAll(new Vector<String>());\n\t\tres.add(mMsg);\n\t\tres.add(\"Unable to execute request, there's no response given\");\n\t\treturn res;\n\t}\n\n\tVector<String> _SERVER_NOT_LOST_REQ_MSG(String mMsg, Object r) throws RemoteException{\n\t\tVector<String> res = new Vector<String>();\n\t\tres.addAll(new Vector<String>());\n\t\tres.add(\"Not enough resources available for send request\");\n\t\treturn res;\n\t}\n\n\tVector<String> _SERVER_NOT_LOST_MSG(String mMsg, Exception e) throws RemoteException {\n\t\tVector<String> res = new Vector<String>();\n\t\t",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\t  /**\n         * Test the method {@link ModernChatServer#getLogger()}.<br>\n         * It's testing methods of the interface {@link Runnable}.<br>\n         * @throws Exception throws Exception if there is any problem\n         */\n        @Test\n\t  public void testMyMethod()\n\t\t throws Exception {\n\t\t\t\n            //Getting the logger : \n\t\t\tLogger logger = Logger.getLogger(\"\");\n\t\t\t\n\t\t\tlogger.addHandler(new FileHandler(\"log.jsp\"));\n\t\t\tlogger.setLevel(Level.DEBUG);\n\n\t\t\tString serverIP = \"192.168.1.103\";\n\t\t\tint serverPort = 8049;\n\t\t\tServerSettingBean setting = new ServerSettingBean();\n\t\t\tsetting.setSettingKey(\"serverIP\", serverIP);\n\t\t\tsetting.setSettingKey(\"port\", String.valueOf(serverPort));\n\n            //Creating a Realm with a Hashtable (and all elements of it)\n\t\t\t//It contains 2 Objects : the Realm of the server and the Realm of the client\n\t\t\tLocateRegistry.createRegistry(serverIP, serverPort);\n\t\t\tRegistry registry = LocateRegistry.getRegistry(serverIP, serverPort);\n\n            //Obtaining the ChatUser object from the Realm of the server and the Realm of the client\n            User user = new User();\n            Vector<String> allUsers = UsersBD.getAllUsers();\n            if(allUsers!= null) {\n\t  \t\t  for(String userName:allUsers) {\n\t  \t\t\t  if(userName.equals(user.getNickName())) {\n\t  \t\t\t\t  user = UsersBD.getChatUser(userName);\n\t  \t\t\t  }\n\t  \t\t  }\n    \t\t} \n\t\t\tint maxUsers = UsersBD.getMaxUsers();\n\t\t\tVector<Integer> allTimes = UsersBD.getAllTimes();\n\t\t\tif(allTimes!= null) {\n\t\t\t\tfor(Integer user:allTimes) {\n\t\t\t\t\tif (user >= maxUsers) {\n\t\t\t\t\t\tuser = maxUsers;\n\t\t\t\t\t}\n\t\t\t\t\tUser newUser = UsersBD.getChatUser(user.toString());\n\t\t\t\t\tfor (Group group: newUser.getGroups()) {\n\t\t\t\t\t\tif (group.isUser()) {\n\t\t\t\t\t\t\tuser = UsersBD.getChatUser(user.toString());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n            //This is a simple test for MyMethod() method.\n\t\t\tif(user == null) {\n\t\t\t\tSystem.out.println(\"testMyMethod failed. The specified user to test does not exist.\");\n\t\t\t\tSystem.out.println(\"Test message was sent as text message.\");\n\t\t\t\tSystem.out.println(\"The test message was sent by user 'Nickname'\");\n\t\t\t\treturn;\n\t\t\t} \n            //This is a simple test for MyMethod() method.\n\t\t\tif (allUsers == null) {\n\t\t\t\tSystem.out.println(\"testMyMethod failed. The specified allUsers are null. Please do not forget to check if the server is running.\");\n\t\t\t\tSystem.out.println(\"Test message was sent as text message.\");\n\t\t\t\tSystem.out.println(\"The test message was sent by user 'Nickname'\");\n\t\t\t\treturn;\n\t\t\t} else {\n                //Getting the chatUser message from the registry and the value of the index.\n\t\t\t\tVector<String> values = UsersBD.getValuesFromRegistry(registry, \"testchat\", 0);\n\t\t\t\t//Checking the index of the message the message to be tested.\n\t\t\t\tif(values!= null) {\n\t\t\t\t\tfor(String value:values) {\n\t\t\t\t\t\tif (value.equals(user.getNickName())) {\n\t\t\t\t\t\t\tuser = UsersBD.getChatUser(user.getNickName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"testMyMethod failed. A not existing text message on the specified index was expected.\");\n\t\t\t\t\tSystem.out.println(\"Test message was sent as text message.\");\n\t\t\t\t\tSystem.out.println(\"The test message was sent by no users is expected",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\t\n\t/**\n\t* {@link #getLogger()} will obtain the value returned by the {@link #getLogger()} method.\n\t*/\n\tprivate static final Logger logger = Logger.getLogger(\"\");\n\t\n\t/**\n\t* @see Test\n\t* @throws Exception to catch some exceptions.\n\t*/\n\t@Test\n    public void testRuns() throws Exception {\n\t\t\n\t\t// Creating new server.\n\t\tSimpleFormatter formatter = new SimpleFormatter();\n\t\tSimpleFormatter.FormatterDelegate delegate = new SimpleFormatter.FormatterDelegate(){\n\n            public void format(LogRecord record, Object[] data) {\n                String s = formatter.format(record);\n                \n                if (data!= null) {\n                    String tmp = \"Test \" + String.valueOf(s.length()) + \"\\r\\n\";\n                    \n                    for (int index = 0;index!= data.length; index++) {\n                        tmp += (String) (data[index] + \"\\r\\n\");\n                    }\n                    \n                    if (index > 0) {\n                        tmp = tmp.substring(0, tmp.length()-2);\n                    }\n                    \n                    System.out.println(tmp);\n                }\n            }\n        };\n\t\t\t\t\n\t\tlogger.addHandler(new ConsoleHandler(formatter.flags()|Logger.APPLICATION_FORMAT, \"logger.txt\"));\n\n\t\tlogger.setLevel(Level.ALL);\n\n\t\t// Creating a new simple logger.\n\t\tlogger = new Logger(new LoggerParent());\n\n\t\t// Creating LoggerParent and Loggername as Logger instance in Logger hierarchy.\n\t\tfinal Logger ParentLogger  = logger.getLogger(\".ParentForMe\");\n\t\tfinal Logger ParentParent  = logger.getLogger(\".\");\n\n\t\tParentLogger.setLevel(Level.FINEST);\n\t\tlogger   .addHandler(new FileHandler(\".ParentForMe\", Formatter.FORMAT_SHORT|Formatter.FORMAT_NONE, \"logger.txt\"));\n\t\tlogger   .addHandler(new FileHandler(\".ParentForMe\", Formatter.FORMAT_SHORT|Formatter.FORMAT_NONE, \"logger.txt\"));\n\t\tLoggerParent.addHandler(new FileHandler(\".ParentForMe\", Formatter.FORMAT_SHORT|Formatter.FORMAT_NONE, \"logger.txt\"));\n\t\tLoggerParent.addHandler(new FileHandler(\".ParentForMe\",Formatter.FORMAT_SHORT|Formatter.FORMAT_NONE, \"logger.txt\"));\n\t\t\n\t\t// Logging a root logger to System.out.\n\t\tlogger = Logger.getLogger(\"\");\n\t\tparent   = logger.getLogger(\"Parent\");\n\t\tparent   = Logger.getLogger(\".\");\n\t\tparent   = Logger.getLogger(\".ParentForMe\");\n\t\t\n\t\t// Creating Root logger using SimpleFormatter.\n\t\tlog = new Logger(null, parent.getParent());\n\n\t\t// Setting a new value for Logger.parent.\n\t\tlevel = Level.FINEST;\n\t\t\n\t\t// Logging a root logger to System.out\n\t\tlogger.log(Level.FINEST, \"(getLogger()) Level= \" + level.getSeverity() + \" [\" + level + \"] \" + \"\\r\\n\");\n\n\t\ttry {\n\t\t\t// Server setup.\n\t\t\tnew User();\n\t\t\tnew Room(\"RoomName-0\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(\"Failed to setup the new server.\");\n\t\t}\n\t\t\n\t\tString[] setUpStrings = {\n\t    \t\"UserName = 'root' ID #1\",\t\t\t\t\t\t\t\t\t\t# Set up a new user with a user name\n    \t\"UserName = \\\"root\\\" ID #1\\r\\n\",\t\t\t\t\t\t\t\t\t# Same with null parameter\n\t    \t\"UserName = 'root' ID #1\",\t\t\t\t\t\t\t\t\t\t# Set up",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\t/**\n\t\t* Return the expected value of static method getLogger()\n\t\t* @return the value for logger\n\t\t* @throws  NullPointerException if logger argument is null\n\t\t*/\n    private static Logger getLogger () throws NullPointerException {\n        if (logger == null) {\n            throw new NullPointerException (\"logger argument is null\");\n        }\n        return logger;\n    }\n\n        /**\n        * Static method for set up loggering of the {@link Logger}\n\t\t* @param  logger the logger to configure\n\t\t* @return          the result of the setUp of logger (null when no operation done)\n\t\t* @throws IllegalArgumentException if the given logger argument is empty\n\t\t* @throws NullPointerException if logger argument is null\n\t\t*/\n    static Logger setUpLogger (Logger logger) throws IllegalArgumentException, NullPointerException {\n        logger.getName();\n        return logger;\n    }\n\n        /**\n        * Standard  method for test the state-of-the-system\n\t\t* @throws Exception in case of error\n\t\t*/\n@Test\n    public void testSt () throws Exception {\n        String sLogger = \"Logger = \";\n        setUpLogger (getLogger (sLogger, true));\n        Log.setLevel(\"Logger = \");\n        Log.getLogger (Logger);\n\n\t\t// Test 1.  Set up.\n\t\tLoginBean lUser = new LoginBean();\n                        String test = StringEncoder64.encodeToString (lUser.getString ());\n                        JOptionPane.showMessageDialog (null, test, \"test\", JOptionPane.OK_OPTION);\n        try {\n            System.out.println (\"Waiting for first kick\");\n            Thread.sleep (0);\n            if (!System.getProperty(\"test.data.dir\").startsWith (\"/tmp\")) {\n                assertTrue (\"Not a directory\", true);\n            }\n            if (!User.isValidEmail (lUser.getString ())) {\n                assertTrue (\"No login\", false);\n            }\n            System.out.println (\"Starting thread for second kick\");\n \n            // Start thread for first kick\n            SendRefreshContactThread mySendRefreshContactThread = new SendRefreshContactThread ();\n            mySendRefreshContactThread.start ();\n\n            System.out.println (\"Running second kick\");\n            SendRefreshContactThread.stopThread (null);\n            WaitThread.waitUntilStop();\n            assertEquals (System.getProperty(\"test.data.dir\"), mySendRefreshContactThread.getDataDir ());\n            System.out.println (\"Received first reply from sendRefreshContactThread\");\n            String myDataDir = mySendRefreshContactThread.getDataDir();\n            ArrayList<BinaryMessage> myBinaryMessage = mySendRefreshContactThread.getBinaryMsg ();\n            System.out.println (\"Received first reply from SendRefreshContactThread\");\n            Enumeration<BinaryMessage> myBinaryMessageEnum = myBinaryMessage.elements ();\n            assertNotNull (\"No binary messages\");\n            int nMessages = myBinaryMessage.size ();\n            if ((nMessages==1)&&(myBinaryMessageEnum.hasMoreElements())) {\n                String dataFileName = myBinaryMessageEnum.nextElement ().getDataFileName ();\n                dataFileName = dataFileName.substring (1, dataFileName.length ());\n                System.out.println (\"First binary message is \" + dataFileName);\n                // Send first binary message.\n                SendBinaryBroadcastMessageThread tSendBinaryMessageThread = SendBinaryBroadcastMessageThread.getSendBinaryMessageThread (mySendRefreshContactThread,lUser.getString (), myBinaryMessageEnum);\n                tSendBinaryMessageThread.start ();\n\n                try {\n                    Thread.sleep (5000);\n                    SendRefreshMessageThread.stopThread (null);\n                } catch (Exception",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n\n// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {\n\t\t\n    /**\n     * Main method for running this test class.\n     * @param args - the parameters for this test.\n     */\n    public static void main(String[] args) {\n        try {\n            final User testUser = new User (0,\"User 1\");\n            final ClientInterface testClIInterface = new ClientInterface();\n            final User testUserServerImpl = new ServerInterface();\n            \n\t\t\tSendUserUpdatedStatusThread sendUserUpdateStatusThread = new SendUserUpdatedStatusThread (testUserServerImpl);\n\t\t\tsendUserUpdateStatusThread.start();\n\n\t\t\tSendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread (testUserServerImpl);\n\t\t\tsendRefreshContactThread.start();\n\t\t\t\n\t\t\tSendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread (testUserServerImpl);\n\t\t\tsendKickOffMessageThread.start();\n\t\t\t\n\t\t\tSendRefreshContactThread sendRefreshContactThreadServerImpl = new SendRefreshContactThread (testClIInterface);\n\t\t\tsendRefreshContactThreadServerImpl.start();\n\t\t\t\n\t\t\tSendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread (testUser);\n\t\t\tsendKickOffByLoginMessageThread.start();\n\t\t\t\n\t\t\tsendUserUpdatedStatusThread.join();\n\t\t\tsendRefreshContactThread.join();\n\t\t\t\n\t\t\tsendUserUpdateStatusThread.join();\n\t\t\tsendKickOffByLoginMessageThread.join();\n\t\t\t\n\t\t\ttestUserServerImpl.join();\n\t\t\ttestClIInterface.join();\n\t\t\t\n\t\t\ttestUserServerImpl.disconnect();\n\t\t\ttestClIInterface.disconnect();\n\t\t\t\n\t\t\ttestUserServerImpl.disconnect();\n\t\t\ttestClIInterface.disconnect();\n            JOptionPane.showMessageDialog (null, \"Succesfully test the new code!\", \"Hello\", JOptionPane.INFORMATION_MESSAGE);\n        } catch (URISyntaxException e) {\n        \tJOptionPane.showMessageDialog(null, \"Uri Syntax Exception!\", \"Hello\", JOptionPane.INFORMATION_MESSAGE);\n        } catch (RemoteException e) {\n        \tJOptionPane.showMessageDialog(null, \"A Remote Exception occurred!\", \"Hello\", JOptionPane.INFORMATION_MESSAGE);\n        } catch (Exception e) {\n        \tJOptionPane.showMessageDialog(null, \"An exception occurred!\", \"Hello\", JOptionPane.INFORMATION_MESSAGE);\n        }\n\t\t}\n\n\tpublic static synchronized String getLoggerMessage () {\n        return \"<===============================================================\";\n    }\n\n    /*\n     * This field contains the currently used loggers.\n     * Field value is \"\".\n     */\n    public static Logger getLogger () {\n        return null;\n    }\n    \n    /**\n     * This method will create a logger for a specific logger name.\n     * @param name - the name of the logger.\n     * @throws RemoteException \n     */\n    public synchronized static void createLogger (String name) throws RemoteException {\n        Class.forName(\"java.util.logging.Logger\");\n        Logger logger = Logger.getLogger(name);\n        logger.setUseParentHandlers(false);\n        logger.setLevel(Level.INFO);\n\n    }\n    \n    \n}\n\nclass ClientInterface extends UnicastRemoteObject implements ClientInterface {\n    \n    /*\n     * This is the new one that is used to register client.\n     */\n    \n    private static Vector<User> clients_ = new Vector<>();\n    private static ClientInterface clients_interfaceClone = null;\n    private static ClientInterface clients_interface = this;\n    \n    public String getLoggerMessage () {\n        return \"test client: \" + StringEncoder64.getBytes(StringEncrypter.getSHA256(StringEncrypter.getBase64(IConstant.C_USER + ClientInterface.getClientID())));\n    }\n    public void createLog",
            "finish_reason": "length"
        }
    ],
    "id": "5b92a0d2-3905-4211-abe2-21a7c155be2c",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_0Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * @return the logger\n     */\n    public static Logger getLogger() {\n        return logger;\n    }\n}\n",
    "test_prompt": "// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {",
    "time_taken": 38.72727012634277,
    "usage": {
        "prompt_tokens": 1120
    }
},
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\tprivate static final Logger logger = Logger.getLogger(ModernChatServer_1Test.class.getName());\n\t\tprivate static final int PING_TESTING_TIME_MILLIS = 10 * 1000;\n\t\tVector<User> users = new Vector<User>();\n\t\tVector<Room> rooms = new Vector<Room>();\n\n\t\t/**\n\t\t * Test pings users\n\t\t */\n\t\t@Test\n\t\tpublic void testPing() {\n\t\t\tStringEncoder64 encoderP = new StringEncoder64();\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tlogger.info(\"ping \"+i);\n\t\t\t\tlogger.info(StringEncoder64.encodeToString(users.size()));\n\t\t\t\tint test = users.size();\n\t\t\t\tusers = new Vector<User> ();\n\t\t\t\tfor (int j = 0; j < PING_TESTING_TIME_MILLIS; j++) {\n\t\t\t\t\tlogger.info(\"Checking if \" + j + \" ping received \");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (j == test) {\n\t\t\t\t\t\t\tfor (int k = 0; k < PING_TESTING_TIME_MILLIS; k++) {\n\t\t\t\t\t\t\t\tString msg = \"New message:1\" + StringEncoder64.encodeToString(BinaryMessage.DEFAULT_PARAM);\n\t\t\t\t\t\t\t\tlogger.info(\"Checking \" + j + \" ping\");\n\t\t\t\t\t\t\t\tNewMsgBean bean = new NewMsgBean();\n\t\t\t\t\t\t\t\tbean.initMessage(msg);\n\t\t\t\t\t\t\t\tlogger.info(bean);\n\t\t\t\t\t\t\t\tfor (User u : users) {\n\t\t\t\t\t\t\t\t\tlogger.info(\"Test pinger for u \" + u);\n\t\t\t\t\t\t\t\t\tif (u.getUserID().equals(encoderP.encodeToString(u.getID())) ) {\n\t\t\t\t\t\t\t\t\t\tif (u.getGroup().getMessage().equals(\"ping\")) {\n\t\t\t\t\t\t\t\t\t\t\tassertTrue(u.getGroup().isEmpty() == true);\n\t\t\t\t\t\t\t\t\t\t\tassertTrue(encoderP.encodeToString(u.getUserID()).equals(encoderP.encodeToString(u.getID())) == true);\n\t\t\t\t\t\t\t\t\t\t\tassertTrue(encoderP.encodeToString(u.getEmail()).equals(encoderP.encodeToString(u.getPassword())) == true );\n\t\t\t\t\t\t\t\t\t\t\tassertTrue(encoderP.encodeToString(u.getName()).equals(encoderP.encodeToString(u.getUserName())) == true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tusers.clear();\n\t\t\t\t\t\t\t\tusers.add(users.get(k).clone());\n\t\t\t\t\t\t\t\tusers.set(k, UsersBD.login(encoderP.encodeToString(users.get(k).getID()), \"PING_USER\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (encoderP.encodeToString(encoderP.encodeToString(test)).equals(encoderP.encodeToString(test))) {\n\t\t\t\t\t\t\tif (encoderP.encodeToString(test).equals(users.get(test).getUserID())) {\n\t\t\t\t\t\t\t\tassertTrue(encoderP.encodeToString(test).equals(users.get(test).getUserID()));\n\t\t\t\t\t\t\t\tfail(\"Test user: \" + encoderP.encodeToString(users.get(k).getPassword()));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tassertFalse(encoderP.encodeToString(test).equals(users.get(k).getUserID()));\n\t\t\t\t\t\t\t\tusers.get(test).setUserID(encoderP.encodeToString(users.get(k).getUserID()));\n\t\t\t\t\t\t\t\tusers.get(test).setPassword(encoderP.encodeToString(users.get(k).getPassword()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassertFalse(encoderP.encodeToString(test).equals(users.get(test).getUserID()));\n\t\t\t\t\t\t\tusers.get(test).",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\t\n\n    /**\n     * Test\n     * <ol>\n     * <li>server.run() throws a RuntimeException</li>\n     * <li>getLoginBean() shall return a login bean from online user</li>\n     * <li>the loginBean shall be read from the server</li>\n     * </ol>\n     */\n    @Test\n    public void testServerGetLoginBean() {\n        try {\n            ServerSettingBean setting = new ServerSettingBean(\n                    ServerSettingBean.ONLINE_USER_NAME.toLowerCase(), ServerSettingBean.ONLINE_PASSWORD.toLowerCase(), \"local_test\", (Calendar)null\n            );\n            StringEncoder64 se = new StringEncoder64();\n            String loginString = (StringEncoder64)se.getStringEncoder();\n            StringEncoder64 se1 = new StringEncoder64();\n            StringEncoder64 se2 = new StringEncoder64(ServerSettingBean.SECRETAIN_PASSWORD.toLowerCase().split(\":\"));\n            String loginString2 = (StringEncoder64)se2.getStringEncoder();\n            System.out.println(\"getLoginBean() : \" + \n                    StringEncrypter.decode(\"LocalUserName==\" + loginString, \"\" ));\n            StringEncrypter.decode(\"LocalPassword!=\", \"pwd\");\n            System.out.println(\"getLoginBean() : \" + \n                    StringEncrypter.decode(ServerSettingBean.SECRETAIN_PASSWORD.toLowerCase(), \"\" ));\n            System.out.println(\"getLoginBean() : \" + \n                    StringEncrypter.decode(ServerSettingBean.SECRETAIN_PASSWORD.toLowerCase().split(\":\"), \"\" ));\n            System.out.println(\"getLoginBean() : \" + \n                    StringEncrypter.decode(ServerSettingBean.SECRETAIN_PASSWORD.toLowerCase().split(\":\"), \"\" ));\n            System.out.println(\"getLoginBean() : \" + \n                    StringEncrypter.decode(loginString.substring(15, loginString.indexOf(':')) + \":\" + ServerSettingBean.SECRETAIN_PASSWORD.substring(loginString.indexOf(':'), ServerSettingBean.SECRETAIN_PASSWORD.indexOf(':')+1), \"\" ));\n            String loginBean = \n                    (loginString > ServerSettingBean.SECRETAIN_PASSWORD.toLowerCase().split(\":\"))? \n                        loginString.replace(ServerSettingBean.SECRETAIN_PASSWORD.substring(0, ServerSettingBean.SECRETAIN_PASSWORD.indexOf(':')), loginString.substring(ServerSettingBean.SECRETAIN_PASSWORD.indexOf(':')+1, loginString.length())) : \n                                loginString.replace(loginString, \"\").toLowerCase(); \n            \n                     \n             ServerSettingBean setting2 = new ServerSettingBean( \n                    loginString2, ServerSettingBean.ONLINE_PASSWORD.toLowerCase(), \"\", (Calendar)null );\n            \n              \n                String nameOfOnlineUser = setting2.getOnlineUserName();\n                System.out.println(\"ServerSettingBean : LoginBean=\"+loginBean+\" nameOfOnlineUser=\"+nameOfOnlineUser);\n               \n                System.out.println(\"ServerSettingBean : OnlineuserID=\"+setting2.getOnlineUserId());\n                \n                String onlineUserID;\n                \n                if ( setting!= null ){\n                    \n                    onlineUserID = \n                        setting.getOnlineUserID();\n                    System.out.println(\"ServerSettingBean : OnlineuserID=\"+onlineUserID);\n                }\n                else {\n                   \n                    onlineUserID = \"\";\n                    System.out.println(\"ServerSettingBean : Online",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\t\n\t/**\n\t* The actual test case.\n\t*/\n    @Test\n    public void testServerPong() throws Exception {\n        \n        /**\n\t * Login\n\t *\n\t * This tests whether the server responds with a simple user list.\n\t *\n\t * @throws RemoteException\n\t */\n        System.out.println(\"----- Test Case #1 -----\");\n        \n        boolean isSuccessful = false;\n        \n        Registry registry = LocateRegistry.getRegistry();\n        \n        registry.rebind(\"Server\", new ServerInterface());\n        \n        LoginBean lb = new LoginBean(new TextMessage(1,\"1234567890\"));\n        boolean ret = (Boolean) ServerSettingBean.loginServer(ServerSettingBean.KEY_OPTIONAL_HOST_ADDRESS,lb);\n        \n        isSuccessful = ((ret==true)?true:false);\n        \n        System.out.println(\"Test case #1 for the ping method returned \" + isSuccessful);\n        \n        /**\n\t * We should receive the message to initialize the RPC server by checking if the host address is provided.\n\t *\n\t * @throws URISyntaxException\n\t */\n        assertTrue(\"Should get a URI.\",isSuccessful);\n        \n        ServerSettingBean.refreshServer();\n        \n        /**\n\t * We should receive the message to change the host address\n\t *\n\t * @throws URISyntaxException\n\t */\n        assertTrue(\"Unexpected URI.\",ServerSettingBean.isValidServerSetting());\n        \n        String hostAddress = ServerSettingBean.getServerUri().getHost();\n        log.log(Level.INFO,\"serverHost: \"+hostAddress);\n        \n        \n        \n        \n        isSuccessful = ((Boolean) ServerSettingBean.loginServer(ServerSettingBean.KEY_HOST_ADDRESS,new TextMessage(\"903\"))) ;\n        //System.out.println(\"Test case #2 for the refresh message returned \"+isSuccessful);\n        \n        assertTrue(\"Unexpected status \", (isSuccessful));\n        \n        \n        /* Test 1: pong received from the server */\n        \n        UsersBD usersBD = new UsersBD(new TextMessage(1,\"1234567890\"));\n        boolean test = usersBD.ping();\n        System.out.print(\"Testing if the pong is received : \" + usersBD.ping());\n        \n        assertTrue(\"Invalid user should be pinged\", test);\n        assertTrue(\"Unexpected ping time \", (calendar.getTimeInMillis() - ServerSettingBean.pingServerLastTime) <= 1500);        \n        \n        /**\n\t * We should receive the message to set the ping flag.\n\t *\n\t * @throws URISyntaxException\n\t * @throws RemoteException\n\t */\n        assertTrue(\"Unexpected URI\", ServerSettingBean.isValidServerSetting());\n        \n        UsersBD usersBD2 = new UsersBD(new TextMessage(1,\"1234567890\"));\n        assertTrue(\"The pong not received\", (usersBD.ping()!= false));\n        \n        ServerSettingBean.pingServerLastTime = calendar.getTime();\n        usersBD2.ping();\n        assertTrue(\"Unexpected ping time \", (calendar.getTimeInMillis() - ServerSettingBean.pingServerLastTime) <= 1500);\n        \n        /**\n\t * We should receive our client udp packet at 30 seconds.\n\t *\n\t * @throws URISyntaxException\n\t */\n         assertTrue(\"Unexpected packet received at the time\",UsersBD.udpSendPacket(usersBD.getLocalUser(),10));\n        //this.log.log(Level.INFO,\"udpPacketToSend: \"+UsersBD.udpSendPacket(usersBD.getLocalUser(),10));\n        /* Test 3: Server send ack packet to the client */\n        \n        \n        \n        \n        \n        \n",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\t\n    /**\n     * Test class for the runnable.\n     *\n     */\n   public static class Runnable implements Runnable {\n       \n    /**\n     * Client side Ping.\n     */\n      public void run(){\n           try{\n               Vector<ClientInterface> clients;\n               clients = new Vector<ClientInterface>();\n               ClientInterface[] users = new ClientInterface[10];\n               Hashtable<String, ClientInterface> usersMapTable = new Hashtable<String, ClientInterface>();\n\n               //Server Configuration.\n               ServerSettingBean serverParam;\n               \n               //Client Configuration.\n               String serverConfigFile = \"localhost\";\n               String serverPort;\n               String serverName = \"\";\n               String adminPort;\n               \n               //Initialize Server Setting.\n               try{\n                   serverParam = new ServerSettingBean();\n                 }\n                catch(Exception e){\n                    assertTrue(false);\n                }\n              \n               serverParam.setServerName(serverParam.getServerName());\n               serverParam.setHostName(\"localhost\");\n               serverParam.setPort(\"8888\");\n               serverParam.setFileName(\"TestServer\");\n               serverPort = serverParam.getPort();\n               serverPort = serverPort.substring(serverPort.lastIndexOf(\"/\") + 1);\n               serverPort = serverPort.substring(serverPort.lastIndexOf(\".\") + 1);\n               serverPort = Integer.toString(serverPort);\n               serverPort = \"8003\";\n               serverName = \"\";\n               serverName = \"localhost\";\n               \n               //Initialize Server User.\n               try{\n                   users = new ClientInterface[6];\n                   for(int i = 0; i < users.length; i++){\n                       users[i] = new ClientInterface();\n                       UsersBD usersBD = new UsersBD();\n                       usersBD.setPassword(\"test\");\n                       usersBD.setAdminAddress(\"test\");\n                       usersBD.setAdminPort(new Integer(0), new Integer(0));\n                       usersBD.setLoginUrl(\"Login\");\n                       usersBD.setRegisterUrl(\"Register\");\n                       usersBD.setLoginUrl(\"Login\");\n                       usersBD.login();\n                       users[i].login();\n                       usersBD.register(users[i]);\n                       users[i].setAdmin();\n                   }\n               }\n               catch(Exception e){\n                   assertTrue(false);\n               }\n              \n               //Initialize a BinaryMessage for the user.\n               BinaryMessage body;\n               body = new BinaryMessage();\n               body.setText(\"hello\");\n               Vector<String> users;\n               users = new Vector<String>();\n               body.setUsers(users);\n             \n               //Initialize the group.\n               Group group = new Group();\n               Vector<User> usersList = new Vector<User>();\n               for(int i = 0; i < users.size(); i++){\n                   usersList.add(new User());\n               }\n               Vector<String> groupUsers = new Vector<String>();\n               userAndGroup(usersList, groupUsers);\n               Vector<Group> groups = new Vector<Group>();\n               userAndGroup(groups, groupUsers);\n               \n               //Create the binary message by filling it.\n               Vector<Character> charVector = new Vector<Character>();\n               Vector<String> stringVector = new Vector<String>();\n               \n               for(int i = 0; i < groups.size(); i++){\n                    group.getUsers().add(usersList);\n                    groupUsers.add(usersList);\n                    group.getGroups().add(groups[i]);\n                    charVector.add(groups[i].getUser());\n                    stringVector.add(\"I am a group\" + groups[i]);\n                   }\n              \n                   //Send Binary Message.\n                   body.setCharacters(charVector);\n               \n\n               //Save binary messages.\n               int result = new SimpleFormatter().format(\"%p|%s |%p\", body,",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\tstatic final String BASEUUID2 = \"1\";\n\t\tstatic public final int PING_INTERVAL_IN_SECONDS = 60;\n\t\tstatic public final String LOCALHOST = \"127.0.0.1\";\n\t\tstatic public final String URL = \"localhost:15151\";\n\t\tstatic public final int BROADCAST_PORT = 5671;\n\t\tstatic private Hashtable<String, String> serverSettings=null;\n\t\tstatic private User user;\n\t\tstatic private ChatServerHandler chatServer;\n\t\tstatic Logger logger;\n\t\tpublic static final int MIN_SERVERCONNECTION = 20;\n\t\t\n//\t\tstatic public void setServerSettings(Hashtable<String,String> s){\n//\t\t\tserverSettings = s;\n//\t\t}\n\t\n//\t\t//this is the setServerSettings\n//\t\tprivate void setServerSettings(){\n//\t\t\t\n//\t\t}\n        /**\n\t\t * Constructor of class {@link ModernChatServer_1Test}.\n\t\t */\n        public ModernChatServer_1Test(){\n        }\n    \n\t\t/**\n\t\t * Run for {@link #ping()} and check if the Server is working.\n\t\t */\n\t\t@Test\n\t\tpublic void testPingServer(){\n\t\t\tString s = \"OK\";\n\t\t\tResultBean sBean = new ResultBean();\n\t\t\tsBean.setResult(s);\n\t\t\t//send ping to server\n\t\t\ttestResultServer(2);\n\n\t\t\tif(user.getIsOnline() ){\n\t\t\t\tif (clientSettings.getServerSocket() == null) {\n\t\t\t\tSystem.out\n\t\t\t\t.println\n\t\t\t\t(\"No Server is connected at \"\n\t\t\t\t+ user.getNick() + \". Connect server at :\" + url + \" server. \");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t\tif(getServerSettings().getServerSocket() == null)\n\t\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tSystem.out\n\t\t\t\t\t.println(\"No Server is connected at \"+user.getNick()+\". Connect server at :\"+URL);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttestResultServer(2);\n\t\t\t\n\t\t\t}else\n\t\t\t\tsBean.setResult(\"Not Connected.\");\n\t\t}\n\t\t\n\t\t/**\n\t\t * Run for {@link #ping()} after a ping to the server.\n\t\t */\n\t\t@Test\n\t\tpublic void testPingAfterPong(){\n\t\t\tif(user.getIsOnline()){\n\t\t\t\tif (clientSettings.getServerSocket() == null) {\n\t\t\t\tSystem.out\n\t\t\t\t.println(\"No Server is connected at \"\n\t\t\t\t+ user.getNick() + \". Connect server at :\" + URL);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\ttestResultServer(2);\n\t\t\t\n\t\t\t}else\n\t\t\t\tSystem.out\n\t\t\t\t.println(\"Not Connected.\");\n\t\t}\n\t\t\n\t\t/**\n\t\t * Send a message to user. Sends a message in a thread.\n\t\t * @param max the number of seconds to send a message\n\t\t */\n\t\tpublic synchronized void sendMessage(int max){\n\t\t\tint counter = 0;\n\t\t\twhile(true){\n\t\t\t\t\n\t\t\t\t//the message to be send\n\t\t\t\tBinaryMessage s2 = new BinaryMessage();\n\t\t\t\n\t\t\t\tif(clientSettings.getServerSocket() == null)\n\t\t\t\t{\n\t\t\t\t\tSystem.out\n\t\t\t\t\t.println(\"No Server is connected at \"\n\t\t\t\t\t+ user.getNick() + \". Connect server at :\" + URL);\n\t\t\t\t\t\n//\t\t\t\t\ts2.setRoomName(user.getNick());\n\t\t\t\t\t//System.out.println(s2);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//send to server\n\t\t\t\ttry{\n\t\t\t\t\tif(chatServer == null){\n\t\t\t\t\t\tchatServer = new ChatServerHandler(new ClientInterface());\n//\t\t\t\t\t\tchatServer.setUser(new User(BASEUUID2, URL));\n\t\t\t\t\t}\n\t\t\t\t\tString r2 = chatServer.sendMessage(s2);\n\t\t\t\t\ts2.setResponse(r2);\n\t\t\t\t\t\n\t\t\t\t\tif(s2.getResponseR())\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\n//\t\t\t\t\tSystem.out.println(r2);\n\t\t\t\t\t\n\t\t\t\t\tsynchronized(s",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\t\n    /**\n     * Test of runnner thread with ping request.\n     * It should wait ping result at least 5 minutes.\n     */\n    @Test\n    public void testPing(){\n        System.out.println(\"Ping for test:\");\n        Thread.sleep(5000);\n    }\n    /**\n    * Test of runnner thread with kick request.\n    * It sends the request to the server and wait if the result is true or not.\n    */\n    @Test\t\n    public void testKick() {\n        System.out.println(\"Server.kick:\");\n        Runnable runner = new ClientInterface(new IConstant(\"0.1\"), \"TestService\", \"test\");\n        Thread.sleep(5000);\n        runner.run();\n\n        assertTrue(runner.wasServerConnected());\n\n        assertTrue(runner.wasKicked());\n    }\n    /**\n    * Test of runnner thread with update contact status.\n    * It sends the request to the server and wait if the result is true or not.\n    */\n    @Test\t\n    public void testUserUpdated() {\n        System.out.println(\"Server.getUserUpdatedStatus:\");\n        Runnable runner = new ClientInterface(new IConstant(\"0.1\"), \"TestService\", \"test\");\n        Thread.sleep(5000);\n        runner.run();\n\n        assertTrue(runner.wasServerConnected());\n\n        assertTrue(runner.wasUpdatedContact());\n\n        runner.updateContactStatus(5);\n    }\n    /**\n    * Test of runnner thread with check contact status.\n    * It sends the request to the server and wait if the result is true or not.\n    */\n    @Test\t\n    public void testContactStatus() {\n        System.out.println(\"Server.checkUserUpdateStatus:\");\n        Runnable runner = new ClientInterface(new IConstant(\"0.1\"), \"TestService\", \"test\");\n        Thread.sleep(5000);\n        runner.run();\n\n        assertTrue(runner.wasServerConnected());\n\n        assertTrue(runner.wasUserUpdated());\n\n        runner.updateUserUpdatedStatus(6);\n    }\n    /**\n     * Test of runnner thread with logon request.\n     * It sends the request to the server and wait if the result is true.\n     */\n    @Test\t\n    public void testLogon() {\n        System.out.println(\"TestServer.logon:\");\n        Runnable runner = new LoginBean(17);\n        Thread.sleep(5000);\n        runner.run();\n\n        assertTrue(runner.wasServerConnected());\n\n        assertTrue(runner.wasLoggedOnByServer());\n\n        runner.updateLoginStatus(13);\n    }\n    /**\n     * Test of logon thread.\n     * It sends the request to the server and wait if the result is true or not.\n     */\n    @Test\n    public void testLogonTwice() {\n        System.out.println(\"TestServer.logonTwice:\");\n        Runnable runner = new LoginBean(0);\n        Thread.sleep(5000);\n        runner.run();\n\n        assertTrue(runner.wasServerConnected());\n\n        runner = new LoginBean(7);\n        Thread.sleep(5000);\n        runner.run();\n\n        assertTrue(runner.wasServerConnected());\n\n        runner = new LoginBean(17);\n        Thread.sleep(5000);\n        runner.run();\n\n        assertTrue(runner.wasServerConnected());\n\n        runner = new LoginBean(15);\n        Thread.sleep(5000);\n        runner.run();\n\n        assertTrue(runner.wasServerConnected());\n\n        runner = new LoginBean(17);\n        Thread.sleep(5000);\n        runner.run();\n\n        assertTrue(runner.wasServerConnected());\n\n        assertFalse(runner.wasLoggedOnByServer());\n    }\n    /**\n    * Test of logon thread with wrong key.\n    * That means",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\t// @@@ This test should be a unit test.\n\t\t@Test\n\t\tpublic void pingTest() {\n            // start server.\n\n            final ClientInterface client = ClientInterface.newInstance();\n\n            // get rid of the logger when the server is shut down.\n            Logger.global = null;\n\n            // initialize\n            final Hashtable h = new Hashtable();\n            h.put(\"chatServerBean\", new ServerSettingBean());\n            h.put(\"adminBean\", new LoginBean());\n            ClientInterface bean = new ClientInterface(h);\n\n            // add the server\n            addServer(client, bean);\n\n            // start the server.\n\n            try {\n                // wait for the server to start\n                Thread.sleep(5000);\n            } catch(Exception e) {\n                System.err.println(e);\n            }\n\n            // wait for the server to be ready\n            try {\n                // wait for the server to be ready\n                Thread.sleep(15000);\n            } catch(Exception e) {\n                System.err.println(e);\n            }\n\n            // start the server\n            startServer();\n\n            // assert isServerReady\n            try {\n                int c = 0;\n                while(true) {\n                    Thread.sleep(5000);\n                    c++;\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            assertNotNull(\"Server is not ready\", bean.getUser().getClient().isServerReady());\n\n            // shutdown the server\n            shutDownServer();\n\n            // assert isServerReady\n            assertFalse(\"Server is not ready\", bean.getUser().getClient().isServerReady());\n            \n            // assert isLogged in\n            try {\n                String s = bean.getUser().getClient().getChat().getRoom().getRoomConfiguration().getStatus().getClientStatus();\n                assertEquals(\"Status is wrong\", \"logged in\", s);\n                \n                // assert that the server is still connected.\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n            }\n            \n\n            // assert isLogged in\n            try {\n                String s = bean.getUser().getClient().getChat().getRoom().getRoomConfiguration().getStatus().getClientStatus();\n                assertEquals(\"Status is wrong\", \"logged in\", s);\n                \n                // assert that the server is still connected.\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n            }\n            \n            assertNotNull(\"Client should be logged in.\", bean.getUser().getClient().getLoggedIn());\n            \n            // assert the number has been changed\n            assertEquals(BeanFactory.getLoggedInCount()+1, bean.getUser().getClient().getLoggedIn().size());\n\n            \n\n\t\t}\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\t\n    /**\n     * set by constructor\n     */\n    private final static int PING_DELAY = 2000;\n\n    /**\n     * the server\n     */\n    private ServerInterface server = null;\n\n    /**\n     * the listener for ping\n     */\n    Runnable ping = new Runnable() {\n\n        @Override\n        public void run() {\n            // test ping\n            try {\n                ListenerBean ping = new ListenerBean(4);\n                ping.ping();\n            } catch (RemoteException e) {\n                System.err.println(e.getMessage());\n            } catch (RuntimeException e) {\n                System.err.println(e.getMessage());\n            } \n        }\n    };\n\n    /**\n     * test ping\n     */\n    @Test\n    public void ping_1Test() {\n        assertTrue(\"Ping must be ok.\" + JOptionPane.showMessageDialog(null, \"Ping must be ok.\", \"TestMessage1\", JOptionPane.ERROR_MESSAGE), ping.ping());\n    }\n\n    /**\n     * test the listening of ping thread\n     */\n    @Test\n    public void ping_2Test() throws InterruptedException, RemoteException, RemoteException {\n        Thread t = new SendKickOffByLoginMessageThread(ping, \"TestMessage2\");\n        t.start();\n        try {\n            assertTrue(\"Ping must be ok.\" + JOptionPane.showMessageDialog(null, \"Ping must be ok.\", \"TestMessage1\", JOptionPane.ERROR_MESSAGE), ping.ping());\n            t.join();\n        } catch (InterruptedException e) {\n            t.interrupt();\n        }\n        if (t!= null) {\n            t.interrupt();\n            t.join();\n        }\n        assertTrue(\"TestMessage3 must be ok.\", JOptionPane.showMessageDialog(null, \"TestMessage3 must be ok.\", \"TestMessage1\", JOptionPane.ERROR_MESSAGE));\n        Thread t2 = new SendRefreshContactThread(ping, \"TestMessage2\");\n        t2.start();\n        Thread.sleep(PING_DELAY);\n        t2.join();\n        if (t2!= null) {\n            t2.interrupt();\n            t2.join();\n        }\n        assertTrue(\"TestMessage4 must be ok.\", JOptionPane.showMessageDialog(null, \"TestMessage4 must be ok.\", \"TestMessage1\", JOptionPane.ERROR_MESSAGE));\n        Thread t3 = new SendUserUpdatedStatusThread(ping, \"TestMessage3\");\n        t3.start();\n        Thread.sleep(PING_DELAY);\n        t3.join();\n        if (t3!= null) {\n            t3.interrupt();\n            t3.join();\n        }\n        assertTrue(\"TestMessage5 must be ok.\", JOptionPane.showMessageDialog(null, \"TestMessage5 must be ok.\", \"TestMessage1\", JOptionPane.ERROR_MESSAGE) );\n    }\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tnew TestServer_1();\n\t}\n\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\t\n    /*\n     * test getters\n     *\n     * the return value of getServerName() should match the one received by ClientInterface\n\t * e.g. \n\t *\n\t * java.io.PrintWriter pw = new java.io.PrintWriter(System.out, true);\n\t * assertTrue(\"getServerName() should return the server's name\", \"test\".equals(getServerName()));\n\t * pw.close();\n     */\n\n    public static final String SERVER_NAME = \"TEST_SERVER\";\n    public static final String SERVER_BIND = \"localhost\";\n    public static final int PORT = 12345;\n    public static final String CLIENT_NAME=\"TEST_CLIENT\";\n\tpublic static final int PORT_SOCKS_ECHO = 9999;\n    public static final int PORT_SERVER = 8844;\n    public static final int PORTS_RECEIVE = PORT;\n    public static final long PORT_LONG = PORT;\n\n    @Test\n    public void testGetters() throws URISyntaxException, RemoteException, NamingException {\n        \n//        java.util.Vector<User> users = UsersService.getUsersByFirstName\n//                (\"jerry\");\n//        System.out.println(users.toString());\n        \n    }\n\t\n    @Test\n    public void testPingUser() throws URISyntaxException, RemoteException, NamingException {\n        \n        //create a client to connect to server\n        ClientInterface client = new ClientInterface(\n                new User(USER_NAME,USER_PASSWORD),\n                new ServerSettingBean(),\n                new UsersBD());\n        \n        //we have a connection to the server using the client\n        //the connection to the server can be done, but after we have just created the client and sent a ping we will have just the new login\n        //there isn't any real need to test to see if the ping receives its information\n        //the server is expected to send the response and the client will close the client\n        ResultBean res = new ResultBean(false,0,\"\");\n        \n        String msg = client.SendPingByLogin(USER_NAME,USER_PASSWORD);\n        \n        //read the messages sent into server\n        Enumeration<BinaryMessage> e = new Vector<BinaryMessage>().elements();\n        while(e.hasMoreElements()) {\n            BinaryMessage bm = e.nextElement();\n            assertTrue(StringEncrypter.ENC.getString().startsWith(\"{\"));\n        }\n\n\t\tres = new ResultBean(true,0,\"\");\n        \n        System.out.println(msg);\n        \n        //write the response to the client\n        String encode = new String(msg.getBytes(StringEncoder64.ENCODING), StringEncoder64.ENC);\n        client.SendLoginInfoByLogin(User.convertBinaryMessage(new ChatLoggingMessage(SERVER_BIND,\n                SERVER_NAME,\n                \"hello world\",\n                encode,\n                calendar.getTime(System.currentTimeMillis()),\n                \"Hello \" + USER_NAME + \"!\")));\n\n        //read the messages sent into server and check if it has the correct encoding\n        Enumeration<BinaryMessage> e2 = new Vector<BinaryMessage>().elements();\n        String encoded = new String(msg.getBytes(StringEncoder64.ENCODING), StringEncoder64.ENC);\n        while(e2.hasMoreElements()) {\n            BinaryMessage bm = e2.nextElement();\n            String message = bm.getMessage();\n            if(message.startsWith(\"{\")) {\n                break;\n            }\n        }\n        assertEquals(\"Binary message from server doesn't match the message sent by client by encoding\",\n                decode(SERVER_BIND), USER_NAME);\n    }\n    \n    @Test\n    public",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n\n// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {\n\t\t/**\n\t\t* The following 2 objects are initialized to point to a server and a registry.\n\t\t*/\n        private Object serverInterfaceRef, registryRef;\n        private Registry registry = null;\n        final StringENCODER64 decoder = new StringEncoder64();\n\n        /**\n        * Test of the method {@link ModernChatServer#ping()}.\n        */\n        @Test\n        public void testPing() {\n            System.out.println(\"ping\");\n            Ping server;\n\n            // The server thread for the clients should check the last presence of the users it was told to.\n            ServerSettingBean bean = new ServerSettingBean(IConstant.PING_SERVER_INTERFACE, IConstant.PING_SERVER_IP);\n            Registry registry = LocateRegistry.getRegistry(bean.getUrl());\n            registry.rebind(IConstant.PING_SERVER_IP, this);\n            assertTrue(registry.isRegistered(IConstant.PING_SERVER_INTERFACE));\n\n            // create a server\n            server = new Ping(registry);\n            // Register the serverInterface reference\n            server.bind();\n            // register a new thread.\n            Thread t = new Thread(server);\n            // This thread should be created once.\n            Thread serverThread = new SendRefreshContactThread(this, t);\n            // Start the server.\n            server.start();        \n\n            // The server thread for the clients should detect whether it has been\n            // able to connect to the server.\n            ServerSettingBean bean2 = new ServerSettingBean(IConstant.PING_SERVER_INTERFACE, IConstant.PING_SERVER_IP);\n            registry = LocateRegistry.getRegistry(bean2.getUrl());\n            registry.rebind(IConstant.PING_SERVER_IP, this);\n            registryRef = registry;\n            while (true) {\n                try {\n                    Calendar cal = Calendar.getInstance();\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\n                    cal.set(Calendar.MINUTE, 0);\n                    cal.set(Calendar.SECOND, 0);\n                    cal.set(Calendar.MILLISECOND, 0);\n                    int n = cal.get(Calendar.MILLISECOND);\n                    Vector users = (Vector) ((User[])registry.lookup(\"user\")).clone();\n\n                    cal.add(Calendar.MILLISECOND, -3L);\n\n                    for (int i = 0; i < users.size(); i++) {\n                        UsersBD mbr = new UsersBD(users.elementAt(i).getUserName());                        }\n                } catch (Exception e) {\n                    throw e;\n                }\n            }\n        }\n}\n\n\n/**\n* {@inheritDoc}\n*/\nclass Ping extends UnicastRemoteObject implements Runnable {\n\n\t/**\n\t * The port of the server on which the {@link ServerInterface} runs.\n\t *\n\t * If set to -1, then a random free port will be generated to the server.\n\t */\n    Ping(Registry registry) throws RemoteException {\n        super(registry);\n    }\n*/\n\tpublic Ping(Registry registry, int port) throws RemoteException {\n\t\tsuper(registry, port);\n\t}\n\n\tpublic boolean ping() {\n\t\t// This method should do what we want.\n\t\treturn true;\n\t}\n\n\tpublic void run() {\t\t\n\t\tJOptionPane.showMessageDialog (\"ping\");\n\t}\n}\n\n/**\n* {@inheritDoc}\n*/\nclass Server extends UnicastRemoteObject implements Runnable, ClientInterface {\n\n\t/**\n\t * The port which points to the server.\n\t */\n\tpublic int port;\n\n\t/**\n\t * Returns the port of the server.\n\t */\n\tpublic static int getServerPort() throws RemoteException {\n\t\tString addrString = System",
            "finish_reason": "length"
        }
    ],
    "id": "bc8bf0ed-0f35-4d5e-80ee-5b258337a260",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_1Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * any clinet ping it should receive true\n     *\n     * @return true always\n     */\n    public boolean ping() {\n        return true;\n    }\n}\n",
    "test_prompt": "// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {",
    "time_taken": 38.410035133361816,
    "usage": {
        "prompt_tokens": 1128
    }
},
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\t/**\n\t\t * {@link #MyClass}\n\t\t * Simple class that just has all the fields.\n\t\t *\n\t\t * @author ooransa\n\t\t *\n\t\t */\n\tprivate class MyClass { // no final field\n        \n        String id; // id of the user\n        String emailAddr; // email address.\n        String password; // password.\n        String ipString = \"[127.0.0.1]\"; // ip address of the user.\n        Calendar expiry = Calendar.getInstance();\n        \n        Hashtable<String,BinaryMessage> responses = new Hashtable<>();\n        Hashtable<String,User> users = new Hashtable<>();\n        Hashtable<String,String> responsesByName = new Hashtable<>();\n        Hashtable<String,Room> rooms = new Hashtable<>();\n\n        public MyClass(String email, String password) {\n\n            this.emailAddr = email;\n            this.adminUser = new LoginBean();\n            this.adminUser.setAuthToken(StringEncrypter.getInstance(this.adminUser.getAuthToken()).decrypt(email, password));\n\n            this.password = password;\n\n            String[] ids = new String[3];\n            ids[0] = StringEncoder64.decodePasswordString(this.adminUser",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\t\n    \t/**\n     * The Logger to log everything through.\n     */\n    \tprivate static  Logger getLogger(){\n        \treturn Logger.getLogger(StringEncrypter.class.getName());\n    \t}\n    \t/**\n     * This is the test main routine.\n     */\n    \tpublic static void main (String[] args)\n              throws Exception{\n    \t\tString userServerSetting = null;\n    \t\tString testMethod = null;\n    \t\tboolean exceptionTest = false;\n    \t\tSystem.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n    \t\tSystem.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n    \t\tSystem.setProperty(\"java.net.useIPAddress\", \"true\");\n    \t\tString userData = null;\n    \t\tEnumeration<String> en = System.getProperty(\"user.dir\").getCanonicalFile().toString().split(\"/\");\n    \t\tSystem.out.println(\"USER : \"+en.nextElement());\n    \t\t//for all test cases  \n\t    \twhile(testMethod!= null) {    \t\n\t    \t\tswitch(testMethod) {\n\t    \t\t\tcase \"01\": \n    \t    \t\t\t\t userData = StringEncrypter.decrypt(System.getProperty(\"",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\t@Test\n\t\tpublic void test1() {\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t\tnew SendRefreshContactThread();\n\t\t}\n\t\t@Test\n\t\tpublic void test3() {\n\t\t\tnew SendUserUpdatedStatusThread();",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\tprivate static final Logger LOG = Logger.getLogger(Test.class.getName());\n\t\t\n\t\t@Test\n        public void test_signIn() throws RemoteException, java.rmi.RemoteException {\n\t\t\tString user = StringEncrypter.randString(5, true);\n\t\t\tString pass = \"Pass\";\n\t\t\tString ipAddress = \"80.15.1.19\";\n\t\t\tString passw = StringEncoder64.encrypt(pass);\n\t\t\tBinaryMessage m = new BinaryMessage();\n\t\t\tResultBean rb  = new ResultBean();\n    \tm.reset();\n\n\t\t\tString room = \"Room1\";\n\n        \tString timeOutTimeStr  = StringEncrypter.encryptToString(StringEncrypter.minStringConstant(StringEncrypter.SECRET_KEY_LENGTH));\n       \t\tString textMessage =\"Text: \"+user+\"-\"+ipAddress+\" \"+passw+\" \"+user+\"-\"+ipAddress+\" \"+textMessage;\n\t\t\tLOG.fine(textMessage);\n\t\t\tString encryptedPassword  = StringEncrypter.encryptToString(passw);\n\t\t\tString encryptedTimeoutText = StringEncrypter.encryptToString(textMessage, StringEncrypter.SECRET_KEY_LENGTH);\n\t\t\tm.setTextMessage(textMessage);\n\t\t\tm.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\tstatic {\n\t\t\ttry {\n\t\t\t\tClass.forName(\"javax.jcr.QueryEngine\");\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\tString s = \"jce is not installed in this system\";\n\t\t\t\te.printStackTrace();\n\t\t\t\tthis.fail(s);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tString s = \"Class not found\";\n\t\t\t\te.printStackTrace();\n\t\t\t\tthis.fail(s);\n\t\t\t} catch (SecurityException e) {\n\t\t\t\tString s = \"Not allowed to use this security manager\";\n\t\t\t\te.printStackTrace();\n\t\t\t\tthis.fail(s);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tClass.forName(\"javax.jcr.Node\");\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tString s = \"jce is not loaded in the JVM\";\n\t\t\t\te.printStackTrace();\n\t\t\t\tthis.fail(s);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Method to initializes the class {@link ModernChatServer}.\n\t\t*/\n\t\tstatic void init() {\n\t\t\ttry {\n\t\t\t\tClass.forName(\"javax.jcr.Session\");\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tString s = \"Class not found\";\n\t\t\t\te.printStackTrace();\n\t\t\t\tthis",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\tprivate static final Logger getLogger() {\n\t\t\treturn Logger.getLogger(ModernChatServer_2Test.class.getName());\n\t\t}\n\n\t\tInteger port = 0;\n\t\tboolean rmi = false;//default is disable RMI\n\t\tString classPath = \"/apache/reactive/rt/\";\n\t/**\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n\t\t\t//String port = \"0\";\n\t\t} catch (URISyntaxException e) {\n\t        \tgetLogger().log(Level.SEVERE, e.getMessage());\n\t\t}\n\n        final String portString = \"0\";\n        if(System.getProperty(\"java.vendor\").startsWith(\"IBM\")){\n        \tport = Integer.valueOf(System.getProperty(\"os.name\").toLowerCase().contains(\"win\")? \"631\" : \"633\");\n        }\n        else{\n        \tport = Integer.valueOf(System.getProperty(\"os.name\").toLowerCase().contains(\"linux\")? \"631\" : \"633\") ;\n        }\n\n        JOptionPane.showMessageDialog(null, \"PORT:\" + port, \"Port Test\", JOptionPane.ERROR_MESSAGE);\n        junit",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\t\n    /**\n     * Test for {@link sendLoginMessageByCalls()};\n     * it checks the call by user and verifies message in received by client when authentication is success by server.\n     */\n    @Test\n    public void testSendLoginMessageByCalls() throws Exception {\n        JOptionPane.showMessageDialog\n        (JOptionPane.\n        create(\"Information\", \"Test message is to send\",\n           JOptionPane.DEFAULT_OPTION,\n           JOptionPane.INFORMATION_MESSAGE), null);\n\n        runLoginMessageInServerThread(null, null, null);\n    }\n}\n\n// UserTest.java\n",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\tpublic void run(String emailAddrTest, String passwordTest, String ipAddrTest) throws ConnectionError {\n\t\t\ttry {\n\t\t\t\tnew ModernChatServer();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new ConnectionError(e.getMessage());\n\t\t\t}\n\t\t}\n\n\t/**\n \t * Unit test for {@link #run(java.lang.String, java.lang.String, java.lang.String)}.\n \t * This method tests the method which sign_in is implemented.\n \t *\n \t * @throws RemoteException remoteException\n \t */\n     @Test\n    public void runSignIn() throws Exception {\n        run(\"Admin\"\n        , \"\", \"\"\n        , \"\"\n         );\n    }\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\t\n\tprivate static final Level LOG_LEVEL = Level.FINE;\n\tprivate static final Logger log = Logger.getLogger(StringEncrypter.class.getSimpleName());\n\tprivate static final String serverName = \"Foo\";\n\t\n\t@Test\n\tvoid testCreateAndSignin() throws Throwable {\n\t\tgetLogger().log(Level.FINE, \"Test createAndSignin {0}\", new Object[] {serverName});\n\t\tServerSettingBean serverSettingBean1 = new ServerSettingBean();\n\t\tserverSettingBean1.setName(serverName);\n\t\tserverSettingBean1.setMessage(ServerSettingBean.CONFIRM_SIGN_IN);\n\t\tServerSettingBean serverSettingBean2 = new ServerSettingBean();\n\t\tserverSettingBean2.setName(serverName);\n\t\tserverSettingBean2.setMessage(ServerSettingBean.ACCESS_KICK_KICKOFF);\n\t\ttry{\n\t\t\tLogicalServer server = new LogicalServer();\n\t\t\ttry {\n\t\t\t\tUser u = server.createUser();\n\t\t\t\tBinaryMessage message = new BinaryMessage();\n\t\t\t\tString ip = \"10.10.10.10\";\n\t\t\t\tString userName = u.getLoginName();\n\t\t\t\tmessage.setUserName(userName);\t\n\t\t\t\tmessage.setServerIp",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly, or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null && ipAddress!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user!= null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne!= null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd!= null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {\n\t\tpublic void runIt() throws Exception {\n\t\t\t//TODO: Create test objects that are used as inputs for the tests\n\t\t\ttry {\n\t\t\t\tServerSettingBean settingBean = User.Test_CreateSettings();\n\t\t\t\tUser testUser = new User(\"testUser\", \"testUser_desc\");\n\t\t\t\tHashtable hashObject = new Hashtable();\n\t\t\t\thashObject.put(\"testUser_desc\", \"\");\n\t\t\t\tloginBean = new LoginBean();\n\t\t\t\tServerSettingBean.setServerSettings(settingBean);\n\t\t\t\tloginBean.setSettings(settingBean);\n                ClientInterface cf = new TestClient(ServerSettingBean.getTestClientIP());\n\n\t\t\t\tlog(ServerSettingBean.SERVER_CLIENT_IP + \" \" + ServerSettingBean.SERVER_IP);\n\t\t\t\t//Get Test client ip as a string\n\t\t\t\tString strTestIpAddress = ServerSettingBean.SERVER_CLIENT_IP;\n\t\t\t\tif (ServerSettingBean.SERVER_CLIENT_IP!= null) {\n\t\t\t\t\tString[] stringArray = strTestIpAddress.split(\"@\", 2);\n\t\t\t\t\tString[] strServerIp = stringArray[0].split(\".\", 2);\n\t\t\t\t\tstrTestIpAddress = strServerIp[1];\n\t\t\t\t} else {\n\t\t\t\t\tstrTestIpAddress = '10.0.0.",
            "finish_reason": "length"
        }
    ],
    "id": "7a279a70-ac70-4c83-bdda-913c180a47d0",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_2Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Method to sing in ..\n     *\n     * @param cf : user client interface to communicate with the client\n     * @param emailAddr : user email\n     * @param password : user password\n     * @param ipAddress : user ip address\n     * @return User object if authentication correctly , or null if not exist.\n     * @throws RemoteException\n     */\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\n        LoginBean loginBean = null;\n        //authenticate User\n        //DB authentication....\n        if (emailAddr != null && password != null && ipAddress != null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            //System.out.println(\"email=\"+email);\n            User user = authenticateUser(email, password);\n            if (user != null) {\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\n                //System.out.println(\"ip=\"+ipAddress);\n                ClientInterface oldOne = connectedClients.get(user.getId());\n                if (oldOne != null) {\n                    String ipAdd = connectedClientsIPs.get(user.getId());\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\n                        sendKickOffByLoginMessageThread.start();\n                    } else {\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\n                        sendKickOffByLoginMessageThread.start();\n                    }\n                }\n                connectedClients.put(user.getId(), cf);\n                connectedClientsIPs.put(user.getId(), ipAddress);\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                loginBean = new LoginBean();\n                loginBean.setUser(user);\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                loginBean.setAuthToken(clientAuthToken);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n",
    "test_prompt": "// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {",
    "time_taken": 15.666637420654297,
    "usage": {
        "prompt_tokens": 1744
    }
},
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\t\n    private ServerInterface serverInterface = new ModernChatServer();\n    /*public final static String SERVER_PING_PERSISTENT = ServerSettingBean.SERVER_PING_PERSISTENT.getServerSettingString();\n    public final static String SERVER_REFRESH_PERSISTENT = ServerSettingBean.SERVER_REFRESH_PERSISTENT.getServerSettingString();\n    public final static String TAG_SERVER_PING_REQUEST_TO = \"Ping Request to\";\n    public final static String TAG_SERVER_REFRESH_REQUEST_TO = \"Refresh Request to\";\n    public final static String TAG_SERVER_PING_TIMEOUT = \"Ping Request timeout\";\n    public final static String TAG_SERVER_REFRESH_TIMEOUT = \"Refresh Request timeout\";*/\n    public final static String TAG_TEST = \"Test\";\n    public final static String TAG_SINGLETON = \"Singleton\";\n    \n    public final static Vector<ResultBean> RESULT_ENCRYPTION;\n    public final static Vector<BinaryMessage> BINARY_MESSAGE_ENCRYPTION;\n    public final static Vector<User> USER_ENCRYPTION;\n    \n\t@Test\n    public void testChangePassword() {\n        String user = serverInterface.changePassword(TAG_SERVER_PING_PERSISTENT+TAG_SERVER_REFRESH_PERSISTENT+TAG_SERVER_REFRESH_TIMEOUT+TAG_TEST, TAG_SERVER_REFRESH_REQUEST_TO, TAG_SINGLETON);\n        assertNotNull(user);\n            //get connection\n        serverInterface.close();\n    }\n    \n    \n}\n\n\n",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\t/**\n\t\t * @param args the command line arguments\n\t\t */\n\t\t@Test\n\t\tpublic void test01ModifyPassword() {\n\t\t\ttry {\n\t\t\t\tfinal int newPassStrength = 12;\n\t\t\t\tfinal int newPassLength = newPassStrength * 3;\n\t\t\t\tfinal ClientInterface c = new ClientInterface(ServerSettingBean.getInstance().getServerPassword());\n\t\t\t\tfinal Vector<User> users = usersBD.getAll(); // should be empty as there are 0 users\n\t\t\t\tusers.removeAllElements();\n\t\t\t\t// create users\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tusers.addElement(new User(StringEncoder64.encodeUTF8(\"m_\" + i), \"\" + newPassStrength));\n\t\t\t\t\tusersBD.updatePassword(users.get(i).getId(), StringEncrypter.getInstance(secToken).decrypt(newPassStrength));\n\t\t\t\t}\n\t\t\t\t// create new users\n\t\t\t\tfor (int i = 1; i < 7; ++i) {\n\t\t\t\t\tusers.addElement(new User(StringEncoder64.encodeUTF8(\"m_\" + i), newPassLength));\n\t\t\t\t\tusersBD.updatePassword(users.get(i).getId(), newPassLength);\n\t\t\t\t}\n\t\t\t\t// change old password\n\t\t\t\tPasswordEncoder.update(c.getPassword());\n\t\t\t\tString newPassword = PasswordEncoder.getInstance(secToken).encrypt(c.getPassword());\n\t\t\t\t// change new password\n\t\t\t\tString newPass = StringEncrypter.getInstance(secToken).decrypt(newPassword);\n\t\t\t\tc.changePassword(StringEncrypter.getInstance(secToken).decrypt(oldPass), newPass, newPass);\n\t\t\t\t// verify all changes were applied\n\t\t\t\t//assertTrue(\"The password has not changed.\", (newPass == passwordEnc.getTextBufferCopy(c.getPassword())));\n\t\t\t\tfinal UsersBD users2 = UserBD.getInstance(new UsersBD.Client(c));\n\t\t\t\tlong count = 0;\n\t\t\t\tVector<String> currentPasswords = users2.getCurrentPasswords();\n\t\t\t\tfinal int oldPassStrength = UsersBD.getInstance(ServerSettingBean.getInstance().getServerPassword()).getCurrentPassStrength();\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tString currentPassword = users2.getPasswordByUser(users.get(i).getId());\n\t\t\t\t\tif ((users2.getLastLogIn() > Calendar.getInstance().getTime()) || (newPassStrength == UsersBD.getInstance(ServerSettingBean.getInstance().getServerPassword()).getCurrentPassStrength())) {\n\t\t\t\t\t\tcount = users2.updateUnseen(users.get(i).getId(), oldPassStrength",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\tpublic static void main(String[] args) {\n\t\t\ttry {\n\t\t\tString s = \"Please enter your First name. Please enter Your second name.\";\n\t\t\t\tSystem.out.println(\"Your Name : \" + s);\n\t\t\t\tString s2 = \"Your password is *\";\n\t\t\t\tString p = StringEncrypter.getInstance(secToken).decrypt(p);\n\t\t\t\tSystem.out.println(\"New Password : \" + p);\n\t\t\t\tString n = StringEncrypter.getInstance(secToken).decrypt(n);\n\t\t\t\tSystem.out.println(\"New Password : \" + n);\n\t\t\t} catch (RemoteException ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t@Test\n\t\tpublic void test_1()\n\t\t\t\tthrows Throwable {\n\t\t\t\tSystem.out.println(\"*** Test: 1 ***\");\n\t\t\t\ttry {\n\t\t\t\t\t// Set Up Server\n\t\t\t\t\tSystem.out.println(\"---Setting up server...\");\n\t\t\t\t\tString s = \"Test 1\";\n\t\t\t\t\tint i = Integer.valueOf(StringEncrypter.getInstance(secToken).decrypt(i));\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\n\t\t\t\t\tHashtable h = new Hashtable();\n\t\t\t\t\th.put(new String(), new String());\n\t\t\t\t\th.put(\"Test\", new String());\n\t\t\t\t\tString s2 = \"Test 2\";\n\t\t\t\t\tint j = Integer.valueOf(StringEncrypter.getInstance(secToken).decrypt(i));\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\t// 1. Initialization\n\n\t\t\t\t\t// 2. Initialization\n\n\t\t\t\t\t// 3. Initialization\n\n\t\t\t\t\t// 4. Initialization\n\n\t\t\t\t\t// 5. Initialization\n\n\t\t\t\t\t// 6. Initialization\n\n\n\t\t\t\t\t// 7. Initialization\n\n\t\t\t\t\t// 8. Initialization\n\n\t\t\t\t\t\t// This thread will start the pinger process in 30 seconds.\n\t\t\t\t\t// This is the simplest case. So the pinger will be initialized at this point.\n\t\t\t\t\t// The initation of the server object cannot be done here. The server is\n\t\t\t\t\t// initialized as a thread in a new thread so all the pinger will run at the same time.\n\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\tSystem.err.println(\"Server 1 started.\");\n\t\t\t\t\tLogger.getLogger(\"\").setLevel(Level.OFF);\n\t\t\t\t\tLogger localLogger = Logger.getLogger(\"\");\n\t\t\t\t\t// localLogger.setLevel(Level.ERROR);\n\t\t\t\t\tSystem.err.println(\"Server Initialization in Thread : \" + Thread.currentThread().getName());\n\t\t\t\t\tSystem.err.println(\"Server Initialization in Thread : \" + Thread.currentThread().getName());\n\n\t\t\t\t\t// Here we create the pinger Thread\n\t\t\t\t\tSystem.err.println(\"Initializating Ping thread.\");",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\t\n}\n\n/**\n* Class performs testing with the runnable for the pings the user thread.\n*/\npublic final class TestRunnablePingUsers {\n\tObject s = null;\n\t\n\t@Test\n\tpublic void run(){\n\t\t//TODO: test this\n\n\t\t/*\n\t\tString s = \"\";\n\t\tString sUserPassword = \"\";\n\t\tInteger i = 0;\n\t\twhile(i == 0)\n\t\t{\n\t\t\ts = RandomString.getString();\n\t\t\ti = 0;\n\t\t}\n\t\t*/\n\t}\n\t\n\tpublic void pingUsers() {\n\t\t\n\t\t\n\t\tObject obj = new Object();\n\t\tObject obj_S = null;\n\t\tObject obj_l_login_logoff = null;\n\t\tHashtable<String, String> hashPings = new Hashtable<String, String>();\n\t\thashPings.put(\"s\", \"\");\n\t\tobj_l_login_logoff = new Object();\n\t\t\n\t\tint i = 0;\n\t\t\n\t\t\n\t\tJOptionPane.showMessageDialog(null, \"Hello World\");\n\t\ttry {\n\t\t\twhile (i < 100) {\n\t\t\t\tS.ping(s);\n\t\t\t\tThread.sleep(500);\n\t\t\t}\n\t\t\t\n\t\t\twhile (obj_l_login_logoff.getClass().getName().startsWith(\"com.interlog\")) {\n\t\t\t\t//wait for login_logoff_thread to stop it\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception ex) {\n\t\t\tLogger.getLogger(\"\").log(Level.WARNING, \"Error during testing, Object was not set.\", ex);\n\t\t\tJOptionPane.showMessageDialog(null, \"Error during testing, Object was not set.\", \"\" + this.getClass().getName());\n\t\t}\n\t\t\n\t\t\n\t\twhile (i < 100) {\n\t\t\ti++;\n\t\t\tif (obj.getClass().getName().startsWith(\"com.interlog\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tassertTrue(i == 100);\n\t\tInteger p_ = ((Integer) (obj)).intValue();\n\t\tLogger.getLogger(\"\").log(Level.INFO, \"Number of users: {0}\", p_);\n\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\t\n}\n\n// end of class",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\t@Test\n\t\tpublic  void testChPassword() {\n\t\t\tString email = \"user@gmail.com\";\n\t\t\tString oldPassword  = \"password\";\n\t\t\tString newPassword  = \"newpassword\";\n\n\t\t\tSystem.out.println(\"Change Password with :\"+oldPassword+\" \"+newPassword);\n\n\t\t\tResultBean result = changePassword(email, oldPassword, newPassword);\n\t\t\tString passString = passwordEnc.encrypt(newPassword);\n\n\t\t\tif (result.getResultCode() == IConstant.SUCCESS) {\n\t\t\t\tSystem.out.println(\"Password Changed\");\n\t\t\t\tassertNotNull(result.getValidationErrors());\n\t\t\t\tassertTrue(result.getValidationErrors().isEmpty());\n\n\t\t\t\tassertTrue(oldPassword.equals(passString));\n\t\t\t\tassertTrue(newPassword.equals(passString));\n\n\t\t\t\tVector<Group> groups = groupsDAO.getAllGroups(\"\");\n\t\t\t\tVector<User> users = usersDAO.getAllUsers(\"\");\n\t\t\t\tVector<Room> rooms = roomsDAO.getAllRooms(\"\");\n\t\t\t\tHashtable<String, String> roomIds = roomsDAO.getRoomIds(\"\");\n\t\t\t\tboolean check = true;\n\t\t\t\tboolean checkGroup = true;\n\t\t\t\tfor (ServerSettingBean setting: serverSettingDAO.loadServerSettingBean(\"group\")) {\n\t\t\t\t\tcheck = true;\n\t\t\t\t\tfor (User u: users) {\n\t\t\t\t\t\tif (StringEncrypter.getInstance(\"newEncrypt\").isPresent(u.getNickName())) {\n\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (checkGroup) {\n\t\t\t\t\t\tif (!setting.isGroup()){\n\t\t\t\t\t\t\tSystem.out.println(\"Group Check...\");\n\t\t\t\t\t\t\tSystem.out.println(\"Group Name : \"+setting.getName()+\" Is Group? \"+setting.isGroup());\n\t\t\t\t\t\t\tSystem.out.println(\"Group Admin : \"+setting.isAdmin());\n\t\t\t\t\t\t\tif (setting.isGroup()) {\n\t\t\t\t\t\t\t\tfor (Vector<User> v: groups) {\n\t\t\t\t\t\t\t\t\tfor (Vector<Group> g:groups) {\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(g.get(0).getId()+ \" - \"+g.get(0).getName()+\" - \"+g.get(0).getDescription());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEnumeration<Group> groupEnum = groups.elements();\n\t\t\t\tEnumeration<User> uEnum = users.elements();\n\t\t\t\twhile (check) {\n\t\t\t\t\twhile (uEnum.hasNext()) {\n\t\t\t\t\t\tUser u = uEnum.next();\n\t\t\t\t\t\tif (u.getId().equals(oldPassword)) {",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\t// Server interface\n\t\tprivate ClientInterface clientInterface;\n\t\tprivate ClientInterface clientInterface2;\n\t\tprivate ClientInterface clientInterface3;\n\n\t\tprotected static UnicastRemoteObject localPortServiceRef;\n\t\tprotected static UnicastRemoteObject remotePortServiceRef;\n\t\tprotected static String serverName = \"server1\";\n\n\t\tprotected static ServerInterfaceServer server;\n\t\tprotected static String serverPort;\n\n\t\tprotected static String userUidName = \"uid\";\n\t\tstatic String userPassword = \"user0\";\n\n\t\tprotected static UsersBD usersBD = new UsersBD();\n\t\t\n\t\t// Client interface for pong test\n\t\tClientInterface pongClient;\n\n\t\t\n\t\t/**\n\t     * @throws URISyntaxException\n\t     * @throws RemoteException\n\t     */\n\t    @Test\n    \tpublic void RunServer() throws RemoteException, URISyntaxException{\n\t        \n\t        String remoteHost = \"test.org\";\n\t        String remotePort = \"8888\"; \n\t        \n\t        System.setProperty(\"javax.net.host\", remoteHost);\n\t        System.setProperty(\"javax.net.ssl.trustStore\", \"server.jks\");\n\t        System.setProperty(\"javax.net.ssl.trustStorePassword\", \"serverpass\");\n\t        System.setProperty(\"javax.net.ssl.trustStoreType\", \"PKCS12\");\n\n\t        System.setProperty(\"javax.net.debug\", \"all\");\n\n\n\t        System.setProperty(\"java.net.preferIPv4Stack\", \"false\");\n\t        System.setProperty(\"java.net.preferIPv6Addresses\", \"false\");\n\t        System.setProperty(\"java.net.ipv4.acceptTrailingSlash\", \"true\");\n\n\t        try (Registry reg = LocateRegistry.getRegistry(remoteHost, remotePort)) {\n\t            System.setProperty(\"javax.net.ssl.trustStore\", reg.toString());\n\t        } catch (Exception ex) {\n\t            ex.printStackTrace();\n\t        }\n\n\t        Thread.sleep(300000);\n\n\t        // Create new remote port object\n\t        remotePortServiceRef =\n\t                new UnicastRemoteObject(new ModernChatServer(remotePort)); \n\t        server = \n\t                (ServerInterfaceServer) remotePortServiceRef.invoke(remoteHost, \"getServer\", new Object[0]); \n\t        localPortServiceRef = remotePortServiceRef;\n\n\t        // Create and start service ref\n\t        clientInterface =  \n\t                new UnicastRemoteObject(new ModernChatServer(\"localhost\"), null); \n\n\t        // Create and start service ref\n\t        ",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\t/**\n\t\t * Change Password\n\t\t */\n    @Test\n    void test_change_password_1() {\n        changePassword(LoginBean.EMAIL, ServerSettingsBean.PASSWORD, ServerSettingsBean.PASSWORD);\n    }\n\t\t\t/**\n\t\t\t * Create the message in server.\n\t\t\t */\n    @Test\n    void test_create_message_1() {\n        BinaryMessage message = new BinaryMessage(ServerSettingsBean.TEXT, IConst.USER_CREATED, \"Test User\", \"0\");\n\n        MessageReceived messageObj = new MessageReceived(User.class, message);\n\n        // send the message\n        server.executeCommand(messageObj);\n\n        // check the result\n        ResultBean result = new ResultBean(true, IConst.SUCCESS, null);\n\n        // print the result\n        printResult(result);\n    }\n\t\t/**\n\t\t * Create the group in server.\n\t\t */\n    @Test\n    void test_create_group_2() {\n        User currentUser = UsersBD.getCurrentUser();\n        String name = ServerSettingBean.GROUP_NAME + \"/\" + System.currentTimeMillis();\n        Vector<User> users = new Vector<>();\n        Vector<String> groups = new Vector<>();\n        users.add(currentUser);\n        groups.add(ServerSettingBean.GROUP_NAME);\n\n        try {\n            // create the group\n            MessageReceived groupAddedMessage = new MessageReceived(Group.class, BinaryMessage.createGroup(name, groups, \"1\"));\n\n            messageObj = new MessageReceived(Group.class, groupAddedMessage);\n\n            // send the message in server\n            server.executeCommand(groupAddedMessage);\n\t\t} catch (Exception e) {\n\t\t\tMessageReceived createGroupMessage = new MessageReceived(Group.class, BinaryMessage.createGroup(ServerSettingsBean.GROUP_NAME, groups, \"1\"));\n\n\t\t\tserver.executeCommand(createGroupMessage);\n\t\t}\n\n        // print the result\n        printResult(new ResultBean(true, IConst.SUCCESS, null));\n    }\n        @Test\n\tvoid test_find_id() throws Exception {\n\t    User user = UsersBD.getCurrentUser();\n\t    Vector<User> users = new Vector<>();\n\t    users.add(user);\n\t    Hashtable<String, String> hashtable = new Hashtable<>(2);\n\t    hashtable.put(LoginBean.EMAIL, user.getEmail());\n\t    hashtable.put(ServerSettingBean.ACCOUNT, user.getAccount());\n\t    hashtable.put(ServerSettingsBean.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\t\n    /**\n     * Test suite for {@link osa.ora.server.threads.SendRefreshContactThread Class}.\n     */\n    @Test\n    public void refreshContact_Thread() {\n    \tString address = \"127.0.0.1\";\n    \tlong port = 3201;\n    \t\n        try {\n            \n            Registry rmiReg = (Registry) Naming.lookup(address);\n            System.out.println(\"rmiReg : \\n\" + rmiReg);\n            \n            ClientInterface clienti = (ClientInterface) UnicastRemoteObject.exportObject(new ClientInterface(address, port), 0);\n            ClientInterface clienti2 = (ClientInterface) UnicastRemoteObject.exportObject(new ClientInterface(address, port), 1);\n            \n            Registry rmiReg2 = (Registry) Naming.lookup(address);\n            System.out.println(\"rmiReg2 : \\n\" + rmiReg2);\n            \n            Group g = createG(1);\n            \n            // send getRoom,getGroup and getRoom\n            \n            Room room01 = createRoom(1);\n            Room room02 = createRoom(2);\n            \n            // test 1\n            \n            result = clienti.getRoom(room02.getId());\n            assertNotNull(result);\n            assertEquals(IConstant.SUCCESS, result.getResult());\n            \n            // test 2\n            \n            ResultBean result_01 = getResult(clienti,room01.getId());\n            assertNotNull(result_01);\n            assertEquals(IConstant.SUCCESS, result_01.getResult());\n            \n            // test 3\n            \n            Set<User> users = new HashSet<User>();\n            users.add(getUser(clienti));\n        \n        //    try {\n        //         List<String> message = clientBD.getContactList(address, \"all\");\n        //         message = clientBD.getMemberList(address);\n        //         message = clientBD\n        //             .getUserList(address, \"all\");\n        //         message = clientBD.queryGroupByName(address, \"all\");\n        //         message = clientBD.queryRoomByName(address, \"all\");\n        //         Logger.getLogger(this.getClass().getName()).log(Level.INFO, \"{0} contactList : {1}, userList : {2}\", new Object[]{address, message, users.toString()});\n        //     } catch (RemoteException e) {\n        //         // TODO Auto-generated catch block\n        //         e.printStackTr",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {\n\t\tprivate final String user = \"Admin3\";\n\t\tprivate final String password = \"passwd3\";\n\t\tprivate final ResultBean expected;\n\t\tprivate final ClientInterface client;\n\n\t\tpublic ModernChatServer_3Test(ResultBean expected, ClientInterface client)\n\t\t\t\t{this.expected = expected; this.client = client;}\n\n\t\t@Test\n\t\tpublic void changePassword_Test() throws RemoteException {\n\t\t\tClientInterface client = new ClientInterface(false);\n\t\t\ttry {\n\n\t\t\t\tBinaryMessage binaryMessage = new BinaryMessage(BinaryMessage.TYPE_BINARYMESSAGE_NEWPASS, String.valueOf(user) + \"/\" + String.valueOf(password) + \"/\" + serverSettingBean.getConcat(serverSettingBean.getConcat().replaceAll(\".\", \"=\")));\n\t\t\t\tlog(binaryMessage.toString());\n\t\t\t\tSendRefreshContactThread thread = new SendRefreshContactThread(client);\n\t\t\t\tthread.start();\n\t\t\t\tThread.sleep(1000);\n\t\t\t\tSendUserUpdatedStatusThread sut = new SendUserUpdatedStatusThread(client);\n\t\t\t\tsut.start();\n\t\t\t\tSendUserUpdatedStatusThread sut_1 = new SendUserUpdatedStatusThread(client);\n\t\t\t\tsut_1.start();\n\t\t\t\tSendRefreshContactThread sut_2 = new SendRefreshContactThread(client);\n\t\t\t\tsut_2.start();\n\n                String userPassword = user + \"/\" + password;\n\n                changePasswordByLogin(user, password);\n\t\t\t\tcheckResult(expected);\n            sendTextMessage(user, \"This is sent by the server\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tLogger.getLogger(\"ServerTestServer\").log(Level.WARNING, e.getLocalizedMessage());\n\t\t\t\tfail(e.getLocalizedMessage());\n\t\t\t}\n\n\t\t}\n\t}\n\n\n// Old Test Class\n// class OldTestClass {\n//\tServerSettingBean serverSettingsBean = ClientInterface.getServerSettingsBean();\n//\tServerSetupBd serverSetupBd = new ServerSetupBd();\n//\tVector<String> userList = new Vector<String>();\n//\tOldTestClass() throws Exception {\n//\t\t\n//\t\tfor(int i=0; i<100; i++) {\n//\t\t\tuserList.add(\"admin\" + i);\n//\t\t}\n//\t\t\n//\t}\n//\t\n//\t\n//\t\n//\tpublic void createNewGame(String newGameId) throws java.rmi.RemoteException {\n//\t\tCreateNewGameThread createNewGameThread = new CreateNewGameThread(serverSetupBd, serverSettingsBean, new Game.Game_t1, newGameId);\n//\t\tcreateNewGameThread.start();\n//",
            "finish_reason": "length"
        }
    ],
    "id": "db34ffe1-2f8c-4128-b302-de6b134d76d9",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_3Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * change user password\n     *\n     * @param email : user email\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean with either true or false\n     * @throws RemoteException\n     */\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\n        email = StringEncoder64.decodeStringUTF8(email);\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        User user = authenticateUser(email, newOldPass);\n        if (user == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\n            passwords.put(user.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n",
    "test_prompt": "// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {",
    "time_taken": 27.729771852493286,
    "usage": {
        "prompt_tokens": 1430
    }
},
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\t\n    @Test\n    void test_ServerInterface() {\n        Registry registry = LocateRegistry.getRegistry();\n        BinaryMessage response = (BinaryMessage) UnicastRemoteObject.exportObject(\"BinaryMessage\", 2, null);\n        BinaryMessage response2 = (BinaryMessage) UnicastRemoteObject.exportObject(\"BinaryMessage\", 2, null);\n        try {\n            registry.rebind(\"serverInterface\", new GenericServer(null));\n        } catch (Exception e) {\n            // nothing to be done here.\n        }\n        log.log(Level.INFO, \"BinaryMessage = \" + binaryMessage);\n        log.log(Level.INFO, \"BinaryMessage2 = \" + binaryMessage2);\n        log.log(Level.INFO, \"ServerInterface = \" + registry.lookup(\"serverInterface\"));\n\n    }\n\n    \n    @Test\n    void test_ServerInterface_1() {\n        LocateRegistry registry = LocateRegistry.getRegistry();\n        log.log(Level.INFO, \"Server Interface lookup = \" + registry.lookup(\"serverInterface\"));\n\n    }\n    \n    @Test\n    void test_sendPkChangeAdmin_success() {\n\n        boolean login = false;\n        Boolean status = new Boolean(false);\n        try {\n            int index = 0;\n            // test\n            String result2 = changeAdminPassword(\"admin\", \"admin\", \"admin\").getCode();\n            System.out.println(\"Index: \" + index);\n            // change Admin password by administrator\n            log.log(Level.INFO, \"Test changeAdminPassword\");\n            status = UsersBD.changeAdminPassword(\"admin@localhost\", \"admin\", \"admin\"), new Boolean(status);\n            log.log(Level.INFO, \"Change password by Administrator: success = \" + status);\n        } catch (Exception e) {\n            System.out.println(\"LoginError\");\n            if (login) {\n                log.log(Level.INFO, \"LoginError: Try Again!\");\n                login = false;\n            }\n            log.log(Level.INFO, \"Try again, status = \" + status);\n        }\n    }\n    \n    @Test\n    void test_sendPkChangeAdmin_failed() {\n\n        String result = sendPkChangeAdmin(\"admin\", \"admin\", \"admin\"), StringEncoder64.decrypt(\"admin\");\n        log.log(Level.INFO, \"changeAdminPassword result = \" + result);\n        if (result.equals(\"ok\")) {\n\n        }\n    }\n    \n    @Test\n    void test_sendRefreshContact_success() {\n\n        String result = refreshContact(), StringEncoder",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\t\n    //Test the {@link #changePassword(String,String,String)};\n\n\tprivate String userId;\n\n\t@org.junit.jupiter.api.Disabled\n    public void setUp() throws Exception {\n        log.setLevel(Level.CONFIG);\n        \n\t\tString testStr = \"This is the first test String\";\n\t\tStringEncrypter.genKey(\"test\", testStr);\n\t\tStringEncrypter.genKey(\"test\", testStr);\n\t\tlog.log(Level.INFO, StringEncrypter.getInstance().encrypt(testStr));\n\t\t\n        ServerSettingBean settingBean = new ServerSettingBean();\n        settingBean.setKey(\"test\");\n        settingBean.setValue(1);\n        settingBean.setEnabled(true);\n        settingBean.setDescription(\"This is just a test\");\n\t\tStringEncoder64.genKey(\"test\", settingBean);\n        \n        PasswordChangeListener listener = new PasswordChangeListener();\n        settingBean.setPasswordChangeListener(listener);\n        StringEncoder64.genKey(\"test\", settingBean);\n        \n        serverSettingBean = new ServerSettingBean();\n        serverSettingBean.setKey(\"test\");\n        serverSettingBean.setUserId(\"jill\");\n        serverSettingBean.setValue(0);\n       \n        settingBean.setName(\"jill\");\n        settingBean.setValue(0);\n        settingBean.setEnabled(true);\n        settingBean.setDescription(\"\");\n        serverSettingBean.setName(\"jill\");\n        \n        Setting.setServerSettingBean(settingBean);\n\t\t\n\t\tVector<User> users = new Vector<User>();\n\t\tusers.add(adminUser);\n\t\tusers.add(jillUser);\n        \n        UsersBD.createUsers(users);\n\n        // Initialization\n        clientSettingBean = new ClientSettingBean();\n        clientSettingBean.setValue(0);\n\t\tsettingBean = new ServerSettingBean();\n        settingBean.setKey(\"test\");\n        settingBean.setUserId(\"jill\");\n        settingBean.setValue(1);\n\n        clientSettingBean = new ServerSettingBean();\n        Setting.setClientSettingBean(settingBean);\n                \n\t}\n\n\t@Test\n\tpublic void test1adds() throws IOException, URISyntaxException {\n\t\t\n\t\tBinaryMessage binaryMessage = new BinaryMessage();\n\t\tbinaryMessage.setUserId(\"jill\");\n\t\tbinaryMessage.setType(\"test1add\");\n    \tbinaryMessage.setStatus(BinaryMessageStatus.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\t/**\n\t\t* Test method for {@link osa.ora.server.modernchat.server.ModernChatServer#changeAdminPassword(java.lang.String, java.lang.String, java.lang.String)}.\n\t\t* @throws RemoteException\n\t\t*/\n    @WithServer(address = \"localhost:8000\")\n    @Test\n    public void test() throws RemoteException {\n        String userName = \"test@localhost.net\";\n        String password = \"password\";\n        int i = 0;\n        while (true) {\n            int n = i++;\n            switch (n) {\n                case 5:\n                    passwords.put(userName, password);\n                    break;\n                case 9: // No Password : no Admin\n                    passwords.remove(userName);\n                    break;\n                default:\n                    break;\n            }\n        }\n        sendUserChanged(1); // change password\n        sendRefresh(1); // change password\n        int i1 = SendKickOffByLoginMessageThread.KICK_OFF_THREAD_ID;\n        ServerSettingBean userSet = usersBD.getServerSetting(userName);\n        String status = SendUserUpdatedStatusThread.UPDATE_STATUS;\n        System.out.println(\"Send userChanged() \");\n        sendUserChanged(2); // send userChanged()\n        sendRefresh(2); // send refresh()\n           \n        ServerSettingBean userSet1 = usersBD.getServerSetting(userName);\n        assertFalse(userSet1.getServerTime() == 0); // must not expire server time after user change\n        assertFalse(userSet.getServerTime() == 0); // must not expire server time after user change\n        \n        usersBD.setServerSetting(userName, userSet);\n        ServerSettingBean userSet2 = usersBD.getServerSetting(userName);\n        assertTrue(userSet2.getServerTime() < userSet.getServerTime()); // check if no change was done yet\n        assertTrue(userSet1.getServerTime() == 0); // server time must not change between send userChanged() and refresh\n       // sendUserChanged(3); // send no change\n        sendUserChanged(4);\n        sendRefresh(4);\n        \n        i = SendRefreshContactThread.ID;\n        sendUserChanged(i); // Send userChanged()\n        sendRefresh(i);\n        sendUserChanged(100);\n        sendUserChanged(100);\n        sendUserChanged(400);\n        \n        System.out.println(\"sendUserChanged() \");\n        int i2 = SendKickOffMessageThread.KICK_OFF_THREAD_ID;\n        String newPassword = StringEncrypter",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\t\n\tprivate static User adminUser = null;\n\tprivate static ClientInterface admin = null;\n\tprivate static User serverUser = null;\n\tprivate static ServerSettingBean serverSetting = null;\n\tprivate static String oldPassword = null;\n\tprivate static String newPassword = null;\n\tprivate static Vector<String> passwords = null;\n\tprivate static ClientInterface c = null;\n\tpublic static String serverHost = null;\n\tpublic static String serverAdmin = null;\n\n\tpublic static Hashtable<String, ClientInterface> servers = new Hashtable<>();\n\tpublic static Hashtable<String, String> passwords = new Hashtable<>();\n\n\tstatic ServerInterface server = null;\n\n\tpublic static ServerSettingBean serverSetting_new = null;\n\n\tpublic  @Test\n\tvoid TestServer(){\n\t\ttry{\n\t\t\tSystem.err.println(\"TestServer\");\n\t\t\tSystem.err.println(\"Start TestServer with \" + (String) StringEncoder64.encodeLiteral(\"  \" + \"admin:admin@ADMIN_HOST\" + \"  \" + \"admin:PASSWORD\" + \"  \" + \"server:ADMIN_HOST\" + \"  \" + \"server:PASSWORD\" + \"  \" + \"server:HOSTNAME\" + \"  \" + \"server:PORT\");\n\n\t\t\tstart(server) ;\n\n\t\t\tfor(Enumeration e = servers.keys()\n\n\t\t\t{\n\n\t\t\t\tSystem.err.println(\"Server:\" + e.next());\n\n\t\t\t\tassertTrue(\"Server : Server is Null!\", e.hasMoreElements());\n\t\t\t\tassertTrue(\"Password is Null!\", passwords.has(e.next()));\n\t\t\t}\n\n\n\t\t\tSystem.err.println(\"Stop TestServer\");\n\t\t\tstopServer() ;\n\t\t} catch (Exception e){\n\n\t\t\te.printStackTrace();\n\n\t\t}\n\n\t}\n\n\tpublic void start(ServerInterface s) throws Exception{\n\n\t\t\tif(serverHost == null){\n\n\t\t\t\ttry {\n\t\t\t\t\tstartServer(s, true);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tSystem.err.println(\"Starting server fail : \" + e);\n\t\t\t\t}\n\t\t\t}else{\n\n\t\t\t\tserver.setHost(s);\n\t\t\t\tserver.start();\n\t\t\t\tassertTrue(\"Server started successfully\", server.isStarted());\n\t\t\t}\n\n\n\t}\n\n\tpublic void start(ServerInterface s, boolean startServer) throws Exception {\n\t\tif(s == null){\n\n\t\t\tserver = s;\n\t\t\tstartServer(s, startServer);\n\t\t}else{\n\n\t\t\tserver.setAddress(s);\n\n\t\t}\n\t}\n\n\tpublic int runServer(String protocol, String serverURL, String userID, String pwd) throws Exception{\n\n\t\tString host = StringEncrypter.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\t\n    /**\n     * A simple logger with file handler and date format for files.\n     */\n    private static final Logger LOGGER = Logger.getLogger(ModernChatServer.class.getName());\n    /**\n     * A simple logger with string encoder (that encodes to and from the\n     * original ISO-8859-1 character set for compatibility with\n     * older releases than 1.6.x).\n     */\n    private static final StringEncoder64 STRING_ENCODER64 = StringEncoder64.INSTANCE;\n    /**\n     * A simple logger for logging messages in the console.\n     */\n    private static final Logger logger = Logger.getLogger(ModernChatServer.class.getName());\n    /**\n     * The directory for the logs.\n     */\n    private static String LOG_DIRECTORY;\n    /**\n     * Whether the installation is in error state or not.\n     */\n    private boolean error;\n    \n\t\n    /**\n     * A simple listener that prints the results in the console.\n     */\n    private boolean listener;\n\n    /**\n     * A listener that prints the status of the server.\n     */\n    private boolean listenerStatus;\n    \n\t\n         /**\n         * @param args the command line arguments\n         */\n\tpublic static void main(String[] args) {\n        new ModernChatServer_4Test().testChangeAdminPasswordOfServer();\n\t}\n\t\n    /**\n     * Creates the server with the two main interface, <code>Runnable</code> and <code>ServerInterface</code>.\n     */\n    private void testChangeAdminPasswordOfServer() {\n\t\t\n        try {\n            //Create the listener\n            listener = true;\n            listenerStatus = true;\n\t\t\t\n            Calendar c = Calendar.getInstance();\n\t\t\t\n            //Get current time\n            long gmtime = System.currentTimeMillis();\n            long gmnow = gmtime;\n            //Current datest\n            String[] months = {\"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n            String currentMonth = months[c.get(Calendar.MONTH)];\n            String[] years = {\"\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n            String currentYear = years[c.get(Calendar.YEAR)];\n            \n            logger.info(\"Started the server installation test.\");\n            //logger.info(currentMonth + \"/\" + currentYear);\n            LOGGER.info(\"Current date is \" + currentMonth + \"/\"",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\t\n    /**\n     * This example test create a new server, set up a server interface and a thread\n     * for it to run.\n     */\n    @Test\n    public void run() throws SecurityException, NoSuchMethodException, RemoteException, java.rmi.RemoteException {\n        //Server setting\n        int serverPort = 8080;\n        boolean portUp = true;\n        String bindDir = \"bin\"+FileHandler.getMappedFileSeparator() + \"daemon\"+FileHandler.getMappedFileSeparator() + \"localhost\"+FileHandler.getMappedFileSeparator() + \"localhost\"+FileHandler.getMappedFileSeparator() + \"localhost\"+FileHandler.getMappedFileSeparator()+\"bin\"+FileHandler.getMappedFileSeparator()+\"chat\"+FileHandler.getMappedFileSeparator();\n        String key = \"\";\n        String appSecretKey = \"\";\n        String privateKey = \"\";\n        String secToken = \"\";\n        \n        //Server setting\n        ServerSettingBean serverSetting = new ServerSettingBean();\n        serverSetting.setPort(serverPort);\n        serverSetting.setPortUp(portUp);\n        serverSetting.setBindDir(bindDir);\n        serverSetting.setAppSecretKey(appSecretKey);\n        serverSetting.setKey(key);\n        serverSetting.setSecToken(secToken);\n        \n        //get server setting\n        String getSetting = ((String) Naming.lookup(\"//127.0.0.1:8080 +\"+bindDir).replace(\"localhost\", \"127.0.0.1\")).replace(\"127.0.0.1\", \"localhost\");\n        serverSetting = new ServerSettingBean();\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(\"JAVA_HOME\", \"/home/ubuntu\");\n        env.put(\"PATH\", \"/home/ubuntu/bin\");\n        env.put(\"HOME\", \"/home\");\n        env.put(\"OPTIONS\", \"-Djava.security.debug=info,debug\");\n        env.put(\"OS_PROMPT\", \">\");\n        env.put(\"JAVA_OPTS\", \"-Djava.endorsed.dirs=\" + env.get(\"PATH\"));\n        env.put(\"JAVA_TOKEN\", serverSetting.getSecToken());\n        env.put(\"USER_SECRET\", serverSetting.getKey());\n        env.put(\"PRIVATE_KEY\", serverSetting.getKey()+\" \"+serverSetting.getSecToken());\n        String serverString=\"ModernChatServer {java.vendor} -D",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\tpublic final static String ADMIN = \"admin\";\n\t\tpublic final static String USERNAME = \"username\";\n\t\t\n\t\t/**\n\t\t * @throws URISyntaxException\n\t\t * @throws RemoteException\n\t\t */\n\t\t@Test\n\t\tpublic void setAdminPassword() throws URISyntaxException, RemoteException {\n\t\t\tnew ServerSettingBean().update(true, null);\n\t\t\tassertEquals(true, changeAdminPassword(USERNAME, ADMIN, UG_PWD));\n\t\t\t//assertEquals();\n\t\t}\n\n\t\t/**\n\t\t * @throws URISyntaxException\n\t\t * @throws RemoteException\n\t\t */\n\t\t@Test\n\t\tpublic void changeAdminName() throws URISyntaxException, RemoteException {\n\t\t\tUsersBD usersBD = new UsersBD();\n\t\t\tnew ServerSettingBean().update(true, null);\n\t\t\tUsersBean adminUser = new UsersBean();\n\t\t\tadminUser.setEmail(ADMIN);\n\t\t\tadminUser.setFirstName(\"firstName\");\n\t\t\tadminUser.setLastName(\"lastName\");\n\t\t\tadminUser.setPasswordRandomized(UG_RANDOM);\n\t\t\tusersBD.update(adminUser);\n\t\t\tUsersBean username = new UsersBean();\n\t\t\tusername.setFirstName(\"firstName\");\n\t\t\tusername.setLastName(\"lastName\");\n\t\t\tusername.setEmail(\"username@name.com\");\n\t\t\tusername.setPassWroteAtTime(UG_PWD);\n\t\t\tusersBD.update(username);\n\t\t\tUsersBean newUser = new UsersBean();\n\t\t\tusername.setFirstName(\"firstName4\");\n\t\t\tusername.setLastName(\"lastName4\");\n\t\t\tusername.setEmail(\"username\");\n\t\t\tnewUser.setFirstName(\"firstName10\");\n\t\t\tnewUser.setLastName(\"lastName10\");\n\t\t\tnewUser.setPassword(\"pwd10\");\n\t\t\tusersBD.update(newUser);\n\t\t\tuserBean = usersBD.getUserByID(username.getId());\n\t\t\tnewUser.setEmail(\"username.com\");\n\t\t\tnewUser.setFirstName(\"firstName11\");\n\t\t\tnewUser.setLastName(\"lastName11\");\n\t\t\tusersBD.updateUserAuths(username);\n\t\t\tusersBD.updateGroup(administrators, new User());\n\t\t\t\n\t\t\tassertEquals();\n\t\t\tassertNotNull(userBean);\n\t\t\tassertFalse(userBean.getPassword().equals(UG_PWD));\n\t\t\tassertEquals(true, changeAdminPassword(userBean.getEmail(), ADMIN, newUser.getPassword()));\n\t\t\tusersBD = null;\n\t\t\t\n\t\t\tLogger.getLogger(StringEncrypter.ENCRYPTION_CLASS).put(\"encrypted-password\",",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\t\n  private IConstant adminUser;\n  private Calendar cr =  Calendar.getInstance();\n  private User adminUser;\n\n\tprivate FileHandler handler = null;\n\t\n    /** Main method. */\n    public static void main(String[] args) throws RemoteException, InterruptedException{\n        try {\n\t\t \tServerSettingBean serverSettingBean = new ServerSettingBean();\n\t            serverSettingBean.updateServer(Integer.parseInt(System.getProperty(\"server.port\")));\n\t            String server = \"/Users/\" + \n\t    \t            StringEncoder64.getInstance(secToken).encode( System.getProperty(\"user.name\"));\n\t            serverSettingBean.updateSetting(server);            \n\t            \n        } catch (URISyntaxException ex) {\n\t\t\tLogger.getLogger(ModernChatServer.class.getName()).log(Level.SEVERE, \"Server Exception\", ex);\n        }\n    }\t\n\n  /**\n   * Run the test without {@link ServerInterface#run()} method.\n   *\n   * @throws URISyntaxException.\n   * @throws RemoteException.\n   * @throws InterruptedException.\n   */\n  @Test\n  public void testRunWithoutArgument() throws URISyntaxException, RemoteException, InterruptedException {\n    adminUser = new User();\n    adminUser.setId(1);\n    adminUser.setIp(\"10.0.0.1\");\n    adminUser.setName(\"admin\");\n    adminUser.setUserStatus(IConstant.ENABLED);\n\n    try (Registry registry = LocateRegistry.getRegistry(Integer.parseInt(System.getProperty(\"server.port\")), 1000)) {\n      new ClientInterface();\n    }\n    \n    /* Start threads. */\n    final String passwordEncoder;\n    final String passwordEnc;\n    final String adminUserPassword;\n    final String adminUserAddr;\n    final String oldPassword;\n    final Hashtable<String, String> passwords = new Hashtable<String,String>();\n    \n    int threadCount = 5;\n    for (int i = 0; i < threadCount; i++) {\n      final String passwordEnCoder = StringEncrypter.getInstance(secToken).encrypt(UUID.randomUUID().toString());\n      final String userPasswordEnc = StringEncrypter.getInstance(passwordEnCoder).encrypt(passwordEnCoder);\n      if (i == 0) {\n        oldPassword = passwordEncoder;\n        adminUserPassword = userPasswordEnc;\n        adminUserAddr = UUID.randomUUID().",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\t\n\n    /**\n     * Create an instance of an Interface for the server.\n     * You should use the {@link IConstant_4Test} class of \n     * {@link ServerInterface#IConstant_4Test} for the test class of {@link ServerInterface#runClient(String, String)}. \n     * @param id : Admin user id\n     * @param ip : Admin ip\n     */\n    public static void runServer(String id, String ip) {\n        System.out.println(\"Server started : \"+id+\" \"+ip+\" on \"+Calendar.getInstance());\n\t\ttry {\n\t\t\tSystem.setProperty(ConfigInterface.SEC_URL, ConfigInterface.SEC_URL_FULL);\n\t\t\tSystem.setProperty(ConfigInterface.KEY_PW, ConfigInterface.KEY_PW_FULL);\n\t\t\tSystem.setProperty(ConfigInterface.NODE_ID, ConfigInterface.NODE_ID_FULL);\n\t\t\t//LoginBean loginBean = signInAsAdmin(id, ip, \"\");\n\t\t\tint port = ConfigInterface.RESULT_PORT;\n       \t\t//String tmpStr = \"jdbc:mysql://\"+id+\":\"+ip+\"/\"+ConfigInterface.RESULT_DB;\n       \t\t//System.out.println(\"My driver name is \"+tmpStr);\n       \t\t//System.out.println(\"Result DB is \"+ConfigInterface.RESULT_DB);\n       \t\tClass.forName(\"com.mysql.jdbc.Driver\");\n \t\t\t  //Class.forName(\"org.postgresql.Driver\");    \t\t\t\t\n \t\t\t  //MyDriver myDriver = (MyDriver)DriverManager.getDriver(\"org.postgresql.Driver\");\t  \n \t\t\t  //System.out.println(\"ResultDB is \"+ConfigInterface.RESULT_DB);\n \t\t\t  //ConfigInterface.RESULT_DB = \"default.server\";\n\t\t\t  if (id.startsWith(\"admin\")) {\n\t\t\t\t  //int i = 0;\n\t\t\t\t  IntUnsignedArray iArray = new IntUnsignedArray();\n\t\t\t\t  iArray.readFromFile(iPath);\n\t\t\t\t  //System.out.println(\"iArray: \"+iArray);\n\t\t\t\t  System.out.println(\"admin : \"+ConfigInterface.NODE_ID_FULL);\n\t\t\t\t  iArray.valueOf_0.setUnsignedInt(iArray.valueOf_0.getUnsignedInt()+1);\n\t\t\t\t  if (iArray.valueOf_0.getUnsignedInt() <= Integer.MAX_VALUE && ConfigInterface.NODE_ID_FULL.equals(iArray.valueOf_0.getUnsignedInt())) {\n     \t\t\tSystem.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n\n// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {\n\t\tclass ServerSetupBean extends UnicastRemoteObject implements ServerSettingBean {\n\t\t\tServerSetupBean(JFrame frame, ClientInterface client, int port) { \n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getServerAddr() {\n\t\t\t\treturn \"localhost\";\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int getPort() {\n\t\t\t\treturn 9897;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getServerDomain() {\n\t\t\t\treturn \"\"; //$NON-NLS-1$\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean verifySSL() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tpublic void setAdminPassword(String newAdminPass, String newOldPass) throws IOException, InterruptedException {\n\t\t\t\ttry {\n\t\t\t\t\tclient.updateServerPassword(adminUser.getId(), newOldPass, newAdminPass);\n\t\t\t\t}\n\t\t\t\tcatch (RuntimeException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tcatch (RemoteException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tpasswords.put(adminUser.getId(), newAdminPass);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void startServer() {\n\t\t\t\ttry {\n\t\t\t\tnew ServerSetupBean(frame, client, 9897).startServer();\n\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void stopServer() {\n\t\t\t\ttry {\n\t\t\t\tnew ServerSetupBean(frame, client, 9897).stopServer();\n\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean validateConfirmation(String oldPassword, String newPassword) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tpublic void checkPasswordConfirmation(String newEmail) throws IOException, InterruptedException {\n\t\t\t\tObject[] array = new User[1];\n\t\t\t\ttry {\n\t\t\t\tClientInterface client = new ClientInterface(newEmail, 9897);\n\t\t\t\tnew UsersBD(client);\n\t\t\t\tvector = vector.add(newUser);\n\t\t\t\tUsersBD test = (UsersBD) client;\n\t\t\t\ttest.updatePassword(adminUser.getId(), oldPassword, newPassword);\n\t\t\t\tusersBD.updateCount(oldPassword, -1);\n\t\t\t\thashtable = hashtable.add(newUser);\n\t\t\t\tUsersBD.test2();\n\t\t\t\ttest2 = UsersBD.test2();\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tcatch (RemoteException e) {\n\t\t\t\t\tthrow",
            "finish_reason": "length"
        }
    ],
    "id": "f821d836-4de9-400d-a9a2-9f1aaea212b4",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_4Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Change admin password\n     *\n     * @param emailAddr : email of the admin\n     * @param oldPass : current password\n     * @param newPass : new password\n     * @return ResultBean : return status\n     * @throws RemoteException\n     */\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\n        if (loginBean == null) {\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\n        }\n        oldPass = passwordEnc.encrypt(oldPass);\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\n        newPass = passwordEnc.encrypt(newPass);\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\n            passwords.put(adminUser.getId(), newPass);\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\n    }\n}\n",
    "test_prompt": "// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {",
    "time_taken": 27.635420083999634,
    "usage": {
        "prompt_tokens": 1430
    }
},
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\t\n\t/** The server instance to use. */\n\tObject osaClient;\n\t\t\n\t/** The server instance we should use for the test case. */\n\tObject connectedClients = new Hashtable();\n\t\n\t/** The registered clients. */\n\tVector<ClientInterface> registeredClients = new Vector<ClientInterface>();\n\t\n\t/**\n\t * The chat server start with one server and each user have a different one.\n\t * The test case should only do the following steps:\n\t * 1.  construct a Server instance\n\t * 2.  register a server instance\n\t * 3.  send one user text message\n\t * 4.  send one message\n\t * 5.  re-register a server instance to let the server run\n\t * @throws Exception\n\t */\n\t@Test\n\tvoid testSendSecureTextMessageWithDifferentServer() throws Exception {\n\t\t//1. Construct the server instance we should use.\n\t\tosaClient = new UsersBD();\n\t\t\n\t\t//2. Register user interface for client.\n\t\tServerSettingBean setting = new ServerSettingBean();\n\t\t//setting.setMaxSize(3);\n\t\tsetting.setUsername(\"UserName\");\n\t\tsetting",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\tString encodedClientLoginMessage = null;\n    String encodedPassword = null;\n     int clientServerPort = 9101;\n    boolean encrypt = true;\n    public final static int SERVER_PORT = 9899;\n\t\t\n    ServerSettingBean setting;\n    ClientInterface cli = null;\n\n\t@Test\n\tpublic void SendSecureTextMessage() throws RemoteException, URISyntaxException {\n\t\tsetting = settingBean(SERVER_PORT);\n\t\tSetting.write(\"ServerConfigurationSetting\", Setting.getSetting(setting));\n\n\t\t// Send a \"send-secure-text\" message to the client(s)\n\t\tString encryptedMessage = StringEncoder64.encode(\"Hello \",encrypt);\n\t\tClientInterface cf = new ClientInterface(setting, encryptedMessage);\n\t\tsendSecureTextMessage(new TextMessage(\"send_secure_text\", cf));\n\t\t//assert that no exception is thrown\n\t}\n\t@Test\n\tpublic void SendSecureTextMessage2() throws RemoteException, URISyntaxException {\n\t\tsetting = settingBean(SERVER_PORT);\n\t\tsetting.setAttribute(IConstant.CONTROL_ENCRYPTION_KEY, true);\n\t\tsetting.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\t\n\tprivate static final Logger logger = Logger.getLogger(\"\");\n\n\t@org.junit.jupiter.api.Test\n\tvoid testSendRoomMessage(){\n\t\t\n\t\t// 1. Create User with 1-3 groups\n\t\t// 2. Connect to Chat Server\n\n\t\t// 3. Send text message for user\n\t\t// 4. Verify result\n\t\t\n\t}\n\t\n\t@org.junit.jupiter.api.Test\n\tvoid testSendUserUpdateStatus(){\n\t\t\n\t\t// 1. Create User with 1-3 groups\n\t\t// 2. Connect to Chat Server\n\n\t\t// 3. Send text message for user\n\t\t// 4. Verify result\n\t}\n\t\n\t@org.junit.jupiter.api.Test\n\tvoid testSendUserGroup(){\n\t\t// 1. Create User with one group and 2-3 users in that groups\n\t\t// 2. Connect to Chat Server\n\n\t\t// 3. Send text message for user\n\t\t// 4. Verify result\n\t\t\n\t}\n\t\n\t@org.junit.jupiter.api.Test\n\tvoid testSendUserUpdateInRoom(){\n\t\t// 1. Create User with 1-3 groups\n\t\t// 2. Connect to",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\t\n\t/**\n\t*\n\t*/\n\t@Test\n\tpublic void sendSecureTextMessage_01() throws RemoteException {\n\t\t\n\t\tServerSettingBean setting = new ServerSettingBean();\n\t\tsetting.setHost(\"192.168.1.5\");\n\t\tsetting.setIp(\"192.168.1.6\");\n        setting.setPort(\"80\");\n        setting.setUser(\"user1\");\n        ServerInterface server = new ServerInterface();\n\t\ttry {\n            System.out.println(\"Connect server at \" + setting.buildDn());\n            System.out.println(server.connect(setting));\n\t\t\t//loop on connected clients\n            User user = User.getUsers().get(0);\n\t\t\tif (user!= null) {\n                BinaryMessage msg = new BinaryMessage();\n                msg.setTargetType(IConstant.USER_CHAT);\n                msg.setFromUserId(user.getId());\n                msg.setToUserId(user.getId());\n\t\t\t\tBinaryMessage result = new BinaryMessage();\n\t\t\t\t\n\t\t\t\tUserInterface user2 = new UserInterface();\n\t\t\t\tresult.setTargetType(user2.getId());\n\t\t\t\tresult.setFrom",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\t\n    @Test\n        public void testSend_NormalBinaryMessage() throws RemoteException {\n        ClientInterface cf = null;\n        BinaryMessage m = null;\n        BinaryMessage sm = null;\n        for (int i = 0; i < IConstant.TOTAL_NUM; i++) {\n            cf = new ClientInterface();\n            m = new BinaryMessage();\n            m.setTargetType(IConstant.USER_CHAT);\n            m.setToUserId(getTestUsers().size());\n            cf.setBinaryMessages(m);\n            cf.setBinaryMessageId(m.getMessageId());\n\n            sm = new BinaryMessage();\n            for (int j = 0; j < IConstant.TOTAL_NUM; j++) {\n                cf.setBinaryMessages(m);\n                cf.setBinaryMessageId(m.getMessageId());\n                m = new BinaryMessage();\n                m.setToUserId(getTestUsers().size());\n                cf.setBinaryMessages(m);\n                cf.setBinaryMessageId(m.getMessageId());\n            }\n\n            sendSecureTextMessage(sm);\n\n        }",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\tprivate static ServerSettingBean defaultServerSettingBean = null;\n\t\tprivate static Calendar cal;\n\t\t/**\n\t\t * Constructor for {@link ModernChatServer_5Test}\n\t\t */\n\t@Test\n\tpublic void test_constructor() throws RemoteException {\n\t\t/*\n\t\t * This test just makes sure the method can create a new instance.\n\t\t */\n\t\ttry {\n\t\t\tnew ModernChatServer();\n\t\t\tfail(\"Exception expected\");\n\t\t} catch (UnknownUserException unue) {\n\t\t\t//we expect our exception\n\t\t\t\n\n\t\t}\n\t}\n\t\n\t/**\n\t * Testcase to create a new instance of ModernChatServer and send it a message with no encrypted message.\n\t */\n\t@Test\n\tpublic void test_createInstance() throws RemoteException, IllegalAccessException, InstantiationException, NullPointerException {\n\t\t/*\n\t\t * This test just makes sure the method can create a new instance.\n\t\t */\n\t\t\n\t\ttry {\n\t\t\t/*\n\t\t\t * Set the system property: system.library.dir=x\n\t\t\t */\n                        System.setProperty(IConstant.PROPERTY_JAVA_LIBRARY_PATH_SET, \"/path\");\n\t\t\t",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\t\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws RemoteException, URISyntaxException {\n        //Create an RMI registry\n        //Registry registry = Naming.lookupRegistry(\"rmi://localhost:1099/?registryName=\" + IConstant.REG_DESIRED);\n        //Logger logger = Logger.getLogger( \"Test\" );\n        //Set up the logger to use\n        Logger logger = Logger.getLogger(\"\");\n        //Set up a simple handler (no format)\n        FileHandler defaultHandler = new FileHandler(\".*\\\\..*\");\n        defaultHandler.setFormatter(null); //Do not use SimpleFormatter\n        //Set up a simple handler (using format)\n        //DefaultHandler defaultHandler = new DefaultHandler(); //Just use the SimpleFormatter. This is OK\n        //Set up a simple handler (with format)\n        //DefaultHandler defaultHandler = new DefaultHandler(new SimpleFormatter()); //Use SimpleFormatter\n        \n\n        //Instantiate new instance\n        //A new instance of modernchatServer using class name\n        //registry.rebind(\"/RegistryName",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\t\n    /**\n     * Test case that is called with two instances of {@link ClientInterface#sendSecureTextMessage(BinaryMessage)}.\n     *\n     * Two instances of ClientInterface are created with 3 users.\n     * The result of sending the secure message is checked with 3 users.\n     */\n    @Test\n    void sendToManyUsersTest() throws JOptionPane, URISyntaxException {\n        int[] tempUsers = null;\n        Vector<User> tempUsersToSend;\n        for (int i = 0; i < 2; i++) {\n            tempUsers = User.getAll();\n            tempUsersToSend = new Vector<User>();\n            //loop on users\n            for (int j = 0; j < tempUsers.length; j++) {\n                if (tempUsers[j].getId() == (i == 0? 2 : 3)) {\n                    tempUsersToSend.add(tempUsers[j]);\n                }\n            }\n            int testResult = sendSecureTextMessage(new BinaryMessage(null));\n            assertEquals(testResult, 3); //there should be 3 users for each message.\n            assertTrue(isSecureMessageOfType(tempUsers",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\tstatic class IUser implements IUserBean {\n\n\t\t\t@Override\n\t\t\tpublic String getFriendName(User user) {\n\t\t\t\treturn user.getFriendName();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getFriendUrl(User user) {\n\t\t\t\treturn user.getFriendUrl();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getGroupShortOrUrl(User user) throws Exception {\n\t\t\t\tif (user.getGroupId()!= -1) {\n\t\t\t\t\tGroup group = UsersBD.getGroupById(user.getGroupId());\n\t\t\t\t\treturn group.getGroupShortedOrUrl();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getGroupUrl(User user) throws Exception {\n\t\t\t\tGroup group = UsersBD.getGroupByUserId(user.getId());\n\t\t\t\treturn group.getGroupShortedOrUrl();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getMaxRoomSize(){\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic User getCurrentUser() throws RemoteException{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getCurrentClientId() {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tstatic class I",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\n// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {\n\t\t\n\tprivate ClientInterface getClientById(String id) {\n\t\tClientInterface cf = null;\n\t\tEnumeration<ClientInterface> e = UnicastRemoteObject.getMethods(ClientInterface.class);\n\t\twhile (e.hasMoreElements()) {\n\t\t\tcf = e.nextElement();\n\t\t\tVector<Object> v = new Vector<Object>();\n\t\t\tv.add(id);\n\t\t\tEnumeration<Object> i = cf.remoteCall(\"Remote method\");\n\t\t\twhile (i.hasMoreElements()) {\n\t\t\t\tv.add(i.nextElement());\n\t\t\t}\n\t\t\te = v.elements();\n\t\t}\n\t\tassertNotNull(\"There are no connection with the user\");\n        return cf;\n\t}\n\n\tprivate ClientInterface getServerByClientByUser(String id, String userToConnect) {\n\t\tClientInterface cf = null;\n\t\tVector<ClientInterface> v = null;\n\t\tv = new Vector<ClientInterface>();\n\t\tv.add(getClientById(id));\n\t\tUnicastRemoteObject.setRemoteMethod(\"Remote method\",v);\n\t\tv = UnicastRemoteObject.invokeAndWait(new SendUserUpdatedStatusThread(),null);\n\t\t",
            "finish_reason": "length"
        }
    ],
    "id": "b399b913-66ef-468a-8588-2a501b43140b",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_5Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send text message but securly (i.e. encrypted)\n     *\n     * @param msg : the message to be send\n     * @return boolean : true/false if the text message send or not.\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextMessageToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers != null && tempUsers.size() > 0) {\n                //loop on users\n                boolean success = false;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers != null && tempUsers.length > 0) {\n                boolean success = false;\n                //loop on users\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i] != msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (sendSecureTextMessageToUser(msg, cf)) {\n                            success = true;\n                        }\n                    }\n                }\n                if (success) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n",
    "test_prompt": "// ModernChatServer_5Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_5Test {",
    "time_taken": 14.499050378799438,
    "usage": {
        "prompt_tokens": 1778
    }
},
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\t\n\tpublic static final String LOGIN_USER = \"test\";\n    static final String USER = \"user\";\n    static final String ROOM = \"room\";\n    private static final int TIMEOUT_SECOND = 30;\n    private final DateFormat dateFormat = new SimpleFormatter(new StringEncrypter());\n\t\n\tprivate UsersBD userRepository = new UsersBD();\n\tprivate ClientInterface clientInterface = new ClientInterface();\n\tprivate ClientInterface clientInterfaceIP = new ClientInterface();\n\tprivate ServerSettingBean serverSetting;\n\tprivate Room room;\n\t\n\t@Test\n\tpublic void test() {\n\t\tClientInterface cf = clientInterface;\n\t\tclientInterfaceIP = clientInterfaceIP;\n        try {\n            serverSetting = Naming.lookup(\n                    \"rmi://localhost:\" + cf.getRMIPort() + \"/server/user/\"\n                    + cf.getServerSettingBean().getServerSetting().getServerName()\n                    + \"/\"\n                    + cf.getClientSettingBean().getSetting());\n        } catch (Exception ex) {\n            System.err.println(\"Server setting could not be found...\\n\");\n        }\n        \n\t\tHashtable<String, User> usersHash;\n\t\tusersHash = new Hashtable<String, User>(5);\n\t\ttry {\n\t\t\tusersHash.put(USER, new User(USER));\n\t\t\tusersHash.put(ROOM, new Room(ROOM, USER, new Date()));\n\t\t} catch (RemoteException ex) {\n\t\t\tSystem.err.println(\"user has not been added to table \");\n\t\t}\n        userRepository = new UsersBD(usersHash);\n\t\t\n\t\ttry {\n\t\t\tString[] groupData;\n            groupData = \"groupData\".toCharArray();\n\t        groupData[2] = \"\";\n\t        groupData[3] = \"User\";\n            groupData[4] = \"User\";\n\t        groupData[5] = \"User\";\n\t        groupData[6] = \"User\";\n\t        \n            Enumeration<String> groups = userRepository.enumerateGroups();\n\t        while (groups.hasMoreElements()) {\n\t            String groupName = groups.nextElement();\n\t            Vector<String> groupData2 = new Vector<String>();\n\t            String groupType = groupRepository.getGroupType(groupName);\n\t            groupData2.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\t\n    JOptionPane lastSelectedOptionPane = null;\n    String lastSelectedOptionValue;\n    @Test\n    void runTest() throws InterruptedException, NamingException, UnsatisfiedLinkError, MalformedURLException, URISyntaxException {\n        getLogger().log(Level.INFO, \"Start test\");\n//        new StartTest().test();\n//        String str = lastSelectedOptionPane.getValue();\n    }\n\t\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\tprivate ClientInterface client = null;\n\t\tprivate ClientInterface lastClient = null;\n\n\t\t/**\n\t\t* This method is a test method, it has an impact for the other class\n\t\t*/\n\t\t@Test\n\t\tpublic void test1() {\n\t\t\ttry {\n\t\t\t\t//creating client\n\t\t\t\tSystem.out.println(\"Starting to create a serverclient for user\" + \" \" + User.getUserID());\n\t\t\t\tClientInterface clientFactory = new ClientFactory();\n\t\t\t\tStringEncoder64 encoder = new StringEncrypter(true, false, new SimpleFormatter());\n\t\t\t\tthis.lastClient = clientFactory.newUnicastClient(User.getUserID(), \"localhost\", \"9\", \"secretkey\");\n\n\t\t\t\t//creating users\n\t\t\t\tVector clients = new Vector();\n\t\t\t\tclients.add(this.lastClient);\n\n\t\t\t\t//creating server\n\t\t\t\tRegistry registry = LocateRegistry.getRegistry();\n\t\t\t\tthis.lastClient.setUserLoggedByServer(true);\n\t\t\t\tthis.lastClient.setServerSetting(\"Offline_login\", \"Server is offline for your account\");\n\t\t\t\tthis.lastClient.setServerSetting(\"Admin_login\", \"Server is offline for your account\");\n\t\t\t\tthis.lastClient.setServerSetting(\"Client_login\", \"Server is offline for your account\");\n\t\t\t\tclient = clientFactory.newClient(\"localhost\", 9);\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"Starting to connect to all users\");\n\t\t\t\tVector contacts = new Vector();\n\n\t\t\t\tcontacts.add(this.lastClient);\n\t\t\t\tclient.initialize(contacts);\n\n\t\t\t\t//creating server setting for admin\n\t\t\t\tclient.setAdminSetting(\"Admin_login\", \"The admin client has been set to a server!\");\n\t\t\t\tSystem.out.println(\"Starting to login admin\");\n\t\t\t\tString adminText = new String();\n\t\t\t\tadminText = client.login(User.getUserID(), \"\", \"admin\", \"secretkey\");\n\t\t\t\tSystem.out.println(\"Sending admin online TextMessage\");\n\t\t\t\tTextMessage text = new TextMessage(adminText);\n\t\t\t\tSystem.out.println(\"Sending online TextMessage\");\n\n\t\t\t\t//starting the runnment for server\n\t\t\t\tsendServerMessage(text, clients);\n\n\t\t\t\t//informing\n\t\t\t\tVector usersOnServer = usersOnServer(clients);\n\t\t\t\tsendUsersOnServer(usersOnServer);\n\t\t\t\t\n\t\t\t\tclient.close();\n\n\t\n\t\t\t} catch (RemoteException ex) {\n\t\t\t\ttry {\n\t\t\t\t\tgetLog",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\t\n    /**\n     * This is the Test Case we want to test.\n     * For more details see:\n     * https://forum.orac4.com/topic/r-server-send-binary-message\n     *\n     * Send binary message from text message to admin of client.\n     * @throws RemoteException\n     * @throws Exception\n     */\n    @Test\n    public void testSendBinaryMessage() throws RemoteException, Exception {\n        StringEncoder64 s = new StringEncoder64(255);\n        for (int i = 1; i <= 40; i++) {\n            String s1 = StringEncrypter.utf64Encode(\"Hello World\");\n            String s2 = StringEncrypter.utf64Encode(\"Hello\");\n            String s3 = StringEncrypter.utf64Encode(\"Hello\");\n        }\n\n        Vector<String> vec = new Vector<>(0);\n        ServerSettingBean sb = new ServerSettingBean(\"1\", \"1\", false, 30, 100, 0, 8);\n        sb.setFromUserID(\"1\");\n        sb.setToUserID(\"3\");\n        sb.setIsAdmin(true);\n        sb.setIsEnable(true);\n        sb.setEnableOffline(true);\n        sb.setOfflineUserListSize(200);\n        sb.setIsNotifyOnline(true);\n        sb.setOnlineSize(10);\n        sb.setOnlineMinutes(20);\n        String toString = sb.toString(), fromString = sb.fromString(s).toString();\n        String[] sa = toString.split(\"\\n\");\n        for (String n : sa) {\n            n = n.toLowerCase().trim();\n            if (n.length() > 0) {\n                System.out.println(n);\n//                Vector<String> vec = new Vector<>(0);\n//                String fromString = sb.fromString(n);\n//                System.out.println(StringEncrypter2.decode(sb.toString().replace(StringEncrypter2.replaceAll(\"\\\"\", \"'\"), String.valueOf(fromString))));\n            }\n        }\n        \n        for (int i = 1; i <= 40; i++) {\n            String s1 = StringEncrypter.utf64Encode(\"Hello World\");\n            String s2 = StringEncrypter.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\tpublic static String ROOM_NAME = \"Room1\";\n\t\tpublic static String ROOM_ID = \"Room1\";\n\t\t\n\t@Test\n\tpublic void test1() throws Exception {\n\t\tServerSettingsBean serverSettingsBean = new ServerSettingsBean();\n\t\tSystem.setProperty(ServerSettingsBean.ENCRYPT_USER_KEY_FILE, \".\");\n\t\tSystem.setProperty(ServerSettingsBean.LOGIN_USER_KEY_FILE, \".\");\n\n\t\t//ServerSettingsBean.ENCRYPT_USER_KEY_FILE = \"../etc/password.txt\";\n\t\tServerSettingsBean.ENCRYPT_USER_KEY_FILE = \"../etc/encrypt_user_key_12345678.txt\";\n\t\tServerSettingsBean.LOGIN_USER_KEY_FILE = \"../etc/encrypt_user_key_12345678.txt\";\n\n\t\t//ServerSettingsBean.SEND_KICK_OFF_MESSAGE_COUNT = 5;\n\t\t//ServerSettingsBean.SEND_KICK_OFF_MESSAGE_INTERVAL = 3600000;\n\t\t\n\t\t//ServerSettingsBean.SEND_USER_MESSAGE_SEARCH_INDEX = 10;\n\t\tServerSettingsBean.SEND_USER_MESSAGE_SEARCH_INTERVAL = 3600000;\n\t\tServerSettingsBean.SEND_USER_MESSAGE_QUERY_ROLES = \"room1,billing\";\n\t\tServerSettingsBean.SEND_USER_MESSAGE_QUERY_DETONES = \"hello!\";\n\t\tServerSettingsBean.SEND_USER_MESSAGE_QUERY_LOBBY_GEO = \"1,200\";\n\n\t\t//ServerSettingsBean.SEND_FIND_CLIENT_DATA_INTERVAL\n\t\t//ServerSettingsBean.SEND_FIND_CLIENT_DATA_TIMEOUT = 60000;\t\n\n\t\ttry {\n\t\t\tRegistry registry = LocateRegistry.getRegistry(ClientInterface.CLIENT_ID);\n\t\t\tregistry.rebind(\"OldClientID\", new ClientInterface(ClientInterface.CLIENT_ID, ClientInterface.CODE));\n\n\t\t\tLogger logger = Logger.getLogger(UltimateChatServer_8Test.class.getName());\n\t\t\tlogger.setLevel(Level.FINE);\n\t\t\tFileHandler handler = new",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\t\n    //This is a test class of {@link ModernChatServer}\n\t@Test\n    public void testSendBinaryMessage() {\n        //This is the message to be sent\n        //\"hello world!\"\n\n        //This method will be called by the server thread.\n        //It will write message to server file\n\t\ttry {\n            int i = 0;\n\t\t\twhile (i < 100)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"Test method # \" + (i/100));\n\t\t\t\tString testMessage = StringEncrypter.encrypt64(\"hello world!\"+\"\\nHello World!\"+\"\\n\");\n\t\t\t\t//String testString = StringEncrypter.encrypt64(testMessage+\"\\n\");\n                //System.out.println((testString));\n                //sendBinaryMessage(new BinaryMessage(testString));\n                //sendBinaryMessage(BinaryMessage.parse(\"hello world!\"));\n\t\t\t\tsendBinaryMessage(BinaryMessage.parse(\"hello world!\"));\n\t\t\t\tString message = StringEncrypter.encrypt64(\"hello world!\"+\"\\nHello World!\"+\"\\n\");\n\t\t\t\t//System.out.println((message));\n\t\t\t\t//sendBinaryMessage(new BinaryMessage(message));\n\t\t\t\tBinaryMessage binaryMessage = new BinaryMessage(message);\n\t\t\t\tsendBinaryMessage(binaryMessage);\n\t\t\t\tif(i < (100*2))\n\t\t\t\t\ttry {\n                        if (i==100){\n                            System.out.println(\"This is the end!\");\n                        }\n                        else System.out.println(\"The message is not correct, its \" + StringEncrypter.encrypt64(\"The message is not correct, its \" + binaryMessage.getData().length + \" bytes is incorrect\"));\n                    }\n                    catch (Exception ex) {\n                        //Do nothing\n                    }\n\t\t\t    i++;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t        e.printStackTrace();\n\t\t}\n        //This method return the status of the command, \"OK\" in this case.\n\t\tResultBean response = new ResultBean(true, IConstant.SUCCESS, null);\n        assertNotNull(\"Server should have a running status\", response);\n        assertEquals(\"Server is not online, but it shouldn't be\", IConstant.OFFLINE, response.getStatus());\n        return;\n    }\n    \n\t//This test can be run",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\t\n    private ClientInterface connectedClientsFirst;\n    private ClientInterface connectedClientsSecond;\n    \n    private ClientInterface clienInterface1;\n    private ClientInterface clienInterface2;\n    static Logger getLogger() {\n        return Logger.getLogger(ModernChatServer.class.getName());\n    }\n    \n    /**\n     * Main method.\n     */\n    @javax.annotation.ParametersAreNonnullByDefault\n    @org.junit.BeforeClass\n    public static void setUpClass() throws Exception {\n        \n    }\n\n    @BeforeClass\n    public static void tearDownClass() throws Exception {\n        \n    }\n    \n    /**\n     * Test to invoke the method.\n     */\n  public static void testSendBinaryMessage() {\n    /**\n     * Call the method and check the return result.\n     */\n    try {\n        \n        BinaryMessage bm = new BinaryMessage();\n        User u = new User();\n        u.setPhoneNumber(\"+7912112121\");\n\t\tgetLogger().exiting(\".testSendBinaryMessage\");\n        ResultBean result = bm.sendBinaryMessage(bm);\n        \n    } catch (RemoteException ex) {\n        \n        \n        return;\n    }\n    \n    fail(\"The method testSendBinaryMessage of class ModernChatServer_6Test failed.\\n\");\n  }\n    \n  /**\n     * Verify that login/logout was success on the server side.\n     */\n  @Test\n  public void testSendUserUpdatedStatus() {\n    /**\n     * Call the method and check the return result.\n     */\n    try {\n        \n        ResultBean result = sendUserUpdatedStatus();\n    } catch (RemoteException ex) {\n        fail(ex.getMessage());\n    }\n    \n    assertTrue(ResultBean.SUCCESS == result);\n\t\n    try {\n        getLogger().exiting(\".testSendUserUpdatedStatus\");\n    } catch (IllegalStateException ex) {\n        assertTrue(\"The server should be ready for reconnect.\", connectedClients.size() > 0);\n    }\n    \n  //} catch (RemoteException ex) {\n  // return;\n  //}\n  }\n  \n  \n  /**\n     * Verifies the result returned by the method {@link ModernChatServer#sendUser",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\t\n\t/**\n\t * Test method for {@link osa.ora.server.server.Main#run(boolean)}.\n\t */\n\t@Test\n\tpublic void test1() throws Exception {\n\t\t\n\t}\n\n\t/**\n\t * Test method for {@link osa.ora.server.server.Main#main(java.lang.String[])}.\n\t */\n\t@Test\n\tpublic void test2() throws Exception {\n\t\t\n\t}\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\tpublic static void main(String[] args) throws URISyntaxException, RemoteException, IOException {\n\t\t\tJOptionPane.showMessageDialog(null, \"/etc/config.txt\", \"Configuration test\", JOptionPane.INFORMATION_MESSAGE);\n\t\t\tSystem.exit(0);\n\t\t}\n    /**\n    * This unit test uses two different threads. We can get a new Thread object with which each thread will run.\n    */\n    @Test\n    public void testServerSendBinaryMessage() throws RemoteException, RemoteException, URISyntaxException {\n        new SendRefreshContactThread();\n        new SendKickOffMessageThread();\n\n        ServerSettingBean setting = new ServerSettingBean();\n        setting.setBinaryMessageQueueEnabled(true);\n        setting.setOfflineQueueEnabled(true);\n        setting.setOfflineQueueSize(3000);\n        setting.setOfflineQueueTimeout(10);\n\n        setting.setChatMaxConcurrentMessages(1);\n        setting.setFileQueueTimeOut(60 * 1000);\n        setting.setFileQueueMaxSize(300 * 1000);\n\n        ServerSettingBean.setDefaultSetting(setting);\n\n        //initialize\n        ServerInterface server = new RealServer();\n\n        //do NOT add this server in ServerSettingBean.getAllSetting(), because of this setting.\n        //ClientInterface client = new ClientInterface();\n\n        //start the server\n        String serverQueueStr = \"\";\n        ServerSettingBean settingsBean;\n        try {\n\n            settingsBean = ServerSettingBean.getDefaultSetting();\n            String serverQueueDir = \"\";\n            if (serverQueueStr.length() > 0) {\n                serverQueueDir = settingsBean.getBinaryMessageQueueDirectory();\n            } else {\n                serverQueueDir = settingsBean.getBinaryMessageQueueDirectory() + FileHandler.ISO_8859_1.fileSeparator + \"BinaryMessage\";\n            }\n\n            final String[] setting = new String[2];\n            setting[0] = serverQueueDir;\n            setting[1] = \"/etc/config.txt\";\n\n            setting = settingsBean.getAllSetting();\n            String settingFileDir = \"\";\n            if (setting.length > 0) {\n                settingFileDir = setting[0];\n            } else {\n                settingFileDir = setting[1] + FileHandler.ISO_8859_1.fileSeparator",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {\n\t\t@Test\n\t\tpublic void testSendBinaryMessage() throws RemoteException {\n\t\t}\n}",
            "finish_reason": "stop"
        }
    ],
    "id": "f768b88d-f80a-4f71-8dd6-06ad53a77f47",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_6Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n",
    "test_prompt": "// ModernChatServer_6Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_6Test {",
    "time_taken": 25.02564787864685,
    "usage": {
        "prompt_tokens": 1498
    }
},
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\t\n\t/**\n     * Test Method for {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n     */\n    @Test\n    void testSecureBinaryMessage()\n    {\n        try {\n            // Get the password of the connected client\n            ClientInterface cf = connectedClients.get(MyConstant.USER_ID);\n\n            // get the current time and the calendar using the registry\n            Calendar c = Calendar.getInstance();\n            Enumeration names = Registry.list();\n            String name = null;\n            String time = null;\n            while (names.hasMoreElements()) {\n                name = (String)names.nextElement();\n                // we cannot use getTime() since in java8, Calendar is an Enumeration, and java8 will throw an\n                // UnsupportedOperationException.\n                c.set(Calendar.MILLISECOND, 0);\n                Calendar currentTime = Calendar.getInstance(c);\n                time = currentTime.toString();\n            }\n\n            // get the users\n            UsersBD usersBD = new UsersBD();\n            Vector<String> usersList = usersBD.getUserIDsList(name, name, time);\n            System.out.println(\"The users=\"+usersList);\n            String usersPassword = usersBD.getUserPassword(usersList.get(0));\n            String usersPasswordDecrypted;\n\n            // Test the method, when userId is empty\n            ClientInterface cf1 = null;\n            for (int i=0; i<5; i++)\n            {\n                // get the password with the same to userId\n                usersPassword = UserPasswordClient.getPassword(MyConstant.USER_ID, name, time);\n                System.out.println(\"Current Server setting - \" + UsersSettingClient.getServerSetting()\n                        + \"\\tPassword: \" + usersPassword);\n\n                // if the to userId is empty or is the same\n                // to userId, we send a secure Binary Message, so the same Password will be used\n                if (cf == null && usersList.get(0).equals(\"\"))\n                {\n                    cf1 = new ClientInterface();\n\n                    String encodedPassword = StringEncrypter.encrypt(\"1234567\", usersPassword);\n                    cf1.setPassword(encodedPassword);\n                    cf1.setId(0);\n                    cf1.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\t/**\n         * Test thread for {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)}\n         */\n    @Test\n    void testSendSecureBinaryMessage(){\n        final ClientInterface client = ClientInterface.getInstance_Server();\n        client.initializeSecureBinaryMessage(BinaryMessage.SENDBYTES);\n        SendRefreshContactThread thread = SendRefreshContactThread.getInstance_Server(client);\n        thread.start();\n        SendRefreshContactThread.getInstance_ServerIP(client);\n        SendRefreshContactThread.start(thread);\n        int val = 0;\n        while (thread.isAlive()) {\n            Thread.yield();\n            thread.join();\n            val++;\n        }\n        assertTrue(\"the test PASS of send the secure binary message  \", val > 0);\n\n    }\n\n}\n\npublic class ModernChatServer_8Test {\n\n    /**\n     * Test thread for {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)}\n     */\n\t@Test\n\tpublic void testSendSecureBinaryMessage_2(){\n\n        try{\n            runOfflineTest();\n        }catch (RemoteException ex){\n            ex.printStackTrace();\n        }\n\n\t}\n\t\n\t//1. Test thread for {@link ModernChatServer#clientReceive(ClientInterface)}\n\t//2. Test thread for {@link RealmClient}\n\t//Test thread for {@link ClientInterface#handleMessage(TextMessage)}\n\t//Test thread for {@link RealmClient#onLogin()}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\t/*\n     * create a new object that implements {@linkplain UnicastRemoteObject}\n     */\n    private class MyUnicastObject implements UnicastRemoteObject, RemoteException {\n\n        /*\n         * set its name field\n         */\n        private String name = \"My Object\";\n\n        /*\n         * set the object's port field\n         */\n        private int port = 12345;\n\n        /*\n         * create a remote object that implements UnicastRemoteObject\n         */\n        MyUnicastObject(int port) {\n            this.port = port;\n        }\n        /*\n         * get remote object name that implements Remote\n         */\n        public String getRemoteName() {\n            return this.name;\n        }\n\n        /*\n         * get remote object class that implements Remote\n         */\n        public Class<?> getRemoteInterface() throws RemoteException {\n            return UnicastRemoteObject.class;\n        }\n\n        /*\n         * get remote object remote\n         */\n        public Object getRemoteObject() throws RemoteException {\n            try {\n                return new MyRemoteObject(this.port, null);\n            } catch (RemoteException e) {\n                try {\n                    MyRemoteObject obj = new MyRemoteObject(this.port, e);\n                    obj.remote = this;\n                    return obj;\n                } catch (RemoteException e1) {\n                    return null;\n                }\n            }\n        }\n\n        /*\n         * set remote object remote\n         */\n        public void setRemote(Object remote) throws RemoteException {\n            try {\n                this.port = remote.getClass().getName().replace(\"MyRemoteObject\", \"Remote\");\n            } catch (RemoteException e) {\n                this.port = remote.getClass().getName().replace(\"MyRemoteObject\", \"Remote\").replace('_', '/').replace('/', '.');\n            }\n        }\n\n        /*\n         * get remote port. 0 : this class do not accept any remote or port value\n         */\n        public int getRemotePort() {\n            return this.port;\n        }\n\n        /*\n         * set remote port. 0 : this class do not accept any remote or port value\n         */\n        public void setRemotePort(int port) {\n            this.port = port;\n        }\n\n    }\n\n    /**\n     * set the system logger to use for logging.\n     */",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\tvoid setUp() throws Exception {\n\t\t}\n\n\t\t@Test\n    \tpublic void sendSimpleBinaryMessageTest() throws URISyntaxException {\n            sendSimpleBinaryMessage(\"TestUser001\");\n        }\n        \n        @Test\n    \tpublic void sendSimpleBinaryMessageClientTest() throws URISyntaxException {\n            sendSimpleBinaryMessage(new LoginBean(\"newLogin\", \"newPassword\", IConstant.CLIENT));\n        }\n}\n\n/**\n* Main {@link Object} method of {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)}.\n* It consists of three unit tests.\n* 1. {@link sendSimpleBinaryMessageTest}\n* 2. {@link sendSimpleBinaryMessageClientTest}\n* @throws Exception\n*/\npublic final class sendSecureBinaryMessage_3Test {\n\t/**\n\t* Main {@link Object} method of {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)}.\n\t* It consists of three unit tests.\n\t* 1. {@link sendSimpleBinaryMessageTest}\n\t* 2. {@link sendSimpleBinaryMessageClientTest}\n\t*/\n    @Test\n    public void sendBinaryMessageTest() throws Exception {\n        User toUser = new User(\"toUser\");\n\ttoUser.setToUserId(1);\n\ttoUser.setToUsername(StringEncoder64.encrypt(\"to_username\"));\n\n\tUser fromUser = new User(\"fromUser\");\n\tfromUser.setFromUserId(2);\n\tfromUser.setFromUsername(StringEncoder64.encrypt(\"from_username\"));\n\n\tString fromEmail = StringEncoder64.encrypt(\"from_email\");\n\tString toEmail = StringEncoder64.encrypt(\"to_email\");\n\n\tString fromUsername = StringEncoder64.encrypt(\"from_username\");\n\tString toUsername = StringEncoder64.encrypt(\"to_username\");\n\t\n       \t\ttoSendSecureMessage.setTextMessage(new TextMessage(\"New text message text\", TextMessage.TYPE_TEXT_MESSAGE, new String[]{\"to_username\", \"to_email\"}));\n\tfromSendSecureMessage.setTextMessage(new TextMessage(\"From_text\", TextMessage.TYPE_TEXT_MESSAGE, new String",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\t\n    private RealmInterface cr;\n    \n    /**\n     * Set up method:\n     * @throws RemoteException\n     */\n\t@Test\n    public void setup() throws RemoteException {\n\t\tnew ServerSettingBean();\n\t\tnew ClientInterface(\"1.1\");\n\t}\n    \n    /**\n     * @throws RemoteException\n     */\n    @Test\n    public void test1() throws RemoteException {\n\t\t//test 1: 1.1 get server setting thread\n        new SendRefreshContactThread();\n        Thread serverSettingThread = new SendRefreshContactThread();\n        int retStatus = serverSettingThread.start();\n        //Tick 1 when finish to wait the server thread\n        serverSettingThread.join();\n        \n        //test 2: 2. get group\n        ServerSettingBean.Group g = new ServerSettingBean.Group();\n\t\tg.setName(\"Hello Android Group\");\n\t\tg.setState(0);\n\t\ttry {\n            g = (ServerSettingBean.Group)cr.lookup(g.getUniqueNumber());\n        } catch (Exception e) {\n            e.printStackTrace();\n            cr.add(g);\n        }\n        String[] str = g.split(\",\");\n        List<ServerSettingBean> set = new Vector<ServerSettingBean>();\n        ServerSettingBean.Group gg = null;\n\t\tfor (String obj : str) {\n            try {\n                gg = (ServerSettingBean.Group) cr.lookup(Integer.parseInt(obj));\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(0);\n            }\n            ServerSettingBean ggObj = new ServerSettingBean();\n            ServerSettingBean.Group ggObj2 = new ServerSettingBean.Group(gg);\n            ggObj2.setEmail(gg.getEmail());\n            ggObj2.setName(gg.getName());\n            set.add(ggObj2);\n\t\t}\n        assertNotNull(ggObj2);\n        String[] g_ggString = new String[set.size()];\n        int i = 0;\n        for (ServerSettingBean g1 : set) {\n            g_ggString[i++] = g1.getUniqueNumber();\n        }\n        g_ggString =",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\t\n    private static final int MAX_USER_COUNT = 200;\n    private static final int FUZZIE_FREQUENCY = 100;\n\n    /**\n     * Class contains all the parameters required to send and do the test.\n     */\n    private static class TestParameters {\n        boolean toUserId;\n        boolean fromUserId;\n        boolean toRole;\n        boolean toName;\n        boolean fromRole;\n        boolean toName2;\n        boolean fromName2;\n        boolean toUserRoles;\n        boolean toGroup;\n        boolean toGroup2;\n        boolean enable;\n\n\n        private TestParameters() {\n        }\n    }\n\n    static TestParameters testParameters;\n\n    /**\n     * Test class that performs tests related to the {@linkplain sendBinaryMessage(BinaryMessage)}\n     * function.\n     */\n    private static class SendBinaryMessage_8Test extends TestParameters {\n        public boolean toUserId;\n        public boolean fromUserId = true;\n        public boolean toRole;\n        public boolean toName;\n        public boolean fromRole;\n        public boolean toName2;\n        public boolean fromName2;\n        public boolean toUserRoles;\n        public boolean toGroup;\n        public boolean toGroup2;\n        public boolean enable;\n\n\n        private SendBinaryMessage_8Test() {\n            testParameters = this;\n        }\n    }\n\n\n    static TestParameters testParameters;\n\n    /**\n     * Test class that performs tests related to the {@linkplain sendBinaryMessage(BinaryMessage)}\n     * function with enabled {@linkplain ClientInterface#isBinaryMessageSupported(BinaryMessage)}.\n     */\n    private static class SendBinaryMessage_9Test extends SendBinaryMessage_8Test {\n        public boolean toUserId;\n        public boolean fromUserId = false;\n        public boolean toRole;\n        public boolean toName2;\n        public boolean fromRole;\n        public boolean toName;\n        public boolean fromName2;\n        public boolean toUserRoles;\n        public boolean toGroup;\n        public boolean toGroup2;\n        public boolean enable;\n\n\n        private SendBinaryMessage_9Test() {\n            testParameters = this;\n        }\n    }\n\n    private static TestParameters testParameters;\n\n    /**\n     ",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\t/** Test {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} for null parameters */\n\t\t@Test\n\t\tpublic void sendSecureBinaryMessageNullParams() throws RemoteException {\n\t\t\tString userEmail = null;\n            String userName = null;\n            String userIp = null;\n            String text = null;\n\t\t\tString textMessage = null;\n            int fromUserId = 0;\n            int toUserId = 0;\n            ServerSettingBean serverSetting = null;\n            Logger logger = null;\n\t\t\tResultBean resultBean = null;\n\t\t\tBinaryMessage msg = null;\n\n\t\t\ttry {\n\t\t\t\tassertTrue(msg == null);\n\t\t\t} catch (RuntimeException ex) {\n\t\t\t\tassertTrue(ex.getMessage().equals(\"sendSecureBinaryMessage(null) - Parameter is mandatory\"));\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t* Test {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} for null parameters and null payload */\n\t\t@Test\n\t\tpublic void sendBinaryMessageNullParamsNullPayload() throws RemoteException {\n\t\t\tString userEmail = null;\n            String userName = null;            \n            String userIp = null;\n            String text = null;\n\t\t\tString textMessage = null;\n\t\t\tint fromUserId = 0;\n\t\t\tint toUserId = 0;\n\t\t\tServerSettingBean serverSetting = null;\n\t\t\tLogger logger = null;\n\t\t\tResultBean resultBean = null;\n\t\t\tBinaryMessage msg = null;\n\n\t\t\ttry {\n\t\t\t\tassertTrue(msg == null);\n\t\t\t} catch (RuntimeException ex) {\n\t\t\t\tassertTrue(ex.getMessage().equals(\"sendBinaryMessage(null) - Parameter is mandatory\"));\n\t\t\t}\n\t\t}\n\t}\n// END OF OldTest.java",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\t   \n    /**\n     * The JUnit configuration.\n     */\n    public static final String configFile = \".junit_config\";\n    \n    /**\n     * The name of this test class.\n     */\n    public static final String testClassName = \"TestClass\";\n    \n    /**\n     * This test instance holds a reference to a server bean.\n     */\n    RemoteBean remoteBean;\n    \n    /**\n     * A new instance of {@link RemoteBean}.\n     */\n    \n    private UnicastRemoteObject remoteBeanObj = null;\n    \n    /**\n     * Default constructor.\n     */\n    public ModernChatServer_7Test(){\n    }\n\n    /**\n     * Initializes this test class using current values of the server.\n     *\n     * @throws RemoteException An exception occured in the server process, or a\n     * remote exception happened\n     * \n     */\n    public void setUp() throws Exception {\n        //Initializing server\n        initServer();\n\n        //Initializing client\n        remoteBean = new UnicastRemoteObject(new MyClientInterface());\n        remoteBeanObj = (UnicastRemoteObject) remoteBean;\n    }\n\n    /**\n     * Tears down the test instance used.\n     *\n     * @throws RemoteException An exception occured in the server process, or a\n     * remote exception happened\n     */\n    public void tearDown() throws Exception {\n        closeServer();\n        assertFalse(\"Connection has been closed.\", connectedClients.isEmpty());\n\n        //Close registry\n        Registry r = Naming.registry(RmiRmiServerUtil.registryName);\n        r.close();\n    }\n\n    /**\n     * Initializes server which use the values stored in this class.\n     *\n     * @throws URISyntaxException if there is a problem while creating the URI\n     * @throws RemoteException when error occurred (in server) or when the connection\n     * fails.\n     * \n     */\n    private static void initServer() throws RemoteException, URISyntaxException, RemoteException{\n        \n        try {\n            System.setProperty(\"sun.rmi.server.X500Principal\", \"CN=RMI X500UserPrincipal\");\n            Registry registry = LocateRegistry.getRegistry(8120);\n",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\tpublic static void main(String[] args) {\n\t\t\t//System.exit(0);\n\t\t\ttry {\n\t\t\t// get the server name\n            System.setProperty(\"java.rmi.server.hostname\", \"\");\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\tSystem.err.println(\"Can't get registry - is java.rmi.server started??\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\t// get location\n\t\t\tString rootDirectory = System.getProperty(\"user.dir\");\n\t\t\tString homeDirectory = rootDirectory + \"/org.bkap.server\";\n\n\t\t\t// register RMI server\n            Registry reg;\n            try {\n            \tSystem.setProperty(\"java.rmi.server.hostname\", \"\");\n                reg = Naming.put(\"//\"+homeDirectory, new TestClass().getClass());\n                reg.rebind(\"TestInterface\", new TestInterfaceImpl(new SimpleFormatter(new StringEncoder64())));\n            } catch (NamingException e) {\n            \te.printStackTrace();\n            }\n\n\t\t\t// get the registry\n            Registry localRegistry = Naming.lookup(\"//\"+homeDirectory);\n\n\t\t\t// register the service\n            try {\n            \tlocalRegistry.bind(\"TestInterface\", new TestInterfaceImpl(new SimpleFormatter(new StringEncoder64())));\n            } catch (NameAlreadyBoundException e) {\n            \te.printStackTrace();\n            }\n\n            localRegistry.rebind(\"RemoteService\", new RemoteServiceImpl());\n\n            TestInterface remoteInterface = new TestInterfaceImpl(new SimpleFormatter(new StringEncoder64()));\n\n\n\t\t\t// start the test\n\t\t\tSystem.exit(0);\n\t\t\t} \n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate final static class RemoteServiceImpl extends UnicastRemoteObject implements ClientInterface {\n\n        private static class ServerInterfaceRegistry implements Registry {\n            public boolean isRegistered(Object obj) throws NamingException {\n                assert obj instanceof TestInterface;\n\n                return true;\n            }\n        }\n\n        private static void registerNewRemoteInterface(Class clza) throws NameAlreadyBoundException, NamingException {\n            final RemoteServiceInterfaceRegistry registry = new RemoteServiceInterfaceRegistry();\n\n            try {\n                Naming.rebind(\n                        \"",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n\n// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {\n\t\t\n    /**\n     * Initialize the test case.\n     * @throws RemoteException\n     */\n    @Test\n    public void testInit() throws RemoteException {\n        //create client.\n        ClientInterface client = new ClientInterface();\n\n        //connect the server.\n        Registry registryClient = LocateRegistry.getRegistry(0);\n        Registry registryServer = LocateRegistry.getRegistry(1);\n\n        try {\n            //register the new server with the client\n            Naming.rebind(\"Server\", ClientInterface.class, client);\n            ServerSettingBean setting\n                    = new ServerSettingBean(ClientInterface.class.getName());\n\n            //configure the server\n            ServerSettingBean beanConfig = new ServerSettingBean();\n            Registry.put(RegistryServer.ROOM_ID, beanConfig);\n            beanConfig.setBinaryMessageSize(IConstant.MAX);\n            registryServer.put(RegistryServer.SETTINGBECLASS, SettingBean.class);\n            try {\n                registryServer.rebind(\"test\" + FileHandler.class.getName(), IConstant.OFFLINE, beanConfig);\n            } catch (Naming.AlreadyBoundException ex) {\n                System.out.println(\"test\" + FileHandler.class.getName() + \" already exist.\");\n            } catch (Naming.NameNotFoundException nnfe) {\n                System.out.println(nnfe.toString());\n            }\n            try {\n                try {\n                    registryServer.rebind(\"test\" + IConstant.OFFLINE, BINARY_MESSAGE_CLASS_NAME);\n                } catch (Naming.ConnectionRefusedException nre) {\n                    System.out.println(\"unable to bind to port 3306\");\n                    return;\n                } catch (Naming.NotFoundException nf) {\n                }\n            } catch (Naming.ReferenceNotFoundException nre) {\n            }\n            //Register new server with the client\n            try {\n                this.newServer(client);\n            } catch (Exception e) {\n                e.printStackTrace();\n                fail(\"Failed to create the new server (Server)\");\n            }\n                            \n        } catch (Naming.NameNotFoundException nnfe) {\n            System.",
            "finish_reason": "length"
        }
    ],
    "id": "2cca0cf6-561a-45fc-ad99-5d125c656e44",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_7Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send Binary message (files) but secure (files not secure)\n     *\n     * @param msg : the message to be send\n     * @return ResultBean include the status of message send or not.\n     * @throws RemoteException\n     */\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\n        if (cf == null) {\n            return new ResultBean(false, IConstant.OFFLINE, null);\n        } else {\n            try {\n                //online message, send it..\n                if (msg.getAction() == IConstant.REQUEST) {\n                    getLogger().log(Level.FINE, \"Request send\");\n                    return cf.receiveSecureBinaryMessageRequest(msg);\n                } else {\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\n                    cf.receiveSecureBinaryMessageLoad(msg);\n                    return new ResultBean(true, IConstant.SUCCESS, null);\n                }\n            } catch (RemoteException ex) {\n                try {\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\n                    connectedClients.remove(msg.getToUserId());\n                    connectedClientsIPs.remove(msg.getToUserId());\n                    offlineStatus(msg.getToUserId());\n                } catch (RemoteException ex1) {\n                }\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\n            }\n        }\n    }\n}\n",
    "test_prompt": "// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_7Test {",
    "time_taken": 24.627068042755127,
    "usage": {
        "prompt_tokens": 1509
    }
},
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\t\n\t/** The current test-case class for the class {@link ModernChatServer}. */\n\tpublic static final String CLASS_NAME = \"Testing the sendSecureTextAnnouncement method\";\n\t/** The test-case class for the server test-case. */\n\tfinal static String TEST_CASE_CLASS = CLASS_NAME + \".SendSecureTextAnnouncementTest.ServerTestCase\";\n\t\n    public static class LogHandler {\n        /** The log file for this test. */\n        final static String LOG_FILE = \"/tmp/ServerLog.txt\";\n\n        /** The log file for the server test case. */\n        final static String SERVER_TEST_CASE_LOG_FILE = \"/tmp/ServerTestCaseLog.txt\";\n\n        /** The log file for server test case. */\n        final static String LOG_FILE_TEST_CASE = \"/tmp/ServerLog2.txt\";\n\n        /** The test case file for sending user updated status information. */\n        final static String TEST_CASE_TEST_CASE_FILE = \"/tmp/SendUserUpdatedStatus.txt\";\n\n        /** The test case file for the test {@link SendSocketTestCase}. */\n        final static String TEST_CASE_TEST_CASE_FILE_TEST",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\t\n    /**\n     * Main Entry Point.\n     */\n    @Test\n    public void testMain() {\n        \n    }\n    \n\n    //@Test\n    public void  checkIfServerRunning() {\n        Logger.getLogger(\"\").log( Level.INFO, \"Starting test for a running server. Exiting test\");\n    }\n    \n    \n    public static void main(String[] args) {\n        StringUtilities un = new StringUtilities(); \n        //UnicastRemoteObject.setTransient(un);\n        try {\n            Logger myLogger = Logger.getLogger(\"\");\n            myLogger.setLevel(Level.OFF);\n            Logger.getLogger(\"\").setLevel(Level.OFF);\n            Logger.getLogger(\"net.unX\").setLevel(Level.OFF);\n        } catch (Exception e) {\n            new Exception(\"Exception while trying to start log file\", e).printStackTrace();\n        }\n        if (StringUtilities.isEmptyOrWhitespaceOnly(args[0])) {\n            un.startServerForTesting();\n        } else {\n            try {\n                Integer temp = new Integer(args[0]);\n                if (temp <=",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\t\n    public StringEncoder64 decoder;  \n    public String decoderName; // for testing\n\n    public static final StringDecode_1 = \n\t\"\\r\\n\" + \n\t\"\\003\\003\\002\\r\\n\" + \n\t\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\" + \n\t\"\\000\\000\\000\" + \n\t\"\\000\\000\\000\" + \n\t\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\" + \n\t\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\" + \n\t\"\\000\\000\\000\\000\\000\\",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\t\n\t/**\n\t * Test the secured sendSecureTextAnnouncement method of {@link osa.ora.server.ClientInterface};\n\t * @throws RemoteException\n\t * @throws java.lang.Exception\n\t */\n\t@Test\n\tpublic void testSendSecureTextAnnounce() throws RemoteException, Exception {\n\t\t//StringServer _Server_9Test_4MySQL_6_1;\n\t\tClientInterface cf = connectedClients.get(\"3A19D50C2D6D40A57C00A00300100\");\n\t\tResultBean result = cf.sendSecureTextAnnouncementToUser(\"Testing1\", cf);\n\t\tassertNotNull(result);\n\t\t//_Server_9Test_4MySQL_6_1 = createServer();\n\t\t//_Server_9Test_4MySQL_6_1.start(_1);\n\t\t//String_Server_7_4MySQL_6_2;\n\t\tClientInterface _Server_7_4MySQL_6_2 = createServer(true);\n\t\t//_Server_9Test_4MySQL_6_2.start(_2);\n\t\ttry {\n\t\t\t//_Server_9Test_4MySQL_6_2.start(_1);\n\t\t\tString",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\t\n}\n\n/**\n * @author ooransa\n * Main class for a test application of the {@link ModernChatServer}\n */\npublic class test_8App {\n\n\t/**\n\t * @throws java.lang.Exception\n\t */\n\t@Test\n\tpublic void testSendSecureTextAnnouncement() throws Exception {\n\n\t\tUser userA = new User();\n\t\tuserA.setUsername(\"testA\");\n\t\tuserA.setPassword(StringEncoder64.encode(\"pA1234567\"));\n\t\t//userA.setAccount(1);\n\t\tHashtable<String, String> props;\n\t\ttry {\n\t\t\tStringEncoder64 ses = new StringEncoder64();\n\t\t\tProperties propsA = new Properties();\n\t\t\tpropsA.addProperty(\"USERNAME\", userA.getUsername());\n\t\t\tUserInfo userInfo = new UserInfo(ses.encode(userA.getPassword()), propsA);\n\t\t\tuserA = UnicastRemoteObject.exportObject(userInfo, 3);\n\t\t} catch (Exception e) {\n\t\t\t//e.printStackTrace();\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t\n\t\tUser userB = new User();\n\t\tuserB.setUsername",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\t/**\n\t\t * @param args the command line arguments\n\t\t */\n\t@Test\n    public void testsSendSecureTextAnnouncement() {\n            try {\n        if (sendSecureTextAnnouncement(\"\")) {\n            }\n        } catch(RemoteException ex) {\n            Logger.getLogger(ClientInterface.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n}\n\n\nclass ClientInterface2 extends UnicastRemoteObject implements ClientInterface, ClientInterface {\n    ServerSettingBean setting;\n    User user;\n    public ClientInterface2() throws RemoteException {\n    }\n\n    public ClientInterface2(ServerSettingBean setting) throws RemoteException {\n        this.setting = setting;\n        String userID = setting.getFromUser();\n        boolean fromChat = setting.isFromChat();\n        User userFromChat = null;\n        if (fromChat) {\n            userFromChat = UsersBD.getInstance().getUser(userID);\n        }\n        this.user = userFromChat;\n\n\n        try {\n            org.jboss.remoting3.Endpoint endPoint = UnicastRemoteObject.exportObject(new EndpointHandler(this), 0);\n            setting.",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\t//public static final String EXECUTION_STATUS_MESSAGE = \"executeStatus\";\n\t\t//public static final String MSG_NOTIFICATION = \"You are sending 1 more announcemnt per year\";\n        \n    /**\n     * @param args the command line arguments\n     */\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tif (args.length == 2) {\n\t\t\t\tString host = args[0];\n\t\t\t\tString user = args[1];\n\t\t\t\t\n\t\t\t}\n\t\t} \n\t\tcatch (org.junit.runner.JUnitCore.Failure failure)\n\t\t{\n\t\t\tfailure.printStackTrace();\n\t\t} \n\t\t\n\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\tStringServerSettingBindingListener bindingListener;\n\t\t\n\t\t@Test\n\t\tvoid testSendSecureTextAnnouncementSendsMessageByServer() throws RemoteException {\n\t\t\t//initialize local vars\n\t\t\tString senderID = \"\";\n\t\t\tString targetUserID = \"\";\n\t\t\tString textBody = \"\";\t\t\t\n\t\t\tString messageRecipientUsername = \"test\";\n\t\t\tServerSettingBean myServerSettingBean = new ServerSettingBean();\n\t\t\tmyServerSettingBean.setUserID(targetUserID);\n\t\t\tmyServerSettingBean.setTextBody(textBody);\n\t\t\tmyServerSettingBean.setTargetUserID(targetUserID);\n\t\t\t\n\t\t\t//create server instance\n\t\t\tString serverURL = \"\";\n\t\t\tString recipientServerAddress = \"\";\n\t\t\tString messageContent = \"testing\";\n\t\t\tmyServerSettingBean.setServerName(\"test\");\n\t\t\tmyServerSettingBean.setServerURL(serverURL);\n\t\t\tmyServerSettingBean.setServerAddress(recipientServerAddress);\n\t\t\tmyServerSettingBean.setRecipientServerAddress(\"TEST_ADDRESS\");\n\t\t\tmyServerSettingBean.setRecipientServerPort(6667);\n\t\t\tmyServerSettingBean.setServerLogLevel(Level.INFO);\n\t\t\t",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\tprivate final String m_oServerInfo = \"Hello World!!!\";\n\t\t@Test\n\t\tpublic void testSendSecureTextAnnouncement() throws Exception {\n\t\t\tfinal ServerSettingBean serverSetting = new ServerSettingBean();\n            serverSetting.setUserPassword(\"test\");\n            serverSetting.setServerPassword(\"test\");\n            serverSetting.setSocketPort(9123);\n\n            final ClientInterface cf = new ClientInterface();\n            // Set up Registry\n            Registry registry = null;\n            try {\n                registry = LocateRegistry.createRegistry(9123);\n            } catch (Exception e) {\n                fail(\"Cannot connect to Registry\");\n            }\n            Naming.register(\"my-binding\", cf);\n            // Register new server\n            BinaryMessage msg = new BinaryMessage(m_oServerInfo);\n\n            //Register new client\n            cf.setSocket(serverSetting);\n            cf.init();\n\n            //Server thread\n            try {\n                ServerStartupAction.test(serverSetting);\n            } catch (Exception e) {\n                fail(\"Server server startup check failed\");\n            }\n\n            try {\n                    \n                //Send ping messages\n                sendSecureTextAnnouncementToUser(msg.getTextMessage(), cf);",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId()!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers!= null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i]!= msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n\n// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {\n\t\t@Test\n\t\tpublic void testSendSecureTextAnnouncement() throws Naming.NamingException, RemoteException {\n\t\t\tServerSettingBean ss = new ServerSettingBean(\"192.168.0.2\", \"192.168.0.3\", \"TestServer\", IConstant.USER_SERVER, false, false, false, IConstant.SERVER_SINGLE_USER_MESSAGE_RUN_CALLS, true);\n\t\t\tBinaryMessage msg = new BinaryMessage();\n\t\t\tmsg.setId(StringEncoder64.encode64(StringEncoder64.encode64(\"\")));\n\t\t\tmsg.setToUser(\"1\");\n\t\t\tmsg.setFromUser(\"2\");\n\t\t\tmsg.setTargetType(IConstant.TEXT_MESSAGE_ANNOUNCEMENT);\n\t\t\tmsg.setTargetUser(StringEncoder64.encode64(\"\" + User.USER_ROOM));\n\t\t\tmsg.setTargetRoom(StringEncoder64.encode64(\"\" + Room.ROOM_CHAT_ROOM));\n\t\t\t//sendannouncement() should not send the user announcement to the user.\n\t\t\t//sendannouncementToAll will simulate that the user message will be send without any user announcement.\n\t\t\tmsg",
            "finish_reason": "length"
        }
    ],
    "id": "3a3195d3-d0b1-40b6-9640-90a0613cd2c0",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_8Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * Send announcemnt but securly (encrypted)\n     *\n     * @param msg : the announcemnt to be send\n     * @throws RemoteException\n     */\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\n            return sendSecureTextAnnouncementToUser(msg, cf);\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\n            Vector<User> tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getGroups().size(); i++) {\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getGroups().get(i).getUsers();\n                    break;\n                }\n            }\n            if (tempUsers != null && tempUsers.size() > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.size(); i++) {\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers.get(i).getId());\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\n            int[] tempUsers = null;\n            ClientInterface cf = null;\n            for (int i = 0; i < getRooms().size(); i++) {\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\n                    tempUsers = getRooms().get(i).getUserId();\n                    break;\n                }\n            }\n            if (tempUsers != null && tempUsers.length > 0) {\n                //loop on users\n                boolean deliverToAll = true;\n                for (int i = 0; i < tempUsers.length; i++) {\n                    if (tempUsers[i] != msg.getFromUserId()) {\n                        cf = connectedClients.get(tempUsers[i]);\n                        if (deliverToAll) {\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\n                        } else {\n                            sendSecureTextAnnouncementToUser(msg, cf);\n                        }\n                    }\n                }\n                return deliverToAll;\n            }\n        }\n        return false;\n    }\n}\n",
    "test_prompt": "// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_8Test {",
    "time_taken": 14.970911502838135,
    "usage": {
        "prompt_tokens": 1764
    }
},
{
    "choices": [
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\t\n\t/**\n\t * @throws RemoteException\n\t */\n\t@Test\n\tpublic void test_simpleRegister() throws RemoteException {\n\t\tClientInterface client = new ClientInterface();\n\t\tRegistry registry = LookupRegistry.lookup();\n\t\ttry {\n\t\t\tThread.sleep(100);\n\t\t\t//registration: add listener\n\t\t\tVector listeners = (Vector)registry.lookup(ClientInterface.class.getName());\n\t\t\tfor (int i = 0; i<listeners.size();i++) {\n\t\t\t\ttry {\n\t\t\t\t\tlogger.log(Level.INFO, \"Register listener \" + i);\t\t\t\t\t\t\n\t\t\t\t\tclass MyListener  implements RemoteObject {\n\t\t\t\t\t\tpublic RegistrationResponse send(Request request) throws RemoteException {\n\t\t\t\t\t\t\tlogger.log(Level.INFO, \"sending a register response\");\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.log(Level.INFO, \"Register listener \" + i);\t\t\t\t\t\t\n\t\t\t\t\tlisteners.add(MyListener.class, listener);\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t// if add listener failed and other exception is thrown\n\t\t\t\t\t// logger.log(Level.SEVERE, \"sending a register response Exception \", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashtable<String,Object> attributes = new Hashtable<>(); \n\t\t\tServerSettingBean setting = new ServerSettingBean(); \n\t\t\tsetting.setServerName(\"testserver\");\n\t\t\tsetting.setServerUrl(new B3ServerURL(3, false));\n\t\t\tsetting.setRMI(null);\n\t\t\tsetting.setServerType(\"1\");\n\t\t\tsetting.setMaxNumberConnection(2);\n\t\t\tsetting.setPassword(setting.getServerType()+\"_\"+new StringEncoder64().encode(setting.getServerName()));\n\t\t\tsetting.setAuthToken(new StringEncrypter().encrypt(setting.getPassword()));\n\t\t\tServerSettingBean server = setting.getServerSettings();\n\t\t\tserver.setRoutes(new Vector<>());\n\t\t\tserver.setUsersList(new Vector<>());\n\t\t\tServerSettingBean.ServerMap serverMap = SettingConfig.getServerMap();\n\t\t\t// register myself to the server.\n\t\t\tregistry.add(client, setting",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\t/**\n\t\t * The main method.\n\t\t*/\n    @Test\n    public void testServerSideSignInAsAdminTest() {\n        try {\n            Logger.getLogger(\"\").addHandler(new FileHandler(\"/.log\"));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised : \" + e.getMessage());\n        }\n        try {\n            //ServerInitBean serverInitBean = new ServerInitBean();\n            //String serverInfoURL = \"/ora/server-Info.html\";\n            //String serverPassword = \"pwd\";\n            //String serverUsername = \"userno\";\n            //String serverUsername = serverUsername + \"\";\n            //ServerSideLoginBean serverSideLoginBean = new ServerSideLoginBean();\n            String serverInformationHtml = \"<html><head><title>Online Ora Server</title><body>\"\n                    + \"<h1>Online Ora Server</h1>\"\n                    + \"<h2>Online Ora Server</h2>\"\n                    + \"<p><h2>Online Ora Server</h2>\"\n                    + \"<h2>Online Ora Server</h2>\"\n                    + \"<h3>Online Ora Server</h3>\"\n                    + \"<h3>Online Ora Server</h3>\"\n                    + \"<h3>Online Ora Server</h3>\"\n                    + \"</p>\";\n            String newPasswordCipher = StringEncoder64.decodeStringUTF8(\"pwd\");\n            String adminPasswordCipher = StringEncoder64.decodeStringUTF8(\"pwd\");\n            String serverUrl = StringEncoder64.encodeStringUTF8(Utils_9.httpServerUrl);\n            try {\n                //Logger.getLogger(\"\").removeHandler(HandlerUtil.createFileAppender(\"log\", \"FMT\"));\n                String serverHost = StringEncrypter.getInstance(Utils_9.passwordEnc).encrypt(Utils_9.serverHost);\n                String server_port_ip = ServerSettingBean.getInstance(Utils_9.serverHost + \":\" + StringEncrypter.getInstance(Utils_9.passwordEnc).encrypt(Utils_",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\tprivate MainThreadListener listener;\n\t\tprivate User adminUser;\n\n\t@Test\n\tpublic void testConstructor() throws Exception {\n\t\tif (adminUser!= null)\n\t\t\tfail();\n\t\tString adminUserStr = \"admin_username\";\n\t\tadminUser = User.getUser(1000, StringEncoder64.encodeString(adminUserStr));\n\t\tStringAdmin userStr = StringEncoder64.encodeString(adminUserStr);\n\t\tadminUser = new User(userStr, User.GROUP_ADMIN_MORPH);\n\t}\n\n\t@Test\n\tpublic void testRunnable() {\n\t\tRunnable r = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tServerSettingBean setting = new ServerSettingBean();\n\t\t\t\tString settingStr = settingEnc.encodeString(ServerSettingBean.PROPERTY_PASSWORD);\n\t\t\t\tsetting = StringEncrypter.getInstance(settingStr);\n\t\t\t\tServerSettingBean.setPropertyPassword(setting);\n\t\t\t}\n\t\t};\n\t\tadminUser.setPassword(StringEncoder64.decodeStringUTF8(setting.getSettingPassword()));\n\t\tString adminUserStr = StringEncoder64.encodeString(adminUser.getUserID());\n\t\tadminUser = new User(StringEncoder64.encodeString(adminUserStr), User.USER_TYPE_MORPH);\n\t}\n\n\t@Test\n\tpublic void testRunnable2() {\n\t\tRunnable r = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (!adminUser.getUserID().equals(\"1000\")) {\n\t\t\t\t\tadminUser.setPassword(StringEncoder64.encodeString(StringEncoder64.decodeStringUTF8(\"pass\")));\n\t\t\t\t\tServerSettingBean setting = new ServerSettingBean();\n\t\t\t\t\tString settingStr = settingEnc.encodeString(ServerSettingBean.PROPERTY_PASSWORD);\n\t\t\t\t\tsetting = StringEncrypter.getInstance(settingStr);\n\t\t\t\t\tServerSettingBean.setSecureToken(setting);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tadminUser.setPassword(\"\");\n\t\tStringAdmin userStr = StringEncoder64.encodeString(\"1000\");\n\t\tadminUser = new",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\tTestLogger mainLogger = Utils.getLogger(this.getClass());\n\t\tVector<Hashtable<String, Hashtable<Object, Object>>> passwords = Utils.toVectorOfHashTable(new Hashtable<>(), getClass().getClassLoader()\n\t\t\t\t.getResources(\"data/data_test_password.dat\"))\n\t\t\t\t.subList(0, 2);\n\t\tTestLogger testLogger = Utils.getLogger(getClass());\n\t\t//The Admin User is not used, so it has no password.\n\t\tTestLogger adminTestLogger = Utils.getLogger(getClass().getClassLoader()\n\t\t\t\t.getResources(\"data/data_test_admin_password.dat\"));\n\n\t\tprivate ClientInterface mClient;\n\t\tprivate ServerInterface mServer;\n\n\t\t/**\n\t\t * constructor\n\t\t * @param mClient : Instance of ClientInterface.\n\t\t * @param mServer : Instance of RMI Server.\n\t\t * @throws MalformedURLException, ServerStoppedException, RemoteException, NamingException, URISyntaxException\n\t\t */\n\t\tprotected ModernChatServer_9Test(ClientInterface mClient, ServerInterface mServer) throws MalformedURLException, ServerStoppedException, RemoteException, NamingException, URISyntaxException {\n\t\t\tthis.mClient = mClient;\n\t\t\tthis.mServer = mServer;\n\n\t\t}\n\n\t\t/**\n\t\t * runs the unit test\n\t\t */\n\t\t@Test\n\t\tpublic void test1_getLoginAsAdmin() throws MalformedURLException, RemoteException, NamingException, ServerStoppedException, RemoteException, NamingException{\n\t\t\t//adminUser is not the first server\n\t\t\tString[] adminServers = Utils.getListFromEnum(new Enumeration() {\n\t\t\t\t\t{ this.getClass().getClassLoader().loadClass(\"org.osgi.service.cm.annotations.Service\")!= null; }\n\n\t\t\t\t}, String.class, \"adminUser\", 1);\n\t\t\tassertTrue(Utils.strEqual(adminServers, StringEncoder64.decodeString(\"adminServer\")));\n\n\t\t\t//adminUser is not the second server\n\t\t\tString[] adminServers2 = Utils.getListFromEn",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\tprivate ServerSettingBean serverB;\n\t\t/** Creates an new instance of ModernChatServer_9Test */\n\t\tpublic ModernChatServer_9Test() {\n\t\t}\n\t\t/**\n\t * Run the test case.\n \t * Return false if test failed.\n \t */\n\t\t@Test\n/*\n * Test checks if a user can sign in the administrator of the server when the user account is changed\n *\n\t * @throws RemoteException\n\t */\n\t\tpublic boolean runSpecific() throws RemoteException, URISyntaxException {\n\t\tBinaryMessage response = new BinaryMessage(); String user = null; String password = null; String encryptedPassword = null; String encryptedPassword = null; String encryptedPass = null; String username = null; ClientInterface client = null;\n\t\tString adminUser = null; String adminPass = null; String orignalPass = null; String secureToken = null; String secureTokenUsed = null; String authToken = null;\n\t\tString msg = null; String msgType = null; String responseType = null; String token = null;\n\t\tString text = null; String type = null;\n\t\ttry {\n\t\t\t\t//create Admin user with password.\n\t\t\tadminUser = StringEncoder64.encodeStringUTF8(getAdminUser().getPassword());\n\t\t\tadminPass = StringEncrypter.getInstance(getAdminUser().getPassword()).getEncuteMD5();\n\t\t\tuser = getAdminUser().getUsername();\n\n\t\t\t//change the server administrator's password.\n\t\t\tencryptedPassword = StringEncrypter.getInstance(adminPass).encrypt(serverB.getAdmins().get(0).getPassword());\n\t\t\tadminPass = StringEncrypter.getInstance(encryptedPassword).getEncuteMD5();\n\t\t\tgetAdminUser().setPassword(adminPass);\n\t\t\tadminPass = StringEncrypter.getInstance(encryptedPassword).getEncuteMD5();\n\t\t\tserverB = new ServerSettingBean();\n\t\t\tuser = StringEncoder64.decodeStringUTF8(getAdminUser().getUsername()).split(\":\")[0];\n\t\t\tString newpass = StringEncrypter.getInstance(getAdminUser().getPassword()).getEncuteMD5();\n\t\t\tserverB.setAdmins(new Vector<User>());\n\t\t\t",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\t/**\n\t\t* Method used to create a server instance.\n\t\t* The server should be running for a bit while.\n\t\t*/\n\t\t@Test\n\t\tvoid check() { // test if the server is running.\n\t\t\tboolean isServerRunning = true;\n\t\t\t\n\t\t\tString key = \"OldDB\";\n\t\t\tRegistry r = LocateRegistry.getRegistry(0); // a random server\n\t\t\t\n\t\t\tlong start = System.currentTimeMillis();\n\t\t\tUser adminUser = new User(\"AdminUser\", \"\");\n            String dbPassword = \"-1\";\n             \n            //create admin connection (only for the first time!!)\n            String encryptedPassword = StringEncrypter.getInstance(dbPassword).encrypt(\"-1\");\n\t\t\t\n            //create admin client\n            String encryptedPlainPassword = StringEncrypter.getInstance(PlainPassword).encrypt(\"-1\");\n\t\t\tClientInterface adminClient = new ClientInterface(EncryptPlainPassword.passwordEnc, StringEncrypter.getInstance(encryptedPlainPassword));\n\t\t\t\n\t\t\t//create user and group table and set it in client\n\t\t\tHashtable<String, User> users = createUsers(AdminUser.class, true);\n\t\t\tgetLogger().log(Level.FINEST, \"Create users, all users for the user : {0}\", users);\n\t\t\t\n\t\t\tfor (Class userClass : users.values()) {\n\t\t\t\tString emailAddr = \"user:\" + ((userClass.equals(TextMessage.class))? userClass.getSimpleName() : userClass.getName()) + \"@gmail.com\";\n                User user = new User(userClass.getSimpleName(), StringEncrypter.getInstance(plainPasswordEnc));\n                getLogger().log(Level.FINEST, \"Create user {0}, email: {1}, encrypted password: {2}\", new Object[]{user.getClass().getSimpleName(), emailAddr, getEncodedPassword(encryptedPassword, user.getPassword().length() / 2)});\n                user = new User(user.getEmail(), encryptedPlainPassword);\n                getLogger().log(Level.FINEST, \"Create user {0}, email: {1}, encrypted password: {2}\", new Object[]{user.getClass().getSimpleName(),",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\t//private Hashtable<String, ClientInterface> clientInterfaces = new Hashtable<String, ClientInterface>();\n\t\tprivate Hashtable<String, ClientInterface> clientInterfaces = new Hashtable<String, ClientInterface>();\n\n\t\t/** Main method */\n\t\t@Test\n\t\tpublic void testConnection() {\n\n\t\t\tinitServerSocket();\n\t\t\tif (ServerSettingBean.loginAsAdministrator.equals(getLoginBean().myPassword)) {\n\t\t\t\tSystem.out.println(\"Authentification has failed\");\n\t\t\t}\n\t\t\tServerSettingBean settingBean = new ServerSettingBean();\n\t\t\tsettingBean.setLoginAsAdministrator(ServerSettingBean.loginAsAdministrator.equals(ServerSettingBean.loginAsAdministrator));\n\t\t\tsettingBean.setLoginAsAdmin(ServerSettingBean.loginAsAdmin.equals(ServerSettingBean.loginAsAdmin));\n\t\t\tServerSettingsBean serverSettingsBean = new ServerSettingsBean();\n\t\t\tserverSettingsBean.setLoginAsAdmin(ServerSettingBean.loginAsAdmin.equals(ServerSettingBean.loginAsAdmin));\n\t\t\tserverSettingsBean.setLoginAsAdmin(ServerSettingBean.loginAsAdmin.equals(ServerSettingBean.loginAsAdmin));\n\n\t\t\tServerSettingBean serverSettings = new ServerSettingBean();\n\t\t\tserverSettings.setLoginAsAdmin(ServerSettingBean.loginAsAdmin.equals(ServerSettingBean.loginAsAdmin));\n\t\t\tserverSettings.setLoginAsAdmin(ServerSettingBean.loginAsAdmin.equals(ServerSettingBean.loginAsAdmin));\n\n\t\t\tsettingBean.setServerSettings(settingBean);\n\t\t\tsettingBean.setServerSettings(serverSettings);\n\n\t\t\t//ServerSettingsBean settingBean_1 = new ServerSettingsBean();\n\t\t\t//settingBean_1.setLoginAsAdmin(false);\n\t\t\t// settingBean_1.setLoginAsAdministrator(false);\n\t\t\t// settingBean_1.setLoginAsAdmin(true);\n\n\t\t\t//ServerSettingsBean settingBean_2 = new ServerSettingsBean();\n\t\t\t//settingBean_2.setLoginAsAdministrator(true);\n\t\t\t// settingBean_2.setLoginAsAdmin(true);\n\n\t\t\t",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\tprivate ClientInterface clientInterface = new ClientInterface();\n\t\tprivate String serverName = \"ModernChatServer9Test\";\n\t\tprivate String chatInterface = \"modernChat\";\n\t\tprivate Hashtable<Long, String> contacts = new Hashtable<Long, String>();\n\t\tprivate Hashtable<Long, int[]> chatRoom = new Hashtable<Long, int[]>();\n\t\tprivate User author = null;\n\t\tprivate Hashtable<Long, ResultBean> result = new Hashtable<Long, ResultBean>();\n\t\tprivate int maxConnectingUserCount = 200;\n\t\tprivate User adminUser;\n\t\tprivate String adminPassword = \"Password\";\n\t\tprivate Vector<BinaryMessage> receiveMsg = null;\n\t\tprivate boolean stopSession = false;\n\t\tprivate boolean isSending = false;\n    \tprivate Thread sendStopSessionThread = null;\n    \tprivate ServerSettingBean settingBean = new ServerSettingBean();\n    \tprivate boolean isLoggedIn = false;\n    \tprivate Hashtable<String,BinaryMessage> sendMsg = new Hashtable<String,BinaryMessage>();\n    \tprivate Hashtable<String,Vector<BinaryMessage>> users2sendMsg = new Hashtable<String,Vector<BinaryMessage>>();\n    \tprivate Vector<User> friends = new Vector<User>();\n    \tprivate Vector<User> friends2 = new Vector<User>();\n    \tprivate Vector<ResultBean> results = new Vector<ResultBean>();\n    \tprivate Vector<BinaryMessage> msg = new Vector<BinaryMessage>();\n    \tprivate int[] sendMsgSize = {0,0};\n\n    \t\n\n\t\t/** Default constructor.\n\t\t */\n\t\tpublic ModernChatServer_9Test(){\n\t\t\t//settingBean = new ServerSettingBean();\t\n\t\t\tsetupServerTest();\n\t\t}\n\n\t\tprivate void setupServerTest(){\n\t\t\tServerSettingBean settingBean1 = new ServerSettingBean();\n\t\t\tsettingBean1.setServerName(serverName);\n\t\t\tsettingBean1.setAdminId(0L);\n\t\t\tsettingBean1.setChatInterface(chatInterface);\n\t\t\tsettingBean1.setMaxConnectingCount(maxConnectingUserCount);\n\t\t\tsettingBean.copyTo(ServerSetting",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\t\n\tprivate static final Logger LOG = Logger.getLogger(\"Log\");\n        private ClientInterface client = null;\n        private IConstant connId = new IConstant (\"\");\n        private ServerSettingBean st_Login = new ServerSettingBean();//the server setting has login password\n        private ServerSettingBean st_ContactUsername= new ServerSettingBean();//the server setting has contact username\n        private Vector<User> allUsers = new Vector<User>();//all Users\n        \n        \n        /**\n        * Creates an New User in the server\n        * @param emailAddr : email of the new user.\n        * @param password : password of the new user.\n        * @return the new user object.\n        */\n        private User createNewUser(String emailAddr, String password) throws RemoteException{\n                User user = null;\n                String email = StringEncoder64.decodeStringUTF8(emailAddr);\n                password = StringEncrypter.getInstance(password).decrypt(password);\n                user = new User();\n                user.setEmail(email);\n                user.setPassword(password);\n                user.setAuthToken(\"FIM\" + Calendar.getInstance().getTimeInMillis());\n                return user;\n        }\n        private static void checkResult(String resultStr) throws RemoteException, RemoteException{\n                            assertEquals(\"the result returned is wrong!\\r\\t\"+resultStr,true,(resultStr.equals(\"ok\")));\n                        }\n/*\n        * Test 1 : Create a new room on the server\n        * - Client login, then we cannot add another user to the room\n        * - Check the result of RoomInterface method\n        *@Test\n        */\n        @Test\n        public void test_Login() throws RemoteException, URISyntaxException {\n            createNewRoom();\n            getLogger().log(Level.FINE, \"New room created\");\n            //the user must login before we can add new room\n            String[] send_user_threads = new String[] {\"send_user_login\", \"usersd_send_join_all_rooms\"};\n            new SendUserUpdatedStatusThread(connId,st_Login, send_",
            "finish_reason": "length"
        },
        {
            "text": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface, both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr!= null && password!= null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password!= null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user!= null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n\n// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {\n\t\tfinal static String ROOMS_ENCRYPT = \"rooms\";\n        final static String ADMIN_USER = \"admin\";\n        final static String[] ROOMS = {\"rooms/\"+ ADMIN_USER+\"/\"+ADMIN_USER, \"rooms/\"+ ADMIN_USER+\"/\"+ADMIN_USER + \"/\" + \"rooms\"};\n        final static String[] ROOMS_ENCRYPT2 = {\"rooms/\"+ ADMIN_USER+\"/\"+ADMIN_USER + \"/\" + \"rooms\"};\n        final static String CLAN_NAME = \"Client Server\";\n\n\n        final static String KICKOFF = \"kickoff\";\n        final static String REFRESH = \"refresh\";\n\n\n        final static String KICKOFF_STATUS = \"kickoff status\";\n        final static String KICKOFF_STATUS_BY_CLIENT = \"2\";\n        final static String KICKOFF_STATUS_BY_CLIENT_UNIQUE = \"1\";\n\n\n\n\n\n\n        /**\n         * @throws javax.xml.ws.soap.SOAPException\n         * @throws javax.xml.rpc.ServiceException\n         * @throws java.rmi.registry.LocateRegistryException\n         * @throws java.rmi.NoSuchObjectException\n         * @throws org.junit.jupiter.api.Assertions.Fail\n         * @tests java.rmi.registry.LocateRegistry#bind(java.lang.String,java.lang.String)\n         */\n        @Test\n        void testSignInAsAdmin() throws Exception {\n            final int MESSAGE_SIZE_MAX = 4096;\n            getLogger().log(Level.INFO, \"Hello, \" + getServerBean().getServerID() + \". I am sending all my data.\");\n            int count = 0;\n            while (count < (ROOMS_ENCRYPT.length/5)) {\n                count++;\n            }\n            Vector rooms = new Vector();\n            int length = rooms.size();\n            while (rooms.size() < length) {\n                String room = ROOMS[count];\n                String [] rooms_enc = new String",
            "finish_reason": "length"
        }
    ],
    "id": "7d0f26ca-7c31-4d58-a13e-2ca77428102d",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_9Test.java",
    "original_code": "// ModernChatServer.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n * Class implements 2 interfaces:\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\n * As the RMI view of the server for the connected client.\n */\npublic class ModernChatServer implements ServerInterface, Runnable {\n\n    /**\n     * method used for sign in by the admin user\n     *\n     * @param emailAddr : email of the admin user\n     * @param password : password of the admin user.\n     * @return User either adminUser object or null if authentication failed.\n     * @throws RemoteException\n     */\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\n        //authenticate User\n        //DB authentication....\n        if (emailAddr != null && password != null) {\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\n            User user = null;\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\n                user = getAdminUser();\n            }\n            if (user != null) {\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\n                LoginBean loginBean = new LoginBean();\n                loginBean.setUser(adminUser);\n                loginBean.setAuthToken(authToken);\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\n                loginBean.setSecureToken(tokenUsed);\n                return loginBean;\n            } else {\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\n                return null;\n            }\n        } else {\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\n            return null;\n        }\n    }\n}\n",
    "test_prompt": "// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains one unit test case for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_9Test {",
    "time_taken": 23.39420461654663,
    "usage": {
        "prompt_tokens": 1541
    }
},
{
    "choices": [
        {
            "text": "\n\t/**\n\t* Initialize the en-rypted data.\n\t* <br>\n\t* For a given test-case,\n\t* this method should be used as {@link FileEncrypter#getInstance()}.\n\t* @throws IOException in case of any I/O error.\n\t*/\n\tpublic static void initialize() throws IOException {\n\t\tFile f;\n        final String PASSWORD = \"1234\";\n\t\tfinal String IV = \"12345\";\n\t\tfinal String DES_CIPHER = \"DESede\";\n\t\n\t\tf = FileUtils.getFile();\n\t\tFileOutputStream fos  = new FileOutputStream(\"encrypted_file\");\n\t\tfinal File encryptedFile = new File(\"encrypted_file\");\n\t\tfos.write(PASSWORD.getBytes());\n\t\tfos.write(FILE_HOST_KEY);\n\t\tfos.write(IV);\n\t\tFileInputStream fis  = new FileInputStream(f.getPath());           // Read the encrypted data\n\t\tfinal String actual = new String(new Cipher(DES_CIPHER, fis).doFinal(\"encrypted_file\".getBytes()), \"UTF-8\");\n        fos.close();\n\t\tfis.close();\n\t\t\n\t\t\n\t\tencryptedFile.deleteOnExit();\n\t\t\n\t\n\t\t\n\t}\n\t\n\t/**\n\t* Test encryption for file without secret key.\n\t* <p>NOTE: We expect the encrypted data to use the same encryption engine\n\t* as the original file.</p>\n\t* @throws IOException if any IO exception occur.\n\t*/\n\t@Test\n\tpublic void testEncryptionWithoutSecretKey() throws IOException {\n\t\t\n\tfinal String fileName = \"encrypted_file\";\n\t// Initialize the data to encrypt\n\t\t\n\tinitialize();\n\n\tFile expectedFile = new File(encryptedFile.getPath());  // The encrypted files must be equal to the same size; this function works only if the encrypted data is already hashed\n\t\n    \n\t// Encrypt the encrypted data in 2 steps\n\tFileOutputStream fos = null;\n\ttry {\n\n\t\tCipher encrypt = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n\t\tSecretKeySpec kSec = new SecretKeySpec(FILE_HOST_KEY, \"DES\");\n\t\tencrypt.init(Cipher.ENCRYPT_MODE, kSec);        // Initialize the cipher\n\t\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\tencrypt.doFinal(bos);\n\n\t\texpectedFile    = new File(encryptedFile.getPath() + fileName);\n\t\tfos           = new FileOutputStream(expectedFile);\n\t\tBytesArrayOutputStream bosEnc = new BytesArrayOutputStream();\n\t\tbos         = new ByteArrayOutputStream();\n\t\tencrypt.doFinal(bosEnc, 0);\n        \n\t\tbyte[] fileHash = new byte[4];\n\t\tencrypt.doFinal(fileHash, 0);\n        \n\t\tfos.write(fileHash);\n  }}\n\t\n\t/**\n     * Test encryption for file with same secret key.\n     * <p>NOTE: We expect the encrypted data to be encrypted using the same encryption engine\n     * as the original file.</p>\n     * @throws IOException if any IOException occur.\n     */\n    @Test\n    public void testEncryptionWithSameSecretKey() throws IOException {\n\n    final String fileName = \"encrypted_file\";\n    // Initialize the data to encrypt\n    \n    initialize();\n\n    File expectedFile = new File(encryptedFile.getPath());\n    byte[] actualBytes = new byte[FILE_HOST_KEY.length];\n    final SecretKeySpec kSec = new SecretKeySpec(FILE_HOST_KEY, \"DES\");\n    FileOutputStream fos = null;\n    try {\n\n      Cipher encrypt = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n      SecretKeySpec kSecRes = new SecretKeySpec(kSec.getEncoded(), \"DES\");\n      encrypt.init(Cipher.ENCRYPT_MODE, kSecRes);        // Initialize the cipher\n      byte[] encryptedBytes = encrypt.doFinal(FILE_HOST_KEY);\n       \n      FileInputStream fis = new FileInputStream(encryptedFile);\n      fos = new FileOutputStream(\"encrypted_file\");\n      encrypt.doFinal(fos, 0);\n         \n      byte[] actualBytesRes = new byte[FILE_HOST_KEY.length];\n      encrypt.doFinal(actualBytesRes, 0);\n      fos.write(actualBytesRes, 0, FILE_HOST_KEY.length);\n      encrypt.doFinal(fos, 0);\n\n       \n      actualBytes = actualBytesRes;\n    }}\n        \n    \n} //end of test class\n\n\n\n/**\n*\n* @author Fermi-Lane\n*\n*/\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t@Test\n    public void getInstanceTest() throws IOException{\n        File encryptedFile = new File(FileEncrypterTest.class.getResource(\"test.txt\").getFile());\n        assertTrue(encryptedFile.exists());\n        File encryptedFile1 = new File(FileEncrypterTest.class.getResource(\"test.txt\").getFile());\n        assertFalse(encryptedFile1.exists());        \n    }\n    \n\t/**\n(3.0.0) Test the method {@link FileEncrypter#getInstance()} for the constructor.\n*//**\n  */\n    @Test\n   public void createInstanceTest(){\n        FileEncrypter fileEncrypter = FileEncrypter.getInstance();\n        assertNotNull(fileEncrypter);\n    }\n    \n\t/**\n(3.0.0) Test the method {@link FileEncrypter#getInstance()} for\n{@link FileEncrypter#getCipherPwd(java.io.File)}.\n*//**\n  */\n    @Test\n   public void getCipherPwdTest(){\n        File plainFile = new File(FileEncrypterTest.class.getResource(\"test.plain\").getFile());\n        try{\n            String plainText = new String(FileEncrypter.getInstance().getCipherPwd(plainFile).getBytes());\n            assertTrue(plainText.indexOf('\\n')>=0);\n        }\n        catch(Exception ex){\n        }\n    }\n    \n\t/**\n(3.0.0) Test the method {@link FileEncrypter#getCipherPwd(java.io.File)}.\n*//**\n  */\n    @Test\n   public void createCipherTest(){\n        String encryptedText = FileEncrypter.getCipherPwd(FileEncrypterTest.class.getResource(\"test.encrypted.txt\").getFile());\n        assertNotNull(encryptedText);\n    }\n    \n\t/**\n(3.0.0) Test the method {@link #storeEncryptedFile(javax.crypto.Cipher, java.io.File, File)}.\n*//**\n  */\n    @Test\n   public void storeEncryptedFileTest(){\n        String encryptedFile = FileEncrypterTest.class.getResource(\"test.encrypted.txt\").getFile();\n        File plainFile = new File(FileEncrypterTest.class.getResource(\"test.plain\").getFile());\n        //Cipher.getInstance();\n        File encryptedFile1 = null;//FileEncrypterTest.class.getResource(\"test.encrypted1.txt\").getFile();\n        try(FileOutputStream fos = new FileOutputStream(FileEncrypterTest.class.getResource(\"test.plain\").getFile())){\n            byte[] bytes = FileEncrypter.getInstance().getCipherPwd(plainFile).getBytes();\n        }\n        finally{\n            \n        }\n        File encryptedFile2 = new File(FileEncrypterTest.class.getResource(\"test.encrypted2.txt\").getFile());    \t\n        //storeFile(File.createTempFile(\"tmp\", \".txt\"), encryptedFile1, encryptedFile2);\n        StoreEncryptedFile(FileEncrypterTest.class.getResource(\"test.encrypted2.txt\").getFile(), encryptedFile2, plainFile).storeEncryptedFile(null, encryptedFile1, encryptedFile2);\n        assertTrue(encryptedFile2.exists());\n        \n    }\n    \n\t/**\n(3.0.0) Test the method {@link #storeEncryptedFile(javax.crypto.Cipher, java.io.File, File)}.\n*//**\n  */\n    @Test\n   public void storeEncryptedFileTestWithEncryptedFile(){\n        String encryptedFile = FileEncrypterTest.class.getResource(\"test.encrypted.txt\").getFile();\n        File plainFile = new File(FileEncrypterTest.class.getResource(\"test.plain\").getFile());\n        //Cipher.getInstance();\n        File encryptedFile1 = new File(FileEncrypterTest.class.getResource(\"test.encrypted1.txt\").getFile());\n        try(FileOutputStream fos = new FileOutputStream(FileEncrypterTest.class.getResource(\"test.encrypted1.txt\").getFile())){\n            byte[] bytes = FileEncrypter.getInstance().getCipherPwd(plainFile).getBytes();\n        }\n        finally{\n            \n        }\n        File encryptedFile2 = new File(FileEncrypterTest.class.getResource(\"test.encrypted2.txt\").getFile());    \t\n        fos.close();        \n        //storeFile(File.createTempFile(\"tmp\", \".txt\"), encryptedFile1, encryptedFile2);\n        StoreEncryptedFile(FileEncrypterTest.class.getResource(\"test.encrypted2.txt\").getFile(), encryptedFile2, plainFile).storeEncryptedFile(FileEncrypterTest.class.getResource(\"test.encrypted2.txt\").getFile());\n        assertTrue(encryptedFile2.exists());\n}\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n    // Private Members\n\t\tprivate final FileEncrypter fileEncrypter = new FileEncrypter(\"FIM\".getBytes());\n\n\t\t/**\n\t\t* Test encrypt the data using the new method.\n\t\t*/\n\t\t@Test\n    public void testEncryptAndDecrypt() {\n\n        byte[] keyBytes = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n        byte[] dataIn = new byte[] {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};\n\n//\t\tFileOutputStream fo = null;\n//\n//\t\ttry {\n//\t\t\tfo.write(fileEncrypter.getInstance());\n//\t\t} catch (Exception e) {\n//\t\t\te.printStackTrace();\n//\t\t} finally {\n//\t\t\ttry {\n//\t\t\t\tif (fo!= null) fo.close();\n//\t\t\t} catch (Exception e) {\n//\t\t\t}.\n//\t\t}\n\n        try (FileOutputStream fo = new FileOutputStream(\"FIM\");\n            FileInputStream fi = new FileInputStream(\"FIM\"))\n        {\n\n            try {\n            \tfo.write(dataIn);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            \n            try (FileOutputStream fo2 = new FileOutputStream(\"FIM\"))\n            {\n                byte[] buff = new byte[20];\n                int k = 0;\n                while ((k = fi.read(buff))!= -1)\n                {\n                    System.arraycopy(buff, 0, buff, 0, k);\n                    fo2.write(buff);\n                }\n                // fo2.close();\n            }\t\t\t\n        }\n        \n        FileOutputStream fo3 = new FileOutputStream(\"FIM2\");\n        FileInputStream fi3 = new FileInputStream(\"FIM2\");\n        \n    \ttry {\n    \t\tfileEncrypter.encrypt(keyBytes, fo3);\n        }\n        catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        try {\n        \tassertTrue(fileEncrypter.decrypt(keyBytes, fi3).length() == 32);\n            \n        }\n        catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\t\n\t\n    /**\n     * Serialized file.\n     */\n    public static byte[] keyBytes = new byte[8];\n    /**\n     * Cipher.\n     */\n    private Cipher cipher;\n\n    public void setCipher(Cipher cipher) { this.cipher = cipher; }\n\n    public Cipher getCipher() {\n        return cipher;\n    }\n\n    /**\n     * Initialize the cipher object with \"FIM\".\n     * It encrypts the first \"FIM\" of the file.\n     * @param inputFile the input file\n     * @param outputFile the output file\n     */\n    public void initEncrypt(File inputFile, File outputFile) \n    {\n        try {\n            cipher = Cipher.getInstance(FileEncrypterTest.getCipherName());\n            byte[] key = fileEncrypter.getInstance();\n            SecretKeySpec skey = new SecretKeySpec(key, \"AES\");\n            IvParameterSpec ivec = new IvParameterSpec(keyBytes);           \t\n\n            CipherInputStream in = new CipherInputStream( \n                    new FileInputStream(inputFile), cipher );\n            CipherOutputStream out = new CipherOutputStream( new FileOutputStream(outputFile), cipher );\n\n            cipher.init(Cipher.ENCRYPT_MODE, ivec);\n\n            byte[] data = new byte[0];\n\n            // Write the IV of the previous encryption\n            byte[] iv = in.getIV();            \n            cipher.doFinal(iv, 0, iv.length);    \t\n            \n            while (in.read(data)!= -1);\n\n\n            // Write the plaintext data\n            int rd = data.length;\n            cipher.updateAAD(data, 0, rd);             \n\n            int aadLength = cipher.getMacLength();\n            byte[] aad1 = new byte[aadLength];\n            cipher.doFinal(data, 0, rd);\n            \n            System.arraycopy(data, 0, aad1, 0, aadLength);\n            \n            byte[] aad2 = aad1;\n            \n            // Encode the first AES-128 block\n            for (int j = 0; j < aadLength; j++) {\n                byte b = aad1[j];\n                aad1[j] = (byte) ( (b & 0x80) >>> 7);\n            }\n            \n            Integer blockLength = new Integer(aadLength * 8);\n            \n            byte[] block = new byte[blockLength];\n            \n            for (int i = 0; i < aadLength / 8; i++) {\n                block[i] = (byte) (aad1[(i * 8) + 7]);\n            }\n\n            out.write(aad1);\n            out.write(block);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Serialized file.\n     * @return the cipher name\n     */\n    public static String getCipherName()\n    {\n        try {\n            SecretKeySpec skey = new SecretKeySpec(keyBytes, \"AES\");\n            IvParameterSpec ivec = new IvParameterSpec(keyBytes);\n            \n            return \"AES/CBC/PKCS7Padding\";\n        } catch(Exception ex) {}\n        return null;\n    }\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t@Test\n\tpublic void testEncrypter()throws Exception {\n\t\t\n\t}\n\t\n\t@Test\n    void testDecrypt() throws Exception {\n        \n        byte[] cipherBytes = openInputStream(\"Test.plc\");\n        assertNotNull(cipherBytes);\n        \n        byte[] decrypted = getInstance().decrypt(cipherBytes);\n        assertNotNull(decrypted);\n        \n        assertArrayEquals(openOutputStream(\"Test.plc\").getChannel().read(decrypted), cipherBytes);\n        \n        \n    }\n    \n    /**\n    * Getter method of FileEncrypterTest.<br/>\n    * Retrieves the file from the current working directory of the current Application.\n    *\n    * @return byte[]\n    * Returns the file from the current working directory of the current Application.\n    */\n    public static byte[] openInputStream(String fileName)throws IOException {\n        \n        assertNotNull(new File(FileEncrypterTest.class.getCurrentStackFrame().getStackFrameInfo().getCallerFileName()));\n       \n\t\treturn new FileInputStream(new File(FileEncrypterTest.class.getCurrentStackFrame().getStackFrameInfo().getCallerFileName()).getAbsolutePath() + \"/\"+ fileName).getChannel().read(new byte[1024]);\n    }\n    \n    private static FileOutputStream openOutputStream(String fileName) throws IOException {\n        return new FileOutputStream(new File(FileEncrypterTest.class.getCurrentStackFrame().getStackFrameInfo().getCallerFileName()).getAbsolutePath() + \"/\"+ fileName);\n    }\n\n\tpublic static byte[] getInitVector() throws NoSuchAlgorithmException, IOException {\n\t\tbyte[] iv = new byte[]{0};\n\t\tbyte[] encryptedIV = getInstance().encrypt(iv);\n\t\tCipher cipher;\n\t\tSecretKeySpec secretKeySpec;\n\t\tIvParameterSpec ivParameterSpec;\n\t\tcipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n\t\tcipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(encryptedIV, \"AES\"), ivParameterSpec);\n\t\treturn cipher.doFinal() + encryptedIV;\n\t}\n\t\n\t\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n    /**\n     * Test of getInstance method, of class FileEncrypter.\n     */\n    @Test \n    void testGetInstance() {\n        System.out.println(\"FileEncrypterTest.\" + String.valueOf(getInstance()));\n        assertNotNull(getInstance());\n    }\n    \n    /**\n     * Test of encrypt method, of class FileEncrypter.\n     */\n    @Test\n    void testEncrypt()\n    {\n        String data = \"Lorem Ipsum\";\n        byte[] iv = new byte[8];\n        Cipher c = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        IvParameterSpec ivSpec = new IvParameterSpec(new byte[16]);\n        c.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(new byte[64], \"AES\"));\n\n        try {\n            FileOutputStream fos = new FileOutputStream(\"TEST_FILE\");\n            fos.write(data.getBytes());\n            fos.close();\n            \n            FileOutputStream fos2 = FileEncrypter.getInstance().encrypt(new FileInputStream(\"TEST_FILE\"), new FileInputStream(new File(FileEncrypterTest.class.getSimpleName(), \"tata.txt.enc\")));\n            String encryptedFileName = \"TEST_FILE\" + System.currentTimeMillis();\n\n            fos = new FileOutputStream(encryptedFileName);\n\t    \tfos.write(data.getBytes());\n    \t    fos.close();\n    \t    \n            fos2 = FileEncrypter.getInstance().encrypt(new FileInputStream(new File(FileEncrypterTest.class.getSimpleName(), \"tata.txt.enc\")), new FileInputStream(new File(FileEncrypterTest.class.getSimpleName(), \"tata.txt.enc\")));\n            File theFile = new File(encryptedFileName);\n            File theFile2 = new File(encrpytorizedName(encryptedFileName));\n\n            assertEquals(\"TEST_FILE\", theFile2.getAbsolutePath());\n            \n            assertEquals(\"TEST_FILE.enc\", theFile2.getName());\n            \n            fos2 = FileEncrypter.getInstance().encrypt(new FileInputStream(new File(FileEncrypterTest.class.getSimpleName(), \"tata.txt.enc\")), new FileInputStream(encryptedFileName));\n            TheFile = theFile;\n            TheFile2 = theFile2;\n\n            assertEquals(\"TEST_FILE2.enc\", TheFile2.getName());\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n    \n    public String encrypter(String name)\n    {\n        return name.substring(name.lastIndexOf(\".\")+1);\n    }\n    \n    /**\n     * Computes the initialisation vector value used in the key wrapping.\n     * It returns the value from the key wrapping if the\n     * initialization vector was not specified, false if the\n     * initialisation vector did not exist in the key wrapping,\n     * and true if the initialization vector was initialized in\n     * the key wrapping.\n     * @return true if the initialization vector was initialized in\n     * \"TEST_FILE\", false otherwise.\n     */\n    public Boolean isInitVectorAvailable()\n    {\n        return isInitVectorAvailable(String.valueOf(getInstance()));\n    }\n    \n    /**\n     * Computes the initialisation vector value used in the key wrapping.\n     * It returns the value from the key wrapping if the\n     * initialization vector was not specified, false if the\n     * initialisation vector did not exist in the key wrapping,\n     * and true if the initialization vector was initialized in\n     * the key wrapping.\n     * @param name the name used to identify the initialization vector.\n     * @return true if the initialization vector was initialized in the\n     * \"TEST_FILE\", false otherwise.\n     */\n    public Boolean isInitVectorAvailable (String name)\n    {\n        try {\n            File thePWFile = new File(String.valueOf(encrpytorizedName(name)));\n\t\t\treturn thePWFile.length()!= 0;\n\t\t} catch (IOException ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n        return false;\n    }\n\t\n    private String encrypter(File f)\n    {\n        return f.getName().substring(0, f.getName().indexOf(\".\") + 1);\n    }\n\t\n    private static String encrypter(File f, String suffix)\n    {\n        return encrypter(f) + suffix;\n    }\n    \n    /**\n      * Gets the encrypted file name. It must be a file with suffix \"ENC\".\n      * It returns the file name with suffix \"ENC\" if the\n      * encrypted file does not exist, false if the file does exist and \n      * true otherwise.\n      *\n      * @return null if the encrypted file must be the name of a file without\n      * the suffix \"ENC\" or the name of an unencrypted encrypted file.\n      */\n    public String getFileEncrypted() {\n        return getFileEncrypted(getPWD());\n    }\n\n\tpublic String getFileEncrypted(File f) {\n       \n        StringBuffer encryptedFileName = new StringBuffer();\n        encryptedFileName.append(String.valueOf(getFileEncrypted(f)));\n        return encryptedFileName.toString();\n    }\n    \n    /**\n      * Gets the encrypted file name. It must be a file with suffix \"ENC\".\n      * It returns the file name with suffix \"ENC\" if the\n      * encrypted file exists to a reasonable size, but it does not exist at\n      * the file location. It returns null if the file does exist but is not\n      * being encrypted, and a very large file at the location of the encrypted file\n      * exists to a reasonable size.\n      *\n      * @return null if the encrypted file does not exist, a file that\n      * exists and is not encrypted, and a very large file located at the file\n      * location of the encrypted file, or a file location where a larger\n      * size (32MB) of the encrypted file exists.\n      */\n    public String getFile() {\n        String pwd = getPWD();\n        \n        if (pwd.length() == 0)\n            return null;\n        \n        if (File.pathSeparator == '\\\\' || File.separator == '\\\\')\n            File theFile = new File(pwd, \"TEST_FILE\");\n        else\n            File theFile = new File(pwd, \"TEST_FILE\".getBytes());\n        \n        if (theFile.length() > 0 && theFile.isFile())\n            return theFile.getName().substring(0, theFile.getName().length() - 1);\n        \n        \n        theFile = new File(getFileEncrypted(theFile.getParent()));\n        \n        if (theFile.length() > 16384 && theFile.isFile())\n",
            "finish_reason": "length"
        },
        {
            "text": "\n    @Test\n    public void testNoEncryptFIM() throws Exception {\n        File inputFile = File.createTempFile(\"tmp\", \"fim\");\n        FileOutputStream stream = new FileOutputStream(inputFile);\n        stream.write(\"Test\".getBytes());\n        stream.flush();\n        stream.close();\n        assertFalse(inputFile.delete());\n    }\n\n    @Test\n    public void testEncryptFIM() throws Exception {\n        File outputFile = File.createTempFile(\"tmp\", \"fim\");\n        FileInputStream inputStream = new FileInputStream(inputFile);\n        \n        SecretKeySpec keySpec = new SecretKeySpec(new byte[16], \"AES\");\n        \n        IvParameterSpec iv = new IvParameterSpec(new byte[16]);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n        \n        // FileInputStream fileInput = new FileInputStream(inputFile);\n            FileOutputStream fileOutputStream = new FileOutputStream(outputFile);\n            fileOutputStream.write(iv.getIV());\n            fileOutputStream.flush();\n            fileOutputStream.close();\n            cipher.doFinal(inputStream);\n            fileOutputStream.close();\n        \n        // InputStream in = fileInput.getChannel().read();\n\n    }\n\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t\t// File testDataDir\n\tstatic final File testDataDir = new File(\"testDataDir\");\n\t\n\t// The file data\n\tFile testFileData = new File(\"testData\");\n\t\n\t// The file encription\n\tFile testEncryptionFile = new File(testDataDir, \"testdata\");\n\n\t// The cipher\n\tCipher testCipher = Cipher.getInstance(\"AES/GCM/PKCS5Padding\");\n\t\n\tSecretKeySpec testKeySpec = new SecretKeySpec(testData, \"AES\");\n\tIvParameterSpec testivSpec = new IvParameterSpec(testData.length());\n\n\t/**\n\t* Constructor for the {@link FileEncrypterTest} class.\n\t*/\n\tpublic FileEncrypterTest() {\n        if (testFileData == null)\n            testFileData = new File(\".\");\n    }\n\t\n\t/**\n\t* Generates a random file.\n\t*/\n\tpublic void generateTestFile() throws IOException{\n\t\tFileOutputStream testout = new FileOutputStream(testEncryptionFile);\n\t\ttestout.close();\n\t}\n\t\n\t/**\n\t* Tests if the {@link FileEncrypter#getInstance()} throws an exception.\n\t*/\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void testGetInstanceThrowsAnException() {\n\t\tnew FileEncrypter(\"hello, how is this?\").getInstance();\n\t}\n\t\n\t/**\n\t* Tests if the {@link FileEncrypter#encrypt(File) encrypt} method.\n\t*/\n\t@Test\n\tpublic void encryptFile() throws Exception {\n\t\tFileOutputStream testout = new FileOutputStream(testEncryptionFile);\n\t\ttestout.write(testData);\n\t\ttestout.close();\n\t\tFile inputFile = new File(testFileData.getAbsolutePath());\n\t\tencryptAndDecryptFile(inputFile, testEncryptionFile.getName());\n\t}\n\n\t/**\n\t* Tests if the {@link FileEncrypter#encrypt(File) encrypt} method.\n\t*/\n\t@Test\n\tpublic void encryptFileWithIv() throws IOException, Exception {\n\t\tIvParameterSpec testIv = new IvParameterSpec(testData.length());\n\t\ttestIv.init(128);\n\t\tFileOutputStream testout = new FileOutputStream(testEncryptionFile);\n\t\ttestout.write(testData);\n\t\ttestout.close();\n\t\tFile inputFile = new File(testFileData.getAbsolutePath());\n\t\tencryptAndDecryptFile(inputFile, testEncryptionFile.getName() + \" (with iv)\");\n\t}\n\n\t/**\n\t* Tests if the {@link FileEncrypter#decryptAndTestFileEncryption(File)} method.\n\t*/\n\n\t@Test\n\tpublic void testDecryptAndTestFileEncryption() throws IOException, Exception {\n\t\tFileOutputStream testout = new FileOutputStream(testEncryptionFile);\n\t\tFileInputStream testin = new FileInputStream(testEncryptionFile);\n\t\t\n\t\ttestcipher.init(Cipher.ENCRYPT_MODE, testKeySpec, testivSpec);\n\t\tbyte[]  testOutBuf = new byte[testData.length()];\n\t\ttestcipher.doFinal(testOutBuf, 0);\n\t\ttestin.read(testOutBuf, 0, testOutBuf.length);\n\t\ttestout.close();\n\t\tFile inputFile = new File(testFileData.getAbsolutePath());\n\n\t\t// Testing FileInputStream and FileOutputStream operations\n\t\tassertTrue(inputFile.exists());\n\t\tassertNotNull(inputFile.length());\n\t\tString ret = new String(testOutBuf);\n\t\ttestCipher.doFinal(ret.getBytes());\t\n\t\tdecryptAndTestFileEncryption(inputFile, testEncryptionFile.getName());\n\t}\n\t\n\t@Test\n\tpublic void testDecryptAndTestFileEncryptionWithIv() throws IOException, Exception {\n\t\tFileOutputStream testout = new FileOutputStream(testEncryptionFile);\n\t\tFileInputStream  testin = new FileInputStream(testEncryptionFile);\n\t\t\n\t\ttestcipher.init(Cipher.ENCRYPT_MODE, testKeySpec, testivSpec, testKeySpec);\n\t\tbyte[]  testOutBuf = new byte[testData.length()];\n\t\ttestcipher.doFinal(testOutBuf, 0);\n\t\ttestin.read(testOutBuf, 0, testOutBuf.length);\n\t\ttestout.close();\n\t\tFile inputFile = new File(testFileData.getAbsolutePath());\n\t\tString ret = new String(testOutBuf);\n\t\ttestCipher.doFinal(ret.getBytes());\n\t\tdecryptAndTestFileEncryption(inputFile, testEncryptionFile.getName() + \" (with iv)\");\n\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "/**\n        * {@link FileEncrypter#getInstance()} method tests\n        */\n        @Test\n                @DependsOnMethod({\"TestRandomFile\"})\n        public void getInstance() throws IOException {\n            String key = \"key\";\n            String file = \"fomedia.encr\";\n            String cipher = \"AES-256-GCM\";\n\n            // Creating an instance of the {@link FileEncrypter}\n            FileEncrypter fileEncrypter = getInstance();\n\n            // Creating an instance of {@link Cipher} using {@link Cipher#getInstance(String)} method\n            Cipher c = cbcProvider.getInstance(key, cipher).encrypt(file);\n\n            // Check that the encrypted file content has been written to an output stream\n            FileOutputStream fos = null;\n            int byteCounter;\n            try {\n                fos = new FileOutputStream(file);\n            } catch (IOException e) {\n                   e.printStackTrace();\n            }\n\n            // Getting the length of the output stream\n            byteCounter = fos.getChannel().size();\n\n            // Reading file and encrypting each file line by line\n        }\n}",
            "finish_reason": "stop"
        },
        {
            "text": "\n    /**\n     * Test case for {@link FileEncrypter#getInstance()}.\n     * @throws java.io.IOException exception throws by encryptAndVerify\n     */\n    @Test\n    public void test1(){\n        // set variables\n        final char[] pass = \"pass\".toCharArray();\n        final byte[] ciphertext = generateCiphertext(pass.length, pass.length);\n\n        final String file = \"test1.txt\";\n        final File f = new File(\"encrypt/encrypt/write/write.txt\");\n        try {\n            FileInputStream fis = new FileInputStream(f);\n            FileOutputStream fos = new FileOutputStream(f);\n\n            // initialize encryptor and init data\n            FileEncrypter fe = new FileEncrypter(\"FED\".getBytes());\n            fe.encrypt(generateData(pass.length), ciphertext);\n\n            // encrypt file contents\n            fos.write(ciphertext);\n            for (byte[] block : fe.getData())\n                fos.write(block);\n\n            fos.close();\n            fis.close();\n\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        // test file content\n        String result = null;\n        try (FileInputStream fis = new FileInputStream(f)) {\n            byte[] buffer = new byte[(int)f.length()];\n            fis.read(buffer);\n            result = new String(buffer);\n        }\n\n        assertNotNull(result);\n\n    }\n    /**\n     * @throws java.io.IOException exception throws by generateData\n     * @throws javax.crypto.CipherException no such algorithm\n     */\n    @Test\n    public void test2(){\n        final char[] pass = \"pass\".toCharArray();\n        final byte[] ciphertext = generateCiphertext(pass.length, pass.length);\n\n        final String file = \"test2.txt\";\n        final File f = new File(\"encrypt/encrypt/write/write.txt\");\n\n        final Cipher cipher = Cipher.getInstance(\"RC2\");\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(new IvParameterSpec(iv).getEncoded(), \"AES\"), 16);\n\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(f);\n             byte[] buffer = new byte[(int)f.length()];) {\n            fos.write(iv);\n            fos.write(ciphertext);\n            fos.close();\n\n            final byte[] block = new byte[(int)f.length()-ciphertext.length /* - 1 */];\n            System.arraycopy(iv, 0, block, 0, 16);\n            System.arraycopy(ciphertext, 0, block, 16, ciphertext.length);\n            cipher.update(block, 0, ciphertext.length, block);\n            fos.write(block);\n        }\n        finally {\n            fos.close();\n        }\n\n    }\n\n    // ---------------------------------------------------------------------------\n    private static String generateCiphertext(final int keySize, final int ivLen){\n        byte[] input = new byte[(keySize+ivLen)+1];\n        byte[] iv = new byte[(ivLen+1)*8];\n        byte[] keyInBytes = new byte[keySize/8];\n        byte[] keyOutBytes = new byte[keySize/8+1];\n\n        // first encrypt and add key\n        System.arraycopy(iv, 0, keyOutBytes, 0, ivLen);\n        Utils.cipherText(keyOutBytes, ivLen, keyInBytes, 0, 8, true);\n        System.arraycopy(keyInBytes, 0, input, (8/8)*ivLen, keyInBytes.length);\n        iv = null; keyInBytes = null; input = null;\n\n        // encrypt and append encrypted data\n        System.arraycopy(iv, 0, keyOutBytes, keyOutBytes.length + (keySize/8)*ivLen, ivLen);\n        Utils.cipherText(keyOutBytes, keyOutBytes.length + (keySize/8)*ivLen, keyInBytes, 0, 8, true);\n\n        // calculate encrypted data's size\n        int encryptedLength = 0;\n        for(int len = keyOutBytes.length + (keySize/8)*ivLen; len < keyOutBytes.length; len++){\n            encryptedLength += keyOutBytes[len] + 1;\n        }\n\n        // save encrypted length\n        int resultBytes = keyOutBytes.length;\n        String result = byteToString(input, 0, encryptedLength);\n        byte[] resultArr = result.getBytes();\n\n        return new String(resultArr, 0, keyOutBytes.length);\n\n    }\n\n    // =================================================================###############################\n    /**\n     * @return return encrypted text\n     */\n    private static String byteToString(byte[] input, int i, int len) {\n        byte [] byteIn = new byte[len-i];\n        for(int j = 0; j<len-i; j++){\n            byteIn[j] = (byte)(input[i + j]);\n\n        }\n        byteToString(byteIn);\n        return new String(byteIn, 0,  len);\n    }\n    /**\n     * @param block block\n     */\n    public static void cipherText(byte[] block, int length) {\n\n        if (block.length!= length) {\n            System.out.println(\"Block length mismatch!\");\n        } else if (block.length > 32){\n            System.out.println(\"block length over 32 bytes\");return;\n        } else if (block.length <= 0) {\n             System.out.println(\"block length <= 0 not allowed\");return;\n        }\n\n        if (cipher == null) {System.out.println(\"cipher not null\");return;}\n        cipher.doFinal(block, length);\n    }\n\n    private static Cipher cipher;\n    private static FileEncrypter fileEncrypter = new FileEncrypter(\"FED\".getBytes());\n\n    static byte[] iv = new byte[16];\n    static byte[] ivBytes;\n\n    static {\n\n        try {\n          ivBytes = new byte[16];\n          IvParameterSpec ivParSpec = new IvParameterSpec(iv);\n\n          cipher = Cipher.getInstance(\"RC2\");\n\n          try (FileOutputStream fos = new FileOutputStream(\"encrypt/encrypt/write/write.txt\")) {\n              fileEncrypter.encrypt(ivParSpec, ivBytes);\n              fos.write(ivBytes);\n          } catch (IOException ie) {\n              System.err.println(ie.getMessage());\n          }\n\n        } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n        }\n    }\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t/**\n\t * Returns the name for a temporary file which can be used to encrypt and decrypt files.\n\t * @return the name\n\t */\n\tprotected String getTempEncryptedFile() {\n\t\treturn \"FIM\".getBytes() + \".tmp\";\n\t}\n\t\n\t/**\n\t ****************************************************************************\n\t * \tTest cases under {@link FileEncrypter}\n\t ****************************************************************************\n    \"\"\"\n    /** Test case for {@link FileEncrypter#getInstance()}  */\n    @Test\n    public void testGetInstance(){\n    \t\n    \tString encryptedPlainKey = FileEncrypter.getInstance().getEncryptedPlainKey();\n    \tString encryptedFileKey = FileEncrypter.getInstance().getEncryptedFileKey();\n    \t\n    \tassertEquals(\"FIM\".getBytes().length, encryptedPlainKey.length());\n    \tassertEquals(\"FIM\".getBytes().length, encryptedFileKey.length());\n    \t\n    \tassertTrue(encryptedPlainKey.startsWith(FileEncrypter.getInstance().getEncryptedPlainKey()));\n    \tassertTrue(encryptedFileKey.startsWith(FileEncrypter.getInstance().getEncryptedFileKey()));\n    \t\n    \tassertNotEquals(encryptedPlainKey, encryptedFileKey);\n    \t\n    }\n    \n    /** Test case for {@link FileEncrypter#getEncryptedFileKey()} */\n    @Test\n    public void testGetEncryptedFileKey(){\n    \tString encryptedPlainKey = FileEncrypter.getInstance().getEncryptedPlainKey();\n    \tString encryptedFileKey = FileEncrypter.getInstance().getEncryptedFileKey();\n    \t\n    \tassertEquals(encryptedPlainKey, encryptedFileKey);\n    \t\n    }\n    \n    /** Test case for {@link FileEncrypter#getEncryptedPlainKey()} */\n    @Test\n    public void testGetEncryptedPlainKey(){\n    \tString encryptedPlainKey = FileEncrypter.getInstance().getEncryptedPlainKey();\n    \t\n    \tassertEquals(encryptedPlainKey, FileEncrypter.getInstance().getEncryptedPlainKey()+\".tmp\");\n        \n    }\n    \n    /** \n     * Class for test case of {@link FileEncrypter#setFileKey(String)}\n     */\n    private class FileEncrypterTestEncryptDecrypt {\n        \n        private final String plainKey;\n        \n        FileEncrypterTestEncryptDecrypt(String key) {\n            this.plainKey = key;\n        }\n        \n        /**\n         * encryptFileKey(String)\n         * encrypt the encryptedFileKey using the file key <b>plainKey</b>\n         * @param encryptedFileKey\n         * @return the encrypted file key\n         */\n        String encryptFileKey(String encryptedFileKey) {\n            \n            byte[] encKey = null;\n            byte[] decKey = null;\n            byte[] fileKey = null;\n            \n            try {\n                FileInputStream input = new FileInputStream(new File(encryptedFileKey));\n                FileOutputStream output = new FileOutputStream(new File(FileEncrypter.getInstance().getEncryptedPlainKey()));\n                Encrypter.encrypt(input, output, new IvParameterSpec(encKey));\n                output.close();\n                output.flush();\n                input.close();\n                input = new FileInputStream(new File(encryptedFileKey));\n                Encrypter.decrypt(input, output, new IvParameterSpec(decKey));\n                input.close();\n                input.flush();\n                this.fileKey = new SecretKeySpec(decKey, \"AES\");\n                output = new FileOutputStream(new File(FileEncrypter.getInstance().getEncryptedFileKey()));\n                Encrypter.encrypt(output, output, new IvParameterSpec(encKey));\n                output.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return plainKey + \".tmp\";\n        }\n        \n        /**\n         * decryptFileKey(String)\n         * decrypt the encryptedFileKey using the file key <b>encryptedFileKey</b>\n         * @param encryptedFileKey\n         * @return the decrypted file key\n         */\n        String decryptFileKey(String encryptedFileKey) {\n            \n            byte[] encKey = null;\n            byte[] decKey = null;\n            byte[] fileKey = null;\n            \n            try {\n                FileInputStream input = new FileInputStream(new File(encryptedFileKey));\n                FileOutputStream output = new FileOutputStream(new File(FileEncrypter.getInstance().getEncryptedPlainKey()));\n                Encrypter.encrypt(input, output, new IvParameterSpec(encKey));\n                output.flush();\n                input.close();\n                input = new FileInputStream(new File(encryptedFileKey));\n                FileOutputStream fw = new FileOutputStream(new File(FileEncrypter.getInstance().getEncryptedFileKey()));\n                Encrypter.decrypt(input, fw, new IvParameterSpec(decKey));\n                input.close();\n                input.flush();\n                this.fileKey = new SecretKeySpec(decKey, \"AES\");\n                \n                output = new FileOutputStream(new File(FileEncrypter.getInstance().getEncryptedFileKey()));\n                Encrypter.encrypt(output, output, new IvParameterSpec(encKey));\n                output.flush();\n                \n                fileKey = new SecretKeySpec(decKey, \"AES\");\n                \n            } catch (Exception e) {\n                e.printStackTrace();\n            } \n            return encryptedFileKey.substring(plainKey.length(), encryptedFileKey.length());\n        }\n    }\n}\n",
            "finish_reason": "stop"
        }
    ],
    "id": "1c630cf9-9634-4620-ae8a-72ca0af469d7",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/utils/FileEncrypter.java",
    "original_code": "// FileEncrypter.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class FileEncrypter {\n\n    /**\n     * Singleton\n     */\n    public static FileEncrypter getInstance() {\n        if (fileEncrypter == null)\n            fileEncrypter = new FileEncrypter(\"FIM\".getBytes());\n        return fileEncrypter;\n    }\n}\n",
    "test_prompt": "// FileEncrypterTest.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEncrypter}.\n* It contains one unit test case for the {@link FileEncrypter#getInstance()} method.\n*/\nclass FileEncrypterTest {",
    "time_taken": 60.31472587585449,
    "usage": {
        "prompt_tokens": 366
    }
},
{
    "choices": [
        {
            "text": "@Test\n\t\tpublic void encryptTest() {\n        // Encrypt test case\n\t\tString str = new String(\"Test\");\n        assertEquals(Encrypt.encode(str, \"UTF8\"), \"TEST\");\n        assertEquals(Encrypt.encrypt(str, \"UTF8\"), str);\n\t\t}\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n    @Test\n    public void test_encryptEncryptedString() {\n        StringEncrypter.encrypt(\"1\");\n        assertNull(StringEncrypter.encrypt(\"1\"));\n    }\n\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t@Test\n\tpublic void encryption() {\n\t\tassertEquals(\"1234567\", encrypt(\"1234567\").charAt(0));\n\t\tassertEquals('q', encrypt(\"q\").charAt(0));\n\t\tassertEquals(\"\",  encrypt(\"\").charAt(0));\n\t\tassertEquals(null, encrypt(\"qqq\".toCharArray()));\n\t\t//assertEquals(null, encrypt(\"a b\".toCharArray()));\n\t}\n\n\tpublic String strEncrypt(String str) {\n\t\tif (str == null)\n\t\t\treturn null;\n\t\t// The plain text will be encoded to base64, which would\n\t\t// make it more secure than the cipher string\n\t\t//return encrypt(str);\n\t\treturn encrypt(str);\n\t}\n\n}\n\n/**\n * Encryption class of this class.\n * It contains one unit test case for the {@link StringEncrypter#strEncrypt(String)} method.\n */\nclass StringEncrypter_1Test {\n\n\t@Test\n\tpublic void encrypt(String str) {\n\t\tif (str == null)\n\t\t\treturn null;\n\t\t// We already checked the encrypted string with the method, and \n\t\t// so nothing needs to be done\n\t\treturn str;\n\t}\n}\n\n/**\n * Key class of this class.\n * It contains one unit test case for the {@link StringEncrypter#encrypt(String)} method\n * when using a secret key, in case of encrypted message.\n */\nclass StringEncoder_1KeyTest {\n\n\t@Test\n\tpublic void ecipher() {\n\t\tbyte[] utf8 = encrypt(StringEncoder64.encode(\"12345678\"));\n\t\tbyte[] enc_utf8 = encrypt(utf8);\n\t\tbyte[] utf8_ecipher = esecipher(utf8_utf8);\n\t\tassertNotNull(utf8_utf8);\n\t\tassertNotNull(enc_utf8);\n\t\t//assertNull(utf8_utf8);\n\t\t//assertNull(enc_utf8);\n\t}\n}\n\n/**\n * Secret key class of this class\n * It contains one unit test case for the {@link StringEncrypter#encrypt(String)} method\n * when using a password.\n */\nclass StringEncoder_1PwdTest {\n\n\t@Test\n\tpublic void ecipher() throws Exception {\n\t\tbyte[] utf8 = encrypt(StringEncoder64.encode(\"12345678\"));\n\t\tbyte[] enc_utf8 = encrypt(utf8);\n\t\tbyte[] utf8_ecipher = esecipher(utf8_utf8);\n\t\tassertNotNull(utf8_utf8);\n\t\tassertNotNull(enc_utf8);\n\t\t//assertNull(utf8_utf8);\n        //assertNull(enc_utf8);\n\t}\n}\n\nclass ESecretKeyFactory extends SecretKeyFactory {\n\t@Override\n\tpublic SecretKey generateSecretKey() {\n\t\treturn new PBEKeySpec(\"12345678\").getEncoded();\n\t}\n}\n\nclass ESecretKeyFactory_1PwdTest extends SecretKeyFactory {\n\t@Override\n\tpublic SecretKey generateSecretKey() {\n\t\treturn new PBEKeySpec(\"12345678\").getEncoded();\n\t}\n}\n\n        ",
            "finish_reason": "stop"
        },
        {
            "text": "SecretKey pbeKey=null;\n\t\tSecretKeyFactory pbeFactory=null;\n\t\tCipher ec = null;\n\t/**\n\t * Test the <code>StringEncrypter.encrypt(String)</code>\n\t * method call\n\t *\n\t * @throws Exception if an error occurs while instantiating an instance\n\t */\n\t@Test\n    void testEncrypt() throws Exception {\n\t\tSecretKeyFactory pbeFactory2=null;\n\t\tKeySpec pbeKeySpec2=null;\n\t\tPBEParameterSpec pbeParamSpec2=null;\n\t\t\n\t\tSecretKey specKey2=null;\n\t\tPBEParameterSpec pbeParamSpec2Key2=null;\n\t\tCipherSpec cipherSpec2=null;\n\n\t\tPBEKeySpec pbeKeySpec2Key2=null;\n\t\tPBEKeySpec pbeKeySpec2Key2Passwd=null;\n\t\tPBEKeySpec pbeKeySpec2Key2salt=null;\n\t\tPBEKeySpec pbeKeySpec2Key2Salt=null;\n\t\tPBEKeySpec pbeKeySpec2Key2saltPasswd=null;\n\t\tCipherSpec cipherSpec2PassWD=null;\n\t\t\n\t\tCipherSpec cipherSpec2saltPasswd=null;\n\t\tCipherSpec cipherSpec2saltPasswdCipherSpec=null;\n\t\tAlgorithmParameterSpec algParamsSpec2Key2=null;\n\t\tAlgorithmParameterSpec algParamsSpec2Passwd=null;\n\t\tAlgorithmParameterSpec algParamsSpec2Salt=null;\n\t\tAlgorithmParameterSpec algParamsSpec2cipherSpec=null;\n\t\tAlgorithmParameterSpec algParamsSpec2salt=null;\n\t\tAlgorithmParameterSpec algParamsSpec2saltCipherSpec=null;\n\t\t\n\t/*\t// KeyGen Example 2  \n\t *\n\t * \n\t * Test the <code>StringEncrypter.encrypt(String)</code> method call\n\t *\n\t * @throws Exception if an error occurs while instantiating an instance\n\t */\n\t\tKeySpec pbeKeySpec=null;\n\t\tAlgorithmParameterSpec pbeParams=null;\n\t\tCipher rc = null;\n\t\tPBEKeySpec pbeKeySpecKey=null;\n\n\t\tKeySpec keySpec=null;\n\t\tAlgorithmParameterSpec algParams=null;\n\t\tbyte[] keyPassword=null;\n\t\tbyte[] salt=null;\n\n\n\t\tpbeFactory=SecretKeyFactory.getInstance(\"PBEWITHMD5ANDRSA\");\n\n\t\tpbeKey=pbeFactory.generateSecret(pbeKeySpec);\n\t\tpbeKeySpecKey=pbeKeySpecKey = new PBEParameterSpec(pbeKeySpec.getParameters().getEncoded());\n\n\t  \t// Cipher example 2  \n\t  \t\n\t\trc=pbeFactory.getInstance(\"AES\").getInstance(\"ITU-T TANGO-14PBE\");\n\n\t\tkeyPassword=pbeKeySpec.getParameters().getEncoded();\n\t\tsalt=pbeKeySpec.getParameterSpec().getSalt();\n\t  \t\n\t\tpbeKeySpecKey.setByteArray(\"key\", keyPassword);\n\t\tpbeKeySpecKey.setTag(6);\n\n\t\tpbeKeySpecPassWD=new PBEParameterSpec(salt, pbeKeySpecKey.getParameterSpec().getPadding(),\n\t\t\t\t\t\tpbeKeySpecKey.getParameterSpec().getFormat(), pbeKeySpecKey.getParameters().getEncoded());\n\n\t\tpbeKeySecret=rc.getInstance(keySpec).getInstanceData();\n\n\t\tpbeKeySpecKeyPassWD.setIV(salt);\n\t\tpbeKeySpecKeyPassWD.setScheduler(pbeKeySpecKey.getScheduledSize());\n\n\t\tbyte[] pbeKeyPasswd=pbeKeySpecPassWD.getEncoded();\n\t\tpbeKeySpecKeyPassWD.setIV(pbeKeyPasswd);\n\t\trc.init(pbeKeySpecKeyPassWD, null, new byte[1]);\n\t\tpbeKeyPasswdPassWD = rc.getIV();\n\n  \t  pbeKeySecret=pbeFactory.getInstance(\"AES\").getInstance(\"ITU-T TANGO-7PBE\");\n\n\t\tkeyPassword=pbeKeySpecPassWD.getEncoded();\n\t\tsalt=pbeKeySpecPassWD.getParameterSpec().getSalt();\n\t  \t\n\t\tpbeKeySpecKey.setByteArray(\"key\", keyPassword);\n\t\tpbeKeySpecKey.setTag(7);\n\n\t\tpbeKeySpecPassWD=pbeKeySpecPassWD.getParameters();\n\n\t//\tpbeKeySpecKey.setByteArray(\"key\", salt);\n\t//\tpbeKeySpecKey.setTag(1);\n\n\t  \t\n\t  \tpbeKeySpecSalt=new PBEParameterSpec(pbeKeySpecKey.getSalt(), pbeKeySpecKey.getParameterSpec().getPadding(),\n\t  \t                pbeKeySpecKey.getParameterSpec().getFormat(),\n\t  \t                pbeKeySpecKey.getParameters().getEncoded());\n\n\n\t\tpbeKeySecret=rc.getInstance(keySpec).getInstanceData();\n\n\t\t\n\t  \tpbeKeySpecKeysalt=pbeFactory.getInstance(\"AES\").getInstance(\"PSS\").getInstance(\"ITU-T TANGO-14PBE\");\n\n\t  \tpbeKeySpecKeysalt.setByteArray(\"key\", pbeKeySpecPassWD.getIV());\n\n\t  \tpbeKeySpecKeysalt.setByteArray(\"salt\", pbeKeySpecPassWD.getSalt());\n\n\t\tpbeKeySpecSalt=pbeKeySpecsalt.getParameters();\n\n\n\t\t\n\t  \t\n\t  \tpbeKeySecret=rc.getInstance(keySecret).getInstanceData();\n\t  \t\n\t  \t\n\t  \tpbeKeySpecsalt.setIV(pbeKeySpec.getParameterSpec().getIV());\n\t  \tpbeKeySpecsalt.setSalt(pbeKeySpecPasswd.getSalt());\n\t  \tpbeKeySpecSalt.setIv(pbeKeySpecPassWD.getIV());\n\n\t  \tpbeKeySpecSalt.setBlockCipher(pbeKeySpecPasswd);\n\t  \t\n\t  \tpbeKeySpecSalt.setTag(8);\n\n\t  \tpbeKeySpecSaltPassWD.setIV(salt);\n\t  \tpbeKeySpecSaltPassWD.setScheduler(pbeKeySpecSalt.getScheduler());\n\t  \tpbeKeySpecSaltDropPassWD.setIV(salt);\n\n",
            "finish_reason": "length"
        },
        {
            "text": "@Test\n\t    public void test1() {\n\t\tSecretKeyFactory f = SecretKeyFactory.getInstance(\"PBEWITAKE\");\n\t\tSecretKey sk = f.generateSecret(\"key\");\n\t\tCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\t\tCipher cbcPadding = cipher.getParameters().getParameter(Cipher.SECRET_KEY_ENCRYPT_PARAM);\n\t\t// Encode the secret key into bytes using utf-8\n\t\tbyte[] utf8 = sk.getEncoded();\n\t\t// Encrypt\n\t\tbyte[] enc;\n\t\tenc = ecipher.doFinal(utf8);\n\t\tbyte[] dec;\n\t\tdec = cipher.doFinal(enc);\n\t\tassertEquals(dec.length, enc.length * 2 + 1);\n\t    }\n}",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t/**\n\t * Tests the creation of {@link StringEncrypter} for encrypting\n\t * to a string (and also from a password).\n\t */\n\t@Test\n\tvoid testEncrypterOneCharacter() {\n\t\tStringEncrypter encrypter = new StringEncrypter();\n\t\t// Test encrypting a character with its own encryption key\n\t\tString encrypted = encrypter.encrypt(\"abcde\").getEncoded();\n\t\tString encrypted2 = encrypter.encrypt(\"ABCDE\").getEncoded();\n\t\tassertArrayEquals(new String[]{\"abcde\", \"ABCDE\"}, encrypted2.split(\"\\\\P\"));\n\t\tassertArrayEquals(new String[]{\"a\", \"b\", \"c\", \"de\", \"ef\", \"gh\", \"ij\", \"kl\", \"mn\", \"o\", \"p\", \"q\", \"r\"}, encrypted2.split(\"\\\\P\"));\n\t}\n\t@Test\n\tvoid testGetInstance() {\n\t\tassertNotNull(StringEncrypter.getInstance());\n\t}\n\t@Test\n\tvoid testEncrypt() {\n\t\t// Encrypt a string to hex value\n\t\tString encrypted = encrypt(\"Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test Test\");\n\t\tStringEncoder_0 encrypt = new StringEncoder_0();\n\t\tString encrypted8 = encrypt(encrypted);\n\t\tassertArrayEquals(new String[]{\"0e3ddf6b10982bda6f095945efcd4a8\", \"a6bce7de2ac8ca7cfd3a0ce1c6f1e5d\"}, encrypted8.split(\"\\\\P\"));\n\t}\n\t@Test\n\tvoid testSetSecretKey() {\n\t\tSystem.out.println(StringEncrypter.DEFAULT_SCHEDULED_PROCESSOR);\n\t\tbyte[] encoded = encrypt(\"ABCDE\").getEncoded();\n\n\t\tSystem.out.println(\"Original key: \" + StringEncrypter.DEFAULT_SCHEDULED_PROCESSOR);\n\t\tSystem.out.println(encoded);\n\t\tSystem.out.println(\"New key: \" + StringEncrypter.DEFAULT_SCHEDULED_PROCESSOR);\n\t\tbyte[] newEncoded = StringEncrypter.DEFAULT_SCHEDULED_PROCESSOR+encrypted;\n\t\tassertNotEquals(newEncoded,encoded);\n\t\t// System.out.println(encoded.length + \" : \" + newEncoded.length);\n\n\t\tSystem.out.println(encoded);\n\t\tSystem.out.println(\"New decoder keys:  \" + StringEncrypter.Cipher.getParameterSpec(Cipher.DECRYPT_MODE));\n\t}\n}\n\n// StringEncrypter_0Test.java\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t/**\n\t* StringEncrypter_0Test is a test case for StringEncrypter_0.\n\t*/\n\t@Test\n\tpublic void testConstructor() {\n        try {\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBEwithNULL\");\n            SecretKey key1 = factory.generateSecret(new PBEParameterSpec(\"DES ECB\", 128));\n            assertFalse(String.valueOf(encrypt(key1.getEncoded())) == null);\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n    }\n\t/**\n\t* ENCRYPT a cipher stream (pending from testSetup)\n\t* with a string of 'test' with 'giant' size.\n\t*/\n\t@Test\n\tpublic void testEncryptString() {\n\t\ttry {\n            String enc = \"test\";\n            String encoded = encrypt(enc);\n            assertEquals(\"Test String is not equal to the generated encrypted string.\", encoded, testEncrypt1String);\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n\t}\n\t/**\n\t* DES-ECB, TEST_STRING is a test string of 'test' which begins with 'test' and ends with 'giant'.\n\t*/\n\t@Test\n\tpublic void testEncrypt2Strings() {\n        try {\n            String enc = \"test\";\n            String encoded = encrypt(enc);\n            assertEquals(\"Test String is not equal to the generated encrypted string.\", encoded, testEncrypt2Strings);\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n\t}\n    /**\n     * Test {@link StringEncrypter#encrypt(String)}, for two string parameters.\n     * <b>Note</b>: it is recommended to use the <code>Encrypted</code>\n     * interface because all methods that are used here return this interface.\n     */\n    public void testEncryptString() {\n        try {\n            SecretKey key1 = new PBEKeySpec(\"test\".getBytes(\"UTF8\"), new byte[0], 1024);\n            SecretKey key2 = new PBEKeySpec(\"giant\".getBytes(\"UTF8\"), key1.getEncoded(), 1024);\n            String encoded1 = encrypt(key1.getEncoded());\n            String encoded2 = encrypt(key2.getEncoded());\n            assertEquals(\"Encrypted String are not equal.\", encoded1, testEncryptEncoded1);\n            assertEquals(\"Encrypted String are not equal.\", encoded2, testEncryptEncoded2);\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n    }\n\t\n    /**\n     * Test {@link StringEncrypter#decrypt(String)}, for two encryption parameters.\n     * <b>Note</b>: it is recommended to use the <code>Decrypted</code>\n     * interface because all methods that are used here return this interface.\n     */\n    public void testDecryptString() {\n        try {\n            byte[] decoded = decrypt(\"test\".getBytes(\"UTF8\"));\n            String dec1 = new String(decoded);\n            String dec2 = decrypt(decoded);\n            assertEquals(\"Decrypted String are not equal.\", dec1, testDecrypted1);\n            assertEquals(\"Decrypted String are not equal.\", dec2, testDecrypted2);\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n    }\n\n\t/**\n\t* ********* StringEncoder.java\n\t*/\n\t/**\n\t* StringEncoder.java is a unit test class for JUnit.\n\t */\n\tclass StringEncoder64 extends Cipher {\n\t\t\n        /**\n         * Creates the AES cipher.\n         * @param spec The encryption algorithm specification for this cipher\n         * @return The created AES cipher\n         */\n        public Cipher getNonCreationCipher(AlgorithmParameterSpec spec) {\n            return AES.getInstance(spec);\n        }\n\n        /**\n         * Encodes the provided encoded string.\n         * @param encoded The {@link String} to be encrypted\n         * @return The encrypted {@link String}\n         */\n        public String encrypt(String encoded) {\n            try {\n                byte[] bytes = encoded.getBytes(\"UTF8\");\n                byte[] encrypted = new byte[bytes.length * 2];\n                AES.doFinal(bytes, 0, bytes.length, encrypted);\n                return new String(encrypted);\n            } catch (Exception e) {\n                return null;\n            }\n        }\n\n        /**\n         * Decodes the provided encrypted string.\n         * @param encrypted The encrypted string to be decoded\n         * @return The decoded string\n         */\n        public String decrypt(String encrypted) {\n            byte[] decryped = new byte[encrypted.length()];\n            try {\n                byte[] bytes = encrypted.getBytes(\"UTF8\");\n                System.arraycopy(encrypted.getBytes(\"UTF8\"), 0, decryped, 0, bytes.length);\n                AES.init(new KeySpec(algo, key1.getEncoded()));\n                decryped = AES.doFinal(decryped);\n            } catch (Exception e) {\n                return null;\n            }\n            return new String(decryped);\n        }\n\t}\n} // StringEncrypter_0Test\n\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n    StringEncrypter_0Test() {\n    }\n\n    /**\n     * Encrypt the String using an instance of SecretKeyFactory\n     */\n    @Test\n    public void encryptFromSecretKeyFactoryTest() {\n        // Prepare the SecretKeyFactory instance\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBEWithS1K1\");\n        // Initialise an Encryptor\n        StringEncrypter.Encryptor enc = new Encryptor(secretKeyFactory);\n        // Encrypt the string using the Encryptor\n        try {\n            enc.encrypt(new String(\"secretkey\"));\n        } catch (Exception e) {\n            assertTrue(\"Exception should not occur\", true);\n        }\n    }\n\t\n\t/**\n     * Encrypt the String using an instance of Encryptor\n     */\n    @Test\n    public void encryptFromEncryptorTest() {\n        // Prepare the Encryptor instance\n        System.setProperty(\"javax.crypto.use.PBEWithSHA1AndAES\", \"true\");\n        System.setProperty(\"java.security.jce.provider\", \"sun.security.provider.SHA1WithRSAEncryption\");\n        System.setProperty(\n            \"java.security.security.SecureRandom.class\",\n            \"org.apache.rat.CipherExecutorImpl_RSA\");\n        System.setProperty(\"java.security.algs.PBEParameterSpec.class\", \"org.apache.rat.enc.parameters.PBEParameterSpec\");\n\n        // prepare the PKCS11\n        PBEParameterSpec pbeSpec;\n        KeySpec sk;\n        // prepare the SecretKey instance\n        PBEKeySpec kk;\n\t\tSecretKey skSecretKey = new SecretKeySpec(\n                           new String(\"secret key\"), \"HmacSHA1\");\n        KeyFactory kf = KeyFactory.getInstance(\"PBEWITHSHA1\");\n\t\tPKCS11CryptoContext pkcs11CryptoContext = new PKCS11CryptoContext(\"test1\", false, \"test2\",\n\t\t        1024*64, \"test12\");\n\t\tsk = kf.generateParameterSpec(kf.builtInPBEKey(null, \"test1\", null, pbeSpec));\n\t\t// prepare the encrypted string\n\t\tPBEKeySpec encryptedPbeSpec =\n                new PBEKeySpec(\n                        new byte[] {\n                             (byte) 0x12, (byte) 0x32, (byte) 0x33, (byte) 0x34\n                        }\n                );\n\t\tSecretKey wrappedPbeKey = kf.generateSecret(encryptedPbeSpec);\n\t\tPKCS11CryptoContext.EncryptedKey encrypted = pkcs11CryptoContext.deriveKey(wrappedPbeKey);\n        kf = KVFactory.getInstance(\"PBEWithMD5AndAES\");\n// use the default key provider for the default JCE provider\n        PKCS11CryptoContext pkcs11CryptoContextOld = PKCS11CryptoContext.getInstance();\n        pkcs11CryptoContextOld.setProvider(\"SunJCE\");\n\t\tsk = kf.generateParameterSpec(kf.builtInPBEKey(null, \"test2\", null, pbeSpec));\n        KeyFactory kfNew = PKCS11CryptoContext.getInstance().getKeyFactory(\"SunJCE\");\n        // get the current keys\n        PKCS11CryptoContext pkcs11CryptoContextLocal = PKCS11CryptoContext.getInstance();\n        PKCS11KeySpec wrappedPbeKeyLocal = pkcs11CryptoContextLocal.deriveKey(wrappedPbeKey);\n\t\tencrypted = pkcs11CryptoContextLocal.deriveEncryptedKey(wrappedPbeKeyLocal);\n\t\tskSecretKey = kfNew.generateSecret(encrypted.getKeySpec(new AlgorithmParameterSpec(\n                                SecretKeySpec.class)));\n        sk = kfNew.generateParameterSpec(kfNew.builtInPBEKey(null, \"test3\", null, pbeSpec));\n        // Encrypt\n        String encryptedPbe = pkcs11CryptoContextLocal.encrypt(sk, encodedPassword);\n// change the PKCS11CryptoContext local implementation\n        PKCS11CryptoContext.setInstance(pkcs11CryptoContextOld);\n        pkcs11CryptoContextLocal.setProvider(null);\n        encryptedPbe = pkcs11CryptoContextLocal.encrypt(sk, encryptedPbe);\n// change the original implementation\n        PKCS11CryptoContext.setInstance(pkcs11CryptoContextOld);\n        encryptedPbe = pkcs11CryptoContextOld.encrypt(sk, encryptedPbe);\n\n        // Check encripted string\n        assertTrue(\"The encrypted string should be the same as the plain\",\n                encryptedPbe.equals(StringEncoder1.encode(encrypted)));\n\t}\n\n}",
            "finish_reason": "stop"
        },
        {
            "text": "private @Test void test_0UnaryConstructor() throws Exception {\n\t\t\tString key = \"password\";\n\t\t\tSecretKey k = new SecretKeySpec(key.toCharArray(), \"AES\");\n\t\t\tAlgorithmParameterSpec k1 = new PBEKeySpec(key.toCharArray());\n\t\t\tPBEParameterSpec pbep = new PBEParameterSpec(128, 112, 32, 64);\n\t\t\tPBEKeySpec k1paeparams = new PBEKeySpec(key.toCharArray());\n\t\t\tAlgorithmParameterSpec[] keySpecArray;\n\t\t\tSecretKeyFactory keyFactory;\n\t\t\tPBEParameterSpec[] pbepSpecArray;\n            try {\n            \tkeySpecArray = new AlgorithmParameterSpec[]{k1paeparams};\n            \tkeyFactory = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            \tkey = \"password\";\n\t\t\t\t\tPBEParameterSpec pbep = pbeparams;\n            \tk1 = new SecretKeySpec(key.toCharArray(), \"AES\");\n            } catch (Exception e) {\n            \tthrow e;\n\t\t\t\t\tthrow new Exception(\"Error in creating instances of Secret KeyFactory instance\", e);\n\t\t\t}\n\t\t\tCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            try {\n            \tcipher.init(Cipher.ENCRYPT_MODE, k, pbep, k1);\n            } catch (Exception e) {\n            \tthrow e;\n\t\t\t\t\tthrow new Exception(\"Error by \" + cipher.getClass().getName() + \" initialization function.\", e);\n\t\t\t}\n\t\t\tcipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            try {\n            \tcipher.init(Cipher.ENCRYPT_MODE, k, pbep);\n            } catch (Exception e) {\n            \tthrow e;\n\t\t\t\t\tthrow new Exception(\"Error by \" + cipher.getClass().getName() + \" initialization function.\", e);\n\t\t\t}\n\n\t\t\tString encrypted = encrypt(cipher.doFinal(cipher.doFinal(\"\")));\n\n\t\t\tassertNotNull(encrypted);\n\t\t}\n    /**\n * TESTCASE for test_0UnaryConstructor.\n */\n    @Test\n    void test_0UnaryConstructor() throws Exception {\n        /* TestCase #1 */\n        String value;\n        PBEKeySpec keySpec;\n        AlgorithmParameterSpec[] keyParams;\n\n        keySpec = new PBEKeySpec(\"Test\".getBytes());\n        keyParams = new AlgorithmParameterSpec[] {};\n\n        keyFactory = Cipher.getInstance(\"PBEWithMD5AndDES/CBC/PKCS5Padding\");\n        value = \"Test\".getBytes();\n        PBEKeySpec pbeparams = new PBEKeySpec(value.getBytes());\n\n        try {\n            byte[] testStr = encrypt(keyFactory.newInstance(keySpec).doFinal(\"Test\".getBytes()));\n\n            assertNotNull(testStr);\n        } catch (Exception e) {\n            throw e;\n        }\n    }\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\t@Test\n\tvoid encrypt_0() throws Exception {\n        try {\n            byte[] encoded = encrypt(\"\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\tvoid encrypt_1(){\n\t\tbyte[] encoded = encrypt(\"\");\n\t\tassertTrue(encoded.length%8 == 0);\n\t}\n\tint count=0;\n\tint length=encrypt(\"\").length/8;\n\n\t@Test\n\tvoid encoded_equal(long len){\n        try {\n            byte[] enc = encipher(length+1,true);\n            assertTrue(\"1.0\"\n                   .substring(0, enc.length)\n                   .compareTo(\"1000000000000000000\".substring(0, enc.length))\n                    == 0);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    /**\n     * Uses pbkdf2 to generate 2 blocks of size {@link #length}\n     * Returns {@link #length} blocks of encrypted with pbkdf2 algorithm\n     */\n    public byte[] enciper(long blocks,boolean usePbkdf2) throws Exception{\n        // Load key size\n        int key_size = BlockCipher.BLOCK_SIZE;\n        // Setup up Key Specifications\n        KeySpec pbkdf2KeySpec = null;\n        if (usePbkdf2)\n            pbkdf2KeySpec = new PBEKeySpec(key_size * 16);\n        else\n            pbkdf2KeySpec = new PBEParameterSpec(pbkdf2KeySpec);\n        PBEKeySpec pbkdf2Pbk = new PBEKeySpec(key_size * 16, \"A4\");\n        SecretKeyFactory schkf = SecretKeyFactory.getInstance(\"PBKDF2WithHMACSHAAnd128BitNoPadding\");\n        SecretKey schkey = schkf.generateSecret(pbkdf2KeySpec);\n        PBEParameterSpec pbkdf2PbkParams = new PBEParameterSpec(256, PBKDF2_DEFAULT.dHash.length, 16*256, 256);\n\t\tCipher cipher = cipher(\"A4\");\n\t\tSecretKey k0 = schkey;\n\t\tif (usePbkdf2){\n            k0 = schkey;\n            algParamsSpec = new AlgorithmParameterSpec(PBKDF2_DEFAULT.hashAlgorithm.getOpaque(), 256, \"A4.\",\n\t\t\t    256, pbkdf2PbkParams);\n\t\t\tcipher = cipher.newChildKey(cipher, pbkdf2Pbk);\n\t\t}\n\t\tcipher = cipher.newChildKey(cipher, k0);\n        byte[] decoded = cipher.doFinal(encipher(blocks,usePbkdf2));\n\n    \t// Compare decoded against what encoded\n    \t//if(usePbkdf2){ \n    \t\tassertArrayEquals(\"Decoded and Encrypted Data not equal\", decoded,encoded);\n    \t//} else {\n    \t\tassertArrayEquals(\"Decoded and Encrypted Key not equal\", encoded,decoded);\n//            \tif(usePbkdf2){\n//            \t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n//            \t\tbyte[] hex = HexEncoder.toHex(bytes3);\n//\t        \t\tfor(int i=0;i<hex.length;i++){\n//\t        \t\t\tSystem.out.println(i+\": \"+hex[i]+\" -> \"+hex[(i+64)%16]);\n//\t        \t\t}\n//            \t\tassertArrayEquals(\"Lengths of decoded and encrypted keys do not match\", hex.length, decoded.length);\n\n                    for(int i=0;i<hex.length;i++){\n                        assertEquals(\"Byte at \" + i isEncoded(i,usePbkdf2) + \" not equal.\\n\" +\n                                \"Found: \" + new String(hex[i], \"UTF8\"), new String(hex[i], \"UTF8\"), new String(encoded[i%length], \"UTF8\"));\n                        assertArrayEquals(\"Encoded key for i: \" + i isEncoded(i,usePbkdf2),\n\t\t\t\t\t    new String(hex[i], \"UTF8\"), new String(decoded[i%length], \"UTF8\"));\n\n                    \t}\n//            \t} else if(usePbkdf2){\n//            \t\tassertArrayEquals(\"Lengths of decoded and encrypted keys do not match\", hex.length, decoded.length);\n//                    \tfor(int i=0;i<hex.length;i++){\n//                    \t\tSystem.out.println(i+\": \"+hex[i]+\" -> \"+hex[(i+64)%16]);\n//                    \t}\n//                    \tassertArrayEquals(\"Encoded key for i: \" + i isEncoded(i,usePbkdf2) + \" not equal.\\n\" +\n//                    \t\t\t\"Found: \" + new String(hex), decoded);\n//            \t}\n   \t\t}\n    \treturn decoded;\n        \t// }\n    }\n    \n\tprivate boolean isEncoded(long pos, boolean usePbkdf2){\n        try {\n            if(usePbkdf2)\n                return ((pos/64)%16 == 0);\n            else\n                return pos/16 < 1;\n        }catch (Exception e){\n            assert false;\n            return false;\n        }\n    }\n     \n    /**\n     * Creates a new cipher instance.\n     * @return Cipher instance\n     */\n    private Cipher cipher(String encryptionAlgorithm) throws Exception{\n        Cipher cipher = Cipher.getInstance(encryptionAlgorithm);\n        return cipher;\n    }\n\n//    private Cipher cipher(long length,boolean usePbkdf2)\n//            throws Exception{\n//        EncryptionKeySpec encKeySpec = new EncryptionKeySpec(8, BlockCipher.BLOCK_SIZE);\n//        AlgorithmParameters algParams = new DHG1Parameters(encKeySpec, 1000);\n//        AlgorithmParameterSpec algorithmParamsSpec = new DHG1Parameters(encKeySpec, 10000);\n//\n////        PBEKeySpec pbkdSpec = new PBEKeySpec(new char[16]);\n////        SecretKeyFactory schkf = SecretKeyFactory.getInstance(\"PBE\");\n////        return schkf.newEncryptingKey(pbk",
            "finish_reason": "length"
        }
    ],
    "id": "c0c28ab9-ca62-4ae6-b729-7d1f9754ee5a",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypter_0Test.java",
    "original_code": "// StringEncrypter.java\npackage osa.ora.server.utils;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEParameterSpec;\n\npublic class StringEncrypter {\n\n    /**\n     * Takes a single String as an argument and returns an Encrypted version\n     * of that String.\n     *\n     * @param str String to be encrypted\n     * @return <code>String</code> Encrypted version of the provided String\n     */\n    public String encrypt(String str) {\n        if (str == null)\n            return null;\n        try {\n            // Encode the string into bytes using utf-8\n            byte[] utf8 = str.getBytes(\"UTF8\");\n            // Encrypt\n            byte[] enc = ecipher.doFinal(utf8);\n            // Encode bytes to base64 to get a string\n            return StringEncoder64.encode(enc);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n}\n",
    "test_prompt": "// StringEncrypter_0Test.java\npackage osa.ora.server.utils;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEParameterSpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncrypter}.\n* It contains one unit test case for the {@link StringEncrypter#encrypt(String)} method.\n*/\nclass StringEncrypter_0Test {",
    "time_taken": 56.34727644920349,
    "usage": {
        "prompt_tokens": 513
    }
},
{
    "choices": [
        {
            "text": "\n    @Test\n    public void testECrypt() {\n    \tSystem.out.println(\"testECrypt()\");\n    \tStringUtility utility = new StringUtility();\n    \ttry {\n    \t\tString str = \"test\";\n            byte[] keyBytes = utility.encrypt(str);\n            int[] keyArray = utility.decrypt(keyBytes);\n            assertArrayEquals(keyArray, new int[] {2, 3, 4});\n    \t} catch (Exception e) {\n    \t\te.printStackTrace();\n    \t}\n    }\n    \n      int[] decode(String encoded) {\n    \tint[] result;\n    \ttry {\n    \t\tresult = new int[8];\n    \t\tbyte b[] = codec.encode(encoded);\n    \t\tbyte[] dec = codec.decode(b);\n    \t\tSystem.arraycopy(dec, 0, result, 0, 6);\n    \t} catch (Exception e) {\n    \t\te.printStackTrace();\n    \t}\n    \treturn result;\n       }\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "public static final StringENCRYPTION_PATTERN = \"**\";\n\t\tprivate static final StringENCRYPTION_KEY = \"ABCD\";\n\t\tprivate Cipher dcipher;\n\n\t\t{\n\t\t\t// Decode\n            String ENCRYPTION_PATTERN = StringEncoder_1.format();\n\t\t\tString ENCRYPTION_KEY = StringEncoder_1.decrypt(ENCRYPTION_PATTERN);\n            // Encrypt\n\t\t\tthis.dcipher = StringEncoder_1.getInstance().createEncrypter();\n        }\n\n\n\t/**\n\t * Test the {@link StringEncrypter#decrypt(String)} method.\n\t */\n        @Test\n        void test_p1() {\n            AlgorithmParameterSpec aps = (AlgorithmParameterSpec)\n            ParameterSpec.getSpec(\"PBKDF2WithHmacSHA256And{\" +\n                    \"iterations\": 200, \"h\": \"PBKDF2WithHmacSHA256And{\" +\n                    \"pbkdf2SaltLength\": 8, \"pbkdf2KeyLength\": 32\n                    }\");\n            Cipher PBEKeySpec = new PBEKeySpec(ENCRYPTION_KEY.toCharArray());\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256And\");\n            SecretKey key = factory.generateSecret(aps);\n\n            try {\n                String EXPECTED = StringEncoder_1.decrypt(StringEncoder_1.format());\n                String EXPECTED2 = StringEncoder_1.decrypt(StringEncoder_1.format());\n                assertArrayEquals(EXPECTED.getBytes(), EXPECTED2.getBytes());\n\n            } catch (Exception e) {\n                e.printStackTrace();\n                fail();\n            }\n        }\n\n\n}",
            "finish_reason": "stop"
        },
        {
            "text": "@Test\n\t\tpublic void testDecrypt() {\n\t\t\n\t\t\t\tSecretKeyFactory keyFactory = SecretKeyFactory\n\t\t\t\t\t.getInstance(\"PBEWITHSHA\");\n\t\t\t\tPBEKeySpec keySpec = new PBEKeySpec\n\t\t\t\t\t(\n\t\t\t\t\t\"a1a2a3a4a5a6a7a6a7a8a9aaabacadaeafcabd\".toCharArray(),\n\t\t\t\t\t8,\n\t\t\t\t\t128\n\t\t\t\t\t);\n\t\t\t\tSecretKey encKey;\n\t\t\t\ttry {\n\t\t\t\t\tencKey = keyFactory.generateSecret(keySpec);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tCipher engine = Cipher.getInstance(\"AES/PKCS5Padding\");\n\t\t\t\ttry {\n\t\t\t\t\tengine.init(Cipher.DECRYPT_MODE, encKey,\n\t\t\t\t\t\tKeySpec.getInstance(\"AES\"));\n\t\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tSystem.err.println(\"Error at Decoder: \"\n\t\t\t\t\t\t+ e.getMessage());\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\n\t\t\t\tassertTrue(engine.getAlgorithm().startsWith(\"AES\"));\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tString text = decrypt(String\n\t\t\t\t\t\t.fromCharArray(new byte[] {0x00}));\n\t\t\t\t\tassertTrue(text.equals(StringEncoder_1Test.decryptedValue));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t}\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "@Test\n\t\tpublic void testDecrypt() {\n\t\t\t\tnew StringEncrypter_1().testDecrypt();\n\t\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "private final String testMsg = \"Test message\";\n\t\tprivate Cipher dcipher = null;\n                /**\n                 * It is necessary that only one thread executes code in the test class at a time.\n                 * Since only an isolated thread executes the code while holding the state lock, \n                 * the test can only have one thread executing at a time executing the code.\n                 */\n\t\tstatic {\n\t\t\tSystem.out.println(\"Starting the test class instance. For thread safety, please ensure that only a single thread executes code in the test \");\n\t\t\tThread.currentThread().getThreadGroup().getThreads().next().setName(\"StringEncrypter_1Test_\" + Thread.currentThread().getId());\n\t\t}\n\t\t/**\n\t\t * It is necessary that only one thread executes code in the test class at a time.\n\t\t * Since only an isolated thread executes the code while holding the state locker, \n\t\t * the test can only have one thread executing at a time executing the code.\n\t\t */\t\n\t\n\t\tpublic StringEncrypter_1Test() {\n\t\t}\n\t\t\n        public void init() {\n        \ttry {\n                // Initialize and load PBE Key Factory\n                \n                // Initialize and initialize the PBE Algorithm Parameters\n                \n                // Initialize and initalize the Cipher Algorithm Parameters \n                \n        \t\t// Initialize and initalize the Secret Key Factory\n                // keySpec holds the key specs for a given parameter\n                \n    \t\t\t// Initialize Secret Key Parameters for a given parameter\n                \n                // Initialize and initalize the PBEParameterSpec for a given parameter\n                \n                // Initialize and init the PCipher Algorithm Parameters\n                \n                // Initialize and initialize the Cipher Parameters\n                \n\t\t    \t// Create and initialize an instance of Cipher with a length of 512 bytes \n\t\t    \t\n\t\t    \tinitializeCipher();\n\t\t    \t\n    \t\t\t// Initialize and create an instance of PCipher with a length of 512 bytes \n    \t\t\t\n    \t\t    // Set the length of the Cipher Parameters to an integer value \n    \t\t    // The default value of 1024 will be ignored in this case. \n    \t\t    initializeCipherParameters();\n    \t\t\t\n                // Initialize the PBE key specification with a name of \"PBE PBKDF2WithHmacSHA1 and 512 salt bits\" \n    \t\t\t\n                PBEKeySpec pbeKeySpec = new PBEKeySpec(\"A\".getBytes(\"UTF8\"));\n    \t\t\t\n                // Initialize and create an instance of the PBEParameterSpec for a given key\n    \t\t\t\n    \t\t\tinitializePBEParameterSpec();\n    \t\t\t\n                // Create Secret Key Parameters for a given key\n    \t\t\t\n    \t\t\tKeySpec keySpec = new PBEKeySpec(new byte[] {1,2,3});\n\t\t\t\n                // Create an instance of Secret Key with a length of 768 bytes \n    \t\t\t\n                // Set the length of the Secret Key Parameters to an integer value \n    \t\t\t// The default value of 768 will be ignored in this case.\n\t\t\t\t\n\t\t\t\t// Create an instance of Secret Key with a length of 768 bytes \n\t\t\t\t\n    \t\t\t// Set the length of the Secret Key Parameters to an integer value \n    \t\t\t// The default value of 768 will be ignored in this case.\n\t\t\t\t\n\t\t\t\t// Create an instance of Secret Key with a length of 768 bytes \n\t\t    \t\n\t\t    \t// Create an instance of Secret Key with a length of 768 bytes \n\t\t    \t// The default value of 768 will be ignored in this case.\n\t\t    \t\n\t\t    \tfinal static byte[] PASSWORD_ALG = new byte[] {'p','a',' ','s','t','e','s','t','e'};\n\t\t    \t\n\t\t    \t// Create an instance of Secret Key with a length of 16 bytes \n\t\t    \t\n\t\t    \t// Create an instance of a Hash Algorithm Instance for a given key\n\t\t    \t\n\t\t    \tfinal static int PRIME = 1773117563;\n\t\t    \t\n\t\t    \t// Generate a random, hashed, prime-prime key\n\t\t    \t\n\t\t    \tSecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n\t\t    \t\n\t\t    \tfinal int prime = (int) secretKeyFactory.generateSecret().getEncoded().length; // 16 bytes\n\t\t    \t\n\t\t\t    // Create KeySpec parameters for the PBE PBEWith PBKDF2 Hash Algorithm \n\t\t    \t\n\t\t    \tPBEParameterSpec params = new PBEParameterSpec(PASSWORD_ALG, PRIME);\n\t\t    \t\n\t\t    \t// Set the Parameters\n\t\t    \t\n\t\t    \t// Set the salt\n\t\t    \t\n\t\t    \t// Set the iterations\n\t\t    \t\n\t\t    \t// Set the key length to a multiple of 32\n\t\t    \t\n\t\t    \t// Set the hash function to a multiple of 16\n\t\t    \t\n\t\t    \t// Set the length of the Salt to an integer value \n\t\t    \t// The default value of 512 bytes will be ignored in this case.\n\t\t    \t\n\t\t    \tfinal static int saltLen = 128;\n\t\t    \t\n\t\t    \t// Set the hash function to a multiple of 16\n\t\t    \t\n\t\t    \tfinal int hLen = saltLen % 16;\n\t\t    \t\n\t\t    \tfinal int iterations = saltLen / 16;\n\t\t    \t\n\t\t    \t// Set the key lenght to a multiple of 16\n\t\t    \t\n\t\t    \tfinal int keylen = (saltLen - hLen * iterations * 8) / (16 * iterations); // 16 bytes\n\t\t    \t\n\t\t\t    // Create an instance of a Hash Algorithm Instance for a given key\n\t\t    \t\n\t\t    \tfinal StringKeyHasher hasher = new StringKeyHasher();\n\t\t\t\n\t\t    \t// Create an instance of the Cipher for a given key\n\t\t    \t\n\t\t    \tfinal Cipher cipher = Cipher.getInstance(\"PBEWithHmac\");\n\t\t    \t\n\t\t    \t// Set the key length from a multiple of 16\n\t\t    \t\n\t\t    \t// Set the hash function to a multiple of 16\n\t\t    \t\n\t\t    \t// Set the iterations to a multiple of 64\n\t\t    \t\n\t\t    \tinitializeCipher(cipher, keylen,\n\t\t    \t\t\t\t\tparams, new byte[] {'e','d','v','i',1},\n\t\t    \t\t\t\t\thasher.hash(new String(testMsg).getBytes(\"utf8\")));\n\t\t    \t\n\t\t    \t// Check for the hash function\n\t\t    \tif (!testMsg.startsWith(\"DUMMYPRIME\")) {\n\t\t    \t\tSystem.out.println(testMsg);\n\t\t    \t\tassertTrue(false);",
            "finish_reason": "length"
        },
        {
            "text": "\n\t@Test\n\tpublic void test_1() {\n        String s = \"LW7Q8WKV\";\n        String enc = encrypt(s);\n        s = decrypt(enc);\n        assertEquals(s, enc);\n\t}\n\n}",
            "finish_reason": "stop"
        },
        {
            "text": "\n\tStringEncrypter testObj;\n\t\n\t\t\n\t/**\n\t * Test constructor.\n\t */\n\tpublic StringEncrypter_1Test() {\n           // This constructor is called once per test instance\n\t}\n\t\n\t/**\n\t * Set of test methods.\n\t * @return The test methods.\n\t */\n\tpublic Class<? extends Test>[] getTests() {\n\t\t// Return a set of test classes\n\t\t\t return new Class[] {TestCipher.class};\n\t}\n\t\n\t/**\n\t * Initialize test object.\n\t * @return <code>The test object</code>.\n\t */\n\tpublic StringEncrypter initTest() {\n\t\t// Call base class constructor\n        testObj = new StringEncrypter();\n        return testObj;\n\t}\n\t\n\t/**\n\t * Tests decoding of base64 cipher-encoded String.\n\t */\n\tpublic void testDecrypt_base64_CipherEncodingString() {\n\tString utf8=\"Z5VwZXJpY2g2MCAxNDQ5NzE0MzIyWDEU0\";\n\tString enc=\"X2D2TmF2dW2Fc2NlY2RhZC8\";\n\t\n\tString res= testObj.decrypt(enc);\n        assertEquals(\"StringEncoder Base64 does not work correctly.\", res, enc);\t// It should be the same after decryption\n\t\n        // Verify decryption of the base64 encoded String\n        // The expected value of utf8 is 0xD3C3D3D5F0E34\n        assertEquals(\"StringEncoder Base64 does not work correctly.\", StringEncoder64.decode(utf8), utf8);\n\t}\n\t\n\t/**\n\t * Tests decoding of base64 Cipher-encoded String.\n\t */\n\tpublic void testDecrypt_base64_Cipher() {\n\tString utf8=\"fTAN5TgwYBhV2hxKgNDAXZsBQF9vYWJlZXRlZi4\";\n\tString enc=\"JQ6tVtkNn0nWt3z4v4Rl1cDyBzEwBbD8rAqF7hMd9sJ1DU9AuRUx8yJ\";\n\tString res= testObj.decrypt(enc);\n        assertEquals(\"Failed Base64 encryption. Unexpected return value\", res, enc);\t// It should be the same after encryption\n\t\n        // Verify encryption of the encrypted string\n        // The expected value of utf8 is 0xEDF3F7A7D6A3DF2\n        assertEquals(\"Failed Base64 encryption. Unexpected return value\", StringEncoder64.decode(utf8), enc);\n\t}\n\t\n\t/**\n\t * Tests encryption of a valid cipher.\n\t */\n\tpublic void testEncrpytSuccess_encryption() {\n        assertNotNull(\"Cipher should not be null\", testObj.getCipher());\n        SecretKey secret = null;\n    \ttry {\n         \tsecret = testObj.getKey(false);\n\t\t\tassertNotNull(\"SecretKey should not be null\", secret);\n    \t\tCipher c = testObj.getCipher();\n\t    \tassertEquals(\"Cipher should be initialized correctly.\", c, CIPHER);\n    \t\tc.doFinal(StringEncoder64.encode(\"hello\"), byte[]);\n    \t} catch (Exception e) {\n    \t\tfail(\"Cipher: \" + testObj.getCipher() + \", Exception: \" + e);\n    \t}\n\t}\n\t\n\t/**\n\t * Tests decrypting a plain string using a specific ciphers.\n\t */\n\tpublic void testDecrypthSuccess_decryptingFromAKeyStringString() {\n\tString key = \"TJtJt2C4jQN2U1z7e5QaZ7JtZg8lHfBQZsX6X5K6YQRqKLwA1kSgHZJxO\";\n\tSecretKey secret = null;\n    \ttry {\n         \tsecret = TestCipher.encrypt(key);\n\t\t\tassertNotNull(\"SecretKey should not be null\", secret);\n    \t\tCipher c = testObj.getCipher();\n\t    \tassertNotNull(\"Cipher should not be null\", c);\n    \t\tbyte[] enc = StringEncoder64.encode(StringEncoder64.decrypt(\"hello\"));\n    \t\tassertEquals(\"There should be no padding.\", new byte[0], enc);\n    \t\tc.doFinal(enc, byte[]);\n    \t\tc = null;\n    \t} catch (Exception e) {\n    \t\tfail(\"Cipher: \" + testObj.getCipher() + \", Exception: \" + e);\n    \t}\n\t}\n\n\t/**\n\t * Encryption should not exist in this object.\n\t */\n\tpublic void testEncryptionNo() {\n\t\tString enc = StringEncoder64.encode(\"hello\");\n\t\ttry {\n\t\ttry {\n\t\t\ttestObj.getCipher();\n\t\t\tfail(\"Failed to get cipher: \" + testObj.getCipher());\n\t\t} catch (Exception e) {\n    \t\tfail(\"Encryption failed: \" + e);\n\t\t}\n\t\t} catch (Exception e) {\n        \tfail(\"Encryption of the cipher unexpectedly failed: \" + e);\n\t\t}\n\t}\n\n\t/**\n\t * Decrypting without encryption should return a plain string.\n\t */\n\tpublic void testDecryptNo() throws Exception {\n\t}\n\t\n\t/**\n\t * Initialize cipher.\n\t */\n\tpublic void testInit() {\n        try {\n        \ttestObj.init();\n            fail(\"Failed to initialize cipher: \" + testObj.getCipher());\n        } catch (Exception e) {\n            // It should not throw exception\n        }\n\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "StringTest test;\n\n\t\tStringEncrypter_1Test() {\n\t\t\ttest = new StringTest();\n\t\t}\n\n\n\t\t/**\n\t\t * Test for \"null\" scenario.\n\t\t *\n\t\t * @throws java.lang.Exception\n\t\t */\n\t\t@Test\n\t\tvoid nullArgs() throws Exception {\n\t\t\tString str = null;\n\t\t\ttest.assertNull(StringEncrypter.decrypt(str));\n\t\t\ttest.assertNull(StringEncrypter.decrypt(str, null));\n\t\t}\n\n\n\t\t/**\n\t\t * Test for a correct and non valid input String.\n\t\t *\n\t\t * @throws javax.crypto.GeneralSecurityException\n\t\t */\n\t\t@Test\n\t\tvoid test1() throws Exception {\n\t\t\tString str = \"test\";\n\t\t\t// Encrypted String as argument\n\t\t\ttest.assertEquals(\"test\", StringEncrypter.decrypt(str));\n\t\t\t// Decrypted String as argument\n\t\t\ttest.assertEquals(\"test\", StringEncrypter.decrypt(str, \"(password)\"));\n\t\t}\n}\n\n\n// StringTest_1Test.java\n",
            "finish_reason": "stop"
        },
        {
            "text": "/**\n\t\t* Encrypts passed String using PBK\n\t\t*/\n\t\t@Test\n\t\tpublic void pbkEncrypt(@SuppressWarnings(\"unused\") String str) {\n                if (str == null)\n                        return;\n\n                System.out.println(\"Encrypting \"+str);\n\n                PBEParameterSpec pbkParams = null;\n                PBEParameterSpec[] pbkParamsArr = new PBEParameterSpec[1];\n                Object[] keyParam = {new javax.crypto.spec.PBEKeySpec(\"testpass\",\n                    \"default\", 1024, pbkParamsArr)};\n                \n                PBEParameterSpec pbkCip = new PBEParameterSpec(keyParam, pbkParamsArr);\n                        pbkCip = new PBEParameterSpec(\"dgcm\"/*\"DES/cbc/noPadding\"*/, pbkParams);\n\n                byte[] enc = encryptPassword(str, pbkCip);\n\n                assertNotNull(enc);                \n                String decrypted = decrypt(new String(enc));\n\n                assertNotNull(decrypted);\n                assertEquals(new String(str), decrypted);\n        }\n        \n        /**\n        * Encrypts string using PBK\n        */\n        @Test\n        public void pbkEncrypt(@SuppressWarnings(\"unused\") String str, byte[] message,@SuppressWarnings(\"unused\") int keylength) {\n                 if (str == null)\n                         return;\n\n                 System.out.println(\"Encrypting \"+str);\n                 PBEParameterSpec pbkParams = new PBEParameterSpec(null, new PBEParameterSpec.Filler(0, message, 0, keylength));\n                 PBEParameterSpec[] pbkParamsArr = new PBEParameterSpec[1];\n                 Object[] keyParam = {new javax.crypto.spec.PBEKeySpec(\"testpass\",\n                    \"default\", 1024, pbkParamsArr)};\n                 \n                 PBECipher enc = new PBECipher(pbkParams, pbkParamsArr);\n\n                 byte[] encrypted = encryptPassword(str, keyParam);\n             \n                 assertNotNull(encrypted);\n                 String decrypted = decrypt(new String(encrypted));\n                 assertNotNull(decrypted);\n                 assertEquals(new String(str), decrypted);\n        }\n           \n        /**\n        * Encrypts string using PBK encrypted with AES\n        */\n        @Test\n        public void pbkEncryptAES(@SuppressWarnings(\"unused\") String str, byte[] message,int keylength) {\n             if (str == null)\n                         return;\n\n             System.out.println(\"Encrypting \"+str);\n                 PBEParameterSpec pbkParams = null;\n                 PBEParameterSpec keyParam = new PBEParameterSpec(null, new PBEParameterSpec.Filler(0, message, keylength, keylength));\n             pbkParams = new PBEParameterSpec(null, keyParam); \n\n                 // create key object\n                 PBECipher enc = new PBECipher(pbkParams, null);    \n                 byte[] encrypted = encryptAES(str, keyParam);\n             \n                 assertNotNull(encrypted);\n                 String decrypted = decrypt(new String(encrypted));\n                 assertNotNull(decrypted);\n                 assertEquals(new String(str), decrypted);\n        }\n        \n        /**\n        * Decrypts encrypted String using PBK encrypted with AES algorithm and salt\n        */\n        @Test\n        public void pbkDecryptAES(@SuppressWarnings(\"unused\") String str, byte[] message,@SuppressWarnings(\"unused\") int keylength) { \n               if (str == null)\n                         return;\n\n               System.out.println(\"Decrypting \"+str);\n                 PBECipher enc = new PBECipher(null, null);    \n                 byte[] decrypted = decryptAES(str, message, keylength);\n             \n                 assertNotNull(decrypted);\n                 String decryptedStr = new String(decrypted);\n                 assertEquals(new String(str),decryptedStr);\n         }\n        \n        /**\n        * Un-Encrypts password with PBK\n        */\n        @Test\n        public void pbkUnEncrypt(@SuppressWarnings(\"unused\") String str) {\n                if (str== null)\n                        return;\n                System.out.println(\"Un-Encrypting \"+str);\n                byte[] message = new byte[0];\n                PBEParameterSpec param = null;\n                Object[] keyParam = {new javax.crypto.spec.PBEKeySpec(\"testpass\",\n                        \"default\", 1024, param)};        \n\n                // create key object\n                PBECipher enc = new PBECipher(null, keyParam);\n                // create Encryptor object\n                PBEParSpec encryptedStoredData = new PBEParSpec();\n                encryptedStoredData.setAlgorithmAndPadding(\"AES/CTR/NoPadding\");\n                encryptedStoredData.setIV(new byte[] {(byte) 0x00});  // set IV for AES encrypted data\n                encryptedStoredData.setK(new byte[]{(byte) 0x01});  // set key bytes\n                encryptedStoredData.setP(new byte[] {(byte) 0x02});  // set parameters to be loaded\n\n                byte[] encrypted = null;\n                try {\n                    encrypted = enc.doFinal(encryptedStoredData.getEncoded());\n                } catch (Exception e) {\n                }\n                if(encrypted!= null) {\n                    byte[] decrypted = decryptPD();\n                } else {\n                    System.out.println(\"Not decrypting because encrypted data is null\");\n                }\n                assertEquals(\"Not decrypting because encrypted data is null\", null, decrypted);\n        }\n        \n        /**\n        * Generate password by given key\n        */\n        private SecretKey createKey(byte[] key) {\n                SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"AES\");\n                KeySpec keySpec = new PBEKeySpec(key);\n                try {\n                    return keyFactory.generateSecret(keySpec);\n                } catch (Exception e) {\n                }\n         \n                return null;\n        }        \n        \n        /** \n        * Generate a random password with given key\n        */\n        //private String getRandomPassword(byte[] key) {\n",
            "finish_reason": "length"
        },
        {
            "text": "\n\t/**\n\t* Test method for {@link osa.ora.server.utils.StringEncrypter#getAesStringKeySpec(int)}.\n\t*/\n\t@Test\n\tpublic void testGetAesStringKeySpec() {\n\t\tassertNull(StringEncrypter.getAesStringKeySpec(0));\n\t\tassertNull(StringEncrypter.getAesStringKeySpec(1));\n\t\tassertNull(StringEncrypter.getAesStringKeySpec(26));\n\t}\n\t\n\t/**\n\t* Test method for {@link osa.ora.server.utils.StringEncrypter#updateFromAesAndStoreToString(byte[], int)}.\n\t*/\n\t@Test\n\tpublic void testUpdateFromAesAndStoreToString() {\n\t\tString toEncode = \"This is a string\";\n\t\tString encoded = StringEncrypter.updateFromAesAndStoreToString(toEncode.getBytes(), 16);\n\t\tassertEquals(\"This is a string\", encoded);\n\t}\n}\n\n\n/**\n* The class should contain 8 tests\n*\n*/\nclass StringEncrypter_8Test {\n\t\t\n\t/**\n\t* Test method for {@link StringEncrypter#getAesStringKeySpec(int)}.\n\t*/\n\t@Test\n\tpublic void testGetAesStringKeySpec() {\n\t\tassertNotNull(StringEncrypter.getAesStringKeySpec(7));\n\t}\n\t\n\t/**\n\t* Test method for {@link StringEncrypter#getAesStringKeySpec(int)}.\n\t*/\n\t@Test\n\tpublic void testGetAesStringKeySpec() {\n\t\tassertNotNull(StringEncrypter.getAesStringKeySpec(0));\n\t}\n\t\n\t/**\n\t* Test method for {@link StringEncrypter#getAesStringKeySpec(int)}.\n\t*/\n\t@Test\n\tpublic void testGetAesStringKeySpec() {\n\t\tassertNotNull(StringEncrypter.getAesStringKeySpec(6));\n\t}\n\n\t/**\n\t* Test method for {@link StringEncrypter#getAesStringKeySpec(int)}.\n\t*/\n\t@Test\n\tpublic void testGetAesStringKeySpec() {\n\t\tassertNotNull(StringEncrypter.getAesStringKeySpec(26));\n\t}\n}\n\n/**\n* The class should contain 5 tests\n*\n*/\nclass StringEncrypter_5Test {\n\t\t\n\t/**\n\t* Test method for {@link StringEncrypter#getAesStringKeySpec(int, String)}.\n\t*/\n\t@Test\n\tpublic void testGetAesStringKeySpec() {\n\t\tassertNotNull(StringEncrypter.getAesStringKeySpec(7, \"testenc\"));\n\t}\n\t\n\t/**\n\t* Test method for {@link StringEncrypter#getAesStringKeySpec(int, String)}.\n\t*/\n\t@Test\n\tpublic void testGetAesStringKeySpec() {\n\t\tassertNotNull(StringEncrypter.getAesStringKeySpec(7, \"testenc\"));\n\t}\n\t\n}\n\n\n/**\n* The class should contain 4 tests\n*\n*/\nclass StringEncrypter_4Test {\n\t\t\n\t/**\n\t* Test method for {@link StringEncrypter#getAesKeySpec(int)}.\n\t*/\n\t@Test\n\tpublic void testGetAesKeySpec() {\n\t\tassertNotNull(StringEncrypter.getAesKeySpec(7));\n\t}\n\t\n\t/**\n\t* Test method for {@link StringEncrypter#getAesKeySpec(int)}.\n\t*/\n\t@Test\n\tpublic void testGetAesKeySpec() {\n\t\tassertNotNull(StringEncrypter.getAesKeySpec(0));\n\t}\n\t\n\t/**\n\t* Test method for {@link StringEncrypter#getAesKeySpec(int)}.\n\t*/\n\t@Test\n\tpublic void testGetAesKeySpec() {\n\t\tassertNotNull(StringEncrypter.getAesKeySpec(6));\n\t}\n\t\n}",
            "finish_reason": "stop"
        }
    ],
    "id": "6172fed9-6ed6-4494-af72-0dbbc5d6c6a3",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypter_1Test.java",
    "original_code": "// StringEncrypter.java\npackage osa.ora.server.utils;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEParameterSpec;\n\npublic class StringEncrypter {\n\n    /**\n     * Takes a encrypted String as an argument, decrypts and returns the\n     * decrypted String.\n     *\n     * @param str Encrypted String to be decrypted\n     * @return <code>String</code> Decrypted version of the provided String\n     */\n    public String decrypt(String str) {\n        if (str == null)\n            return null;\n        try {\n            // Decode base64 to get bytes\n            byte[] dec = StringEncoder64.decode(str);\n            // Decrypt\n            byte[] utf8 = dcipher.doFinal(dec);\n            // Decode using utf-8\n            return new String(utf8, \"UTF8\");\n        } catch (Exception e) {\n        }\n        return null;\n    }\n}\n",
    "test_prompt": "// StringEncrypter_1Test.java\npackage osa.ora.server.utils;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEParameterSpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncrypter}.\n* It contains one unit test case for the {@link StringEncrypter#decrypt(String)} method.\n*/\nclass StringEncrypter_1Test {",
    "time_taken": 56.43905973434448,
    "usage": {
        "prompt_tokens": 510
    }
},
{
    "choices": [
        {
            "text": "/**\n\t\t * The action to invoke when the OK button is pressed.\n\t\t */\n\t\tpublic static final Action OK = new AbstractAction(\"Ok\") { public void actionPerformed(ActionEvent e) { System.exit(0); } };\n\t\n        /**\n         * The action to invoke when the Cancel button is pressed.\n         * Sets the value of <code>getOk()</code> to <code>false</code>.\n         */\n        public static final Action CANCEL = new AbstractAction(\"Cancel\") { public void actionPerformed(ActionEvent e) { getOk(); } };\n    \n\t/**\n\t* Creates a dialog with the specified parent and title.\n\t* @param parent the parent <code>Container</code>\n\t* @param title the <code>String</code> containing the dialog title\n\t* @param modal <code>boolean</code> specifying whether the dialog\n\t* should block for event or not. Default is <code>false</code>\n\t* @param okListener the {@link ActionListener} to invoke when the\n\t* OK button is pressed\n\t* @param cancelListener the {@link ActionListener} to invoke when the\n\t* Cancel button is pressed\n\t* @see #showDialog\n\t*/\n\tpublic static JDialog createDialog(Container parent, String title, boolean modal, ActionListener okListener, ActionListener cancelListener) {\n\t\treturn createDialog(parent, title, modal, okListener, cancelListener, null);\n\t}\n\n\t/**\n\t* Creates a dialog with the specified parent and title.\n\t* @param parent the parent <code>Container</code>\n\t* @param title the <code>String</code> containing the dialog title\n\t* @param modal <code>boolean</code> specifying whether the dialog\n\t* should block for event or not. Default is <code>false</code>\n\t* @param okListener the {@link ActionListener} to invoke when the\n\t* OK button is pressed\n\t* @param cancelListener the {@link",
            "finish_reason": "length"
        },
        {
            "text": "\n    final static int NUM_ROWS = 100;\n    final static int MAX_IMAGE_SIZE = 1000000;\n    final static int MIN_IMAGE_SIZE = MAX_IMAGE_SIZE - 50000; \n    //final static int NUM_COLUMNS = 200;\n\n    final static int LEFT_MARGIN = 50000;\n\n    @Before\n    public void setup() {\n        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n        GraphicsEnvironment e2 = GraphicsEnvironment.getSubstituteGraphicsEnvironment();\n        Font font = (Font) ge.findFont(\"Custom Dialog Font\");\n        Font font2 = (Font) e2.getFont(\"Custom Dialog Font\");\n        Font orig = e2.getDefaultFont();\n        e2.setFont(\"Dialog\", 10);\n        System.setProperty(\"awt.requestFocusOnKeyboard\", \"false\");\n        Font chooserFont = orig.deriveFont(Font.PLAIN, 7);\n        Font dropDownFont = orig.deriveFont(Font.BOLD, 7);\n        Font customFont = new Font(Font.MONOSPACED, Font.PLAIN, 12);\n        System.setProperty(\"swing.border\", \"none\");\n        Window w = new JDialog();\n        Component c;\n        c = new JButton(\"Button\");\n        w = new FileChooser(e, 0);\n        w.setBounds(LEFT_MARGIN, 10, 300, 1000);\n        w.setLocation(25, 80);\n\tc.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent event) {\n                showDialog(null, \"My custom font chooser dialog\");\n            }\n        });\n        c = new JButton(\"Button\");\n        w = new JDialog();\n        w.setLocation(25, 100);\n\tc.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent event) {\n                showDialog(null, \"My custom font",
            "finish_reason": "length"
        },
        {
            "text": "\n\tprivate static final String PROPERTY_KEY = \"key\";\n\n\tprivate Map<Action, ActionListener> actionListeners = new HashMap<>();\n\tprivate Map<ListSelectionListener, ListSelectionListener> selectionListeners = new HashMap<>();\n\n\t/**\n\t * Create JFontChooser with default settings.\n\t * @param parent parent Component used for setting parent for this component\n\t * @see JComponent#JComponent()\n\t */\n\t\n\tpublic JFontChooser_0Test(JComponent parent) {\n\t\t\n\t\t// Add listener\n\t\tactionListeners.put(new ActionListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif (e.getSource() instanceof Action) {\n\t\t\t\t\tAction action = (Action) e.getSource();\n\t\t\t\t\t\n\t\t\t\t\t// Get the ListSelectionManager\n\t\t\t\t\tListSelectionModel model = JList.this.getSelectionModel();\n\t\t\t\t\t\n\t\t\t\t\t// Get the current element or use the last selected item\n\t\t\t\t\t// TODO: use getElementToSelect instead?\n\t\t\t\t\tObject obj = model.getSelectedValue();\n\n\t\t\t\t\tif (obj instanceof Font) {\n\t\t\t\t\t\t\n                        object = (Font) obj;\n\t\t\t\t\t\t\n                    } else if (obj instanceof Font[]) {\n                        object = (Font[]) obj;\n                    } else {\n                        // TODO: handle case of null return value for element\n                        return;\n                    }\n\t\t\t\t\t\n\t\t\t\t\t// Get the \"command\"\n\t\t\t\t\tObject command = action.getValue(PROPERTY_KEY);\n\t\t\t\t\t\n\t\t\t\t\t// Display font command\n\t\t\t\t\ttry {\n\t\t\t\t\t\tobject.setText((String) command);\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t\tString msg = \"<font name=\\\"italic\\\">Sorry, that font cannot be displayed!\";\n\t\t\t\t\t\tJOptionPane.showMessageDialog(null, msg, \"Please select a font\", JOptionPane.WARNING_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t",
            "finish_reason": "length"
        },
        {
            "text": "/**\n\t\t* An empty container of components of type\n\t\t* {@link Container}, which makes sure the component\n\t\t* is not removed while an action is running.\n\t\t*/\n        private final JList list = new JList();\n        \n        /**\n\t\t* This field is required if a test is not to be\n\t\t* executed.  It is a {@link Serializable} value.\n\t\t*/\n        private final ActionListener listener = new ActionListener() {public void actionPerformed(ActionEvent arg0) {}};\n\n\t\t/**\n\t\t* The JDialog component.\n\t\t*/\n        private final JDialog dialog = new JDialog();\n\n        /**\n\t\t* The container of components that is used \n\t\t* to create the JDialog.\n\t\t*/\n        private Container cont;\n\n        /**\n\t\t* This is the container of all components in this JFrame.\n\t\t*/\n        private final Container c;\n        \n        /**\n\t\t* The JList component of this container.\n\t\t*/\n        private final JList l = new JList(list);\n        \n        /**\n\t\t* The list of font names.\n\t\t*/\n        private final JList names = new JList();\n        \n        /**\n\t\t* This field is required if a test is not to be\n\t\t* executed.  It is a {@link Serializable} value.\n\t\t*/\n        private final ListSelectionListener listeners = new ListSelectionListener() {public void valueChanged(ListSelectionEvent e) {}};\n\n        /**\n\t\t* This field is required if a test is not to be\n\t\t* executed.  It is a {@link Serializable} value.\n\t\t*/\n        private final KeyListener [] kl = { new KeyAdapter(){public void keyPressed(KeyEvent e) {assertEquals(KeyEvent.VK_ESCAPE, e.getKeyCode());}}};\n\n        /**\n\t\t* This array of action listeners is required if a test\n\t\t* is not to be executed.  It is a\n\t\t* {@link Serializable} value.\n\t\t",
            "finish_reason": "length"
        },
        {
            "text": "\nprotected static final int WINDOW_WIDTH = 360;\nprotected static final int TEXT_HEIGHT = 40;\nprotected static final int DEFAULT_FONT_SIZE = 10; // 10 points\nprotected static final Font DEFAULT_FONT = new Font(\"Verdana\", Font.PLAIN, DEFAULT_FONT_SIZE); \nprotected static final String NEW_TEXT =\n        \"\\u0060-\\u0065\" + // 0x1 & 0x2...\n        \"\\u0066\\u0074\\u0061\\u006E\" + // 0x3 & 0x4...\n        \"\\u0061\\u006F\\u006E\\u0075\" + // 0x5 & 0x6...\n        \"-\\u006A-\\u0070\\u006A\" + // 0x7 & 0x8...\n        \"\\u0073-\\u006D\" + // 0x9 & 0xa...\n        \"\\u006C\\u0065\" + // 0xb & 0xc...\n        \"\\u0064\" + // 0xd & 0xe...\n        \"-\\u0070\\u006A\" + // 0xf & 0x10...\n        \"\\u0069\" + // 0x11...\n        \"\\u0071\" + // 0x12...\n        \"-\\u0074\" + // 0x13...\n        \"\\u006D\" + // 0x14...\n        \"-\\u0061\\u0074\" + // 0x15...\n        \"-\\u0073\" + // 0x16...\n        \"-\\u0075\" + // 0x17...\n        \"-\\u0068\" + // 0x18...\n        \"-\\u0069\" + // 0x19...\n        \";\" + // 0x1a...\n        \"\\u006E\" + // 0x1b...\n        \"\\u0066\" + // 0x1c...\n         \"\\u0075\"; // 0x1d...\n\n",
            "finish_reason": "length"
        },
        {
            "text": "\nJFontChooser j;\n\n\t/**\n    * Creates a new instance <code>JFontChooser</code> with JFontChooser_0Test.\n    */\nJFontChooser_0Test(JFontChooser j) {\n    this.j = j;\n}\n\nint iFont = getTestFont(true);\n\n/**\n* Tests {@link JFontChooser#showDialog(Component, String)}. \n*/\n@Test\npublic void test_0_showDialog() {\n\tj.showDialog(new JButton(), \"JFontChooser\");\n\tassertEquals(\"JButton\", j.getTitle());\n}\n\nvoid testFontChooser( String title) {\n\tj.showDialog(new JButton(), title);\n}\n\nint iFont;\n\n/**\n* Creates a new instance\n* <code>JFontChooser</code> with JFontChooser_0Test.\n* @param testFont the font that is tested\n* @see #testFontChooser\n*/\nJFontChooser_0Test(Font testFont) {\n    iFont = Font.getDefaultClientSize();\n    j = new JFontChooser(testFont);\n}\n\n}\n\n",
            "finish_reason": "stop"
        },
        {
            "text": "\n\tprivate static final long serialVersionUID = -1489553826398975391L;\n\tprivate final static Font TEST_FONT = new JTextField();\n\tprivate final static String TEST_FONT_NAME = \"Dialog Font\";\n\tprivate final static Font TEST_FONT_SYSTEM_DEFAULT = new Font(null, Font.PLAIN, 14);\n\tprivate final JFontChooser chooser;\n\tprivate void checkFontComponent() {\n\t\tFont font = chooser.getFont();\n\t\tComponent component = chooser.getFontComponent();\n\t\tassertEquals(TEST_FONT_NAME, font.getName());\n\t\tassertEquals(TEST_FONT_SYSTEM_DEFAULT, font.getFont(TEST_FONT_SYSTEM_DEFAULT, false));\n\t\tassertEquals(TEST_FONT, font);\n\t\tassertEquals(TEST_FONT_NAME, font.getName());\n\t\tassertNull(font.getFont(TEST_FONT_SYSTEM_DEFAULT));\n\t\tassertNull(font.getFont(TEST_FONT_SYSTEM_DEFAULT, true));\n\t}\n\tprivate void checkFontList() {\n\t\tString[] names = chooser.getFontFamilyNames();\n\t\tassertTrue(names.length == 1);\n\t\tassertTrue(names[0].equals(TEST_FONT_NAME));\n\t}\n\tprivate void checkFontMap() {\n\t\tString defaultFontName = TEST_FONT.getName();\n\t\tString defaultFamilyName = TEST_FONT.getFamilyName();\n\t\tString[] names = chooser.getAvailableFontFamilyNames();\n\t\tif (names.length > 1) {\n\t\t\tnames[1] = defaultFontName;\n\t\t}\n\t\tif (names.length == 2) {\n\t\t\tassertTrue(defaultFamilyName.equals(names[0]));\n\t\t}\n\t\tassertTrue(names[0].equals(defaultFontName));\n\t\tassertTrue(names[1].equals(",
            "finish_reason": "length"
        },
        {
            "text": "\n\t@Test\n\tvoid test1() {\n\t\tfinal String title = \"JCheckBoxTest\";\n\t\tfinal JCheckBox check = new JCheckBox(title) {\n\t\t\t\t{\n\t\t\t\t\tsetText();\n\t\t\t\t\tsetFontPosture(Font.PLAIN);\n\t\t\t\t}\n\t\t\t};\n\t\tfinal JFontChooser chooser = new JFontChooser(new JDialog(new JFrame(), title), check);\n\t\tassertEquals(title, chooser.getTitle());\n\t\tassertNotNull(check.getModel());\n\t\tassertNotNull(check.getModel().getRootElement());\n\t\tassertEquals(title, check.getModel().getRootElement().getAttribute(\"text\"));\n\t\tassertEquals(title, check.getModel().getRootElement().getAttribute(\"font-name\"));\n\t\tcheck.setFont(new Font(UIManager.getSystemLookAndFeelClassName(), Font.PLAIN, 5));\n\t\tassertEquals(title, check.getFont().getFamily());\n\t\tassertEquals(new Font(UIManager.getSystemLookAndFeelClassName(), Font.PLAIN, 10), check.getSelectedFont());\n\t\tassertNotNull(check.getSelectedFont());\n\t\tassertEquals(new Font(UIManager.getSystemLookAndFeelClassName(), Font.PLAIN, 11), check.getSelectedFont().getFamily());\n\t\tassertEquals(new Font(UIManager.getSystemLookAndFeelClassName(), Font.PLAIN, 10, new char [] { '1', '2', '3' })\n\t\t\t\t\t.getFamily(), check.getSelectedFont().getFamily());\n\t\t\n\t\tJPanel panel = new JPanel();\n\t\tfinal JList list = new JList() {\n\t\t\t\t{\n\t\t\t\t\taddListSelectionListener(new ListSelectionListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void valueChanged(ListSelectionEvent event) {\n\t\t\t\t\t\t\tcheck.requestFocusInWindow();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\tlist.set",
            "finish_reason": "length"
        },
        {
            "text": "\n\t\n    private static final long serialVersionUID = 1L;\n\tprivate JFontChooser chooser = null;\n\tprivate static final Integer I_INT = new Integer(250);\n    \n\t@Test\n    public void test_Constructor() {\n        assertNull(chooser);\n    }\n    \n\t@Test\n    public void test_ActionListener() {\n        new FontTracker();\n    }\n    \n\t@Test\n    public void test_ActionMap() {\n\t}\n    \n\t@Test\n    public void test_ComponentAdapter() {\n    }\n        \n\t@Test\n    public void test_ComponentEvent() {\n    }\n    \n\t@Test\n    public void test_ComponentListener() {\n    }\n    \n\t@Test\n    public void test_ListSelectionListener() {\n    }\n     \n\n    @Test\n    public void test_JPanel() {\n        JPanel container = new JPanel();\n    }\n    \n    @Test\n    public void test_JPanel_addActionListener() {\n    }\n     \n     \n \n    \n\t\n\t@Test\n\tpublic void test_getFont() {\n        JFontChooser chooser = new JFontChooser();\n        Font font = chooser.getFont();\n        assertEquals(System.getProperty(\"linux.font.name\"), \"Linux-Bold\", font.getName());\n        assertTrue(!font.isBold());   \n        //JFontChooser chooser = (JFontChooser) JComponent.createJComponentFor(null);\n        //assertTrue(chooser.isLight());\n\t}\n    \n    private static class JFontChooserDialog extends JDialog {\n\t\t\n\t    private FontTracker fontTracker;\n\t    private JCheckBox checkBox;\n\t    private JPanel selectionPanel;\n\t    private JLabel currentLabel;\n\t    private JList fontList;\n\t    private JList colourBoxList;\n\t    \n\t    public JFont",
            "finish_reason": "length"
        },
        {
            "text": "static final String fontPath = \"M :9 a.ttf; K50 d:13 a:9.ttf:13\";\n\tstatic final String fontName = \"Font name font.ttf\";\n\tstatic final String Font_0_Text_1 = \"Font name font.ttf; K50 d:13 a.ttf:13\";\n\tstatic final String Font_0_Text_2 = \"font name default: default.ttf; K50 d:13 a default: default.ttf:13\";\n\t\n\t/** Component used to display the dialog */\n\tprivate JDialog dialog;\n\n\t/** Component used to add action listeners */\n\tprivate JButton buttonOK;\n\n\n\n    /**\n     * Sets up the test.\n     */\n    JPFontChooser_0Test() {\n\t\tdialog = createDialog(new JPanel(), \"Dialog\", true, null, null);\n\t\tdialog.addComponentListener(new FontChooserDialog.Listener());\n\t\tbuttonOK = new JButton(\"Ok\");\n\t\tbuttonOK.addActionListener(new ActionListener() {\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tdialog.dispose();\n\t\t\t}\n\t\t});\n\n\t\tUIManager.LookAndFeelInfo info = UIManager.getUIofType(\"defaultlaf\");\n\t\tfontName = info.getName();\n\t}\n\n\t/**\n\t * Creates the dialog to be tested.\n\t * @param container the parent <code>Container</code>\n\t * @param title the title of the dialog, may be null\n\t * @param noBorder is the dialog visible in the border in any locale\n\t*/\n\tprotected JDialog createDialog(Object container,String title,boolean noBorder,Action mapAction, Action mapContext) {\n\t\tdialog = new JDialog(new JPanel(), (container == null)? \"dialog\" : container, modal(noBorder));\n\t\t// set up the title and title color...\n\t\tif (title == null) {\n\t\t\tdialog.setTitle(\"",
            "finish_reason": "length"
        }
    ],
    "id": "cd61a8d1-d29f-4b8c-8ccb-7d7d1369c55b",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooser_0Test.java",
    "original_code": "// JFontChooser.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\n\n/**\n * <code>JFontChooser</code> provides a pane of controls designed to allow\n * a user to manipulate and select a font.\n *\n * This class provides three levels of API:\n * <ol>\n * <li>A static convenience method which shows a modal font-chooser\n * dialog and returns the font selected by the user.\n * <li>A static convenience method for creating a font-chooser dialog\n * where <code>ActionListeners</code> can be specified to be invoked when\n * the user presses one of the dialog buttons.\n * <li>The ability to create instances of <code>JFontChooser</code> panes\n * directly (within any container). <code>PropertyChange</code> listeners\n * can be added to detect when the current \"font\" property changes.\n * </ol>\n * <p>\n *\n * @author Adrian BER\n */\npublic class JFontChooser extends JComponent {\n\n    /**\n     * Shows a modal font-chooser dialog and blocks until the\n     * dialog is hidden.  If the user presses the \"OK\" button, then\n     * this method hides/disposes the dialog and returns the selected color.\n     * If the user presses the \"Cancel\" button or closes the dialog without\n     * pressing \"OK\", then this method hides/disposes the dialog and returns\n     * <code>null</code>.\n     *\n     * @param component the parent <code>Component</code> for the dialog\n     * @param title the String containing the dialog's title\n     * @return the selected font or <code>null</code> if the user opted out\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public Font showDialog(Component component, String title) {\n        FontTracker ok = new FontTracker(this);\n        JDialog dialog = createDialog(component, title, true, ok, null);\n        dialog.addWindowListener(new FontChooserDialog.Closer());\n        dialog.addComponentListener(new FontChooserDialog.DisposeOnClose());\n        dialog.setAlwaysOnTop(true);\n        // blocks until user brings dialog down...\n        dialog.setVisible(true);\n        return ok.getFont();\n    }\n}\n",
    "test_prompt": "// JFontChooser_0Test.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JFontChooser}.\n* It contains one unit test case for the {@link JFontChooser#showDialog(Component, String)} method.\n*/\nclass JFontChooser_0Test {",
    "time_taken": 21.64822793006897,
    "usage": {
        "prompt_tokens": 1587
    }
},
{
    "choices": [
        {
            "text": "JFontChooser jc;\n        private String fontProperty_1 = \"MyFont1\";\n        private String fontProperty_2 = \"MyFont2\";\n\n        /**\n         * Set up the unit test environment\n         */\n        @Test\n        public void createDialog_initializes() throws java.beans.PropertyVetoException {\n          jc = new JFontChooser();\n        }\n\n\n        /**\n         * Test that the JFontChooser Dialog is visible using a\n         * default font, a JPanel with the current font, a JCheckBox for showing\n         * a \"Do not use default\" setting and the \"OK\" button.\n         * @throws java.beans.PropertyVetoException\n         * @see java.util.prefs.BackingStoreException\n         * @see org.xdi.ide.icons.font.FontChooserDialogDialog\n         */\n        @Test\n\t\tpublic void createDialog_showsCorrectFont_correctly() throws java.beans.PropertyVetoException {\n//\t\t\tString font = jc.getCurrentFontName();\n\n\t\t\t// JFontChooser only accepts JFonts, not other kinds of font\n\t\t\tassertTrue(\"bad current font: \"+font+\" \"+java.text.AttributedCharacterIterator.class.getName());\n\n\t\t\t// Use a default font so checkboxes appear in proper state\n\t\t\tFont f = UIManager.getFont( \"Dialog.font\" );\n\t\t\tFont plain = Font.decode( f.getName() );\n\t\t\tSystem.out.println(\"Default font name: \"+plain.toString());\n\t\t\tFont defaultFont = new Font( plain.getName(), defaultFontName, plain.getSize() );\n\n\t\t\tassertEquals(\"Bad current font: \"+font+\" \"+((DefaultListFont) defaultFont).name(), defaultFont, jc.getCurrentFontName());\n\n\t\t\t// Set the Font to a font that doesn't allow default font (e.g., a Japanese text box)\n\t\t\t",
            "finish_reason": "length"
        },
        {
            "text": "\n    /*\n      Test method for 'JFontChooser.createDialog(Component, String, boolean, ActionListener, ActionListener)'\n      @since 1.7\n      */\n    @Test\n    public void testCreateDialog() {\n        JFontChooser dialog = createDialog(\"Dialog\", \"1.0\", true, new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n            }\n            @Override\n            public void action(ActionEvent e) {\n            }\n        }, new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n            }\n            @Override\n            public void action(ActionEvent e) {\n            }\n        });\n        assertNotNull(dialog);\n    }\n    \n    /*\n      Test method for 'JFontChooser.createDialog(Component, String, boolean, ActionListener)'\n      @since 1.7\n      */\n    @Test\n    public void testCreateDialog_2() {\n        JFontChooser dialog = createDialog(\"Dialog\", \"1.0\", true, new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n            }\n            @Override\n            public void action(ActionEvent e) {\n            }\n        });\n        assertNotNull(dialog);\n    }\n    \n    /*\n      Test method for 'JFontChooser.createDialog(Component, String, boolean, ActionListener, ActionListener)'\n      @since 1.7\n      */\n    @Test\n    public void testCreateDialog_3() {\n        JFontChooser dialog = createDialog(\"Dialog\", \"1.0\", true, new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n            }\n            @Override\n            public void action(ActionEvent e) {\n            }\n        }, new ActionListener() {\n            @Override\n            public",
            "finish_reason": "length"
        },
        {
            "text": "/**\n\t\t*\n\t\t*/\n\t\tprivate final Object lock = new Object();\n        private static final String FONT = \"Font\";\n        private static final String FONT3 = \"Font 3\";\n        private static final int WIDTH = 300;\n        private static final int HEIGHT = 250;\n        private final boolean[] test = {false};\n        private Object[][] table = new Object[][] {\n            {new String(\"Helvetica\"), FONT, FONT, WIDTH},\n            {new String(\"Times\"), FONT, FONT3, WIDTH},\n            {new String(\"Helvetica-Bold\"), FONT, FONT3, WIDTH}\n        };\n\n//        /**\n//         * @tests test createDialog(Container parent, String title, boolean modal)\n//         */\n//         @Test\n//         public void test_createDialog_1() {\n//\n//                 int dialogWidth = 300;\n//                 int dialogHeight = 150;\n//                 Window win = new Window(\"Dialog\");\n//                 FontChooserDialog dialog = new FontChooserDialog(win, \"Dialogs\", false, null, null, null);\n//........\n//                 JDialog dialog0 = dialog.createDialog(win, \"New Dialog\");\n//                // Test result \n//                assertEquals(dialog0, dialog);\n//\n//                 dialog = new FontChooserDialog(win, \"Dialogs\", true, null, null, null);\n//\n//                // Test result \n//                assertEquals(dialog, dialog0);\n//\n//                dialog.setTitle(null);\n//\n//                // Test result \n//                 dialog = new FontChooserDialog(win, \"Dialogs\", true, null, null, null);\n//           \n//              // Test result \n//                 dialog = new FontChooserDialog(win, \"Dialogs\",",
            "finish_reason": "length"
        },
        {
            "text": "private static final String TEST_NAME = \"TEST_NAME\";\n\t\tprivate static final String TEST_FONT = \"TEST_FONT\";\n\t\tprivate static final String TEST_FONT_PLAIN = \"TEST_FONT_PLAIN\";\n\t\tprivate static final int TEST_SIZE = 15;\n\t\tprivate static final int TEST_LAYOUT = GridBagLayout.LAYOUT_4X12;\n\t\tprivate static final GridBagConstraints gbc_btnBorderBottom = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_btnBorderBottom_1 = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_btnBorderBottom_2 = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_btnBorderBottom_3 = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_btnBorderBottom_4 = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_btnBorder = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_btnBorder_1 = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_btnBorder_2 = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_btnBorder_3 = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_pnlFonts = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_txtProgName = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_txtDefaultFont = new GridBagConstraints();\n\t\tprivate static final GridBagConstraints gbc_lstFonts = new GridBagCon",
            "finish_reason": "length"
        },
        {
            "text": "/**\n\t     * Test method for {@link osa.ora.server.client.ui.utils.JFontChooser#createDialog(java.awt.Component, java.lang.String, boolean, java.lang.RuntimeException)}.\n\t     */\n    @Test\n    public void testCreateDialog_2Args() {\n        try {\n            JFontChooser_1Test.testCreateDialog(true, true);\n            fail(\"Should throw an InvalidOperationException when dialog has two children.\");\n        } catch (java.lang.IllegalStateException e) {\n            // PASS\n        }\n\n        try {\n            JFontChooser_1Test.testCreateDialog(true, false);\n            fail(\"Should throw an IllegalArgumentException when dialog has no children\");\n        } catch (java.lang.IllegalStateException e) {\n            // PASS\n        }\n\n\t\ttry {\n            Container c1 = new JFontChooser_1Test().getParent();\n            assertNotNull(\"Parent is null\", c1);\n        } catch (java.lang.IllegalStateException e) {\n            fail(\"Should have failed with an IllegalStateException\");\n        } catch (SecurityException e) {\n            fail(\"Should have failed with a SecurityException\");\n        } catch (NoSuchFieldException e) {\n            fail(\"Should have failed with a SecurityException\");\n        }\n\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "\n    private final int _height = 700;\n    private final int _width = 100;\n    private int _height_current = 500;\n    private int _width_current = 100;\n    private final String _title = String.format(\"%d\", _height);\n    private final String _text = String.format(\"%d\", _width);\n    private final ListSelectionModel _smsl;\n    private JList _lst;\n    private JCheckBox _lb;\n    private JPanel _panel;\n    private Font _font;\n    private transient EventListenerList eventListenerList = new EventListenerList();\n\n\t/**\n\t* This method is run before each test case is executed.\n\t* It returns the height of the dialog.\n\t*\n\t* @return the height\n\t*/\n\tint getHeight()\n\t{\n\t\treturn _height;\n\t}\n\n\t/**\n\t* This method is run before each test case is executed.\n\t* It sets the height of the dialog.\n\t*\n\t* @param n the height to be set\n\t*/\n\tvoid setHeight(int n)\n\t{\n\t\t_height = n;\n\t}\n\n\t/**\n\t* This method is run before each test case is executed.\n\t* It returns the width of the dialog.\n\t*\n\t* @return the width\n\t*/\n\tint getWidth()\n\t{\n\t\treturn _width;\n\t}\n\n\t/**\n\t* This method is run before each test case is executed.\n\t* It sets the width of the dialog.\n\t*\n\t* @param n the width to be set\n\t*/\n\tvoid setWidth(int n)\n\t{\n\t\t_width = n;\n\t}\n\n\t/**\n\t* This method is run before each test case is executed.\n\t* It sets the font and then creates a JFontChoser window with the specified values.\n\t* If the JFontChooser window is",
            "finish_reason": "length"
        },
        {
            "text": "final static ActionListener listener1 = new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tString text = (String) e.getActionListeners().get(ActionListener.ACTION_NAME);\n\t\t\t\tif (\"RESET\".equals(text)) {\n\t\t\t\t\tFont myCurrentFont = JFontChooser_1.currentFont;\n\t\t\t\t\tmyCurrentFont.setName(null);\n\t\t\t\t}\n\n\t\t\t\tJFontChooser_1.currentFont = null;\n\t\t\t}\n\t\t};\n\t\tfinal static ActionListener listener2 = new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tObject o = e.getActionListeners().get(ActionListener.ACTION_NAME);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Constructor for tests. \n\t\t */\n\t\tJFontChooser_1Test(Object o) {\n\t\t\tlistener1.actionPerformed(null);\n\t\t\tlistener2.actionPerformed(null);\n\t\t}\n\t}\n\n\n// JDialog_1Test.java\n/*\n* Serializable tests\n*/\n\n// Dialog_1Test.java\n// Dialog containing components and test for serialization and deserialization.\n// \npublic class JColorChooser_1Test implements Serializable {\n\tpublic static void main(String argv[]) {\n\t\tjunit.textui.TestRunner.run(JColorChooser_1Test.class);\n\t}\n\n\t/**\n\t  * Tests serialization of the font chooser dialog.\n\t  */\n\tpublic void test1() {\n\n        ColorChooserDialog dialog = new ColorChooserDialog(\n            new JFontChooser_1Test(\"Dialog Test\"),\n            \"Dialog Test Dialog\",\n        );\n\n        JPanel panel = (JPanel) dialog.getComponent();\n        dialog.close();\n\n        dialog = (ColorChooserDialog) (((ColorChooserDialog) panel.getComponent",
            "finish_reason": "length"
        },
        {
            "text": "JFontChooser(String title) {\n\t\t\t\tthis.title = title;\n\t\t\t}\n\t\tpublic String getTitle() { return title; }\n\t\tpublic static String title;\n\t}\n\t/**\n\t * A test to check the return value of <code>JPanel.add(Component)</code>.\n\t */\n\tpublic class JPanel_1Test_addComponent extends JPanel_1Test_1 implements Serializable {\n\t\tstatic int invokedCount;\n\t\tstatic int addedCount;\n\t\tpublic void showListener1(){\n\t\t\tinvokedCount++;\n\t\t}\n\t\tpublic void showListener2(){\n\t\t\taddedCount++;\n\t\t\treturn;\n\t\t}\n\t\tpublic void showListener3(final JComponent comp) {\n\t\t\tinvokedCount++;\n\t\t\tif(comp!= null) { addedCount++ ; }\n\t\t}\n\t\tpublic void showListener4() { called(); }\n\t}\n\t/**\n\t * A test to check the return value of <code>remove(int index)</code>.\n\t */\n\tpublic class JPanel_1Test_removeComponent extends JPanel_1Test_1 implements Serializable {\n\t\tstatic int invokedCount;\n\t\tpublic void showListener(){\n\t\t\tinvokedCount++;\n\t\t\tif(invokedCount == 1){\n\t\t\t\tSystem.out.println(\"remove(int index). Removed!\");\n\t\t\t\tremove(index);\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * A test to check the return value of <code>remove(Component)</code>.\n\t * @throws NullPointerException if the <code>list</code> or the <code>c</code> parameter is null.\n\t */\n\tpublic class JList_1Test_removeComponent extends JList_1Test_1 implements Serializable {\n\t\tStaticList list = new StaticList();\n\t\tpublic void setList(ListChooserPane pane) {\n\t\t\tthis.pane = pane;\n\t\t\tsetModel(pane.getListModel());\n",
            "finish_reason": "length"
        },
        {
            "text": "\n\t@Test\n\tvoid testCreateDialog_OkCancelCancelKeyStrokes_ActionListener_ActionListener() {\n            String[] a = {\"\", \"A\", \"\", \"b\", \"\"};\n\n            JFontChooser chooser = new JFontChooser(\"test\");\n\n            ActionListener a1 = new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    System.out.println(\"test createDialog: ActionListener actionPerformed: \" + e);\n                }\n            };\n            ActionListener a2 = new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    System.out.println(\"test createDialog: ActionListener actionPerformed: \" + e);\n                }\n            };\n            ActionListener a3 = new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    System.out.println(\"test createDialog: ActionListener actionPerformed: \" + e);\n                }\n            };\n            ActionListener a4 = new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    System.out.println(\"test createDialog: ActionListener actionPerformed: \" + e);\n                }\n            };\n\n            ActionListener a5 = new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    System.out.println(\"test createDialog: ActionListener actionPerformed: \" + e);\n                }\n            };\n\n            ActionListener a6 = new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    System.out.println(\"test createDialog: ActionListener actionPerformed: \" + e);\n                }\n            };\n\n            ActionListener a7 = new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    System.out.println",
            "finish_reason": "length"
        },
        {
            "text": "/**\n\t\t* Returns a null Font that contains the font.\n\t\t*/\n\tpublic Font getNullFont() { return null; }\n\t/**\n\t* Returns the font of the dialog.\n\t*/\n\tpublic Font getFont() { return null; }\n\t/**\n\t* Returns the font of the dialog.\n\t*/\n\tpublic Font getFontByName(String fontName) { return null; }\n\t/**\n\t* Returns the actionListener specified by the\n\t* <code>{@link #createDialog(Component, String, boolean, ActionListener, ActionListener)}</code> method.\n\t*/\n\tpublic ActionListener getActionListener(String dialogID) { return null; }\n\t/**\n\t* Returns an instance of JFontChooser with a component pane.\n\t* This method returns <code>null</code> as any value for\n\t* <code>componentFonts</code> or for <code>defaultFont</code>.\n\t*/\n\tpublic FontChooser createSelector(boolean defaultFont) { return null; }\n\t/**\n\t* Returns a component pane for the dialog.\n\t*/\n\tpublic Window createComponent(String dialogID) { return null; }\n\t/**\n\t* Creates a new FontChooserDialog that displays the specified\n\t* FontChooser.\n\t* @param c parent component\n\t* @param title a title\n\t* @param modal a boolean to indicate whether the dialog is modal\n\t* @param dialogID an unique string that identifies this dialog and\n\t*                   can be used in the ActionListener's signature\n     * @param okListener the ActionListener invoked when the ok button\n     *                   is pressed. The dialog is closed and\n     *                   the ok action is performed.\n     * @param cancelListener the ActionListener invoked when the cancel\n     *                   button is pressed. The dialog is closed and/or\n     *                   the cancel action is performed.\n     */\n\tpublic JDialog createDialog",
            "finish_reason": "length"
        }
    ],
    "id": "294e6178-28e5-4015-b7b8-233b3054d552",
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooser_1Test.java",
    "original_code": "// JFontChooser.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\n\n/**\n * <code>JFontChooser</code> provides a pane of controls designed to allow\n * a user to manipulate and select a font.\n *\n * This class provides three levels of API:\n * <ol>\n * <li>A static convenience method which shows a modal font-chooser\n * dialog and returns the font selected by the user.\n * <li>A static convenience method for creating a font-chooser dialog\n * where <code>ActionListeners</code> can be specified to be invoked when\n * the user presses one of the dialog buttons.\n * <li>The ability to create instances of <code>JFontChooser</code> panes\n * directly (within any container). <code>PropertyChange</code> listeners\n * can be added to detect when the current \"font\" property changes.\n * </ol>\n * <p>\n *\n * @author Adrian BER\n */\npublic class JFontChooser extends JComponent {\n\n    /**\n     * Creates and returns a new dialog containing the specified\n     * <code>ColorChooser</code> pane along with \"OK\", \"Cancel\", and \"Reset\"\n     * buttons. If the \"OK\" or \"Cancel\" buttons are pressed, the dialog is\n     * automatically hidden (but not disposed).  If the \"Reset\"\n     * button is pressed, the color-chooser's color will be reset to the\n     * font which was set the last time <code>show</code> was invoked on the\n     * dialog and the dialog will remain showing.\n     *\n     * @param c the parent component for the dialog\n     * @param title the title for the dialog\n     * @param modal a boolean. When true, the remainder of the program\n     *                       is inactive until the dialog is closed.\n     * @param okListener the ActionListener invoked when \"OK\" is pressed\n     * @param cancelListener the ActionListener invoked when \"Cancel\" is pressed\n     * @return a new dialog containing the font-chooser pane\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public JDialog createDialog(Component c, String title, boolean modal, ActionListener okListener, ActionListener cancelListener) {\n        return new FontChooserDialog(c, title, modal, this, okListener, cancelListener);\n    }\n}\n",
    "test_prompt": "// JFontChooser_1Test.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JFontChooser}.\n* It contains one unit test case for the {@link JFontChooser#createDialog(Component, String, boolean, ActionListener, ActionListener)} method.\n*/\nclass JFontChooser_1Test {",
    "time_taken": 20.880170583724976,
    "usage": {
        "prompt_tokens": 1607
    }
}
]