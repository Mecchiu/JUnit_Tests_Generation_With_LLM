ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
7291140f-aa4e-4ee6-a590-ee7f82e4d186,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_0Test.java,53.782947063446045,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }
}
","// ClassInfo_0Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {","// ClassInfo_0Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {
// ----------------------------------------------------------- Constructor

		/**
		 * Build the test.
		 */
		public ClassInfo_0Test() {
			className = ""ClassInfo_0Test$ClassInfo_0Test"";
		}

		// --------------------------------------------------------- Public Methods

		/**
		 * Construct the test.
		 */
		public Test suite() {
			TestSuite test = new TestSuite(""Test Class Info for class "" + className);
			test.addTest(new TestInstance(c.staticFieldTest(JUNCTION), new junctionInfo(c)));
			return test;
		}

		/**
		 * Construct the test environment in debug mode.
		 */
		public static junctionInfo junctionInfo(JUNCTION junctionClass) {
			return new junctionInfo(junctionClass);
		}

		// --------------------------------------------------------- Private Methods

		/**
		 * Tests the {@link ClassInfo#printFields()} methods.
		 */
		private static junctionInfo junctionInfo(JUNCTION junctionClass) {
			TestSuite junctions = junctionClass.testSuites();
			ClassInfo junctyClass = junctions.get(0).getTestClass();
			ClassInfo junctyInfo = junctyClass.classInfo();
			Field[] f = junctyClass.fields();
			StringBuilder out = new StringBuilder();

			// Print the fields
			for (int count = 0; count < len(f); count++) {
				Field fD = f[count];
				out.append(fD.getName()).append("", "");
				FieldInfo fiD = junctyClass.classInfo().field(fD.getName());
				if (fiD.isPublic())
					continue;

				out.append(fiD.toString());
				if (fiD.isPublic())
					out.append("", "");
				else
					out.append("" "");

				if (fiD.isPrivate())
					continue;

				if (fD.getType().isArray()) {
					out.append(""is array"");
					Class k = (Class) Array.newInstance(fD.getType(), 1);
					if (count > 0)
						out.append("", "");
					out.append(fiD.toString());
					String[] data = junctyInfo.printMethods(new Object[1], new Object());
					for (int dataCount = 0; dataCount < data.length; dataCount++)
						out.append("", \"""");
					out.append(fiD.toString());
					out.append(""\"""");
				} else 
					out.append(fiD.toString());
			}

			return new junctionInfo(out.toString());
		}

		/**
		 * Returns the name of the test class.
		 */
		private static String className = ""ClassInfo_0Test"";

		/**
		 * Returns the class that is tested.
		 */
		private JUNCTION junctureClass = null;

		/**
		 * Returns the c private Class object.
		 */
		private Class c = null;

		/**
		 * Returns the c private Class object.
		 */
		private Field[] fields = null;

		/**
		 * Returns the c private Class object, null if no junctions class.
		 */
		private ClassInfo junctyClass = null;

		/**
		 * Returns the c private Class object, null if no juncty class.
		 */
		private Field[] fields_ = null;

	}

// End ClassInfo_0Test.java
"
9b36b73a-db1b-467d-926c-0040ebdd54ec,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_1Test.java,57.46868014335632,length,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }
}
","// ClassInfo_1Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {","// ClassInfo_1Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {
// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods!= null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }
}

// ClassInfo_1Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {
		
	/**
	 * Sets up a ClassInfo object.
	 * <p>
	 * First it creates a class with the <code>public int</code> methods.
	 * This is necessary to satisfy the {@link Set} interface.
	 * The returned <code>cMethods</code> and <code>cMethods</code> array contain
	 * methods that are not <code>public</code>.
	 */
	public static void setupClassInfo() {
		cMethods = new char[0x40];
		System.arraycopy(publicMethods(), 0, cMethods, 0, cMethods.length);
		System.arraycopy(publicMethods(), 0x40, cMethods, cMethods.length, 40);

		/* Create the class object.
		 * 				   System.arraycopy(
		 */
				Class c = null;
				try {
					c = Class.forName(""java.util.HashSet"");
					System.arraycopy(publicMethods(), 0, cMethods, 0, cMethods.length);
					cMethods = cMethods.clone();
				}
				catch (Exception e) {
					fail(""ClassInfo_1Test.setupClassInfo() failed: "" + e.getMessage());
				}
	}

	/**
	 * Prints the array returned by {@link ClassInfo#printMethods()}.
	 */
	public static void printArray(String[] a) {
		Object o;
		System.out.println(""cMethods array is "" + a.length);
		System.out.println(""cMethods is "");
		System.arraycopy(a, 0, cMethods, 0, a.length);
		if (debug) {
			System.out.println(""cMethods is "" + new String(cMethods));
		}
		for (int i = 0; i < cMethods.length; ++i) {
			o = cMethods[i];
			if (debug)
				System.out.println(""cMethods[i]="" + o);
			if (o!= cMethods[i])
				fail(""cMethods[i] not equal to cMethods[i]"");
		}
		System.out.println("""");
	}

	/**
	 * Sets up the various static and non-static constructors.
	 */
	public static void setupStatic() {
		int a2;
		Object o;
		Constructor c;
		Constructor[] tempArray;
		String[][] tempArray2;
		staticConstructor();
		staticConstructor2();

		for (int i = 0; i < test2.length; ++i) {
			a2 = test2[i][0]; // first element is the constructor
			c = test2[i][1]; // second element is the static constructor
			testConstructor3(a2, c);
			if (isFieldInit(c)) {
				tempArray = (Constructor[]) c.getDeclaredConstructors()[0]; // the ""c"" constructor has a public constructor,
				// because the c field will always be initialized.

				for (int j = 0; j < test2.length; ++j) {
					o = test2[j][0]; // get the constructor
					java.util.Arrays.fill(cMethods, 0x20);
					java.util.Arrays.fill(cMethods, 0x40);
					if (!(o instanceof Constructor))
						fail(""testConstructor3() failed: the nonStatic constructor is not a constructor"");
					c = (Constructor) o;
					cMethods[test2[i][2]++] = c.newInstance();
				}
				tempArray2 = (Constructor[]) CtClass.make(c, c.getDeclaringClass());
				c.newInstance().apply(tempArray, tempArray2);
				if (!isFieldInit(tempArray2[2][2]))
					fail(""testConstructor3() failed: "" + o);
			}
		}
	}

	private static boolean isFieldInit(Object o) {
		Field f;
		Class o1;
		try {
			f = o.getClass().getDeclaredField(""init""); // first
			return (o1 = f.get(o)).equals(new Object()); // second
		}
		catch (Exception ee) {
			return false;
		}
	}

	/**
	 * Runs a constructors with the specified number of private methods and assert that the results are the same.
	 */
	void testedConstructor3(int a, Constructor c) {
		if (debug)
			System.out.println(""Testing constructor "" + c.toString());
		c.setAccessible(true);
		try {
			if (!c.newInstance().equals(c.newInstance()))
				fail(""TestConstructor3() failed: "" + c.toString());
			c.setAccessible(false);
		}
		catch (Exception ee) {
			fail(""TestConstructor3() failed: "" + c.toString());
		}
	}

	public static void staticConstInit() {
		//	Object o = null;
		//	try
		//	{
		//		staticConstInit(o);
		//	}
		//	catch (Exception ee)
		//	{
		//		// TODO Auto-generated catch block
		//		fail(""static const init failed"");
		//	}
	}

	private static void staticConstInit(Object o) {
		if (o == null) {
			Class temp = null;
			try {
				temp = Class.forName(""java.util.HashMap"");

				if (temp.isArray()) {
					if (temp.getComponentType().isArray()) {
						if (temp.getComponentType().getComponentType().isInterface()) {
							if (temp.getComponentType().getComponentType() == Object.class)
								return null;
							temp = temp.getComponentType().getComponentType();
						}
						else
							return null;
					}
					if (temp.getComponentType().isInterface())
						return null;
					temp = temp.getComponentType();
				}
			}
			catch (Exception e) {
				e.printStackTrace();
			}
			if (debug)
				System.out.println(""Initializing "" + o.getClass().getName() + "" with "" + Arrays.toString(temp.getClass().getComponentType().getComponentType()));
			cMethods = (char[]) Arrays.deepCopyOf(cMethods, temp.getClass().getComponentType().getComponentType());
			debug ="
94f17a28-ada8-4069-bd51-0e9c031325b5,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_2Test.java,54.46428632736206,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }
}
","// ClassInfo_2Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {","// ClassInfo_2Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {
// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.')!= -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }
}

// ClassInfo_2Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {
		
    /**
     * The test is to verify that methods are printed correctly.
     */
    @Test
    void verifyMethods() { 
        // This is the point where the unit tests exist.
		String[] data = new String[]{""abstract"", ""default"", ""static"", ""constructors"", ""overloads"", ""is-annotated"",
		                        ""implements"", ""annotated"", ""private"", ""extended"", ""annotation""};
        ClassInfo cMethods = new ClassInfo();
        // Try to get at the c methods array.    
        String res = cMethods.printMethods(0);
        assertEquals(res, data[2].toString());
        System.out.println(""Successfully retrieved public methods for an interface."");
    }    
}
"
13061256-b882-4b01-a6b9-9c17e4ebd95c,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_3Test.java,57.41143584251404,length,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }
}
","// ClassInfo_3Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {","// ClassInfo_3Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {
JFrame frame;
		Panel p1;
		Panel p2;
		Button button;
		Button button3;
		String[] data;
		String[] strData;
		int[]    intData;

		// Sets up the fixture.
		void playAndShot () {
			p1 = new Panel();
			button = new Button(""Hello World"");
			p2 = new Panel();
			button3 = new Button(""Called by click"");
			frame = new JFrame(""ClassInfo_3Test"");
			p1.setLayout(new BorderLayout());
			p1.add(button, BorderLayout.SOUTH);
			p1.add(button3, BorderLayout.NORTH);
			intData = new int[] { 5, 15 };
		}
		
		void clear (String test) {

			if (debug) System.out.println(""************************************************"");
			System.out.println(""*******************""+test);

			ArrayList<Panel> panels = new ArrayList<>();
			String[] sdata = { ""1"", ""2"", ""3"" };
			ArrayList<Integer> ids = new ArrayList<>(Arrays.asList(new Integer[] { 1, 2, 3 }));
			Panel[] pdata = new Panel[4];
			pdata[0] = new Panel();
			pdata[1] = new Panel();
			pdata[2] = new Panel();
			pdata[3] = new Panel();

			for (int i = 0; i < ids.size(); ++i) {
				pdata[i] = new Panel();
				
				if (debug) System.out.println(""*******************""+i+"""");

				p1 = new Panel();
				p1.add(new JLabel(0, 0, 0, 0, Color.BLACK));
				p1.add(pdata[i]);
				p1.add(pdata[i]);
				p2 = new Panel();
				p2.add(new JLabel(0, 0, 0, 0, Color.BLACK));
				p2.add(p1);
				p2.add(new JLabel(0, 0, 0, 0, Color.BLACK));
				p1 = new Panel();
				p1.add(new JLabel(0, 0, 0, 0, Color.BLACK));
				p1.add(p2);
				p1.add(new JLabel(0, 0, 0, 0, Color.BLACK));
				p2 = new Panel();
				p2.add(new JLabel(0, 0, 0, 0, Color.BLACK));
				p2.add(p1);
				p2.add(new JLabel(0, 0, 0, 0, Color.BLACK));
				p1 = new Panel();
				p1.add(new JLabel(0, 0, 0, 0, Color.BLACK));
				p1.add(pdata[i]);
				p1.add(new JLabel(0, 0, 0, 0, Color.BLACK));

				p1.setLayout(new BorderLayout());
			
				panels.add(p1);
				
				
			}

			String className = test;

			if (debug) System.out.println(""***** Classname=""+className);

			panel(className)
		       .setLayout(new BoxLayout(BoxLayout.LEFT, new FlowLayout()))
		       .add(buttons(className))
		       .setLayout(new FlowLayout());

			panel(className)
		       .add(buttons(className, panel(className)))

			p2.setLayout(new BorderLayout());
			p2.add(buttons(className), BorderLayout.SOUTH);
		}

		void assertEquals (int expected[], int actual[]) {
			if (debug) System.out.println(""\nexpected: "");
			for (int i = 0; i < expected.length; ++i) {
				if (debug)
					System.out.println(""  i ""+i+"": ""+expected[i]);
				assertEquals(expected[i], actual[i]);
			}
		}

		void assertEquals (Panel expected[], Panel actual[]) {
			if (debug) System.out.println(""\nexpected: "");
			for (int i = 0; i < expected.length; ++i) {
				if (debug)
					System.out.println(""  i ""+i+"": ""+expected[i]);
				assertEquals(expected[i], actual[i]);
			}
		}

		void assertEquals (ArrayList<Panel> expected, ArrayList<Panel> actual) {
			if (debug) System.out.println(""\nexpected: "");
			for (int i = 0; i < expected.size(); ++i) {
				if (debug)
					System.out.println(""   i ""+i+"": ""+expected.get(i));
				assertEquals(expected[i], actual.get(i));
			}
		}

		void assertEquals (ArrayList<Border> expected, ArrayList<JComponent> actual) {
			if (debug) System.out.println(""\nexpected: "");
			for (int i = 0; i < expected.size(); ++i) {
				if (debug)
					System.out.println(""   i ""+i+"": ""+expected.get(i));
				assertEquals(expected[i], actual.get(i));
			}
		}

		Panel buttons (String className, Panel p) {
			if (debug) System.out.println(""\n\nbuttons "");
			Panel button = new Panel(p);
			int[] ids = { 0 };

			ArrayList<Panel> panels = new ArrayList<>();

			ArrayList<Panel> p1 = new ArrayList<>();
			ArrayList<Panel> p2 = new ArrayList<>();


			ArrayList<JComponent> components = new ArrayList<>();

			ArrayList<JComponent> p1copy = new ArrayList<JComponent>(p);
			p1copy.removeAll(panels);
			ArrayList<JComponent> p2copy = new ArrayList<JComponent>(p);
			p2copy.removeAll(panels);


			p1copy.addAll(buttons(className, p1));
			p2copy.addAll(buttons(className, p2));

			ArrayList<AbstractButton> buttons = new ArrayList<AbstractButton>(p1copy + p2copy);


			ArrayList<AbstractButton> buttonP2 = buttonsCopy(buttons, p2);
			ArrayList<Abstract"
5e413759-ff7e-499a-88e3-dd1fa53e7201,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_4Test.java,49.345789432525635,length,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }
}
","// ClassInfo_4Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {","// ClassInfo_4Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {
// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c!= java.lang.Object.class &&!c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data!= null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC!= null && superC!= java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data!= null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size()!= 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }
}

// ClassInfo_4Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {
		/**
		 * Testing classinfo.
		 *  @see ClassInfo
		 *  @see ClassInfo$Test
		 *  @see ClassInfo$Test_C1
		 */
	static class TestClassInfo extends ClassInfo_4Test {
		/**
		 * Constructor of class info.
		 * @param c The Class object of this object.
		 */
		TestClassInfo(Class c) {
			super(c);
		}
	}
	static class TestClassInfo$TestC1 extends ClassInfo_4Test {
		public static boolean test(Class... args) {
			System.out.println(args.length);
			for (Object o: args)
				System.out.println(o);
			return false;
		}
		public TestClassInfo$TestC1() {
			super(TestClassInfo.class);
		}
	}
		private static void test(String cName,String cDescription) {
		System.out.println(cName);
		System.out.println(cDescription);
		Class[] inter = c.getInterfaces();
		if (inter!= null) {
			for (int idx = 0; idx < inter.length; idx++) {
				inter[idx] = inter[idx].getCanonicalName();
				System.out.println(inter[idx]);
			}
		}
		if (c.isInterface())
			System.out.println();
		else {
			String d = getData(inter);
			System.out.println(d);
		}
		System.out.println(inter);
		System.out.println(Class.getPackage(inter[0]).getName());
		Class<?> cl = inter[0];
		System.out.println("""" + cl);
		Class<?> ct = cl.getSuperclass();
		System.out.println("""" + ct);
		Map m = new HashMap();
		Class[][] interfaces = ct.getInterfaces();
		for (int idx = 0; idx < interfaces.length; idx++) {
			System.out.println(""[""+idx+""]"" + interfaces[idx][0]);
			for (int i = 1; i < interfaces[idx].length; i++)
				m.put(interfaces[idx][i], interfaces[idx][i]);
		}
		Class[] d = new Class<?>[] {};
		System.out.println("""" + m);
		m.keySet().toString(); // toString():
		for (int i = 0; i < interfaces.length; i++) {
			System.out.println(""[""+i+""]"" + interfaces[i][0]);
			for (int j = 0; j < interfaces[i].length; j++)
				if (i!= j)
					System.out.println(""[""+j+"",""+interfaces[i][j]+""]"" + interfaces[i][j]);
		}
		System.out.println(m);
		Class classForJST = getClass(m.get(d[0]));
		System.out.println("""" + classForJST);
		String[] names = m.keySet().toString().split("","");
		for (int i = 0; i < names.length; i++) {
			System.out.println("""" + names[i]);
		}
	}

		public static void main(String[] args) {
			test(""java.lang.Object"", ""Object"");
			Class[] inter = ClassInfo.class.getInterfaces();
			while (inter!= null) {
				test(""com.jstevh.viewer.ClassInfo$Test$TestClassInfo$TestC1"", ""This class does not implement TestClassInfo$Test."");

				System.out.println("""" + inter);
				test(""com.jstevh.viewer.ClassInfo_4Test$TestClassInfo$TestC1"", ""I'm a test class!"");

				test(""com.jstevh.viewer.ClassInfo"", ""I'm a test class! I don't understand."");

				test(""com.jstevh.viewer.ClassInfo.TestClassInfo"", ""This is a public class."");
				test(""com.jstevh.viewer.ClassInfo$TestClassInfo"", ""This is a public class!"");
				test(""com.jstevh.viewer.ClassInfo.TestClassInfo$TestClassInfo"", ""This is a public class!"");
				test(""com.jstevh.viewer.ClassInfo$TestClassInfo"", ""This is a public class!"");
				test(""com.jstevh.viewer.ClassInfo$TestClassInfo.TestClassInfo"", ""This is a public class!"");

				System.out.println(test(""com.jstevh.viewer.ClassInfo"", ""This is a public class.""));
						//public void printInterfaces() {
						//System.out.println(interfaces.length);
						//int idx = 0;
						//for (Object o: interfaces)
						//	System.out.println(""[interface ""+idx+""]""+o);
						//}


				System.out.println(test(""com.jstevh.viewer.ClassInfo.TestClassInfo"", ""This is a public class!""));
				Class[] c = ClassInfo.class.getInterfaces();
				test(""com.jstevh.viewer.Class"
7dd52b3e-dc8b-4a42-bec5-bd91a91e4399,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_5Test.java,57.72285604476929,length,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param m array of Member objects
     * @return string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }
}
","// ClassInfo_5Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {","// ClassInfo_5Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {
/**
		 * Checks the class info works.
		 */
		@Test
		public void CheckGetData() {
			assertNotNull(new ClassInfo().getData(new Member[0]));
		}
} /* ClassInfo_5Test */

// ClassInfo_6Test.java
package com.jstevh.viewer;

import java.util.*;
import java.net.URL;
import java.io.IOException;
import javax.swing.JPanel;

import com.jsterlang.compiler.CompiledClass;
import com.sun.jdi.*;
import javax.swing.border.AbstractBorder;

public class ClassInfo_6 extends JPanel {
	public interface ClassInfo extends Comparable<ClassInfo> {
		public int getNameCount();
		public Enumeration<String> getNames();
	}
	public static class Class1 implements ClassInfo {
		public int getNameCount() { return 0; }
		public Enumeration<String> getNames() { return null; }
		public Map<String, Object> getFields() { return null; }
	}
	private static final long serialVersionUID = 1L;
	
	/**
	 * The fields of the class info are collected.
	 */
	private static Map<String, ClassInfo> FieldMap = new HashMap<>();
	private Map<String, ClassInfo> Fields = new HashMap<>();

	/**
	 * Constructor used to construct class info from the string.
	 * 
	 * @param args String describing the class that is going to get the fields
	 */
	public ClassInfo_6(final String args) {
		final Field[] fields = null;
		try {
			Enumeration<?> enumeration = ClassLoader.getSystemClassLoader().getResources(""jstest/com/jstevh/viewer/TestClasses.class"");
			while (enumeration.hasMoreElements()) {
				URL url = (URL) enumeration.nextElement();
				URLClassLoader classLoader =  new URLClassLoader(new URL[]{url});
				JarEntry entry = classLoader.findEntries(System.class.getPackage().getName(), ""TestClasses.class"", (String[]) null)[0];
				try {
					Enumeration<?> enumFields = classLoader.entries(entry.getName());
					while (enumFields.hasMoreElements()) {
						Enumeration<String> fieldEnum = enumFields.nextElement().getName().split("";"");
						FieldInfo[] fieldInfos = new FieldInfo[fieldEnum.count()];
						for (int i = 0; i < fieldEnum.count(); i++) {
							fieldInfos[i] = new FieldInfo(fieldEnum.nextElement(), fieldEnum.nextElement());
						}
						setFields(fieldInfos);
					}
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
		} catch (SecurityException e) {
			throw new RuntimeException(e);
		}
		ClassInfo classInfo = null;
		try {
			ClassLoader classLoader =  new URLClassLoader(new URL[]{url});
			Class<?> clazz0 = classLoader.loadClass(""TestClasses"");
			try {
				classInfo = (ClassInfo) clazz0.newInstance();
			} catch (InstantiationException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			}
			classCount++;
		} catch (ClassNotFoundException e) {
	        e.printStackTrace();
		}
		if (classInfo!= null) {
			FieldMap.put(classInfo.getName() + ""_"" + classInfo.getFields().size(), classInfo);
			ClassInfo c = classInfo;
			Fields.put(c.getName(), c);
		}
	}
	
	/**
	 * Gets the class count. This info is required by the
	 * {@link ClassInfo#getData(Member[])} method.
	 * 
	 * @return int the count of class
	 */
	int classCount;
	/**
	 * A map where the keys indicate field names and the values are
	 * the respective field's objects as well as the class being
	 * examined. 
	 */
	private final Map<String, ClassInfo> FieldMap = new HashMap<>();
	private final Map<String, ClassInfo> Fields = new HashMap<>();
	/**
	 * Construct class info from enumeration of the given className.
	 * 
	 * @param name string describing the class to get
	 * @exception IOException when getting the field of the enumerated class fails
	 */
	public ClassInfo_6(final String name) throws IOException {
		try {
			ClassReader reader = new ClassReader(this.getClass().getClassLoader().getResourceAsStream(name));
			ClassInfo classInfo = new ClassInfo(reader);
			this.FieldMap.put(classInfo.getName(), classInfo);
			Enumeration<?> enumeration2 = classInfo.getNames();
			while (enumeration2.hasMoreElements()) {
				FieldInfo fieldInfo = new FieldInfo(enumeration2.nextElement(), this.FieldMap.get(classInfo.getName() + ""_"" + enumeration2.nextElement().toString()));
				getFields().add(fieldInfo);
				this.Fields.put(fieldInfo.getName(), fieldInfo);
			}
			this.classCount++;
		} catch (ClassNotFoundException e) {
			throw new IOException(e);
		}
	}
	
	/**
	 * Get the class info from the given field. 
	 * 
	 * @param field the given field to get
	 * @exception IOException when getting the field from the enumeration fails
	 */
	public ClassInfo getClassInfo(final Field field) throws IOException {
		return FieldMap.get(field.getName());
	}
	
	/**
	 * Get the class info from the given field. 
	 *
	 * @param field the given field to get
	 * @exception IOException when getting the field from the enumeration fails
	 */
	public ClassInfo getClassInfo(final String fieldName) throws IOException {
		return this.Fields.get(fieldName);
	}
	
	/**
	 * Gets all the field names currently defined. 
	 *
	 * @return Set<String> a string collection of all field names
	 * @exception IOException when getting the field names from"
eb534190-d767-4b55-ac06-2b2c8971c48c,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_6Test.java,57.70858573913574,length,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param m array of Class objects
     * @return string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }
}
","// ClassInfo_6Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {","// ClassInfo_6Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {
// ArrayLengthTest.java
		/**
		 * GetDataTest.java
		 * <p>
		 * Tests the ArrayLength constructor of a ClassInfo class.
		*/
		@Test
		public void ArrayLengthTest() {
			Class[] m = new Class[]{
				ArrayList.class
			};
			ClassInfo jvmObj = new ClassInfo(m);
			assertEquals(new Integer(m.length).intValue(), jvmObj.getData(m).length);
		}
}


// DataViewTest.java

/**
 * Returns test data for {@link ClassInfo}.
 * In the past, this class had a lot of data that was not a reference to the ClassInfo class
 * and was just used to test the default constructor. This class just keeps data that does not
 * need it. That's probably not desirable, but this means that some people
 * will want to run the tests with this because they can create an object of its own.
 */
class DataViewTest extends JFrame {

	private JPanel basePane;
	private AbstractButton searchButton;
	private JList classList;
	private JScrollPane scrollPane;

	public DataViewTest(String aClassName) {
		setTitle(""test ""+ aClassName);
		addClassToTest(aClassName);
	}

	/**
	 * Test the getData(Class[] ) method of a class that has one method. This method is to
	 * check for different implementations of Class. For a given Class object, the
	 * {@link ClassInfo#getData(Class[])} method returns a string array of names. This
	 * string array just contains the name of the method. It is expected that the names
	 * in the getData(Class[] ) are in the following order:
	 * <ol>
	 * <li><em>the name of the class name (e.g., foo.bar)</em></li>
	 * <li><em>name of the constructor of the class</em></li>
	 * <li><em>the name of the class' constructor</em></li>
	 * <li><em>the name of the class' field</em></li>
	 * <li><em>the name of the class' data</em></li>
	 * </ol>
	 */
	private void testGetData(Class[] m) {
		String name, data;
		for (int count = 0; count < m.length; count++) {
			name = m[count].getName();
			String method = name.substring(0, name.indexOf("".""));
			data = m[count].getDeclaredMethod(method).invoke(null).toString();
			assertTrue(name, name.equals(data.trim()));
		}
	}

	/**
	 * Return the first name of a class that is public.
	 */
	public final void addClassToTest(String aClassName) {
		final Class clazz = Class.forName(className);
		ClassInfo classInfo = (ClassInfo) clazz.newInstance();
		classList.setListData(classList.getModel().toArray());
		new Thread(new Runnable() {
			public void run() {
				basePane = new JPanel();
				JButton searchButton = new JButton(""Search Class..."");
				searchButton.addActionListener(null);
				searchButton.setOpaque(false);
				searchButton.setEnabled(false);
				basePane.setLayout(new BoxLayout(basePane, BoxLayout.LINE_AXIS));
				basePane.add(searchButton);
				JPanel dataPane = new JPanel();
				basePane.add(dataPane);
				JList classDataList = new JList();
				classDataList.setCellRenderer(new ClassDataRenderer());
				templateList = new JList();
				classDataList.setVisibleRowCount(10);
				for (int count = 0; count < classList.getModel().size(); count++) {
					Class currentClass = (Class) classList.getModel().getElementAt(count);
					classDataList.setListData(
							new ClassInfo[currentClass.getSuperclass().getInterfaces().length+1]);
					if (count == 0) {
						dataPane.setOpaque(false);
					} else {
						dataPane.setOpaque(true);
					}
					dataPane.add(new JLabel(""""));
					dataPane.add(classInfo.getData(currentClass.getInterfaces()));
					templateList.setListData(currentClass.getClassData().getClassData());
					dataPane.add(new JLabel(""""));
					dataPane.add(classDataList);
					templateList.addListData(new ParameterizedDataInfo[""classDataList""]);
					classDataList.setSelectedIndex(count);
				}
				scrollPane = new JScrollPane(templateList);
				scrollPane.setMaximumSize(new Dimension(300, 300));
				scrollPane.setOpaque(false);
				scrollPane.setViewportBorder(new EmptyBorder(3, 3, 3, 3));
				basePane.add(scrollPane);
				searchButton.setText("" Search Class..."");
				searchButton.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
			}
		}).start();
	}

	/**
	 * Shows the class details.
	 */
	public final void showDisplay() {
		basePane.removeAll();
		JPanel dataPanel = new JPanel();
		JPanel header = new JPanel();
		JPanel headerLabel = new JPanel();
		JPanel buttons = new JPanel();
		headerLabel.setLayout(new BorderLayout());
		headerLabel.setLayout(new GridBagLayout());
		headerLabel.add(displayArea, BorderLayout.CENTER);
		header.add(headerLabel);
		headerPanel = new JPanel();
		headerPanel.setLayout(new GridLayout(3, 2));
		JPanel headerPanelContents = new JPanel();
		templateList = new JList();
		templateList.setOpaque(false);
		templateList.setCellRenderer(new TemplateListRenderer());
		headerPanelContents.setLayout(new BoxLayout(headerPanelContents, BoxLayout.PAGE_AXIS));
		headerPanelContents.setOpaque(false);
		headerPanelContents.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		showClassInfo(null);
		templateList.setSelectedIndex(0);
		header"
03a699d5-bd0d-4c6b-aba6-88c3f8ba413e,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_7Test.java,56.77112293243408,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param tempStr string fragment with which to search
     * @return string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }
}
","// ClassInfo_7Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {","// ClassInfo_7Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {
// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param tempStr string fragment with which to search
     * @return string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods!= null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }
}

// ClassInfo_7Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {
		/**
		 * Provides a list of public constructors from the superClass object.
		 * It also provides a list of method names (if any) that are not
		 * public.
		 *
		 * @param superClass superClass object for the list of methods
		 * @return The methods and constructors for the class
		 */
		public List cMethods(Class superClass) {
			List methods = new ArrayList();
                        Class cClass = superClass;
			while (cClass!= null) {
                               	List methods2 = new ArrayList();
                               	for (int it = 0; it < superClass.getDeclaredConstructors().length; it ++) {
                                		cConstructor_7(superClass.getDeclaredConstructors()[it], it, methods);
                                	}
                                	cClass = cClass.getSuperclass();
                                }
			return methods;
		}

       private void cConstructor_7(Constructor cConstructor, int itCmp, List methods) {
                        Object[] theMethods = methods.toArray();
                        for (Object method : theMethods) {
                                if ((method instanceof Method)) {
                                        Method m = (Method) method;
                                        Class[] argumentTypes = m.getParameterTypes();
                                        if (argumentTypes.length == 1) {
                                                String theArgumentName = ((Parameter) m.getParameter(0)).getName();
                                                if (methodSigEquals(theArgumentName, itCmp, cConstructor))
                                                {
                                                        int iReturn = cConstructor.invoke(cClass, new Object[] {itCmp}, the);
                                                        Object returnMe = m.invoke(itCmp, null);
                                                        assertTrue(""The value of the first return argument is correct."", (returnMe instanceof Boolean) && (((Boolean)returnMe).booleanValue() == true));
                                                }
                                        }
                                } else if (method instanceof Field) {
                                        Field m = (Field) method;
                                        Class[] argumentTypes = m.getParameterTypes();
                                        if (argumentTypes.length == 1) {
                                                String theArgumentName = ((Parameter) m.getParameter(0)).getName();
                                                if (methodSigEquals(theArgumentName, itCmp, cConstructor))
                                                {
                                                        Object returnMe = m.get(itCmp, null);
                                                        if (returnMe instanceof Boolean) {
                                                                  boolean bVal = ((Boolean)returnMe).booleanValue();
                                                                  if (getBoolean(bVal, itCmp, cConstructor))
                                                                  {
                                                                         int iResult = cConstructor.invoke(cClass, new Object[] {itCmp}, the);
                                                                         Object returnMe2 = m.get(itCmp, itCmp);
                                                                         assertTrue(""The value of the second return argument is correct."", (returnMe2 instanceof Boolean) && (((Boolean)returnMe2).booleanValue() == true));
                                                                  }
                                                        } else {
                                                                  assertFalse(""The value of the second return argument is incorrect"", bVal);
                                                                  System.err.println(""Could not interpret as boolean"");
                                                        }
                                                }
                                        }
                                }
                        }
		}
}
"
f67af4a7-1306-4cda-991e-6131ca2f65ff,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_8Test.java,49.06888127326965,stop,"// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param pos position of found methods in array 0 is first.
     * @return MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }
}
","// ClassInfo_8Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_8Test {","// ClassInfo_8Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_8Test {
// ClassInfo.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author James Harris
 * @version 2.0a
 */
public class ClassInfo {

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param pos position of found methods in array 0 is first.
     * @return MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage()!= null? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }
}

// ClassInfo_8Test.java
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains one unit test case for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_8Test {
		private final static ClassInfo[] CLASS = new ClassInfo[4];
		private final static int[] METHOD = {0, 1, 2, 3};
		static {
			for (int i = 0; i < 4; i++)
				CLASS[i] = new ClassInfo();
		}
		private final static int INNER = 0;
		private final static int FIELD = 1;
		private final static int OUTER = 2;
	
		@Test
		void test1() {
			
			assertNotNull(CLASS);  // test null class  should throw NPE
			for (ClassInfo ci : CLASS) {
				assertNotNull(ci);
				assertNotNull(ci.getFoundMethod());
				
				if (ci.getMethClass().equals(""ClassInfo"")) {
                    Object v = ci.getFoundMethod(0);
					System.out.println(""C1 = "" + v);
					
				} else if (ci.getMethClass().equals(""MethodInfo"")) {
                    Object v = ci.getFoundMethod(0);
					System.out.println(""C1 = "" + v);
					
				} else if (ci.getMethClass().equals(""OuterClass"")) {
                    Object v = ci.getFoundMethod(0);
					System.out.println(""C1 = "" + v);
					
				}
				System.out.println(""CInfo = "" + ci);
			}
		}
}
"
