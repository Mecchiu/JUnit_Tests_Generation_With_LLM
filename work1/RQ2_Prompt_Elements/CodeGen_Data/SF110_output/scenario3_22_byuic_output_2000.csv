ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
39b9e7b9-f799-47b4-85c6-fcd45a2b177f,/EvoSuiteBenchmark/original/22_byuic/src/main/java/org/mozilla/javascript/Decompiler.java,51.7001314163208,stop,"// Decompiler.java
package org.mozilla.javascript;

/**
 * The following class save decompilation information about the source.
 * Source information is returned from the parser as a String
 * associated with function nodes and with the toplevel script.  When
 * saved in the constant pool of a class, this string will be UTF-8
 * encoded, and token values will occupy a single byte.
 *
 * Source is saved (mostly) as token numbers.  The tokens saved pretty
 * much correspond to the token stream of a 'canonical' representation
 * of the input program, as directed by the parser.  (There were a few
 * cases where tokens could have been left out where decompiler could
 * easily reconstruct them, but I left them in for clarity).  (I also
 * looked adding source collection to TokenStream instead, where I
 * could have limited the changes to a few lines in getToken... but
 * this wouldn't have saved any space in the resulting source
 * representation, and would have meant that I'd have to duplicate
 * parser logic in the decompiler to disambiguate situations where
 * newlines are important.)  The function decompile expands the
 * tokens back into their string representations, using simple
 * lookahead to correct spacing and indentation.
 *
 * Assignments are saved as two-token pairs (Token.ASSIGN, op). Number tokens
 * are stored inline, as a NUMBER token, a character representing the type, and
 * either 1 or 4 characters representing the bit-encoding of the number.  String
 * types NAME, STRING and OBJECT are currently stored as a token type,
 * followed by a character giving the length of the string (assumed to
 * be less than 2^16), followed by the characters of the string
 * inlined into the source string.  Changing this to some reference to
 * to the string in the compiled class' constant pool would probably
 * save a lot of space... but would require some method of deriving
 * the final constant pool entry from information available at parse
 * time.
 */
public class Decompiler {

    /**
     * Decompile the source information associated with this js
     * function/script back into a string.  For the most part, this
     * just means translating tokens back to their string
     * representations; there's a little bit of lookahead logic to
     * decide the proper spacing/indentation.  Most of the work in
     * mapping the original source to the prettyprinted decompiled
     * version is done by the parser.
     *
     * @param source encoded source tree presentation
     * @param flags flags to select output format
     * @param properties indentation properties
     */
    public static String decompile(String source, int flags, UintMap properties);
}
","// DecompilerTest.java
package org.mozilla.javascript;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Decompiler}.
* It contains one unit test case for the {@link Decompiler#decompile(String, int, UintMap)} method.
*/
class DecompilerTest {","// DecompilerTest.java
package org.mozilla.javascript;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Decompiler}.
* It contains one unit test case for the {@link Decompiler#decompile(String, int, UintMap)} method.
*/
class DecompilerTest {

	final Decompiler d = new Decompiler();
	
    @Test
    public void testDecompile_SingleString() {
    	String src = ""abc"";
    	int i = 0;
    	String expected = ""'abc"" + i;
    	assertEquals(expected, d.decompile(src, DECODED_FLAGS, UintMap.EMPTY));
    }
    
    @Test
    public void testDecompile_ManyString() {
    	// Tests that when the source string is a huge, and huge amount of bits, 
    	// the output will be a single byte. This case would require 3 steps (the first to see
    	// the right spacing, then to the token sequence of the string, and then to the
    	// characters in the string
        String src = ""abc"" + new char[100000];
        String[] expected = {
        	""\""abc\"" + 1"",
                ""\""abc\"" += 2"",
                ""\\"" + ""c""
        };

        // This is not very efficient, but it's close enough to improve the 
        // speed of the string comparison.
        int expectedSize = src.length();
        int srcSize = expectedSize * 3;

        // First test the size of the last character before the next character.
        assertEquals(""Incorrect last character"", srcSize, d.decompile(src).length());

        // Then test the next two characters. The next character will be a backslash.
        expectedSize--; // Skip the character before the next one (the last one)
        expectedSize--; // Make the last one the same.
        assertEquals(""Incorrect next character"", expectedSize, expectedSize);

        // Finally test that the actual decomposition is in fact 1 or 4 bytes.
        assertEquals(""Incorrect next character"", 4, expectedSize);
    }
}
"
