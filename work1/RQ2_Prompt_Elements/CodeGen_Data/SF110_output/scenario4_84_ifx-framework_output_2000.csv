ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
4f05de07-d5b1-4ef1-9c5a-603967e45e93,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_0Test.java,37.415719985961914,length,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    private String packageName = null;

    private String classJavadocs = null;

    private String className = null;

    private String superClass = null;

    private String interfaceName = null;

    private List memberVariables = new ArrayList();

    private boolean hasSuperClass = false;

    private boolean isInterface = false;

    /**
     * Returns the package name for the class.
     * @return the package name for the class.
     */
    public String getPackageName();

    /**
     * Allows setting the package name for the class.
     * @param packageName the package name to set.
     */
    public void setPackageName(String packageName);

    /**
     * Returns the class javadocs for this class.
     * @return the class javadocs for this class.
     */
    public String getClassJavadocs();

    /**
     * Allows setting the class javadocs for this class.
     * @param classJavadocs the class level javadocs to set.
     */
    public void setClassJavadocs(String classJavadocs);

    /**
     * Returns the class name.
     * @return the class name.
     */
    public String getClassName();

    /**
     * Sets the class name.
     * @param className the class name.
     */
    public void setClassName(String className);

    /**
     * Gets the superclass name for this class.
     * @return the superclass for this class.
     */
    public String getSuperClass();

    /**
     * Sets the superclass name if applicable.
     * @param superClass the super class name to set.
     */
    public void setSuperClass(String superClass);

    /**
     * Gets the fully qualified interface for this class if specified,
     * @return the interface name for this class.
     */
    public String getInterface();

    /**
     * Sets the fully qualified interface name for this class.
     * @param interfaceName the fully qualified interface name for this class.
     */
    public void setInterface(String interfaceName);

    /**
     * Returns a list of member variable objects in this class.
     * @return a list of member variable objects in this class.
     */
    public List getMemberVariables();

    /**
     * Returns the number of member variables for this class.
     * @return the number of member variables.
     */
    public int getNumberOfMemberVariables();

    /**
     * Adds a new member variable object for the class. Deduces a variable
     * name from the class name.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarClass, boolean isArray);

    /**
     * Adds a new member variable for the class.
     * @param mVarName the name of the member variable.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarName, String mVarClass, boolean isArray);

    /**
     * Convenience methods since velocity does not understand the conditional
     * ""== null"". Returns true if this class implements an interface.
     * @return true if this class implements an interface else false.
     */
    public boolean hasInterface();

    /**
     * Convenience method since velocity does not understand the conditional
     * ""== null"". Returns true if this class inherits from a superclass.
     * @return true if this class has a superclass, else false.
     */
    public boolean hasSuperClass();
}
","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {
private final String TEST_CLASS_NAME = ""javaclassesrc.TestSuperclass"";

        /**
         * @return the String package name to be used to initialize this class.
         */
        String getPackageName() {
            return packageName;
        }

        /**
         * Sets the String package name to initialize this class.
         * @param packageName the String package name to set.
         */
        void setPackageName(String packageName) {
            this.packageName = packageName;
        }

		/**
		 * Tests whether the JavaSource class has the proper
		 * signature for an interface.
		 */
        @Test
        void hasInterface_01() {
			JavaSource source = new JavaSource();
			assertArrayEquals(new String[] {
					TEST_CLASS_NAME
			}, source.extractClassName(source.getClassSource()));
		}

		/**
		 * Unit test of {@link JavaSource#hasInterface()}.
		 * @throws InitializationException is thrown if test is not
		 *     implemented correctly.
		 */
        @Test
        void hasInterface_02() {
			String classname = getClass().getName().substring(getClass().getName().lastIndexOf('.') + 1);
		}

		/**
		 * Unit test of {@link JavaSource#extractClassName()}.
		 * @throws InitializationException is thrown if test is not
		 *     implemented correctly.
		 */
        @Test
        void extractClassName_01() {
			ArrayList<String> list = new ArrayList();
			list.add(TEST_CLASS_NAME);
		}

		/**
		 * Unit test of {@link JavaSource#extractClassName()}.
		 * @throws InitializationException is thrown if test is not
		 *     implemented correctly.
		 */
        @Test
        void extractClassName_02() {
			@SuppressWarnings(""unused"")
			ArrayList<String> list = new ArrayList();
		}

		/**
		 * Unit test of {@link JavaSource#extractMemberVariableNames()}.
		 * @throws InitializationException is thrown if test is not
		 *     implemented correctly.
		 */
        @Test
        void extractMemberVariableNames_01() {
			ArrayList<String> list = new ArrayList();
			list.add(""a"");
		}

		/**
		 * Unit test of {@link JavaSource#extractMemberVariableNames()}.
		 * @throws InitializationException is thrown if test is not
		 *     implemented correctly.
		 */
        @Test
        void extractMemberVariableNames_02() {
			ArrayList<String> list = new ArrayList();
			list.add(""a"");
		}

		/**
		 * Unit test of {@link JavaSource#extractMemberVariableNames()}.
		 * @throws InitializationException is thrown if test is not
		 *     implemented correctly.
		 */
        @Test
        void extractMemberVariableNames_03() {
			ArrayList<String> list = new ArrayList();

			// adds a new member variable with type String because it is the superclass name
			list.add(""stringarray"");
			list.add(""stringArray"");
			list.add(""a"");
		}

		private JavaSource() {
		}

		private String getClassName() {
			return TEST_CLASS_NAME;
		}
		
		private String getMemberVariableNames() {
			String stringlist = ""stringarray"", stringarray = ""stringArray"";
			return new StringBuilder().append(stringarray).append("", "").append(stringlist).append(""Array"").toString();
		}

		private String getNumberOfMemberVariableNames() {
			return Integer"
2934daf4-8364-4603-bc35-964eb51a920a,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_1Test.java,37.314244508743286,stop,"// JavaSource.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    private String packageName = null;

    private String classJavadocs = null;

    private String className = null;

    private String superClass = null;

    private String interfaceName = null;

    private List memberVariables = new ArrayList();

    private boolean hasSuperClass = false;

    private boolean isInterface = false;

    /**
     * Returns the package name for the class.
     * @return the package name for the class.
     */
    public String getPackageName();

    /**
     * Allows setting the package name for the class.
     * @param packageName the package name to set.
     */
    public void setPackageName(String packageName);

    /**
     * Returns the class javadocs for this class.
     * @return the class javadocs for this class.
     */
    public String getClassJavadocs();

    /**
     * Allows setting the class javadocs for this class.
     * @param classJavadocs the class level javadocs to set.
     */
    public void setClassJavadocs(String classJavadocs);

    /**
     * Returns the class name.
     * @return the class name.
     */
    public String getClassName();

    /**
     * Sets the class name.
     * @param className the class name.
     */
    public void setClassName(String className);

    /**
     * Gets the superclass name for this class.
     * @return the superclass for this class.
     */
    public String getSuperClass();

    /**
     * Sets the superclass name if applicable.
     * @param superClass the super class name to set.
     */
    public void setSuperClass(String superClass);

    /**
     * Gets the fully qualified interface for this class if specified,
     * @return the interface name for this class.
     */
    public String getInterface();

    /**
     * Sets the fully qualified interface name for this class.
     * @param interfaceName the fully qualified interface name for this class.
     */
    public void setInterface(String interfaceName);

    /**
     * Returns a list of member variable objects in this class.
     * @return a list of member variable objects in this class.
     */
    public List getMemberVariables();

    /**
     * Returns the number of member variables for this class.
     * @return the number of member variables.
     */
    public int getNumberOfMemberVariables();

    /**
     * Adds a new member variable object for the class. Deduces a variable
     * name from the class name.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarClass, boolean isArray);

    /**
     * Adds a new member variable for the class.
     * @param mVarName the name of the member variable.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarName, String mVarClass, boolean isArray);

    /**
     * Convenience methods since velocity does not understand the conditional
     * ""== null"". Returns true if this class implements an interface.
     * @return true if this class implements an interface else false.
     */
    public boolean hasInterface();

    /**
     * Convenience method since velocity does not understand the conditional
     * ""== null"". Returns true if this class inherits from a superclass.
     * @return true if this class has a superclass, else false.
     */
    public boolean hasSuperClass();
}
","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains one unit test case for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {

	@Test
	public void testHasSuperClass() {
		JavaSource javaSource = new JavaSource();
		assertFalse(""Has a superclass"", javaSource.hasSuperClass());
		javaSource.addMemberVariable(""iHasSuper"", true);
		assertTrue(""Has a superclass"", javaSource.hasSuperClass());
		Iterator<String> iter = javaSource.getMemberVariables();
		while (iter.hasNext()) {
			String result = iter.next();
			assertEquals(new Integer(50), result);
		}
	}
	



}"
944274fc-e6bd-4530-925e-3b7edfe0ceef,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDecoder.java,45.19010329246521,stop,"// IFXDecoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;

/**
 * Decodes an IFX XML String to its equivalent Framework bean.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXDecoder {

    private ResourceBundle bundle;

    /**
     * Creates an IFXDecoder object.
     */
    public IFXDecoder() {
    }

    /**
     * Decodes the element into its equivalent IFX XML representation.
     * @param element the Element to decode.
     * @return an IFXObject.
     * @exception IFXException wrapper for underlying exception.
     */
    public IFXObject decode(Element element) throws IFXException;

    /**
     * Returns a single setXXX Method object corresponding to the IFXObject
     * and childElement.
     * @param obj the IFXObject.
     * @param childElement the element corresponding to the mutator method.
     * @return a setXXX method object.
     * @exception IFXException if there was a problem getting the mutators.
     */
    private Method getMutator(IFXObject obj, Element childElement) throws IFXException;

    /**
     * Returns a single setXXX Method object corresponding to the IFXObject
     * and childElement name.
     * @param obj the IFXObject.
     * @param childElementName the element name for the mutator method.
     * @return a setXXX method object.
     * @exception IFXException if there was a problem getting the mutators.
     */
    private Method getMutator(IFXObject obj, String elementName) throws IFXException;

    /**
     * Returns the accessor method associated with the given element name.
     * @param obj an IFXObject.
     * @param element the element object.
     * @return a getXXX Method object associated with the element.
     * @exception IFXException wraps the original exception thrown.
     */
    private Method getAccessor(IFXObject obj, Element element) throws IFXException;

    /**
     * Returns the element name from a bean name.
     * @param element the Element representing the bean.
     * @return the element name.
     * @exception IFXException if bean class name could not be found.
     */
    private String getBeanClassName(Element element) throws IFXException;
}
","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains one unit test case for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {
/**
		 * Initializes test.
		 * @throws IFXException wrapped by IFXException.
		 */
	@Test
	void initialize() throws IFXException {
		IFXDecoderIF.init(new IFXDecoder());
	}

	/**
	 * Tests the handling of a setXXX method.
	 * @throws IFXException wrapping the original exception thrown.
	 */
	@Test
	void decodeSetXXX() throws IFXException {
		Element element = bundle.getString(""beanWithSetXXX"");
		Element element2 = bundle.getString(""beanWithSetXXX"");
		IFXObject obj = IFXDecoder.decode(element);
		IFXObject obj2 = IFXDecoder.decode(element2);
		assertEquals(obj, obj2);
	}

	/**
	 * Tests the handling of a listXXX method.
	 * @throws IFXException wrapping the original exception thrown.
	 */
	@Test
	void decodeListXXX() throws IFXException {
		Element element = bundle.getString(""beanWithListXXX"");
		Element element2 = bundle.getString(""beanWithListXXX"");
		IFXObject obj = IFXDecoder.decode(element);
		IFXObject obj2 = IFXDecoder.decode(element2);
		assertEquals(obj, obj2);
	}

	/**
	 * Tests the handling of a listXXX method with parameters.
	 * @throws IFXException wrapping the original exception thrown.
	 */
	@Test
	void decodeListXXXWithParameters() throws IFXException {
		Element element = bundle.getString(""beanWithListXXX-Parameters"");
		Element element2 = bundle.getString(""beanWithListXXX-Parameters"");
		IFXObject obj = IFXDecoder.decode(element);
		IFXObject obj2 = IFXDecoder.decode(element2);
		assertEquals(obj, obj2);
	}

	/**
	 * Tests the handling of a setXXX method with parameters.
	 * @throws IFXException wrapping the original exception thrown.
	 */
	@Test
	void decodeSetXXXWithParameters() throws IFXException {
		Element element = bundle.getString(""beanWithSetXXX-Parameters"");
		Element element2 = bundle.getString(""beanWithSetXXX-Parameters"");
		IFXObject obj1 = IFXDecoder.decode(element);
		IFXObject obj2 = IFXDecoder.decode(element2);
		assertEquals(obj1, obj2);
	}

	/**
	 * Tests the handling of an element associated with an IFXObject with a setXXX method.
	 * @throws IFXException wrapping the original exception thrown.
	 */
	@Test
	void decodeElementWithSetXXXMethod() throws IFXException {
		Element element = bundle.getString(""myBeanElementWithSetXXXMethod"");
		Element element2 = bundle.getString(""myBeanElementWithSetXXXMethod"");
		IFXObject obj = IFXDecoder.decode(element);
		IFXObject obj2 = IFXDecoder.decode(element2);
		assertEquals(obj, obj2);
	}

	/**
	 * Tests the handling of an element associated with an IFXObject with a setXXX method
	 * @throws IFXException if element name cannot be found.
	 */
	@Test
	void decodeElementWithSetXXXMethodMissing() throws IFXException {
		Element element = bundle.getString(""myBeanElementWithSetXXXReturnTypeMethod"");
		Element element2 = bundle.getString(""myBeanElementWithSetXXXReturnTypeMethod"");
		IFXObject obj = IFXDecoder.decode(element);
		IFXObject obj2 = IFXDecoder.decode(element2);
		assertNull(obj);
		assertNull(obj2);
	}


	/**
	 * Tests the handling of a list object to a setXXX method.
	 * @throws IFXException wrapping the original exception thrown.
	 */
	@Test
	void decodeListOfObjectsWithSetXXXMethod() throws IFXException {
		IFXObject obj1 = IFXDecoder.decode(bundle.getString(""myBean""), IFXObject.class);
		IFXObject obj = IFXDecoder.decode(bundle.getString(""myBean""));
		assertEquals(obj, obj1);
	}

	private ResourceBundle bundle;
}"
467ec1a3-1dca-4ec4-9911-62311c71a065,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXEncoder.java,35.7885308265686,length,"// IFXEncoder.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;

/**
 * Encodes an IFXObject to its equivalent IFX XML Element.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXEncoder {

    private ResourceBundle bundle;

    private int xmlIndentSize = 2;

    private String lineSeparator = System.getProperty(""line.separator"");

    private Namespace namespace = Namespace.NO_NAMESPACE;

    /**
     * Creates an IFXEncoder object in the default namespace.
     */
    public IFXEncoder() {
    }

    /**
     * Creates an IFXEncoder in the specified namespace.
     * @param namespacePrefix the namespace prefix to use. If set to null,
     * then the element will be considered to be in the default namespace.
     * @param namespaceURI the URI of the namespace.
     */
    public IFXEncoder(String namespacePrefix, String namespaceURI) {
    }

    /**
     * Builds a JDOM Element for the IFXObject supplied. No validation is
     * performed, regardless of the setting. To validate, use the encode()
     * methods instead.
     * @param obj an IFXObject.
     * @return a JDOM Element.
     * @exception IFXException if an exception was encountered in encoding.
     */
    public Element encode(IFXObject obj) throws IFXException;

    /**
     * Sets the name space for this Document.
     * @param prefix the namespace prefix to use. If null, this namespace
     * will be set to the default namespace.
     * @param nameSpaceURI the String URI of this namespace.
     */
    private void setNamespace(String prefix, String nameSpaceURI);

    /**
     * Return a List of accessor methods for a given IFXObject. The
     * accessors will be ordered in the same order expected by the IFX
     * schema. This ordering is dictated by the ELEMENTS String[] variable.
     * @param obj an IFXObject.
     * @return a List of getXXX Method objects.
     * @exception IFXException wraps the original exception thrown.
     */
    private List getAccessors(IFXObject obj) throws IFXException;

    /**
     * Gets the element name from the object class name. It retrieves the
     * class name portion from the fully qualified class name for the bean,
     * then applies transformations to convert back to dotted form for
     * certain elements.
     * @param obj an IFXObject.
     * @return the name of the element that is represented by this object.
     * @exception IFXException if element name was not found.
     */
    private String getElementName(IFXObject obj) throws IFXException;
}
","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains one unit test case for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains one unit test case for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {

	/**
	 * Encodes an IFXObject to an xml element.
	 * @param obj an Object to convert
	 * @return the encoded XML Element representation of the provided object.
	 * @exception IOException if an error occured saving the output buffer.
	 * @exception IFXException wrapped by other exceptions.
	*/
	private Element encode(IFXObject obj) throws IOException, IFXException {
		return encode(obj, null);
	}

	/**
	 * Encodes anIFXObject to an xml element.
	 * @param obj an object to convert.
	 * @return the generated xml element representation of the provided object.
	 * @exception IOException if an error occured saving the output buffer.
	 * @exception IFXException wrapped by other exceptions.
	*/
	private Element encode(IFXObject obj, HashMap<String, String> map) throws IOException, IFXException {

		Class<?> javaClass = obj.getClass();
		Element newElement = new Element(""IFX"");

		if(javaClass.getName().equals(""java.lang.String"")) {
			javaClass = String.class;
		}
		newElement.setAttribute(""name"", javaClass.getName());

		List<Element> elementList = new ArrayList<>();

	    if(map!= null) {
			Map<String,String> attributeMap = new HashMap<>();

			for(String key : map.keySet()) {
				attributeMap.put(key, map.get(key));
			}

			if(!attributeMap.isEmpty()) {
				newElement.setAttributes(attributeMap);
			}
		}

		for(Class<?> cls : getAccessors(obj)) {
			newElement.addContent(cls.newInstance().encode(obj));
		}
		for(Class<IFXObject> rtcls : javaClass.getClasses()) {
			newElement.addContent(rtcls.newInstance().encode(obj));
		}
		//newElement.setAttribute(""nsprefix"", ""ns"");

		//newElement.addContent(obj.getContent().encode(obj));

        HashMap<String,String> namespaceMap = obj.getNamespaceMap();

		if(namespaceMap!= null) {
			// Save namespace map
			ArrayList<String> keys = namespaceMap.keySet();

			for(String key : keys) {
				if(!map.containsKey(key)) {
					newElement.setAttribute(key + ""Map"", namespaceMap.get(key));
				}
			}
		}

		return newElement;

	}

	/**
	 * Encode a given object to a new XML with no namespace
	 * @param obj the object to encode
	 * @return the generated XML element representation of the provided object.
	 * @exception IOException if an error occured saving the output buffer.
	 * @exception IFXException wrapped by other exceptions
	*/
	private Element encode_no_ns(IFXObject obj) throws IOException, IFXException {
		OutputStream os = null;
		try {
			os = new ByteArrayOutputStream();
			encode(obj, new HashMap<>());
	        return XMLEncoder.encodeXML(os, bundle);
		} catch (IOException e) {
			throw e;
		} catch (MissingResourceException e) {
			throw new IFXException();
		} finally {
			closeResources(os);			
		}		
	}
	
	/**
	 * Encode the contents"
4b1327e4-500c-422b-b7a2-e1d1a200d420,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_0Test.java,40.422499656677246,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * System default Line separator string.
     */
    public static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");

    /**
     * Builds a JDOM Document object from an IFXObject.
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException;

    /**
     * Writes a Document object to the specified output stream.
     * @param doc a JDOM Document object.
     * @param indentSize the size of the indent in the output. A value of
     * zero implies no indentation.
     * @param lineSeparator the line separator for the output. A value of
     * null implies no line separators and no newlines in the output. To use
     * the system default, use DEFAULT_LINE_SEPARATOR.
     * @param ostream the OutputStream to write the formatted output to.
     * @exception IFXException if there was a problem writing the Document.
     */
    public static void write(Document doc, int indentSize, String lineSeparator, OutputStream ostream) throws IFXException;

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException;

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException;
}
","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {
TestIFXDocumentHandlerTestCase testcase = new TestIFXDocumentHandlerTestCase();

    @Test
    void test_build() throws Exception {
		final Document test1 = build( testcase.test1);

		testcase.verifyBuilding(""test1"");

    	testcase.verifySaving(""test1"", test1);
    	testcase.verifyReading(""test1"", test1);
    }

    @Test
    void test_read() throws Exception {
		final Document test1 = testcase.test1;

		testcase.verifyReading(test1);

    	testcase.verifyEvaluate(""test1"");
		testcase.verifyReading(test1);

    	testcase.verifyEvaluate(""test1"");
    	testcase.verifyReading(""test1"");

		testcase.verifyEvaluate(""test1"");
    	testcase.verifyWriting(""test1"", test1);
    }

    @Test
    void test_parse() throws Exception {
		final Document test1 = testcase.test1;

		final Document test2 = build( test1);

		final Document test3 = parse(test2);

		testcase.verifyParsing(""test3"", test3);

    	testcase.verifyEvaluate(""test3"");
		testcase.verifyReading(""test3"");
    }

    @Test
    void test_validate() throws Exception {
		final Document test1 = testcase.test1;

		final Document test2 = build( test1, ""test2.xml"", ""test3.xml"");

		test3 = parse(test2);

		testcase.verifyValidation(""test3"", test3, null);

    	testcase.verifyEvaluate(""test3"");
		testcase.verifyReading(""test3"");
    }

    // TODO Add tests for other classes.
}

static class TestIFXDocumentHandlerTestCase {

        Element test;

		public void test1() throws Exception {
			test = build(""<doc>foobar</doc>"", ""schema.xsd"", ""ns1"").getRootElement();
			final Element e = build(""<doc>foobar</doc>"", ""schema.xsd"", ""ns1"").getRootElement();
			parse(e);
		}

		public void test2() throws Exception {
			test = build(""<doc>foobar</doc>"", ""schema.xsd"", ""ns1"").getRootElement();
			final Document d = parse(test);
			assertNull(d.getRootElement());
		}

        public void test3() throws Exception {
		Document d = build(""<doc>foobar</doc>"", ""schema.xsd"", ""ns1"").getRootElement();
		parse(d);
		Document d1 = parse(build(""<doc>foobar</doc>"", ""schema.xsd"", ""ns1"").getRootElement());
		assertNotSame(d, d1);
		assertNotSame(d1, d);
		assertNotSame(d1.getRootElement(), d);
		}

        public void test4() throws Exception {
			InputStream istream = IFXDocumentHandler_0Test.class.getResourceAsStream(""Test5.xml"");
			Document test5 = build( istream, false);

			test5 = parse( test5 );
			Element test6 = parse(test5).getRootElement();
            Document test7 = parse(test6);

			test5 = parse( test6 );
			assertSame(test5, test7);
		}

	}


}
"
2e275441-22f7-49e1-ac9c-6e8861966a40,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_1Test.java,40.47553372383118,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * System default Line separator string.
     */
    public static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");

    /**
     * Builds a JDOM Document object from an IFXObject.
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException;

    /**
     * Writes a Document object to the specified output stream.
     * @param doc a JDOM Document object.
     * @param indentSize the size of the indent in the output. A value of
     * zero implies no indentation.
     * @param lineSeparator the line separator for the output. A value of
     * null implies no line separators and no newlines in the output. To use
     * the system default, use DEFAULT_LINE_SEPARATOR.
     * @param ostream the OutputStream to write the formatted output to.
     * @exception IFXException if there was a problem writing the Document.
     */
    public static void write(Document doc, int indentSize, String lineSeparator, OutputStream ostream) throws IFXException;

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException;

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException;
}
","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {
/**
		* Creates and returns a document builder.
		* @return The builder.
		* @exception IOException if there was a problem creating or parsing the document.
		*/
        SAXBuilder createSAXBuilder() throws IOException;

        /**
         * Creates an output stream to write an xml document to.
         * @return an OutputStream.
         */
        OutputStream openOutputStream() throws IOException;
}"
a307c7a0-2b5f-4e0a-af32-6042513edcbc,/EvoSuiteBenchmark/original/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_2Test.java,40.03510355949402,stop,"// IFXDocumentHandler.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 *
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * System default Line separator string.
     */
    public static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");

    /**
     * Builds a JDOM Document object from an IFXObject.
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException;

    /**
     * Writes a Document object to the specified output stream.
     * @param doc a JDOM Document object.
     * @param indentSize the size of the indent in the output. A value of
     * zero implies no indentation.
     * @param lineSeparator the line separator for the output. A value of
     * null implies no line separators and no newlines in the output. To use
     * the system default, use DEFAULT_LINE_SEPARATOR.
     * @param ostream the OutputStream to write the formatted output to.
     * @exception IFXException if there was a problem writing the Document.
     */
    public static void write(Document doc, int indentSize, String lineSeparator, OutputStream ostream) throws IFXException;

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException;

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException;
}
","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains one unit test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {

	/**
	 * Test method for
	 * {@link org.sourceforge.ifx.utils.IFXDocumentHandler#build(org.jdom.Document, java.lang.String, java.lang.String)}.
	 * Check that the result of the build process properly handles ifXNm.
	 * @see org.jdom.Element#getQName()
	 */
    @Test
    public void testBuild() {

		Document doc = null;
		Element root = null;
		try {
			doc = build(null, null, null);
		} catch (Throwable t) {
			t.printStackTrace();
			assertTrue(t instanceof IOException);
		}
		

        root = doc.getRootElement();
        assertNotNull(root);
	}

	

    
}


"
