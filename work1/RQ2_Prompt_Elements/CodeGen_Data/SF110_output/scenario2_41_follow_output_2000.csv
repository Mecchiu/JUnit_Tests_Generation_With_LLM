ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
34c22d85-2d13-45d9-a017-9e7ca6e9caaf,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/config/EnumeratedProperties.java,44.48461604118347,stop,"// EnumeratedProperties.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * Extension of {@link java.util.Properties} which allows one to specify property values which are
 * Lists of Strings.
 *
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class EnumeratedProperties extends Properties {

    /**
     * Returns the List value of the property with the supplied key. Note that one can call
     * getEnumeratedProperty() for a given key successfully if and only if setEnumeratedProperty()
     * for that key was called some time beforehand. All members of the list returned will be
     * Strings.
     *
     * @param key lookup of the enumerated property to be retrieved.
     * @return list containing String values
     */
    public List<String> getEnumeratedProperty(String key) {
        ArrayList<String> values = new ArrayList<String>();
        int i = 0;
        String value;
        while ((value = this.getProperty(key + delimiter + i++)) != null) {
            values.add(value);
        }
        return values;
    }
}
","// EnumeratedPropertiesTest.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EnumeratedProperties}.
* It contains one unit test case for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
*/
class EnumeratedPropertiesTest {","// EnumeratedPropertiesTest.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EnumeratedProperties}.
* It contains one unit test case for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
*/
class EnumeratedPropertiesTest {
// EnumeratedProperties.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * Extension of {@link java.util.Properties} which allows one to specify property values which are
 * Lists of Strings.
 *
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class EnumeratedProperties extends Properties {

    /**
     * Returns the List value of the property with the supplied key. Note that one can call
     * getEnumeratedProperty() for a given key successfully if and only if setEnumeratedProperty()
     * for that key was called some time beforehand. All members of the list returned will be
     * Strings.
     *
     * @param key lookup of the enumerated property to be retrieved.
     * @return list containing String values
     */
    public List<String> getEnumeratedProperty(String key) {
        ArrayList<String> values = new ArrayList<String>();
        int i = 0;
        String value;
        while ((value = this.getProperty(key + delimiter + i++))!= null) {
            values.add(value);
        }
        return values;
    }
}

// EnumeratedPropertiesTest.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EnumeratedProperties}.
* It contains one unit test case for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
*/
class EnumeratedPropertiesTest {
		
	public EnumeratedPropertiesTest() {
	}
	
	@Test
    public void listOfStrings() {
		//Given
		Properties p = new Properties();
		p.setProperty(""a"", ""A"");
		p.setProperty(""b"",""B"");
		p.setProperty(""c"",""C"");
		List<String> stringList = new ArrayList<String>();
		stringList.add(""a"");
		stringList.add(""b"");
		p.setProperty(""D"",stringList);

		p.store(fileName,""persons.properties"");

		//When
		List<String> list = p.getEnumeratedProperty(""D"");

		//Then
		assertEquals(""A"",""B"");
		assertEquals(""C"",""D"");
		assertEquals(""D"",""B"");
		assertEquals(list,new ArrayList<String>());

	}
	
	@Test
    public void listOfListOfStrings() {
		//Given
		Properties p = new Properties();
		p.setProperty(""a"",""A"");
		p.setProperty(""b"",""B"");
		p.setProperty(""c"",""C"");
		List<String> list = new ArrayList<String>();
		list.add(""a"");
		list.add(""b"");
		list.add(""c"");
		p.setProperty(""D"",list);

		p.store(fileName,""persons.properties"");

		//When
		List<String> list = p.getEnumeratedProperty(""D"");

		//Then
		assertEquals(""A"",""B"");
		assertEquals(""C"",""D"");
		assertEquals(list,new ArrayList<String>());

	}
	
	@Test
    public void listOfStringsWithDelimiter() {
		//Given
		Properties p = new Properties();
		p.setProperty(""a"",""A"");
		p.setProperty(""b"",""B"");
		p.setProperty(""c"",""C"");
		List<String> list = new ArrayList<String>();
		list.add(""a"");
		list.add(""b"");
		list.add(""c"");
		p.setProperty(""d"",""a"");
		p.setProperty(""e"",""d"");
		p.setProperty(""f"",""e"");
		p.setProperty(""g"",list);

		p.store(fileName,""persons.properties"");

		//When
		List<String> list = p.getEnumeratedProperty(""f"");
		List<String> list2 = p.getEnumeratedProperty(""g"");
		
		//Then
		
		assertEquals(""a"",""A"");
		assertEquals(""b"",""B"");
		assertEquals(""c"",""c"");
		assertEquals(list,new ArrayList<String>());
		assertEquals(list,new ArrayList<String>());
		assertEquals(list2,new ArrayList<String>());
		assertEquals(list,new ArrayList<String>());
		assertEquals(list2,new ArrayList<String>());
		
                assertEquals(list,p.getEnumeratedProperty(""b"",""b""));
                assertEquals(list,p.getEnumeratedProperty(""d"",""b""));
                assertEquals(list,p.getEnumeratedProperty(""e"",""d""));
                assertEquals(list,p.getEnumeratedProperty(""f"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""g"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""h"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""i"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""j"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""k"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""l"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""m"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""n"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""o"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""p"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""q"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""r"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""s"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""t"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""u"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""v"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""w"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""x"",""e""));
                assertEquals(list2,p.getEnumeratedProperty(""y"",""e""));
                assertEquals(list,p.getEnumeratedProperty(""z"",""e""));
                
		System.out.println(""========= done"");
	}
    
}
"
df23e01d-3e35-4690-93c9-dffb099dfc36,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextPaneDestination.java,60.899704933166504,stop,"// JTextPaneDestination.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;

/**
 * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextPane}.
 *
 * @see OutputDestination
 * @see JTextPane
 * @author <a href=""mailto:carl.hall@gmail.com"">Carl Hall</a>
 */
public class JTextPaneDestination implements OutputDestination {

    /**
     * @return whether caret will be automatically moved to the bottom of the text area when text is
     *         appended
     */
    public boolean autoPositionCaret() {
        return autoPositionCaret;
    }
}
","// JTextPaneDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextPaneDestination}.
* It contains one unit test case for the {@link JTextPaneDestination#autoPositionCaret()} method.
*/
class JTextPaneDestinationTest {","// JTextPaneDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextPaneDestination}.
* It contains one unit test case for the {@link JTextPaneDestination#autoPositionCaret()} method.
*/
class JTextPaneDestinationTest {

	private static final String DUMMY = ""\u0000"";
	
	/**
    * Main method of the JTextPaneDestinationTester.
    * It contains one test case for the JTextPaneDestination::autoPositionCaret() method.
    */
	@Test
    void testAutopositionCaret() {
        assertNotNull(JTextPaneDestination.autoPositionCaret());
    }
    
    /**
    * Main method of the JTextPaneDestinationTester.
    * It contains one test case for the JTextPaneDestination::autoPositionCaret() method.
    */
	@Test
    public void testAppendString() throws IllegalArgumentException, BadLocationException {
        System.out.println();
        final StringBuilder builder = new StringBuilder();
        final JTextPane pane1 = new JTextPane();
        final JTextPane pane2 = new JTextPane();
        final JTextPane pane3 = new JTextPane();

        final AutoPositionCaretTester tester = new AutoPositionCaretTester();

        final int width = 800;

        pane3.setLineWrap(true);
        assertNotNull(tester.getTextArea());
        assertEquals(height, pane3.getLineHeight(), 0.0);

        pane2.setLineWrap(true);
        pane2.setLineWrapStyleWord(true);
        assertNotNull(tester.getTextArea());
        assertEquals(height, pane2.getLineHeight(), 0.0);
        
        pane1.setLineWrap(false);
        pane1.setLineWrapStyleWord(false);
        assertNotNull(tester.getTextArea());
        assertEquals(14, pane1.getCaretPosition(), 0.0);
        
        pane1.setLineWrap(false);
        assertNotNull(tester.getTextArea());
        assertEquals(14, pane1.getCaretPosition(), 0.0);
        
        pane1.setLineWrap(true);
        assertNotNull(tester.getTextArea());
        assertEquals(14, pane1.getCaretPosition(), 0.0);
        
        pane1.setLineWrapStyleWord(true);
        assertNotNull(tester.getTextArea());
        assertEquals(11, pane1.getCaretPosition(), 0.0);
        
        pane1.setLineWrap(true);
        assertNotNull(tester.getTextArea());
        assertTrue(pane1.getLineWrapStyleWord());
        
        pane3.revalidate();
        assertNotNull(tester.getTextArea());
        assertEquals(height, pane3.getLineHeight(), 0.0);
        
        assertEquals(height, pane2.getLineHeight(), 0.0);
        pane2.setLineWrap(true);
        assertNotNull(tester.getTextArea());
        assertEquals(height, pane2.getLineHeight(), 0.0);
        
        assertEquals(height, pane3.getLineHeight(), 0.0);
        pane3.setLineWrap(true);
        assertNotNull(tester.getTextArea());
        assertEquals(height, pane3.getLineHeight(), 0.0);


        Thread.sleep(1);
        pane3.setLineWrap(false);
        assertNotNull(tester.getTextArea());
        assertEquals(height, pane3.getLineHeight(), 0.0);
        
        pane3.revalidate();
        assertNotNull(tester.getTextArea());
        assertTrue(pane3.getLineWrapStyleWord());
        
        pane3.insert(1, DUMMY);
        assertEquals(height, pane3.getLineHeight(), 0.0);
        pane3.setLineWrap(false);
        assertEquals(height, pane3.getLineHeight(), 0.0);


        Thread.sleep(1);
        
        assertNotEquals(width, pane3.getWidth());
        assertNotEquals(1, pane3.getCaretPosition());
    }
    
    /**
    * @param tester Test case.
    * @throws IllegalArgumentException in case of wrong parameters.
    * @throws BadLocationException in case of bad location exception.
    */
    private class AutoPositionCaretTester extends JTextPaneDestinationTester {
        

        /**
        * @param area TextArea to check.
        * @throws IllegalArgumentException in case of invalid area.
        * @throws BadLocationException in case of bad location exception.
        */
        @Override
        public void checkTextPane(JTextPane area) throws IllegalArgumentException, BadLocationException, IllegalStateException {
            final JTextPane area1 = (JTextPane) area.getEditor().getWrappedComponent();
            final JTextPane area2 = (JTextPane) area.getSelection().getCaret().getTextPane();
            final Document doc = area1.getDocument();
            assertNotNull(doc.get(0));
            assertNotNull(doc.get(1));
            assertNotNull(doc.get(doc.getSpanCount()));
            assertNotNull(doc.get(doc.getParagraphBefore(1)).getText(0));
            assertNotNull(doc.get(doc.getSpanBefore(1)).getText());
            assertNotNull(area1.getSelectedText());
            assertNotNull(area1.getSelectionModel().getSelectedRange());
            assertNotNull(area2.getSelectedText());
            assertNotNull(area2.getSelectionModel().getSelectedRange());
        }
    }
    
}
"
ef239080-b6e0-4365-b4d1-09ffc3bd4797,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextComponentDestination.java,60.08863663673401,length,"// JTextComponentDestination.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;

/**
 * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextComponent}.
 *
 * @see OutputDestination
 * @see JTextCompnent
 * @author <a href=""mailto:carl.hall@gmail.com"">Carl Hall</a>
 */
public class JTextComponentDestination extends FilterableOutputDestination {

    /**
     * @return whether caret will be automatically moved to the bottom of the text area when text is
     *         appended
     */
    public boolean autoPositionCaret() {
        return autoPositionCaret;
    }
}
","// JTextComponentDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextComponentDestination}.
* It contains one unit test case for the {@link JTextComponentDestination#autoPositionCaret()} method.
*/
class JTextComponentDestinationTest {","// JTextComponentDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextComponentDestination}.
* It contains one unit test case for the {@link JTextComponentDestination#autoPositionCaret()} method.
*/
class JTextComponentDestinationTest {

    private final Logger logger = Logger.getLogger(this.getClass().getName());
    private static final boolean autoPositionCaret = true;
  
    @Test
    void testAutoPositionCaret() throws BadLocationException {
    	
    	StringBuilder componentStrBuilder = new StringBuilder();
        JTextComponent component = new JTextComponent(""Test"");
        componentStrBuilder.append(component);        
        
        // Auto position caret and remove
        // componentStrBuilder.append(componentStrBuilder.toString());
        String componentStr = componentStrBuilder.toString();

        int offset = component.getSelectionStart();

        componentStrBuilder.setLength(0);
        componentStrBuilder.append(componentStr.substring(0,offset));

        assertEquals(0,componentStrBuilder.length());
        assertEquals(offset, component.getSelectionStart());
        assertEquals(offset, component.getSelectedText().length());

        // No caret
        
        componentStrBuilder.setLength(1);
        componentStrBuilder.append(componentStr);

        assertEquals(""Test\tNo caret"", componentStrBuilder.toString());
        assertEquals(0, component.getSelectionEnd());
        assertEquals(component.getSelectedText().length(), component.getSelectedText().replace(componentStr.substring(0,offset), componentStr));
        
    }
        
    @Test
    void testCustomPositionCaretWithExpandedLineDelimiter() throws BadLocationException {
    	
        StringBuilder componentStrBuilder = new StringBuilder();
        JTextComponent component = new JTextComponent(""Test"");
        componentStrBuilder.append(component);        
        
        // Auto position caret and remove
        String componentStr = componentStrBuilder.toString();

        int offset = component.getSelectionStart();

        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\t"");
        componentStrBuilder.append(componentStr);

        assertEquals(""\tTest\tNo caret"", componentStrBuilder.toString());
        assertEquals(""1\t"", componentStrBuilder.substring(0,offset));
        assertEquals(offset+1, component.getSelectionStart());
        assertEquals(offset+1, component.getSelectedText().length());

        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\t"");
        componentStrBuilder.append(componentStr.substring(0,offset));

        assertEquals(""\tTest\tNo caret"", componentStrBuilder.toString());
        assertEquals(""2\t"", componentStrBuilder.substring(0,offset));
        assertEquals(offset+2, component.getSelectionStart());
        assertEquals(offset+2, component.getSelectedText().length());
        
        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\n"");
        
        assertEquals(""\nTest\tNo caret\n"", componentStrBuilder.toString());
        assertEquals(""2\t"", componentStrBuilder.substring(0,offset));
        assertEquals(offset+2, component.getSelectionStart());
        assertEquals(offset+2, component.getSelectedText().length());



    }

    @Test
    void testCustomPositionCaret() throws BadLocationException {
    	
    	StringBuilder componentStrBuilder = new StringBuilder();


        int firstOffset = 0;        
        int secondOffset = firstOffset+1;
        int secondLineDelimiterCount = 0;
        JTextComponent component = new JTextComponent(""Test"");
        componentStrBuilder.append(component);        
        
        // Auto position caret and remove
        String componentStr = componentStrBuilder.toString();

        int offset = component.getSelectionStart();

        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\t"");
        componentStrBuilder.append(componentStr.substring(0,firstOffset));

        assertEquals(firstOffset+1, componentStrBuilder.length());
        assertEquals(""\tTest\tNo caret"", componentStrBuilder.toString());
        assertEquals(firstOffset+1, component.getSelectionStart());
        assertEquals(firstOffset+1, component.getSelectedText().length());
        
        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\t"");
        componentStrBuilder.append(componentStr.substring(firstOffset, secondOffset));
        
        assertEquals(""\tTest\tNo caret\n\t\t"", componentStrBuilder.toString());
        
        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\n"");
        
        assertEquals(""\nTest\tNo caret\n\t"", componentStrBuilder.toString());
        
        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\n\t"");
        componentStrBuilder.append(componentStr.substring(firstOffset, secondOffset));
        
        assertEquals(""\nTest\tNo caret\n\t\t\t"", componentStrBuilder.toString());

        firstOffset= secondOffset+1;
        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\t"");
        componentStrBuilder.append(componentStr.substring(firstOffset, secondOffset));

        assertEquals(""\tTest\tNo caret\n\t\t"", componentStrBuilder.toString());


        firstOffset= secondOffset+1;
        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\t\t"");
        componentStrBuilder.append(componentStr.substring(firstOffset, secondOffset));

        assertEquals(""\t\tTest\tNo caret"", componentStrBuilder.toString());
        
        // Auto position caret is not supported by any format, nor is it supported by this test
        firstOffset= 0;
        componentStrBuilder.setLength(1);
        componentStrBuilder.append(""\n\t\t"");
        componentStrBuilder.append(componentStr.substring(firstOffset, secondOffset));

        assertEquals(""\n\t\tTest\tNo caret\n\n\t"", componentStrBuilder.toString());
        

        // Auto position caret is not supported by any format, nor is it supported by this test
        firstOffset= 0;
        secondOffset= firstOffset+1;
        secondLineDelimiterCount= 1;
        
        componentStrBuilder.setLength(1);
       // componentStrBuilder.append(""<div>\n"");
        componentStrBuilder.append(""<div style=\""line-height:1px\"">\n"");
        componentStrBuilder.append(""<label style=\""line-height:0px\"">"");
        componentStrBuilder.append(""<div style=\""display:inline\"">"");

        componentStrBuilder.append(""<div style=\""color:rgb(0,0,0)\"">"");
        componentStrBuilder.append(""<div class='line' style=\""background"
053ecbba-046c-4bad-b5d4-b1eb843d06e4,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_0Test.java,48.25083565711975,length,"// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    /**
     * Searches for a term. If the term provided matches the last searched term, the last found
     * position is used as a starting point.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term The string for which to search.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term) {
        if (term != null && term.length() > 0) {
            if (term.equals(lastSearchTerm)) {
                // assume to start at the beginning
                int pos = 0;
                // if there is a previous search position, start there plus the
                // length
                // of the last term so that last term again isn't found again
                if (lastSearchPos != -1) {
                    pos = lastSearchPos + lastSearchTerm.length();
                }
                lastSearchPos = search(lastSearchTerm, pos);
            } else {
                lastSearchPos = search(term, 0);
            }
        }
        // remember the term if it was found
        if (lastSearchPos == -1) {
            lastSearchTerm = null;
        } else {
            lastSearchTerm = term;
        }
        return lastSearchPos;
    }
}
","// SearchableTextPane_0Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String)} method.
*/
class SearchableTextPane_0Test {","// SearchableTextPane_0Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String)} method.
*/
class SearchableTextPane_0Test {
// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    /**
     * Searches for a term. If the term provided matches the last searched term, the last found
     * position is used as a starting point.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term The string for which to search.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term) {
        if (term!= null && term.length() > 0) {
            if (term.equals(lastSearchTerm)) {
                // assume to start at the beginning
                int pos = 0;
                // if there is a previous search position, start there plus the
                // length
                // of the last term so that last term again isn't found again
                if (lastSearchPos!= -1) {
                    pos = lastSearchPos + lastSearchTerm.length();
                }
                lastSearchPos = search(lastSearchTerm, pos);
            } else {
                lastSearchPos = search(term, 0);
            }
        }
        // remember the term if it was found
        if (lastSearchPos == -1) {
            lastSearchTerm = null;
        } else {
            lastSearchTerm = term;
        }
        return lastSearchPos;
    }
}

// SearchableTextPane_0Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String)} method.
*/
class SearchableTextPane_0Test {
		// This test checks that the {@code search()} method of the
		// {@code AbstractSearchableTextPane} interface returns a value that
		// is not {@code null} when the string to search is not null. For
		// this test to pass, the null value must be equal to the value
		// returned by {@code search(String)}.


	@junit.jupiter.ExpectedWhen
	@test
    void searchForTermWhenNotNull() {
          
		String searchedTerm = null;
		int pos = search(""not existing"", -1);
		assertNull(searchedTerm);
		assertTrue(pos!= -1);
  }	

	@junit.jupiter.ExpectedWhen
	@test
    void searchForTermStartsWithFoundTerm() {
		String foundTerm = ""something"";

		int pos = search(""found it"", foundTerm.length());

		assertTrue(pos!= -1);
		assertTrue(pos + foundTerm.length() < textArea().length());
	}
	
	@junit.jupiter.ExpectedWhen
	@test
	void searchForStartOfOtherTerm() {
		Object textArea = textArea();

		String otherTerm = ""term"";

		int pos = search(otherTerm, -1);
		assertTrue(pos + otherTerm.length() < textArea.length());

		DefaultHighlighter highlight = (DefaultHighlighter)textArea.getUI().getComponent(""DefaultHighlighter"").getHighlighter();
		highlight.setLineWrap(true);

		pos = search(otherTerm, pos);
		assertTrue(pos + otherTerm.length() < textArea.length());

		highlight.setLineWrap(false);

		pos = search(otherTerm, pos);
		assertTrue(pos + otherTerm.length() < textArea.length());
	}
	
	@junit.jupiter.ExpectedWhen
	@test
	void searchForTextWhenNull() {
		assertEquals(0, textArea().getDocument().getLength());
		assertEquals(0, textArea().getLineStartOffset(0));

		String text = null;

		int pos = search(""text"", -1, text);

		assertEquals(0, textArea().getDocument().getLength());
		assertEquals(0, textArea().getLineStartOffset(0));

		pos = search(""text"", text.length(), text);

		assertEquals(text, textArea().getText(0, text.length()));

		highlightString(text, pos);
	}

	@junit.jupiter.ExpectedWhen
	@test
	void searchForStartOfTextWhenNull() {
		assertEquals(0, textArea().getDocument().getLength());
		assertEquals(0, textArea().getLineStartOffset(0));

		String text = null;

		int pos = search(""start"", text);

		assertEquals(0, textArea().getDocument().getLength());
		assertEquals(0, textArea().getLineStartOffset(0));
        assertNotEquals(pos, 0);

		highlightString(text, pos);
	}

    @Test
    void testSearchingText() {
        String t = """";
        String fw = """";
        //String sw = """";
        String text = """";

        int pos = search("""", -1, text);
        int lineLength = textArea().getLineLength(0);
        assertEquals(0, lineLength);
        assertEquals(-1, pos);

        DefaultHighlighter.DefaultHighlightPainter highlighter = textArea().getHighlighter();

        pos = search(fw + fw + fw + fw + fw + """", -1, text);
        lineLength = textArea().getLineLength(0);
        assertEquals("""", textArea().getLine(0));
        assertEquals(1, pos);

        text = ""foobarfoobar"";
        pos = search(text + ""foobar"", -1, text);
        lineLength = textArea().getLineLength(0);
        assertEquals(""foobarfoobar"", textArea().getLine(0));
        assertEquals(text.length() + fw.length(), textArea().getLineStartOffset(0)) ;
        assertEquals(pos, textArea().getLineStartOffset(0)) ;
        assertEquals(lineLength, textArea().getLineLength(0));
        highlighter.setColors(Color.BLUE, Color.BLUE);
    }
    
    private int search(String text, int pos) {
        int result = pos;
        DefaultHighlighter highlighter = textArea().getHighlighter();
        Element el = textArea().getDocument().getDefaultRootElement();
        String currentLine = textArea().getText(0, text.length());
        List<Highlight> highlight = new ArrayList<Highlight>();
        try {
            highlighter.drawHighlight(el, currentLine, 0, currentLine.length());
        } catch (BadLocationException ex) {
            Logger.getLogger(SearchableTextPane_0Test.class.getName()).log(Level.SEVERE, ""Cannot determine highlighted text"");
        }
        Document doc"
56c08484-3be0-4320-9975-cbe289f40f63,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_1Test.java,50.869600772857666,stop,"// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    /**
     * Searches for a term at the given starting position.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term The string for which to search.
     * @param startPos Where to start.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term, int startPos) {
        int pos = 0;
        try {
            Document doc = getDocument();
            String text = doc.getText(0, doc.getLength());
            // Search for pattern
            pos = text.indexOf(term, startPos);
        } catch (BadLocationException e) {
            // just return -1;
            log.log(Level.WARNING, ""BadLocationException in SearchableTextPane"", e);
            pos = -1;
        }
        return pos;
    }
}
","// SearchableTextPane_1Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String, int)} method.
*/
class SearchableTextPane_1Test {","// SearchableTextPane_1Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String, int)} method.
*/
class SearchableTextPane_1Test {

    /// Logger for Test cases
    private static final Logger log = Logger.getLogger(""SearchableTextPane_1Test"");
    private static final int CHARS_IN_TEXT = 10;
    
    
    @Test
    void testSearch_emptyText() {
        assertEquals(""Empty text should match nothing"",
                """", getStringSearch().toLowerCase());
        assertEquals(""Nothing should match empty text"",
                """", search("",,"",""));

        assertEquals(""Empty text should match nothing"",
                """", search("""", 0));
        assertEquals(""Nothing should match empty text"",
                """", search("",,"", 0));
    }
    
    @Test
    void testSearchForOneCharacter() {
        assertEquals(""Search for one character"",
        		""hello world"", search(""hello world""));
        assertEquals(""Search for a character that's different from anything that's different"",
        		""hello world"", search(""w"", 2));
        assertEquals(""Search for everything but 'w'"",
        		""hello world"", search("""", 3));
    }
    
    @Test
    void testSearchForSpace() throws BadLocationException {
        StringBuilder searchResult = new StringBuilder();
        StringBuilder text = new StringBuilder();
        
        Element element = null;
        Element next = null;

        List<Element> resultList = new ArrayList<>();
        for (Element e : getDocument().getRootElements()) {
            if (Utilities.isBreakingNewLineCharacter(e.getEndOffset())) {
                next = e;
            } else {
                next = e;
            }
            
            Element nextRoot = next.getNextSibling();
            if (nextRoot!= null) {
                element = nextRoot;
                if (Utilities.isBreakingNewLineCharacter(element.getEndOffset())) {
                    text.append(element.getText());
                    resultList.add(element);
                } else {
                    for (int i = 0; i < CHARS_IN_TEXT; i++) {
                        int x = e.getStartOffset() + i;
                        if (x >= next.getStartOffset() &&
                                x <= next.getEndOffset()) {
                            searchResult.append(e.getText());
                            searchResult.append("" "");
                            searchResult.append(element.getText());
                            resultList.add(element);
                            break;
                        }
                    }
                }
            }
        }
        if (resultList.size() == 1) {
            assertEquals(""Searching text that's a line in the middle"",
                    ""w"", searchResult.toString());
            assertEquals(""Searching text for a space"",
                    "" w"", text.toString());
        }
    }
    
    @Test
    void testSearchForManyCharacters() throws BadLocationException {
        StringBuilder searchResult = new StringBuilder();
        StringBuilder text = new StringBuilder();
        
        Element left = null;
        Element right = null;

        List<Element> resultList = new ArrayList<>();
        for (Element leftRoot : getDocument().getRootElements()) {
            if (Utilities.isBreakingNewLineCharacter(leftRoot.getEndOffset())) {
                left = leftRoot;
            } else {
                left = leftRoot;
            }
            
            List<Element> leftList = new ArrayList<>();
            for (int i = 0; i < CHARS_IN_TEXT; i++) {
                Element e = left.nextSibling();
                if (Utilities.isBreakingNewLineCharacter(e.getEndOffset())) {
                    text.append(e.getText());
                    leftList.add(e);
                } else if (i >= 1) {
                    leftList.add(left);
                    if (left.getEndOffset() < e.getStartOffset()) {
                        leftList.add(e);
                        left = e;
                    }
                    else {
                        right = e;
                    }
                }
            }
            if (leftList.size() == CHARS_IN_TEXT && right!= null) {
                searchResult.append("" "");
                searchResult.append(leftList.get(0).getText());
                searchResult.append("" "");
                searchResult.append(right.getText());
                resultList.add(leftList.get(0));
            }
        }
        if (resultList.size() == CHARS_IN_TEXT && left!= null) {
            assertEquals(""Searching text that's a line in the middle"",
                    ""w"", searchResult.toString());
            assertEquals(""Searching text for a space"",
                    "" w"", text.toString());
        }
    }

}
"
cc85c1e9-fc5f-4174-baf0-66ca16b9d36b,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/gui/FileFollowingPane.java,54.08543062210083,length,"// FileFollowingPane.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;

/**
 * A component which allows one to view a text file to which information is being asynchronously
 * appended.
 *
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollowingPane extends JScrollPane {

    /**
     * Returns whether caret is automatically repositioned to the end of the text area when text is
     * appended to the followed file
     *
     * @return whether caret is automatically repositioned on append
     */
    public boolean autoPositionCaret() {
        return destination.autoPositionCaret();
    }
}
","// FileFollowingPaneTest.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollowingPane}.
* It contains one unit test case for the {@link FileFollowingPane#autoPositionCaret()} method.
*/
class FileFollowingPaneTest {","// FileFollowingPaneTest.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollowingPane}.
* It contains one unit test case for the {@link FileFollowingPane#autoPositionCaret()} method.
*/
class FileFollowingPaneTest {

    /**
     * Test method for {@link FileFollowingPane#autoPositionCaret()}.
     */
    @Test
    public void testAutoPositionCaret() {
        assertEquals(""Expected auto caret position at the end of text"", true, autoPositionCaret());
    }

    
    /**
     * Test method for {@link FileFollowingPane#autoPositionCaret()}.
     * @throws IOException
     * @throws BadLocationException 
     */
    @Test
    public void testAutoPositionCaretFail() throws IOException, BadLocationException {
        JTextComponentDestination destination = new JTextComponentDestination();

        destination.setText(new File(""."").getCanonicalPath());
        destination.setAutoPositionCaret(true);
        assertEquals(""Expected auto caret position at the end of text"", true, autoPositionCaret());
    }

    
    @Test
    public void testClose() throws IOException, IOException, BadLocationException {
        File file = File.createTempFile(""TestApp"", "".txt"");
        
        file.deleteOnExit();
                
        FileOutputStream out;

        try {
            out = new FileOutputStream(file);
            new Document(out).setPageOrientation(java.awt.PageOrientation.PORTRAIT);
            
            FileFollower following = new FileFollower(file, null);
            following.setDestination(new JTextComponentDestination(new OutputDestination()));

            JTextComponentSource tcs = new JTextComponentSource();
            tcs.setText(following.getText());

            SearchableTextPane textpane = new SearchableTextPane(tcs, null);
            textpane.setAutoPositionCaret(true);

            textpane.setFont(new Font(""SansSerif"", Font.PLAIN, 42));

            int length = textpane.getTextLength();

            String textstring = new String(new char[length]).replaceAll(""\\\\n"", ""\n"");
            textpane.appendText(textstring);
            
            FileFollowingPane fp = new FileFollowingPane(null, null, null, null);
            fp.setFont(new Font(""SansSerif"", Font.PLAIN, 42));
            fp.addText(""abcdef"");
            fp.addText(""1234567"");
            fp.setAutoRemoveLineStart(true);
            fp.setCaretPosition(length);
            fp.update(0);

            assertEquals(""Auto close position is not as expected"", new File(file, ""/"").length() / 2, lineCountToCaretPosition());

            fp.update(length);

            assertEquals(""File position not correctly updated"", length, lineCountToCaretPosition());
            assertFalse(""Auto close position is now at the end"", autoPositionCaret());
            assertTrue(""Auto close position is still at the end"", sameLine(textpane));
            
            assertFalse(""After close position is at the end of text"", sameLine(textpane));
            assertFalse(""Auto close position is not set up when text is the same"", autoPositionCaret());
            assertFalse(""Auto close position is set up on the next update"", autoPositionCaret());
            
            fp.setText(textpane.getText());
            assertTrue(""After closing position set up the position"", sameLine(textpane));
            fp.setAutoRemovingTheLine(false);
            assertFalse(""After closing position not set up the position on the next update"", autoPositionCaret());
            assertEquals(""Position set for autoclose position not correctly set up"", new File(file, ""/"").length() / 2, lineCountToCaretPosition());
            assertFalse(""Position set for autoclose position set the next update"", autoPositionCaret());

        } finally {
            file.delete();
        }
    }        
        
    @Test
    public void testSameLine() throws IOException, BadLocationException {
        PseudoDocument document = new PseudoDocument();
        FileOutputStream out;
        DocPageOrientation orientation = java.awt.PageOrientation.PORTRAIT;
        Font defaultFont = new Font(""SansSerif"", Font.PLAIN, 42);
        Document other = new Document(orientation, defaultFont, document, document.getEndOffset());
                
        FileFollower following = new FileFollower(new File("".""), other);
        following.setDestination(new JTextComponentDestination(new OutputDestination()));

        JTextComponentSource tcs = new JTextComponentSource();
        tcs.setText(following.getText());

        SearchableTextPane textpane = new SearchableTextPane(tcs, null);
        textpane.setAutoPositionCaret(true);

        TextPosition otherLineStart = new TextPosition(0, 0);
        TextPosition otherLineEnd = new TextPosition(0, otherLineStart.getLength() - 1);

        textpane.appendText("".\\1"");
        textpane.appendText("".\\2"");
        textpane.appendText("".\\3"");
        textpane.appendText(""abc"");
        textpane.appendText(""def"");
        
        TextPosition firstLineStart = textpane.getPosition(0, otherLineStart);
        TextPosition firstLineEnd = textpane.getPosition(0, otherLineEnd);
        
        textpane.setTextPositions(firstLineStart, firstLineEnd);
        textpane.setPosition(0, otherLineStart);
        
    }
    
    private int lineCountToCaretPosition() {
        Document doc = document();
        try {
            int lineCount = 0;
            int position = 0;
            
            // Find the first ""line start"" position
            //
            CharSequence start = doc.get(0, position);
            
            while(position > 0 && posBefore(start) > 0) {
                posBefore(start);
                position--;
            }
            
            // Find the last ""line end"" position
            //
                position = doc.getEndOffset();// - doc"
bda74dc0-0c4b-4774-8f81-6ed5c3c0de0d,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_0Test.java,56.74136281013489,length,"// FileFollower.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Instances of this class 'follow' a particular text file, assmebling that
 * file's characters into Strings and sending them to instances of
 * {@link OutputDestination}. The name and behavior of this class are inspired
 * by the '-f' (follow) flag of the UNIX command 'tail'.
 *
 * @see OutputDestination
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollower {

    /**
     * Add another OutputDestination to which the followed file's contents
     * should be printed.
     *
     * @param outputDestination OutputDestination to be added
     */
    public boolean addOutputDestination(OutputDestination outputDestination) {
        return outputDestinations.add(outputDestination);
    }
}
","// FileFollower_0Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#addOutputDestination(OutputDestination)} method.
*/
class FileFollower_0Test {","// FileFollower_0Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#addOutputDestination(OutputDestination)} method.
*/
class FileFollower_0Test {

    /**
     * Unit test case for the {@link FileFollower#addOutputDestination(FileFollower.OutputDestination)} method.
     * Tests all possible ways to add an output destination to this object.  It checks that
     * the object implements the {@link OutputDestination} interface.
     */
    @Test
    public void outputDestinationsTest() {
        OutputDestination expectedDestory = new OutputDestination() {
            @Override
            public void sendFileContent(File file) {
                //noinspection ResultOfMethodCallIgnored
                System.out.println(""SendFileContent File="" + file.getName());
            }
        };
        OutputDestination follower = new FileFollower.OutputDestinationsBuilder().addOutputDestinition(expectedDestory).build();
        OutputDestination actualDestory = follower.addOutputDestination(expectedDestory);
        assertEquals(expectedDestory, actualDestory);
    }
    
    @Test
    public void sendOneFileTest() throws IOException {
        
        File f1 = new File(""src/test/resources/gutenberg.txt"");
        BufferedInputStream f1in = new BufferedInputStream(new FileInputStream(f1));
        List<String> f1output = readFromAllThreads(20);
        List<String>[] f1outputThreads = split(f1output, 10);
        long f1fence = System.currentTimeMillis();
        long f1size = f1in.available();
        long f1offset = f1in.getTotalBytesRead();
        System.out.println(""\r"" + f1in.read() + "" read bytes in "" + (System.currentTimeMillis() - f1fence) + "" ms"");
        long f1time = System.currentTimeMillis();
        
        Logger.getLogger(FileFollower.class.getName()).log(Level.INFO, ""FileFollower.sendOneFile, first file ""+f1fence + "" bytes read"");
        f1outputThreads[0].clear();
        List<String> f1outputNext = readFromThread1(f1fence);
        long f1sizeNext = readWithThread1(f1fence).getFirstNumberOfBytes();
        long f1offsetNext = readWithThread1(f1fence).getFirstNumberOfBytes();

        System.out.println(""\r"" + f1in.read() + "" read bytes in "" + (System.currentTimeMillis() - f1fence) + "" ms"");
        Logger.getLogger(FileFollower.class.getName()).log(Level.INFO, ""FileFollower.sendOneFile, second file ""+f1fence+"" bytes read"");
        System.out.println(""\r""+ f1outputNext + ""\n"";
        assertOrderedEquals(f1output, f1outputNext);
        
        
        f1fence = System.currentTimeMillis();
        logFileContent(f1fence, f1fence+f1size);
        f1size = f1in.available();
        f1offset = f1in.getTotalBytesRead();
        Logger.getLogger(FileFollower.class.getName()).log(Level.INFO, ""FileFollower.sendOneFile, read after "" + (System.currentTimeMillis() - f1fence) + "" sec"");
        f1sizeNext = readWithThread1(f1fence);
        f1offsetNext = readWithThread1(f1fence);
        logFileContent(f1fence, f1fence+f1size);
        System.out.println(""\r"" + f1in.read() + "" read bytes in "" + (System.currentTimeMillis() - f1fence) + "" sec"");
        System.out.println(""Total bytes read: "" + f1size + "", total bytes read before : "" + f1sizeNext + "", total bytes read after : "" + f1offsetNext);
        checkOrder(f1sizeNext,f1time, f1offsetNext);
        assertOrderedEquals(f1output, f1outputNext);
    }
    
    public void logFileContent(long t, long f2) {
        FileOutputStream fos = null;
        try {
            //Open the stream we want to read from
            fos = new FileOutputStream(new File(""src/test/resources/log.txt""));
            BufferedInputStream fis = new BufferedInputStream(new FileInputStream(new File(""src/test/resources/log.txt"")));
            byte[] buf = new byte [4096];
            long ts = t;
            while((ts-t-1) >= 0) {
                ts+=fis.read(buf);
                System.err.print(new String(buf));
                if (ts-t-1 ==0) {
                    ts = System.currentTimeMillis();
                }
            }
            System.err.println(""log time: ""+ts+"", timestamp: ""+f2+"", total bytes read: ""+fis.getTotalBytesRead());
            
        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            if(fos!= null) fos.close();
        }
    }
    
    public List<String> readWithThread1(long t) {
        int offset = 10 * (int)(t - System.currentTimeMillis() / 1000);
        List<String> f2 = new ArrayList<String>();
        for(int i = offset; i<offset+4096; i++) {
            FileInputStream fis = null;
            try {
                //Open the stream we want to read from
                fis = new FileInputStream(new File(""src/test/resources/log.txt""));
                BufferedInputStream fis1 = new BufferedInputStream(new FileInputStream(new File(""src/test/resources/log.txt"")));
                byte[] buf = new byte[4096];
                f2.add(new String(buf));
                
                //Close the streams
                fis = null;
                
                //Read the file content
                while((fis=fis1)!= null) {
                    int length = fis.read(buf, 0, 4096);
                    f2.add(new String(buf));
                }
                //Close the streams
                fis = fis1;
                fis.close();
                fis1 = null;
            } catch(Exception e) {
                e.printStack"
240236f7-1e80-4b98-9db6-603a9f85e631,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_1Test.java,56.552932262420654,stop,"// FileFollower.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Instances of this class 'follow' a particular text file, assmebling that
 * file's characters into Strings and sending them to instances of
 * {@link OutputDestination}. The name and behavior of this class are inspired
 * by the '-f' (follow) flag of the UNIX command 'tail'.
 *
 * @see OutputDestination
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollower {

    /**
     * Remove the supplied OutputDestination from the list of OutputDestinations
     * to which the followed file's contents should be printed.
     *
     * @param outputDestination OutputDestination to be removed
     */
    public boolean removeOutputDestination(OutputDestination outputDestination) {
        return outputDestinations.remove(outputDestination);
    }
}
","// FileFollower_1Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.
*/
class FileFollower_1Test {","// FileFollower_1Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.
*/
class FileFollower_1Test {

	/**
	 * Tests the removal of an OutputDestination from the list of OutputDestinations
	 *
	 * @throws IOException
	 * @throws UnsupportedOperationException
	*/
	@Test
    void testRemoveOutputDestination() throws IOException {
        List<OutputDestination> outputDestinations = new ArrayList<OutputDestination>();
        fileFollower.outputDestinations = outputDestinations;
        
        OutputDestination outputDestination = fileFollower.removeOutputDestination(""one"");
        assertNotNull(outputDestination);
        assertNotNull(outputDestinations);
        assertEquals(outputDestinations.size(), 0);
        
        outputDestination = fileFollower.removeOutputDestination(""two"");
        assertNotNull(outputDestination);
        assertNotNull(outputDestinations);
        assertEquals(outputDestinations.size(), 0);
		
        outputDestination = fileFollower.removeOutputDestination(""three"");
        assertNotNull(outputDestination);
        assertNotNull(outputDestinations);
        assertEquals(outputDestinations.size(), 0);
        
        try {
            fileFollower.removeOutputDestination(""test"");
            fail(""Should have thrown an IllegalArgumentException."");
        } catch (NullPointerException expected) {
        }
    }

    /**
	 * Tests printing a File to a 'buffered' stream
	 *
	 * <pre>
	 * print to stdout using 'buffered' flag
	 *
	 * </pre>
	 */
	@Test
    void testPrintFileToBufferedStream() throws IOException {
        System.setProperty(""java.util.logging.SimpleFormatter.output"", ""buffered"");
        
        fileFollower.outputDestinations = new ArrayList<OutputDestination>();
        boolean outputDestsionEnabled = true;
        
        FileOutputStream outputStream; 
        OutputDestination outputDestination = fileFollower.removeOutputDestination(""one"");
        assertNotNull(outputDestination);
        assertTrue(outputDestsionEnabled);
        
        outputStream = new BufferedOutputStream(new FileOutputStream(""file.txt""));
        outputStream.write(""one"" + ""\n"".getBytes());
        outputStream.close();
        
        if (outputDestsionEnabled) {
            outputDestination = fileFollower.removeOutputDestination(""two"");
            assertNotNull(outputDestination);
            assertFalse(outputDestsionEnabled);
        }
        
        outputDestination = fileFollower.removeOutputDestination(""three"");
        assertNotNull(outputDestination);
        assertTrue(outputDestsionEnabled);
        
        outputDestination = fileFollower.removeOutputDestination(""four"");
        assertNotNull(outputDestination);
        assertFalse(outputDestsionEnabled);
        
        outputDestination = fileFollower.removeOutputDestination(""five"");
        assertNotNull(outputDestination);
        assertTrue(outputDestsionEnabled);
        outputDestination = fileFollower.removeOutputDestination(""six"");
        assertNotNull(outputDestination);
        assertFalse(outputDestsionEnabled);

        
        OutputDestination outputDestination2 = fileFollower.removeOutputDestination(""three"");
        assertEquals(outputDestination, outputDestination2);
        assertNotNull(outputDestination2);
        assertTrue(outputDestsionEnabled);
        
        outputDestination2 = fileFollower.removeOutputDestination(""seven"");
        assertNotSame(outputDestination, outputDestination2);
        assertFalse(outputDestsionEnabled);
        
        outputDestination = fileFollower.removeOutputDestination(""eight"");
        assertNotNull(outputDestination);
        assertFalse(outputDestsionEnabled);
        
        outputDestination2 = fileFollower.removeOutputDestination(""ten"");
        assertNotSame(outputDestination, outputDestination2);
        assertFalse(outputDestsionEnabled);
    }
}
"
5806a2d9-976e-4e98-b8ea-c30792419f7d,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FollowApp.java,4.739939451217651,length,"// FollowApp.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This class' main() method is the entry point into the Follow application.
 *
 * @see #main(String[])
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FollowApp {

    /**
     * Gets an image icon from the resource path.
     *
     * @param clazz The class to use as an entry point to the resource path. Image
     *            path should be relative to this class.
     * @param iconNameKey The resource key name where the image is defined.
     * @return An image icon based on the URL generated from the value of
     *         iconNameKey. null if no URL can be found.
     */
    public static ImageIcon getIcon(Class<?> clazz, String iconNameKey) {
        String filename = getResourceString(iconNameKey);
        URL url = clazz.getResource(filename);
        LOG.finer(""Class: "" + clazz + "", iconNameKey: "" + iconNameKey);
        LOG.finer(""filename: "" + filename);
        LOG.finer(""url: "" + url);
        ImageIcon icon = null;
        if (url != null) {
            icon = new ImageIcon(url);
            LOG.finer(""errored: "" + (java.awt.MediaTracker.ERRORED == icon.getImageLoadStatus()));
        }
        return icon;
    }
}
","// FollowAppTest.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains one unit test case for the {@link FollowApp#getIcon(Class, String)} method.
*/
class FollowAppTest {","// FollowAppTest.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains one unit test case for the {@link FollowApp#getIcon(Class, String)} method.
*/
class FollowAppTest {
// FollowApp.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This class' main() method is the entry point into the Follow application.
 *
 * @see #main(String[])
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FollowApp {

    /**
     * Gets an image icon from the resource path.
     *
     * @param clazz The class to use as an entry point to the resource path. Image
     *            path should be relative to this class.
     * @param iconNameKey The resource key name where the image is defined.
     * @return An image icon based on the URL generated from the value of
     *         iconNameKey. null if no URL can be found.
     */
    public static ImageIcon getIcon(Class<?> clazz, String iconNameKey) {
        String filename = getResourceString(iconNameKey);
        URL url = clazz.getResource(filename);
        LOG.finer(""Class: "" + clazz + "", iconNameKey: "" + iconNameKey);
        LOG.finer(""filename: "" + filename);
        LOG.finer(""url: "" + url);
        ImageIcon icon = null;
        if (url!= null) {
            icon = new ImageIcon(url);
            LOG.finer(""errored: "" + (java.awt.MediaTracker.ERRORED == icon.getImageLoadStatus()));
        }
        return icon;
    }
}

// FollowAppTest.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains one unit test case for the {@link FollowApp#getIcon(Class, String)} method.
*/
class FollowAppTest {
		
    private static DefaultSystemInterface defaultSystemInterface = new DefaultSystemInterface();
    private static Map<ActionContext, Boolean> actionContext = new HashMap<ActionContext, Boolean>();

    "
