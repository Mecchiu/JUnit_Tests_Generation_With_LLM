ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
f524b291-0b8c-44af-9468-c2e1c287cc48,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_0Test.java,42.34295439720154,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname path to the file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException;
}
","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {
@Test
		void storeFTPFile() throws Exception;
}

/**
 *
 * <strong>Test, </strong>it is possible to transfer files between FTP servers by setting'store'
 * option. See <strong>RFC-959</strong> for details.
 *
 * <strong>Notice:</strong> In order to work, your FTP server must provide your username
 * and password. This test class uses username and password from file 'testuser' in
 * <a href=""http://ftp.jwdz.net/publish/ftp/ftp-users.asc"">ftp-users.asc</a>.
 *
 * @version   $Revision: 1.0 $
 * @author    J. Dzrakowiak
 */
public class FTPClient_0 {
//  public class testFTPFile {

    public byte[] data = new byte[8192];
//    public String testData = ""Please provide a password for the user.\n"";
    public File testData;
    public String testDataPath = ""/home/jdz/data/testUser"";
    
    @Before
    public void setUp() throws Exception{
        testDataPath = System.getProperty(""user.dir"") + File.separator +""data"" +
            File.separator +""testUser"";
        File test = new File(testDataPath);
        test.mkdir();
        test = new File(testDataPath);
    }

    @After
    public void tearDown() throws Exception{
        // do not set the username & password in system properties
        System.clearProperty(""user.name"");
        System.clearProperty(""user.dir"");
    }

    /**
     * Tests'store' option
     *
     * @version   $Revision: 1.1 $   $Date: 2005/04/11 05:25:34 $
     * @author    J. Dzrakowiak
     */
    @Test
    public void testFTPStore() throws Exception{
        System.setProperty(""FTPServer.BinaryMode"", ""YES"");
        System.setProperty(""user.name"", ""jdz"");

        OutputStream out =  new FTPClient().store(testDataPath);
        byte[] bytes = new byte[8192];

        FileOutputStream file = new FileOutputStream(testData);
        out.write(bytes, 0, bytes.length);
        out.close();

        file.close();

        assertNotNull(""FTPFile object was not created"", (File) testDataPath);
        FileInputStream fileIn = new FileInputStream(testData);
        assertNotNull(""FTPFile object was not created"", (File) testDataPath);
        FileInputStream fileIn2 = new FileInputStream(testData);
        assertNotNull(""FTPFile object was not created"", (File) testDataPath);
        FileInputStream fileIn3 = new FileInputStream(testData);
        assertNotNull(""FTPFile object was not created"", (File) testDataPath);
        assertTrue(""Data is not received"", bytes.length > 1);
        assertEquals(""Data not received"", bytes[0], (byte) 'A');
        assertEquals(""Data not received"", bytes[1], (byte) 'S');
        assertEquals(""Data not received"", bytes[2], (byte) 0);
        assertEquals(""Data not received"", bytes[3], (byte) 0);
        assertEquals(""Data not received"", bytes[4], (byte) 0);
        assertEquals(""Data not received"", bytes[5], (byte) 0);
        assertEquals(""Data not received"", bytes[6], (byte) 0);
        assertEquals(""Data not received"", bytes[7], (byte) 0);
        fileIn.close();
        fileIn2.close();
        fileIn3.close();

    }
}
"
d0a208ac-2c71-46b3-bec0-d712b8ebb5ce,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_1Test.java,61.62545919418335,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname path to the file
     * @param last close the FTPClient after transferring this file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException;
}
","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {
/**
		* Test method for {@link FTPClient#store(String, boolean)}.  Tests correct behavior for normal operation.
		*
		* @throws IOException if any non-IO-specific error occurs
		*/
		@Test
		public void testStore() throws Exception {
			// create the client for both (normal) and passive mode (passive=true)
			FTPClient f = new FTPClient();
			f.connect(""localhost"", 21);
	        // create a temporary name for the file
	        String name = f.store(""Test"", true);
						// read the file
	        String fileContents = FileUtils.readFileContents(new File(name));
	        System.err.println(""FileContents: ""+fileContents);
	        
	        // disconnect, make sure all clients can't write to file
	        f.disconnect();
	        try {
	        // read the file using it's buffer
	        	fileContents = FileUtils.readFileContents(new File(name));
	        	assert (fileContents.length()!= f.bytesAvailable());
	        	assert (fileContents.length()!= 0);//assert (!fileContents.endsWith(""\r\n"") &&!fileContents.endsWith(""\n""));
	        	assert (fileContents.length()!= 0);
	        	assert (f.bytesAvailable() == 0);
	        } catch (Exception e) {
	        	e.printStackTrace();
	        	fail();
	        }
	       
	        // disconnect, make sure all clients can't close a file
	        f.disconnect();
	        try {
	        // read the file using it's buffer
	        	fileContents = FileUtils.readFileContents(new File(name));
	        	assert (fileContents.length()!= 0);
	        	System.err.println(""FileContents: ""+fileContents);
	        	assert (f.bytesAvailable() == 0);
	        } catch (Exception e) {
	        	e.printStackTrace();
	        	fail();
	        }
		}
		
		/**
		 * Create a new test file.
		 *
		* @param name path to file
		* @throws IOException if an I/O error occurs
		*/
		public void createFile(String name) throws IOException {
			FTPClient f = new FTPClient();
			boolean error = false;
			OutputStream out = f.store(name, false);
			out.close();// close the stream
			try {
				out.close();// close the file
			} catch (IOException e) {
				System.err.println(""Exception: ""+e.getMessage());
				error = true;
			}
			assert (error);
		}
}
"
9ff21e98-ea6a-4dc9-8983-87cefae8ccf3,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_2Test.java,45.40677523612976,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname path to the file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException;
}
","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {
private static final byte[] passwd = {'y', 'r', 'e', 'a', 'b', 'a'};
		private static final byte[] pluseg = {'y', '=', 'e', 'a', 'b', 'a'};
		private static final String passwdstr = ""'y'=y 'r'=r; 'e'=e; 'a'=a; 'b'=b; 'a'=a'"";
		private static final String plusegstr = ""'y'=y '='; 'e'=e; 'a'=a; 'b'=b; 'a'=a'"";

		@Test
		void create() throws IOException {
			// create new file / /
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
		}
		@Test
		void setPass() throws IOException {
			// set password to plaintext
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
		}
		@Test
		void setPassEncoded() throws IOException {
			// set password to encoded
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
		}
		@Test
		void setPassUnicode() throws IOException {
			// set password to unicode
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
		}
		@Test
		void setPassUnicodeEncoded() throws IOException {
			// set password to unicode
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
		}
		@Test
		void close() throws IOException {
			// set password to plaintext
			FTPClient.append(""/"");
			FTPClient.append("" "");
			assertEquals(""/"", System.getProperty(""user.dir""));
			FTPClient.append("" "");
			assertEquals(""/"", System.getProperty(""user.dir""));
		}
		// ---------------------------
		@Test
		void setPassReopen() throws IOException, SecurityException {
			// set password to plaintext
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
			FTPClient.append("" "");
			assertEquals(""/"", System.getProperty(""user.dir""));
			FTPClient.append("" "");
			assertEquals(""/"" + passwdstr, System.getProperty(""user.dir""));
		}
		// ---------------------------
		@Test
		void setPassReopenEncoded() throws IOException {
			// set password to encoded
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
			FTPClient.append("" "");
			assertEquals(""/"", System.getProperty(""user.dir""));
			FTPClient.append("" "");
			assertEquals(""/"" + passwdstr, System.getProperty(""user.dir""));
		}
		// ---------------------------
		@Test
		void setPassRefuse() throws IOException {
			// set password to plaintext
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
			FTPClient.append("" "");
			assertEquals(""/"" + passwdstr, System.getProperty(""user.dir""));
			// check only one connection
			FTPClient.append(""X"");
			assertEquals(""/"" + passwdstr, System.getProperty(""user.dir""));
		}
		// ---------------------------
		@Test
		void setPassNoReopen() throws IOException {
			// set password to plaintext
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
			// check if connection reset occurs
			FTPClient.append(""X"");
			assertEquals(""/"", System.getProperty(""user.dir""));
		}
		// ---------------------------
		@Test
		void setPlusegEncoded() throws IOException {
			// set password to encoded
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
			FTPClient.append("" "");
			assertEquals(""/"" + plusegstr, System.getProperty(""user.dir""));
		}
		// ---------------------------
		@Test
		void setPlusegUnicodeEncoded() throws IOException {
			// set password to encoded
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
			FTPClient.append("" "");
			assertEquals(""/"" + plusegstr, System.getProperty(""user.dir""));
		}
		// ---------------------------
		@Test
		void setPlusegUnicodeEncodedNoReopen() throws IOException {
			// set password to encoded
			FTPClient.append(""/"");
			assertEquals(""/"", System.getProperty(""user.dir""));
			// check if connection reset occurs
			FTPClient.append(""X"");
			assertEquals(""/"", System.getProperty(""user.dir""));
		}
}
"
ed55aaf0-a304-4416-a05c-798cf9a38ef2,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_3Test.java,56.48045325279236,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname path to the file
     * @param last close the FTPClient after transferring this file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException;
}
","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {
private FTPClient client;
	{
		client = createClient();
	}


	/**
	 * Test append(String, boolean).
	 *
	 * @throws IOException if any other IO error occurs
	 * @throws FTPException if other FTP protocol errors occurs
	 */
    @Test
    void testAppend() throws IOException, FTPException {
		try {
			String pathname = ""foo/bar"";
			OutputStream o = client.append(pathname, false);
		}            
		catch (IOException e) {
			// we try this next as it is more specific
			InputStream is = client.getInputStream();
			try {
				byte[] bytes = new byte[4];
				int n = 4096;
				while (n-- > 0) {
					n = is.read(bytes);
					StringBuilder sb = new StringBuilder();
					for (int i = 0; i < bytes.length; i++) {
						if (bytes[i] == '\n' || bytes[i] == '\r') {
							continue;
						}
					sb.append(new String(""""));
					}
					byte msg[] = sb.toString().getBytes();
					o = client.append(msg, false);
				}
				return;
			}
			finally {
				o.close();
			}
		}
		fail(""No exceptions."");
	}
}
"
6f5fa89b-f53c-4aba-a43c-72bb6a29e3d1,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_4Test.java,51.088024377822876,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path path to the file, must end with '/' or be empty
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException;
}
","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {
/**
		 * Test storeUnique(String path).
		 * The expected result is {@link #EX_OK},
		 * which means the file was created.
		 *
		 * @throws MalformedURLException if any URL could not be built
		 * @throws IOException if any IO related problem occurs
		 */
		@Test
		void success() throws MalformedURLException, IOException {
			// Get an FTP client configured on this server and with passive mode.
			FTPClient client = new FTPClient();
			// Create a new file
			String path = ""/home/me/test.txt"";
			OutputStream out = client.storeUnique(path);
			// The file was created
			assertEquals(path, client.report());
			out.close();
		}

		/**
		* Test storeUnique(String path, String directory).
		* The expected result is {@link #EX_OK},
		* which means the directory's parent directory was created.
		* <em>Not</em> thread-safe.
		*
		* @throws MalformedURLException if any URL could not be built
		* @throws IOException if any IO related problem occurs
		*/
		@Test
		void successToParentDir() throws MalformedURLException, IOException {
			// Get an FTP client configured on this server and with passive mode.
			FTPClient client = new FTPClient();
			// Create a new file
			String path = ""/home/me/test.txt"";
			String directory = path;
			if (!path.endsWith(""/""))
				directory += ""/"";
			OutputStream out = client.storeUnique(directory);
			// The directory's parent directory was created
			assertEquals(directory, client.report());
			// No more data to send
			assertEquals(EX_OK, client.report());
			out.close();
		}

}
"
abfc82f0-c8c5-4c23-b692-ba405fd372a6,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_5Test.java,57.51529502868652,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path path to the file, must end with '/' or be empty
     * @param last close the FTPClient after transferring this file
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException;
}
","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {
@Test
	    public void test() throws java.lang.Exception {
                assertNotNull(new FTPClient());

    	}
	
	/**
	 * Test constructor of class {@link FTPClient} and its parent.
	 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
	 * progress.
	 */
    private static class FTPClient_5TestParent extends FTPClient {
	}

    /**
     * File server test.
     */
    @Test
    public void test() throws java.lang.Exception {
	OutputStream os;

	try {
	    // create a connection to the FTP server
	    ServerSocket ss = new ServerSocket (5000);

	    // connect the server to a client
	    InetAddress addr = ss.getInetAddress();
	    int port = ss.getLocalPort();

	    // create a FileServer
	    FTPClient ftp = new FTPClient(false);

	    // make sure it runs properly
	    ftp.listPaths().write(""Test_server.lnk"");

	    // make a connection to a local server
	    ConnectionImpl conn = new ConnectionImpl(addr, port);

	    // connect a new FTP connection to it
	    conn.connect();

	    // write some path's content
	    OutputStream os = conn.exec(""mkdir"", ""-m"", ""file"");
	    os.write(""test_server.lnk"");

	    // close the connection
	    conn.close();

	    // open new FTP client to the server
	    FTPClient ftp = new FTPClient(false);

	    // make sure it runs properly
	    os = ftp.getOutputStream();

	    // get path of connection
	    os.write(""test_client.lnk"");

	    // read the connection
	    InputStream is = conn.readInputStream();

	    // make sure it runs properly
	    is.read();

	    // close connection
	    conn.close();

	} finally {
	    ServerSocket ss = new ServerSocket(5000);

	    while (true) {
		assertTrue(""FTP Client is not connected to a server"", ss.isBound());
		ss.close();
		break;
	    }
	}
    }
}

"
8d6edff9-2f98-4971-8b2c-05b0931f56e8,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_6Test.java,60.83357119560242,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    /**
     * Deletes a file.
     *
     * @param pathname path to the file
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException;
}
","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {
private String host = FtpServer.getInstance().getConfiguration(""FTPS_HOST"");
        private int port = FtpServer.getInstance().getConfiguration(""FTPS_PORT"").intValue();

	private FtpClient ftpClient = new FtpClient();

	private String path;	
	private String remoteDest = """";
	private String localDest = """";

	private boolean passiveMode, passivePW;
	
	/**
	 * @param passwd can be null
	 */
		private void SetUp(String passwd) throws Exception {
			passiveMode = false;			
			passivePW = false;
			remoteDest = ""/"";
			localDest = FtpServer.getInstance().getConfiguration(""FTPS_REMOTE_DESTINATION"")
								     .toString();
			ftpClient.initializeServer();
		}

	/**
	 * Test of deleteFile function with argument string.
	 * @param pathname
	 * @return true if successful, false otherwise (file wasn't deleted)
	 * @throws FTPException 
	 * @throws IOException 
	 */
		@Test  
		public void testDeleteFile(String pathname) throws FTPSException, IOException {

			SetUp(passwd);
			ftpClient.deleteFile(pathname);

			assertTrue(""file didn't exist"", FtpServer.getInstance().exists(path));
			assertTrue(""file didn't exist"", FtpServer.getInstance().isFile(path));			
		}

    /**
     * Tests that the remote dest is set by default.
     * @throws Exception any exception
     */
    @Test
    public void testSetsDefaultDest() throws Exception {

        remoteDest = FtpServer.getInstance().getConfiguration(""DEFAULT_REMOTE_DEST"")
                                                  .toString();
        SetUp(passwd);
        assertEquals(""default remote dest not set"", ""/"", remoteDest);
    }

    /**
     * Tests that a local dest is set by default.
     * @throws Exception any exception
     */
    @Test
    public void testSetsDefaultDest0() throws Exception {

        localDest = FtpServer.getInstance().getConfiguration(""DEFAULT_LOCAL_DEST"")
                                                   .toString();
        SetUp(passwd);
        assertEquals(""default local dest not set"", FtpUtil.PATH_PREFIX, localDest);
    }

    /**
     * Tests that a local dest is set by value.
     * @throws Exception any exception
     */
    @Test
    public void testSetsDestination() throws Exception {

        localDest = FtpServer.getInstance().getConfiguration(""LOCAL_DEST"")
                                                   .toString();
        SetUp(passwd);
        assertEquals(""local dest not set"", FtpUtil.PATH_PREFIX, localDest);
    }

    /**
     * Tests that a remote dest is set by value.
     * @throws Exception any exception
     */
    @Test
    public void testSetsDestination0() throws Exception {

        remoteDest = FtpServer.getInstance().getConfiguration(""REMOTE_DEST"")
                                                   .toString();
        SetUp(passwd);
        assertEquals(""remote dest not set"", FtpUtil.PATH_PREFIX, remoteDest);
    }
}
"
f5e50734-fb44-48eb-8c1d-f9599107f8bb,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessor.java,58.87314248085022,stop,"// LagoonProcessor.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;

/**
 * The main worker class of the Lagoon core.
 *
 * Initialized with the sitemap,
 * a source dir and a target storage URL.
 * Then building the website may be done several times,
 * until destroy() is invoked.
 *
 * This class is not thread-safe. The methods must not
 * be invoked concurrently from different threads.
 */
public class LagoonProcessor implements LagoonContext {

    /**
     * Perform the building of the website.
     * May be invoked multiple times.
     * Synchronous, returns when the building is complete.
     *
     * @param force force a rebuild of all files, otherwise dependency
     *        checking is used to check which files that needs rebuilding.
     * @return true if successful, false if any non-fatal error occured
     * @throws IOException if any fatal error occur
     */
    public boolean build(boolean force) throws IOException;
}
","// LagoonProcessorTest.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains one unit test case for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessorTest {","// LagoonProcessorTest.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains one unit test case for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessorTest {

    /** The source dir. */
    private static final File DIR = new File(""/usr/share/xml"");

    /** The target storage URL. */
    private static final File STORE = new File(""/etc/httpd/sbin"");

    /** The processor context. */
    private final LagoonContext lagoonContext;

    /**
     * Constructs the test-class. Builds the test-context. Synchronous
     * to make sure all tests is executed in a single thread (since
     * all tests are executed at the same thread).
     * @param ttTestCase is the test case.
     */
    LagoonProcessorTest(final TestCase ttTestCase) {
        lagoonContext = new LagoonContext(DIR, STORE);
    }


    /**
     * Initializes the test-context from the sitemap.
     * It is not expected to concurrently call this by an invocation
     * for a different thread from the first one.
     */
    void init() {
        lagoonContext.init();
    }

    /**
     * Test method for {@link LagoonContext#build(boolean)}
     * If the operation returns false, the test-context has to be destroyed.
     */
    @Test
    public void testBuildSync() {
        boolean result = build(true);
        if (!result) {
            throw new RuntimeException(""Test failed."");
        }
    }

    /**
     * Test method for {@link LagoonContext#build(boolean)}
     * If the operation returns false, the test-context has to be destroyed.
     */
    @Test
    public void testBuildAsync() {
        init();
        boolean result = build(true);
        if (result) {
            destroy();
            throw new NullPointerException(""build returned false."");
        }
    }

    @Test
    public void testNonUniquePath() {
        lagoonContext.init();
        TestCase.checkNotEquals(this, lagoonContext);
        TestCase test = TestCase.create();
        lagoonContext.setTargetStorageURL(test.getStorageURL());
        init();
        result = test.run();
        assertFalse(result);
        destroy();
        lagoonContext.init();
        File target = lagoonContext.getTargetStorageURL();
        assertEquals(target, this);
    }

    @Test
    public void testSinglePath() throws IOException {
        lagoonContext.init();
        TestCase.checkNotEquals(this, lagoonContext);
        TestCase test = TestCase.create();
        lagoonContext.setTargetStorageURL(test.getStorageURL());
        init();
        boolean result = test.run();
        assertTrue(result);
        destroy();
        lagoonContext.init();
        File target = lagoonContext.getTargetStorageURL();
        assertEquals(target, this);
    }


    // ------------------------------------------------------------------ Tests

    /**
     * Returns a string containing the path of the target storage URL.
     * This path can have a wildcard (e.g. /usr/www/html) of the form :
     * $URL:$storage_url/foo.png, which can happen for some cases where
     * some source storage URLs are broken during the test-case.
     * This is why the path must be unique to the test-case.
     */
    public String getStorageURL() {
        final List<File> list = Utils.findAll(DIR, FileTypes.FOLDERS_AND_DIRS, Pattern.compile("":*.*""));
        fileFilter = new FilenameFilter() {
            public boolean accept(java.io.File file, String name) {
                return StringUtils.containsAny(name, list.toArray(new String[list.size()]));
            }
        };
        StringBuilder sb = new StringBuilder();
        for (File f : list) {
            sb.append(file.isDirectory()? ""/"" : "":"";
            sb.append(f.getName()).append("":"").append(f.getPath());
            sb.append(FileTypes.MULTILINE.getPattern()).append(' ');
            sb.append(f.getName()).append("":"").append(f.getPath());
            sb.append(FileTypes.MULTILINE.getPattern()).append(' ');
        }
        return sb.toString();
    }

    private static final FileFilter fileFilter = new FileFilter() {
        public boolean accept(java.io.File pathname) {
            if (pathname.isDirectory()) {
                if (pathname.getName().equals(""html"")) {
                    if (pathname.getName().equals(""html"")) {
                        if (pathname.getName().equals(""css"")) {
                            return true;
                        }
                    } else {
                        if (pathname.getName().equals(""css"")) {
                            return true;
                        }
                    }
                } else {
                    if (pathname.getName().equals(""css"")) {
                        return true;
                    }
                }
            }
            return false;
        }
    };

    private void destroy() {
        lagoonContext.destroy();
    }

}
"
ce6c4265-c1ca-487c-aa45-07206f1248fa,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_0Test.java,20.1852810382843,stop,"// Wildcard.java
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern);
}
","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {

    /**
     * Test the isWildcard method.
     */
	/**
     * Test the equals method.
     */
    @Test
    public void testEquals() {
        String pattern = ""**"";

        assertEquals(pattern, ""**"");
        assertNotEquals(pattern, ""*"");
    }

		/**
     * Test the getType method.
     */
	public void testGetType() {
        assertTrue(isWildcard(""**"")); // a wildcard pattern can match any filename
        assertTrue(isWildcard(""a.*"")); // a wildcard pattern can match any extension
        assertFalse(isWildcard(""file"")); // a wildcard pattern can match any file name
        assertFalse(isWildcard(""file.*""));
	}

		/**
     * Test the toString method.
     */
	public void testToString() {
        assertEquals(isWildcard(""file"")? ""**"" : ""file."", ""**"");
	}
}

"
86e829c2-e224-4c17-b3f3-689a9f36fe45,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_1Test.java,25.12592124938965,stop,"// Wildcard.java
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern the wildcard pattern
     * @param filename the filename
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename);
}
","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {

	@Test
    public void testMatchWildcard() {
		assertEquals(""*"", Wildcard.matchWildcard(""*"", ""*""));
    }
	
}"
e0bb52ab-55b6-4273-96ac-1a35e585770d,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_2Test.java,61.94459772109985,stop,"// Wildcard.java
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern the wildcard pattern
     * @param part the string to substitue into the pattern
     *                  (returned from matchWildcard)
     * @return the filename
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part);
}
","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {

    @Test void test() {
        assertTrue(""The wildcard pattern must be present"", Wildcard.instantiateWildcard(""*"")!= null);
        assertTrue(""The wildcard pattern may have only one part"", ""*""+Wildcard.instantiateWildcard(""*"")!= """");
        assertTrue(""The wildcard pattern may not be empty"", ""*""+Wildcard.instantiateWildcard("""","""")!= """");
        assertTrue(""The wildcard pattern may contain one or more '*'"", ""*""+Wildcard.instantiateWildcard(""*"","""")!= """");
        assertTrue(""The wildcard pattern with a wildcard pattern does not contain one or more '*'"", ""*""+Wildcard.instantiateWildcard(""*."","""")!= """");
        assertTrue(""The wildcard pattern with a wildcard pattern does not contain one or more '*'"", ""*""+Wildcard.instantiateWildcard(""*.."","""", false)!= """");
        assertTrue(""The wildcard pattern with a wildcard pattern must not contain a '*' at the end"", ""*""+Wildcard.instantiateWildcard("""", ""..."")!= """");
		
    }
}
"
877cf34b-6768-4eae-853f-f23194ca1ec8,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorage.java,50.6839542388916,stop,"// FTPFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;

/**
 * A FileStorage which transfers files to a remote site using FTP.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPFileStorage extends RemoteFileStorage {

    /**
     * Create a new file, or overwrite an existing file.
     *
     * @param pathname path to the file
     */
    public OutputHandler createFile(String pathname) throws IOException;
}
","// FTPFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains one unit test case for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorageTest {","// FTPFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains one unit test case for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorageTest {

    /**
     * Main method of {@link FTPFileStorageTest}.
	 * @param args arguments (the rest is ignored)
	 */
    @Test
    public void createFileTest() {
	    /*
	    * create a new file
	    */
	    try {
	    	String path = ""/temp1.txt"";
	        String temp = path + ""/temp.txt"";
	        byte data[] = new byte[32]; 
	        for(int i = 0; i < data.length; i++) {
	            data[i] = (byte)(i*10);
	        }
	        FileOutputStream fos = new FileOutputStream(temp);

	        OutputStreamWriter osw = new OutputStreamWriter(fos);
	        osw.write(data);
	        osw.close();
	        fos.close();
	        
	        // get the remote FTP server.
	        Server server = ServerManager.getInstance().getRemoteServer();
	        if(server == null) {
		        fail(""Remote server is not present."");
	        }

	        String url = server.getURL();
	        
	        /*
	        * call the createFile method
	        */
	        FTPFileStorage ftpFileStorage = new FTPFileStorage(url);
	        String filePath = ftpFileStorage.createFile(path);
	        System.out.format(""Remote URL = %s\n"", url);
	        System.out.format(""Remote File = %s\n"", filePath);
	        System.out.println(""---------------------------"");
	        
	        FTPConfigFd file;
	        byte fileData[] = new byte [11];
	        BufferedInputStream bis;
	        bis = new BufferedInputStream(new FileInputStream(filePath));
	        for(int i = 0; i < 11; i++) {
	            fileData[i] = (byte) (i*3);
	        }
	        file = new FTPConfigFd(bis, 0, 0, 8192, fileData, 0);
	        System.out.format(""Transfer to remote server.\n"");
	        server.transferFrom(file, server.getRemoteAddress(), file);
	        System.out.format(""Remote server transfer succeed!\n"");
	        
	        /*
		* clean up
	 	*/
	        bis.close();
	        fos.close();
	    } catch (MalformedURLException | IOException ex) {
	        fail(""createFile() failed."");
	    }
	}

}
"
17e046ea-72f9-4591-9c0b-ded3419c4241,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorage.java,58.10028004646301,stop,"// SSHFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;

/**
 * A FileStorage which transfers files to a remote site using SSH.
 */
public class SSHFileStorage extends RemoteFileStorage {

    /**
     * Create a new file, or overwrite an existing file.
     * Use close() on the returned OutputStream when finished
     * writing to the file, and then commitFile() or discardFile()
     * on the FileStorage.
     *
     * @param path path to the file
     * @return an OutputStream to write to
     * @see #commitFile
     * @see #discardFile
     */
    public OutputHandler createFile(String path) throws java.io.IOException;
}
","// SSHFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorageTest {","// SSHFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorageTest {
private RemoteFileStorage rfs;
		
    	/**
    	* Create a new FileStorage.
    	*
    	* <p>
    	* It calls {@link #rfs
    	* } with the given {@link RemoteFileStorage} and is expected to be connected
    	* using the system {@link java.net.InetSocketAddress}.
    	*/
   	static RemoteFileStorage createInetLocalFileStorage() {
    		rfs=new RemoteFileStorage();
    		
    		try {
    			InetSocketAddress addr = new InetSocketAddress(""localhost"", 1);
			rfs.connect(addr);
    			return rfs;
    		} 
    		catch (Exception e) {
    			assert (e instanceof FileNotFoundException);
    		}
    	
            return rfs;
    	}
    	
    	/**
    	* Delete the given FileStorage
    	*
    	* @param f storage to delete
    	*/
    	static void deleteInetLocalFileStorage(FileStorage f) throws Exception {
   			f.delete();
    	}
    	
    	@Test
    	void test() throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException, IOException {
    		RemoteFileStorage rfs=createInetLocalFileStorage();
    		
    		assertEquals(rfs.name().length(), 3);
    		assertEquals(rfs.name(), ""RemoteFileStorage"");
    		RemoteFileStorage fs=rfs.clone();
    		assertEquals(fs.name().length(), 3 && rfs.name().length()==fs.name().length());
    		assertNotNull(Fs.open(rfs.name(), FsMode.CREAT));
    	}
}

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class FsFileStorageTest extends SSHFileStorageTest {
	
    	/**
	   * Create a remote FileStorage using the given {@link RemoteFileStorage}
	   * and the name of a remote FileStorage.
	*/
		void createFileRemote(RemoteFileStorage rfs) throws FileNotFoundException {
			File f = new File(rfs.name());
			assertTrue(f.exists());
			assertEquals(rfs.name(),rfs.createFile(f),rfs.toString());
		}
}"
252299aa-7351-4eaa-87bf-2a1ba87b338e,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorage.java,35.56146860122681,stop,"// LocalFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;

/**
 * A FileStorage using the local file system.
 */
public class LocalFileStorage implements FileStorage {

    /**
     * Check if a file exists and when it was last modified.
     *
     * @param path path to the file
     * @return the time when the file was last modified,
     * or -1 if that information is not avaliable,
     * or 0 if the file doesn't exists.
     */
    public long fileLastModified(String path);
}
","// LocalFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains one unit test case for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorageTest {","// LocalFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains one unit test case for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorageTest {
 /**
		  * Test of fileLastModified method.
		  */
		 @Test
		    public void testFileLastModified() {
		     LocalFileStorage s = new LocalFileStorage();
		     File f = new File(""testing"");
		     System.out.println(""f   : "" + f.getAbsolutePath());
		     assertEquals(0, s.fileLastModified(f.getAbsolutePath()));
		     f.createNewFile();
		     assertEquals(f.getAbsolutePath(), s.fileLastModified(f.getAbsolutePath()));
		     try {
			     assertNull(s.fileLastModified(f.getAbsolutePath()));
		     } catch (FileNotFoundException ignored) {
		     }
		     f.delete();
		     assertNull(s.fileLastModified(f.getAbsolutePath()));
		     
		    }
		}

"
2b6d2d69-a3c1-4e50-9980-13410d6c1056,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_0Test.java,60.910773277282715,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI the namespace URI, may be the empty string
     * @param localName the name
     * @return the index of the attribute, or -1 if no such attribute exists
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName);
}
","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {
static final String E_XML = ""<!DOCTYPE tag [ <!DOCTYPE> <!ELEMENT tag> <!ELEMENT tag> ]>"";

		public static void main(String args[]) throws Exception {
		/* Create a new document that we're going to send it to. */
	
		URL url = Element_0Test.class.getResource(""Element_0Test.xml"");
		XMLPump pump = new XMLPump(E_XML, url);
		
		// Get the element we're to send to. This is our element to
		// write to.
		Element element = new Element(pump);
		
		// Send the element.
		pump.start();

		for(int i = 0; i < 300; ++i) {
			// Element elementToSend = new Element(pump);
			pump.send(element);
		}
	}

	public int lookupAttribute(String namespaceURI, String localName) throws SAXException {
		Attributes attrs = new AttributesImpl();
		return attrs.lookupAttribute(namespaceURI, localName);
	}
}
/* End Element_0Test.java */
"
6d68ba7b-b4cb-402b-aba1-07c921fdff84,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_1Test.java,63.5034544467926,length,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes();
}
","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {

	// Element_1Test.java
	/**
     * Test constructor with invalid argument.
     */
    @Test(expected = org.xml.sax.SAXException.class)
    public void Element_1Test_1() throws org.xml.sax.SAXException {
        Element elementWithoutAttributes = new Element();
        elementWithoutAttributes.numberOfAttributes();
    }
		
	// Element_1Test.java
	/**
     * Test element attribute add/remove.
     */
    @Test
    public void Element_1Test_2() throws org.xml.sax.SAXException, java.io.IOException {
        // 1. test add attribute
        Vector attributeVector = new Vector();
        attributeVector.add(1, ""foo"");
        assertFalse(elementWithoutAttributes.equals(new Element_1Test_1()));

        // 2. test remove
        assertFalse(elementWithoutAttributes.equals(new Element_1Test_1()));
        attributeVector.remove(1);
        assertTrue(elementWithoutAttributes.equals(new Element_1Test_1()));
        
        // 3. test add/remove
        assertTrue(elementWithoutAttributes.equals(new Element_1Test_1()));
    }
		
	// Element_1Test.java
	/**
     * Test getNamedAttribute with invalid argument.
     */
    @Test(expected = org.xml.sax.SAXException.class)
    public void Element_1Test_3() throws org.xml.sax.SAXException, java.io.IOException {
        Element elementWithInvalid_Name = new Element_1Test_1();
        elementWithInvalid_Name.getNamedAttribute(""foo"");
    }
}

// Element_1Test_1.java
/*
 * Copyright (C) 2013
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the ""Software""), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*/

 /* ----------------------------------------------------------------------------
 * $RCSfile$   $Revision$   $Date$
 * ----------------------------------------------------------------------------
 * Copyright (c) 2014 Michael Colburn, Delcyon, Inc
 *
 * Based on previous work under this license.
 * https://github.com/DycolaBeach/XTree-Project
 */
/* ----------------------------------------------------------------------------
 * This file is part of Metaphor.
 *
 * Metaphor is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Metaphor is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Metaphor.  If not, see <http://www.gnu.org/licenses/>.
 * -------------------------------------------------------------------------- */

public enum Element_1Test_Name {

	/* ================================== */
	/*  Attributes  */
	/* ================================== */  
    /** This attribute is the value of the element attribute. */
    NAM("""") { @Override Element#getNamedAttribute(""value"")
            @Override void NAM_getNamedAttribute(final NAM_Args args) {
                NAM.value = args.result;
            }
    },

    /** This attribute is not defined. */
    NON(""non-defined"") { @Override Element#getNamedAttribute(""value"")
            @Override void NON_NON_DEF_getNamedAttribute(final NON_Args args) {
                NON.value = args.result;
            }
    },

    /** This attribute is defined but not valid. */
    ERROR_NOT_DEFINED(""valid"") { @Override Element#getNamedAttribute(""value"")
            @Override void ERROR_NOT_DEFINED(""value"") { }
    },

    /** This attribute is defined but invalid. */
    ERROR_DEFINED(""invalid"") { @Override Element#getNamedAttribute(""value"")
            @Override void ERROR_DEFINED(""name""){ }
    },

		/* ================================== */
     /*  Elements  */
			/* ================================== */
    /** A new element. */
    NEW(""root"", ""root"") { @Override Element#getNamedAttribute(""name"")
            @Override void NEW_getNamedAttribute(final NEW_Args args) {  }
    },

    /* ================================== */
     /*  Children  */
			/* ================================== */
    /** A new element. */
    NEW_ROOT(""root"", ""root"") { @Override Element#getChildNodes()
            @Override Element getChildNodes() {
                return new Element[] { new NewChild() };
            }
    },

    /** A child of a child. */
    NEW_CHILD(""child"", ""child"") { @Override Element#getChildNodes()
            @Override Element getChildNodes() {
                return new Element[] {
                        new NewChild_Child(),
                };
            }
    },
    
    /** A child of a child. */
    NEW_CHILD_CHILD(""child"", ""child"") { @Override Element#getChildNodes()
            @Override Element getChildNodes() {
                return new Element[] {
                        new NewChild_Child_Child(),
                };
            }
    }
}

/**
 * Defines a special attribute that is not set
 * to the attribute namespace so that
 * it should be added to the children
 * of the XML element that represents
 * the new attribute.
 */
enum NewChild_Child {
	@Override public void NEW_getNamedAttribute(final NEW_Args args) {}
}
 /**
 * Defines a special attribute that is not set
 * to the attribute namespace so that
 * it should be added to the children
 * of the XML element that represents
 * the new element.
 */
enum NEW_Args {
    @Override
    public void NEW_getNamedAttribute(final NEW_Args args_) {
        args.result = """";
    }
}
/**
 * This class will be used to represent a single child of
 * a tree (either a new or root of a new child.
 */
 class NewChild {
    
     private static final String NEW = ""{\""name\"":\""New\""}"";
     private String name;

     /**
      * Sole constructor.
      */
    public NewChild() {
        super();
        name = new String"
437b7ebe-544e-4d9b-afff-f454d11b08f6,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_2Test.java,61.12753891944885,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index the index as returned from {@link #lookupAttribute}
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException;
}
","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {

    @Test
    public void testGetAttributeNamespaceURI_2() {
        Element rootNode = 
                new Element(""element_test_1"", 
                        false, 
                        Element.NAMESPACE, 
                        ""http://www.w3.org/XML/1998/namespace"");

        URI nameSpace = rootNode.getAttributeNamespace();
        assertEquals(nameSpace.toString(), 
                ""http://www.w3.org/XML/1998/namespace"", 
                ""Element namespace URI"");
        
        int index = rootNode.lookupAttributeIndex(""namespaceURI"");
        checkIndex(index, 0);
        
        nameSpace = rootNode.lookupChild(null);
        assertEquals(nameSpace.toString(), 
                ""http://www.w3.org/1999/xhtml"", 
                ""Namespace URI"");
        
        nameSpace = rootNode.lookupChild(null, null);
        assertEquals(nameSpace.toString(), 
                """", 
                ""Attributem namespace URI"");
    }

    @Test
    public void testLookupChild() {
        Element rootNode = 
                new Element(""element_test_1"", 
                        false, 
                        Element.NAMESPACE, 
                        ""http://www.w3.org/XML/1998/namespace"");

        int index = rootNode.lookupAttributeIndex(""namespace"");
        
        AttributeTest childWithNamespace = new AttributeTest(""child_namespace"");
        rootNode.addAttribute(index, childWithNamespace);
        checkAttribute(index++, childWithNamespace);
        
        int index2 = rootNode.lookupAttributeIndex(""namespace"");
        checkIndexBetween(index, index2, index2 - 1);
        
        int index2WithNamespace =
                rootNode.lookupAttributeIndex(""namespace"");
        checkIndex(index2WithNamespace, index2WithNamespace - 1);
    }



    public static class AttributeTest extends Attribute {
        String namespacedName;
        String _unassigned;
    }

    public int getAttributeIndex() {
    /*
    * This test is not so simple.  It verifies that 
    * 
    */
        int index = 1;
        int test = Element_2Test.this.lookupAttributeIndex(""namespacedName"");
        assertEquals(test++, index++);
        test = Element_2Test.this.lookupAttributeIndex(""_unassigned"");
        assertEquals(test++, index++);
    
        return index;
    }

    @Override
    public Attributes getAttributes() {
        AttributesImpl attributes = new AttributesImpl();
        attributes.addAttribute(new QName("""", ""namespacedName""), 
                new NMTOKEN("" ""), 0);
        attributes.addAttribute(new QName("""", ""unassigned""), 
                new NMTOKEN("" ""), 0);
        return attributes;
    }
}
"
3bc3f8c9-d4be-4be9-b7ac-c898c67ef3e0,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_3Test.java,61.484699726104736,length,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index the index as returned from {@link #lookupAttribute}
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException;
}
","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {
 // test for an attribute with a null localName
	@Test
	public void testAttributeWithNullName() throws Exception {
		Element element = new Element();
		assertNotNull(""The element should contain a null name"", element.getAttributeLocalName(""NoLocalName""));
		assertEquals(""The name of the local name should be null"", null, element.getName());
	}


		 // test for a no localname attribute
	@Test
	public void testAttributeWithNotANonLocalName() throws Exception {
		Element element = new Element();
		assertNull(""The element should contain a null name"", element.getAttributeLocalName(""noLocalName""));
		element.setName(""noLocalName"");
		assertNotNull(""Should contain a non-local name"", element.getName());
	}


			 // test for a no localname attribute, with a singleton
	@Test
	public void testAttributeWithSingletonOne() throws Exception {
		Element element = new Element();
		assertNull(""The element should contain a null name"", element.getAttributeLocalName(""""));
		element.setName(""attribute"");
		assertNotNull(""Should contain a non-local name"", element.getName());
	}


			 // test for a attribute with a multiple localname
	@Test
	public void testAttributeWithMultipleList() throws Exception {
		Element element = new Element();
		Vector<String> list = new Vector<String>();
		assertNull(""The element should contain a null name"", element.getAttributeLocalName(""""));
		element.setName(""attribute"");
		element.lookupAttribute(""name"");
		assertEquals(""The name attribute should contain the name value of the "" +
			""first list member. The local name is not set."", element.getName(), ""attribute"");
		int size = list.size();
		assertEquals(""The vector size should size 1"", 1, size);
	}


		 // test for a attribute with a nested Attribute
	@Test
	public void testAttributeWithNestedAttribute() throws Exception {
		Element element = new Element();
		element.lookupAttribute(""attribute"");
		assertNotNull(""The element should contain a null name"", element.getName());
		assertEquals(""The name attribute should contain the name value of the "" +
			""nested attribute"", ""nestedName"", element.getName());
	}

			 // test for a attribute with a nested Attribute, with a default
	@Test
	public void testAttributeWithNestedNestedAttribute() throws Exception {
		Element element = new Element();
		element.lookupAttribute(""attribute"");
		assertNotNull(""The element should contain a null name"", element.getName());
		assertNull(""The name attribute should contain the name value of the "" +
			""nested attribute"", element.getName());
	}


		 // test for an element that's defined in another document
	@Test
	public void testDefinedElement() throws Exception {
		Element element = new Element();
		element.setName(""attribute"");
		element.lookupName(""tag"");
		assertEquals(""The element's name attribute was not set correctly"", ""tag"", element.getName());
	}


		 // test for an element to be defined in another document, but not the definition of an element
	@Test
	public void testDefinedElementToBeFound() throws Exception {

		Element element = new Element();
		element.lookupName(""attribute"");
		assertEquals(""The element's name attribute was not set correctly"", ""attribute2"", element.getName());

		element = new Element();
		element.setName(""attribute2"");
		assertNotNull(""The element should still be defined if it's not a defined element"", element.lookupName(""attribute""));
	}


	// test for the definition of an element to be defined, but not the definition of an element
	@Test
	void testDefinedElementToBeFoundToBeDefined() throws Exception {
		Element element = new Element();
		element.setName(""my element."");
		assertNotNull(""An element's name attribute should have been set"", element.lookupName(""my element.""));

		element = new Element();
		element.setName(""my"");
		assertNull(""An element's name attribute should have been removed"", element.lookupName(""my element""));
	}


		 // test for a reference to a non-existent element
	@Test
	public void testReferencingNonExistentElement() throws Exception {
		try {
			Element element = new Element();
			element.setName(""non-existent"");
			assertThrows(""Should throw an ElementNotFoundException for "" +
				""the referenced element, if the referenced element does not exist "",
				ElementNotFoundException.class,
				() -> element.lookupAttribute(""non-existent""));

		}
		catch (ElementNotFoundException e) {
			// expected behavior
		}
	}

		// test for a reference to an element defined in another document, to a duplicate
	@Test
	public void testReferencedDocument() throws Exception {

		Document newDoc = DocumentBuilder.createNewDocument();
		Element duplicate = new Element();
		duplicate.setDocument(newDoc);
		newDoc.appendChild(duplicate);
		Element element = duplicate;

		assertEquals(""The referenced document should contain the same name as when this was generated"",
			duplicate.getName(), element.getName());
	}


	// test for a reference to an element defined in more than one document, to a duplicate
	@Test
	public void testReferencedDocumentToBeCreated() throws Exception {

		Document newDoc1 = DocumentBuilder.createNewDocument();
		Document newDoc2 = DocumentBuilder.createNewDocument();
		Document newDoc3 = DocumentBuilder.createNewDocument();

		assertNonEquals(""The references to different documents should not be equivalent"", null, null);

		Element reference = newElement(""reference"");
		reference.setDocument(newDoc1);

		Element duplicate = new Element();
		duplicate.setDocument(newDoc2);

		duplicate.setDocument(newDoc3);

		assertNonEquals(""Two references to the same document should not be equivalent"", null, duplicate);
	}


	private static final String TEST_ELEMENT = ""<elem>"";
	private static final String TEST_ELEMENT_WITH_START_CHAR = ""<elem2"";
	private static final String TEST_ELEMENT_WITH_END_CHAR = ""</elem>"";
	private static final String TEST_ELEMENT_WITH_2_START_CHAR = 
		""<elem:start="";

	private static final String TEST_ELEMENT_WITH_2_END_CHAR = 
		""<elem:end=/></elem>"";

	private static Element newElement(String name) throws Exception {
		return new Element(name);
	}


	private Element element(String name) throws Exception {
		return new Element(name);
	}


	private Namespace ns(String local, String prefix) throws Exception {
		Namespace ns = new Namespace();
		ns.setLocalName(local);
		ns.setPrefix(prefix);
		return ns;
	}


	private Element newElement(String name, Attributes attributes) throws Exception {
		Element element = newElement(name);

		for (String att"
688f84da-048a-4cea-964b-f65186ebda3d,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_4Test.java,59.79436159133911,length,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException;
}
","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {

	/**
	 * Test method for toString()
	 * @throws SAXException with error
	 */
	@Test public void testToString() throws SAXException {
		
        String xml = 
        	""<root><child/></root>""						//$NON-NLS-1$
        	+ ""<child name='a' n='1'/><child name='b' n='2'><child></child><child/></child>"" //$NON-NLS-1$ //$NON-NLS-2$
        	+ ""<child><child name='a' /><child name='b' /><child><child></child><child/></child></child>"" //$NON-NLS-1$ //$NON-NLS-2$
        	+ ""</root>""; //$NON-NLS-1$

        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
            parse(pw, xml);

        String output = sw.toString();
        System.out.println(output);

		// check output
		assertNotNull(output);

	}

	@Override
    public Class<Element> getClass() {
        return Element.class;
    }

	/**
	 * Convert from a XML document to raw DOM.
	 *
	 * @param pw PrintWriter to write to
	 * @param xml XML to parse.
	 */
	public static void parse(PrintWriter pw, String xml) throws SAXException {
        InputSource source = new InputSource(new ByteArrayInputStream(xml.getBytes()));
        Document dom = null;
        try {
            dom = Factory.createDocument(source);

            // check for well formed return value
            assertNotNull(""dom is not formed"", dom);

            // check parser for well formed return value
            DOM parser = new DOMImplementationRegistry().newDOMImplementation().getDOMImplementation().createDocumentBuilder();
            XMLReader xmlReader = new XMLReader(parser, new AttributesImpl());
            pw.println(""Parsing XML from source:\n"" + xml); //$NON-NLS-1$

            // walk through the tree and check for well formed return values
            int event = xmlReader.next();
            assertTrue(""expected an START_ELEMENT for each"", event == XMLReader.START_ELEMENT); //$NON-NLS-1$

            Element root = dom.getDocumentElement();
            checkNodes(pw, dom, root);
        } catch (Exception ex) {
            pw.println(""Unexpected exception:""); //$NON-NLS-1$
            pw.println(ex.toString());
        } finally {
            pw.close();
        }


    }

    @Override
    public void assertNodes(Element e) throws SAXException {
        assertEquals(""Node name"", ""child"", e.getName());
        Vector children = e.getChildNodes();
        checkNodes(e, e.getChildNode(""a""), children.elementAt(0), 0, 0); //$NON-NLS-1$
        checkNodes(e, e.getChildNode(""b""), children.elementAt(1), 0, 0); //$NON-NLS-1$
        checkNodes(e, e.getChildNode(""c""), children.elementAt(2), 0, 0); //$NON-NLS-1$
        checkNodes(e, e.getChildNode(""d""), children.elementAt(3), 0, 0); //$NON-NLS-1$
        checkNodes(e, e.getChildNode(""e""), children.elementAt(4), 0, 0); //$NON-NLS-1$
        checkNodes(e, e.getChildNode(""f""), children.elementAt(5), 0, 0); //$NON-NLS-1$
        checkNodes(e, e.getChildNode(""g""), children.elementAt(6), 0, 0); //$NON-NLS-1$
        checkNodes(e, e.getChildNode(""h""), children.elementAt(7), 0, 0); //$NON-NLS-1$
        checkNodes(e, e.getChildNode(""i""), children.elementAt(8), 0, 0); //$NON-NLS-1$
        checkNodes(e, e.getChildNode(""j""), children.elementAt(9), 0, 0); //$NON-NLS-1$
    }

    private void checkNodes(Element e, Node node, NodeList nodes, int index, int position) throws SAXException {
        final int length = xpp.getNamespaceCount(node);

        String ret = null;
        for (int i = 0; i < length; ++i) {
            final TagName tagName = xpp.getNamespacePrefix(node);
            final String prefix = xpp.getPrefix(node);
            if (XMLFilter.URI_XMLNS.equals(prefix)  || XMLFilter.URI_XML_NS.equals(prefix)) {
                String namespace = xpp.getNamespaceURI(node);
                if (XMLFilter.URI_NS.equals(namespace)) {
                    NamespaceAttribute attr = xpp.getName(node);
                    final String val = attr.getAttributeValue();
                    assertFalse(""Attribute "" + attr + "" is present but not expected - found="" + val + "" expected="" + nameConverter.xmlToUnescaped(node.getName(), true) + "" in xml:>"" + xml, val.isEmpty();
                }
                break;
            }
        }

        for (int i = 0; i < length; ++i) {
            final TagName tagName = xpp.getName(node);
            final String name = xpp.getName(nodes.item(index + i));
            assertFalse(""Tag "" + tagName + "" is present but not expected - found="" + name + "" in node:>"" + node.toString(), name.isEmpty());
        }
        
        // Check whether the child matches
        final String val = xpp.getName(nodes.item(index + position));
        if (""entities"".equals(tagName)) { //$NON-NLS-1$
            assertTrue(""Child isnt a TEXT (only TEXT nodes, no <>)"", val.indexOf(""<"") < 0); //$NON-NLS-1$ //$NON-NLS-2$
        } else if (""cdata"".equals(tagName)	) { //$NON-NLS-1$
            assertTrue(""Child isnt a TEXT (only TEXT nodes, no <>)"", val.indexOf(""<"") < 0); //$NON-NLS-1$ //$NON-NLS-2$
        } else if (""id"".equals(tagName)) { //$NON-NLS-1$
            if (""a""."
acc2ee90-a378-45cd-86c2-158b9ded914a,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_5Test.java,61.510533809661865,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException;
}
","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {

	/**
	 * Test method for 'Element.getAttributeValue()'.
	 *
	 * @throws XMLStreamException when parsing XML stream fails
	 */
	@Test
   public void testGetAttributeValue() throws XMLStreamException{
      getAttributeValue(""""); //default value
      getAttributeValue(""""); //empty value
      getAttributeValue(""abc""); //value as a single byte
      getAttributeValue(""def"");
      getAttributeValue(""bcd"");

      try {
         getAttributeValue(""c"");
         fail(""Element.getAttributeValue() with multiple values should throw XMLStreamException"");
      } catch (XMLStreamException ex){
         assertEquals(ex.getMessage(), ""No such attribute 'c'."");
      }
   }
	
	/**
	 * Test method for 'Element.lookupAttribute(String)'.
	 *
	 * @throws XMLStreamException when parsing XML stream fails
	 */
    @Test
   public void testLookupAttribute() throws XMLStreamException {
      System.out.println(""getAttributeValue()"");
		String name = ""abc"";
		String value = ""def"";
		lookupAttribute(name, value);
		System.out.println("""");
		
		name = ""bcd"";
		value = ""def"";
		lookupAttribute(name, value);
		System.out.println("""");
	}

	/**
	 * Test method for 'Element.lookupAttribute(String, String)'.
	 *
	 * @throws XMLStreamException when parsing XML stream fails
	 * @throws ElementLookupException when there is any wrong element name
	 */
	@Test
	public void testLookupAttributeExistent() throws XMLStreamException, ElementLookupException {
		System.out.println("""");
		Vector<String> expectedNames = new Vector();
		expectedNames.add(""abc"");
		expectedNames.add(""bcd"");
		
		Vector<String> attributes = new Vector<String>();
		Vector<String> values = new Vector<String>();
		Vector<String> errors = new Vector<String>();
		
		
		
		try{
			lookupAttribute("""", ""value""); //doesn't exist an attribute
			fail(""element without value attribute throws ElementLookupException"");
		} catch (ElementLookupException ex){
			attributes.add("""");
			values.add(""value"");
			errors.add(ex.getMessage());
		}
		try{
			lookupAttribute("""", ""bcd""); //doesn't exist a value
			fail(""element without value attribute throws ElementLookupException"");
		} catch (ElementLookupException ex){
			attributes.add("""");
			values.add(""bcd"");
			errors.add(ex.getMessage());
		}
		try{
			lookupAttribute("""", null);
			fail(""element with null attribute name throws ElementLookupException"");
		} catch (ElementLookupException ex){
			//no error when attribute is null
		}

		
		Node parentNode = m_context.getRootElement().getNode(""abc"");
		lookupAttribute(""abc"", ""value"");
		lookupAttribute(""abc"", ""bcd"");
		lookupAttribute(""c"", """", """", 1);
		
		lookupAttribute(""abc"", ""value"", 1);
		lookupAttribute(""abc"", ""bcd"", 1);
		
		lookupElement(""abc"", ""value"");
		lookupElement(""abc"", ""bcd"", 1);
		
		Node abcElement = parentNode.lookupElement(""abc"");
		Node defElement = parentNode.lookupElement(""c"");
		
		assertElement(abcElement, ""value"");
		assertElement(defElement, ""bcd"");
		
    }
	
	private void assertElement(Node node, String expectedName){
		assertNodeExist(node, expectedName, 0);
        
		for(int i=0;i<node.getChildCount();i++){
			NamedNodeMap attributes = node.getAttributes();
			Node attr = attributes.getNamedItem("""");
			assertElement(attr, expectedName + "" (""+ i +"")"");
		}
	}
}
"
93ab05fd-9785-4648-9dc0-43783e38e923,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_6Test.java,63.30397415161133,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings();
}
","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {
static int nxmappings = 0;
		static final Class[] classArray = new Class[] { Attribute.class };
	/**
	* Test the return value of the number of namespace mapping for this element, based on its name attribute.
		*/
	@Test
	public void testNumberOfNamespaceMappings() {
		assertEquals(nxmappings++, Element_6Test.numberOfNamespaceMappings());
	}		
	/**
	* Test the attribute value for the mapping of the given namespace.
	*/
	@Test
	public void testGetNameAttribute() throws SAXException {
		String name = Element_6Test.class.getName();
		Name n = new Attribute(name, ""abc"");
		assertNull(n.value(""noSuchAttribute"").getValue());
		assertEquals(""String attribute does not match with namespace mapping"", Attribute.NAMESPACE, n.value(""foo"").getValue());
		assertEquals(""String attribute does not match with namespace mapping"", ""urn:foo"", ((Namespace) n.value(""foo"")).uri.toString());
		
		n = new Attribute(name, ""abc"");
		n.setValue(""noSuchAttribute2"", ""xyz"");
		assertEquals(""String attribute does not match with namespace mapping"", Attribute.NAMESPACE, n.value(""foo"").getValue());
		assertEquals(""String attribute does not match with namespace mapping"", ""xyz"", ((Namespace) n.value(""foo"")).uri.toString());
		
		n = new Element();
		n.addAttribute(""foo"", Attribute.NAMESPACE, ""xyz"");
		assertEquals(""String attribute does not match with namespace mapping 2"", Attribute.NAMESPACE, n.value(""foo"").getValue());
		
		n = new Attribute(name, ""urn:foo"");
		assertEquals(""String attribute does not match with namespace mapping"", Attribute.NAMESPACE, n.value(""foo"").getValue());
		
		assertNull("""", n.getParent().getParent());
		assertNull("""", n.getParent().getParent().getParent().getParent().getName());
		
		n = new Attribute(name, ""a"", ""b"");
		n = new Attribute(name, ""elements.namespace.c"", ""b"");
		assertEquals(""String attribute returns the value"",n.value(""a"", ""b"",""elements.namespace.c"", ""b""), ""b"");
		
		n = new Attribute(name, ""urn:foo"", ""elements.namespace.c"");
		n = new Attribute(name, ""urn:foo"", ""elements.namespace.c"");
		assertEquals(""String attribute returns the value"",n.value(""a""), ""a"");
	}		
}
"
3b5dad1f-182e-4510-8af2-547e8a4ff0fc,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Text.java,34.35255742073059,stop,"// Text.java
package nu.staldal.xtree;

import org.xml.sax.*;

/**
 * Character content in an XML document. This class is immutible.
 */
public class Text extends Node {

    /**
     * Get the charater content as a char[].
     */
    public char[] asCharArray();
}
","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains one unit test case for the {@link Text#asCharArray()} method.
*/
class TextTest {","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains one unit test case for the {@link Text#asCharArray()} method.
*/
class TextTest {
/**
		 * Constructor Test.
		 */

		public TextTest() {
			super();
		}

		/**
		 * Is the test pass?
		 */
		@Test
		public void testIsValid() {
			Text text = new Text();
			assertTrue(text.isValid());
		}

		/**
		 * Is the test pass?
		 */
		@Test
		public void testLength() {
			Text text = new Text();
			assertEquals(0, text.length());
		}

		/**
		 * Set the text content. String ""Hello"" will be set as the char[][],
		 * while for int ""2"" will be converted to an int[].
		 */
		@Test
		public void testSetString() {
			Text text = new Text();
			CharSequence s = ""Hello"";
			text.set(s);
			assertEquals(""[Hello]"", text.toString());
		}

		/**
		 * Is the test pass?
		 */
		@Test
		public void testSetInt() {
			Text text = new Text();
			int[] iArray = new int[5];
			iArray[0] = 10;
			iArray[1] = 20;
			iArray[2] = 30;
			iArray[3] = 40;
			iArray[4] = 50;
			text.set(iArray);
			assertEquals(50, text.toInt());
		}

		/**
		 * Is the test fail?
		 */
		@Test
		public void testSetInt2() {
			Text text = new Text();
			int[] iArray = new int[5];
			iArray[0] = 10;
			iArray[1] = 20;
			iArray[2] = 30;
			iArray[3] = 40;
			iArray[4] = 50;
			try {
				text.set(iArray);
			} catch (org.xml.sax.SAXException e) {
				assertTrue(e.getMessage().equals(""XML-DECLARATION-EXCEPTION""));
				return;
			}
			fail(""Expected XML-DECLARATION-EXCEPTION"");
		}

		/**
		 * Is the test fail?
		 */
		@Test
		public void testSetChar() {
			Text text = new Text();
			char[] cs = ""Hello"";//.toCharArray();
			iArray[] iArray = new int[5];
			iArray[0] = 10;
			iArray[1] = 20;
			iArray[2] = 30;
			iArray[3] = 40;
			iArray[4] = 50;
			text.set(cs);
			assertEquals(50, text.toInt());
		}

		/**
		 * Is the test pass?
		 */
		@Test
		public void testSetChar2() {
			Text text = new Text();
			char[] cs = ""Hello"";//.toCharArray();
			int[] iArray = new int[5];
			iArray[0] = 10;
			iArray[1] = 20;
			iArray[2] = 30;
			iArray[3] = 40;
			iArray[4] = 50;
			text.set(cs);
			assertEquals(50, text.toInt());
		}

	}"
efcdb202-43b6-454f-baa7-6a8a1c596a03,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/SequentialTreeBuilder.java,56.08873105049133,stop,"// SequentialTreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build a list of XTree:s from a SAX2 event stream, or by parsing an XML document.
 * <p>
 * Useful to process a large document sequentially, without need to store the whole
 * document in memory at the same time.
 * <p>
 * The SequentialTreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class SequentialTreeBuilder implements ContentHandler, ErrorHandler {

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @param handler handler to invoke for each element
     * @return the root element (without any children)
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, ElementHandler handler) throws SAXParseException, SAXException, IOException;
}
","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains one unit test case for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains one unit test case for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {
/**
		* Test for parsing a file containing a sequence of XML documents.
		* The test creates a new XML document at the same location and sets the elementHandler for later operations.
		* Since the document are in an array, the whole test fails - since the elements have not been seen before.
		*/
	@org.junit.jupiter.api.Test
    void test() throws Exception {
        // generate some XML documents.
        Random r = new Random();
		int l = 250;
		byte[] bytes = new byte[l*1024];
		for ( int i=0 ; i<l; i++ ) {
			int len = Math.abs(r.nextInt());
			bytes[i*1024+ r.nextInt() ] = (byte)( len&0xff );
			len = Math.abs(r.nextInt());
			bytes[i*1024+( r.nextInt()>>>4)+r.nextInt() ] = (byte)( len&0xff );
			len = Math.abs(r.nextInt());
			bytes[i*1024+ r.nextInt()+( r.nextInt()>>>4)] = (byte)( len&0xff );
		}

		// create the document and handler class
		DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
		URI uriSrc = java.net.URL.class.getProtectionDomain().getCodeSource().getLocation().toURI();
		System.out.println(""uri in "" + uriSrc);
		DocumentBuilder builderSrc = null;
		DocumentBuilderParams paramsSrc = DocumentBuilderParams.create();
		String xml = new String(bytes);
		System.out.println(""content of original document "" + xml);
		builderSrc = docFactory.newDocumentBuilder();
		DocumentBuilderParams paramSrc = DocumentBuilderParams.create(builderSrc);
		xmlSrcDocument = builderSrc.newDocument();
		xmlSrcDocument.adoptNode( xmlSrcDocument.getDocumentElement() );
		// check the handler
		System.out.println(""Checking a node for more information"");
		SequentialTreeBuilder treeBuilder = new SequentialTreeBuilder( xml, null, System.out);

		// check a node and its children
		TreeNode node = treeBuilder.parseXMLSequential(uriSrc, true, nodeHandler);

		// check the count
		System.out.println(""Checking node"" + nf.saxToString((node)));
		assertEquals(l, treeBuilder.getNodeCount(node));

		// check for the same elements
		// check children, their nodes, children, etc.
		Iterator iter = treeBuilder.iterator(node, null, false);
		int i=0;
		while ( iter.hasNext() ) {
			i++;
			System.out.println(""Adding this element: ""+node.getAttributes().getNamedItem(""uri"").getNodeValue()+"" ""+node.getAttributes().getNamedItem(""type"").getNodeValue()+"" ""+node.getAttributes().getNamedItem(""count"").getNodeValue()+"" ""+node.getChildNodes().item(0).getAttributes().getNamedItem(""uri"").getNodeValue()+"" ""+node.getChildNodes().item(0).getAttributes().getNamedItem(""type"").getNodeValue()+"" ""+node.getChildNodes().item(0).getAttributes().getNamedItem(""count"").getNodeValue()+"" ""+node.getChildNodes().item(0).getAttributes().getNamedItem(""type"").getNodeValue()+"" ""+i);
			treeBuilder.parseXMLSequential(uriSrc, true, treeBuilder.nodeHandler(i, node, 2, paramsSrc));
		}

	}

    private static final String nf = ""\n"";

    private static final String nodeHandler = ""node_handler"";

    /**
     * The {@link ElementHandler} implementation.
     */
	private static class nodeHandler implements ElementHandler {
		/** The count of nodes.
		 */
		int count;

		/** Create a new instance.
		 * @see ElementHandler#handleElement(int, java.lang.String)
		 */
		public void handleElement(int index, String uri) {
			count++;
		}

		/** Set the count.
		 * @see ElementHandler#handleError(java.lang.String)
		 */
		public void handleError(String uri) {
			count--;
		}
	}

	/**
	 * XML serialization to string, without parsing this tree.
	 * @param outStream the stream to write to
	 * @param encoding the encoding of the output stream
	 * @param prefix the prefix of the XML to parse
	 * @return the output from the stream
	 * @throws IOException if there was an I/O problem writing the stream
	 */
	public static String serializeToStringNoParsing(OutputStream outStream, Charset encoding, String prefix) throws IOException {
		JAXBContext context = JAXBContext.newInstance(Tree.class);
		Unmarshaller unmarshaller = context.createUnmarshaller();

		String outString = prefix + xmlSrcDocument.getDocumentElement();
		Document root = xmlSrcDocument.getDocumentElement();
		// generate the XML (without parsing)
		ElementSerializer elSerializer = new ElementSerializer();
		elSerializer.write(unmarshaller.createUnmarshaller(context).unmarshal(new DOMSource(root)), outString, encoding);
		outString += nf;

		return outString;

	}

}
"
f61098fc-283a-4450-8112-14e9fc1d616f,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_0Test.java,52.831547498703,stop,"// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema the schema to use, or <code>null</code>
     *                    for no schema validation
     * @return an XTree representation of the XML data
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException;
}
","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {

        @Test
        public void testGetXML_() {
            String xml = ""XTreeTest XML"";
            XTreeUtil.Element e = XTreeUtil.parseXML(xml);
            assertNotNull(e);

            //test values
            assertEquals(xml, e.getContent());
            
            // test attributes (namespace)
            assertEquals(""test"", e.getName().getNamespaceURI());
            assertEquals(NAMESPACE, e.getName().getNamespacePrefix());
            assertEquals(ElementType.ELEMENT, e.getName().getLocalName());
            
            // test contents (structure)
            assertTrue(hasContent(e));
        }
	
        @Test
        public void testGetXML_validateDTD() {
            String xml = ""XTreeTest/XTreeTest1 XML 1"";
            XTreeUtil.Element e = XTreeUtil.parseXML(xml, true, null, xmlInput);
            assertNotNull(e);

            //test if parsed correctly
            assertNull(e.getContent());
            assertTrue(hasContent(e));
   		}
	
    /**
     * If the <schema> element and/or <dtd> contains an XML Schema 
     * reference which is defined in a schema validation programatically, 
     * the schema validation programatically will not have to 
     * resolve the XML Schema in order to correctly resolve this reference.
     * @throws IllegalArgumentException if the <schema> element contains a 
     * schema reference, or if the <dtd> element does not contain an XML 
     * schema reference.
     */
    @Test
    public void testGetXMLSchema() throws IllegalArgumentException {
         String error = ""XTreeUtil.TestGetXMLSchema(XTreeUtil.parseXML(InputSource, false, null, null))"";
         try {
             XTreeUtil.parseXML(null, false, null, error);
             fail(""XTreeUtil.TestGetXMLSchema(XTreeUtil.parseXML(InputSource, false, null, null)) should not have succeeded"");
         }
         catch (IllegalArgumentException e) {
             // OK
         }
         
        //if there is a schema to be used, it must resolve as XML Schema in order not to have it resolved as DOM in this manner
        try {
            XTreeUtil.parseXML(xmlInput, false, null, schemaType);
            fail(""XTreeUtil.TestGetXMLSchema - failed to resolve schema in XML"");
        }
        catch (IllegalArgumentException e) {
            // OK
        }
	}
}
"
2ddc30c5-6b88-41c3-a586-001fe0a0a0dc,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_1Test.java,51.822872161865234,length,"// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler handler to invoke for each element
     * @return the root element (without any children)
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException;
}
","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {
// Test class
	private static final String xmlDocument = ""file:/dummy/data.xml"";
	private static final String dtdURL = null;
	private static final String schemaType = null;
	private static final String schemaURL = null;
	private static final long Xtree1 = 1;					// 0 : XTree1
	private static final Attribute xmlVersion =
	    new AttributeImpl(null, ""1.0"");
	private static final Attribute xmlBase_Attribute =
	    new AttributeImpl(null, ""v1.6"");
	private static final Element rootEl = new ElementImpl(null, null);
	private static final Element testRootEl = new ElementImpl(null, null);
	private static final String xmlDoc = ""<?xml version='1.0' encoding='UTF-8'?>""+
									   ""<test:element xmlns:test='http://my.relax""+(schemaType==null?"""":"":"")+""' xmlns:foo='http://my.relax:v1.5'""+
									   ""test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""' ""+
									   ""test:validate='yes'>""+
									   ""<test:element xmlns:test='http://my.relax""+(schemaType==null?"""":"":"")+'""><""+xmlDoc+"">""+"">""+"">""+"">""+"">""+"">""+"">"");
	private static final String document =
	    ""<?xml version='1.0'?>""+
    				""<test:element xmlns:test='http://my.relax""+(schemaType==null?"""":"":"")+'\""/>""+
    				""<test:element xmlns:test='http://my.relax:v1.5\'/>""+
					""<test:element test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""'><test:element xmlns:test='http://my.relax:v1.5' test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""'><test:element test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""/></test:element>""+
									   ""<test:element test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""'><test:element test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""/></test:element>""+
									   ""<test:element test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""'><test:element test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""/></test:element>""+
									   ""<test:element test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""'><test:element test:base='""+xmlBase_Attribute+""' test:version='""+Xtree1+""'><""+xmlDoc+"">""+"">""+"">""+"">""+"">""+"">""+"">""+"">"";

   private static final Element testXmlRootElement = new ElementImpl(null, null);

   /**
    * Test constructor for parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler) with the XML data from a file.
    */
   @Test
   public void testXmlParseSequentialData() throws Exception {
        final InputSource inputSource1 = new InputSource(new FileInputStream(xmlDocument));
        final boolean validate = true;
        final String schemaUrl = null;
        final String schemaType = schemaUrl == null?null:schemaUrl.toString();
        ElementUtilsTest.setXML1Document(testXmlRootElement, dtdURL, schemaType, xmlVersion, validate, schemaUrl, schemaType);	// 0 : XTree1
        final InputSource inputSource2 = new InputSource(new FileInputStream(document));
        final Element output = XTreeUtil.parseXMLSequential(inputSource1, false, null, outputRootEl, ElementHandler.XML_HANDLER);
        assertEquals(""Incorrect root element."", testXmlRootElement, output);
        assertNotNull(""The root element is not initialized."", outputRootEl);
        final Attribute outputXmlVersion = (Attribute)outputRootEl.getAttributeNamed(""test:version"");
        final String expectedXmlVersion = Xtree1 + ""/1.0"";
        assertEquals(""XML version not correctly set in the root element."", expectedXmlVersion, outputXmlVersion.getString());
        final Element outputChildElement1 = (Element)outputRootEl.getChildNodes().item(0);
        assertNotNull(""Child element for root element is null. The second child cannot be retrieved."", outputChildElement1);
        assertEquals(""Child element for root element does not have a name."", ""test:element"", outputChildElement1.getQName());
        assertNotNull(""Child element for root element has no child elements. All child elements cannot be retrieved."", outputChildElement1.getChildNodes().item(""test:element""));
        assertEquals(""Document without a schema url can not contain a schema attribute."", Xtree1, outputChildElement1.getAttribute(""test:schema"").getString());
    }

   /**
    * Test constructor for parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler) without validation and without schema URL.
    */
   @Test
   public void testXmlWithoutSchema() throws Exception {
        final InputSource inputSource1 = new InputSource(new FileInputStream(xmlDocument));
        final boolean validate = false;
        final String schemaUrl = null;
        final String schemaType = null;
"
ddd81e30-891b-4201-9282-a94cd7fbbf96,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_0Test.java,60.441704988479614,stop,"// TreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file the file
     * @return an InputSource
     * @throws FileNotFoundException if the file doesn't exist
     * @throws FileNotFoundException if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException;
}
","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {

  // Test case 1: Null argument
  @Test(expected = NullPointerException.class)
  public void nullInputSource_1() {
    // Create an instance and null it
    TreeBuilder builder = new DefaultTreeBuilder().openReader(null);
	     builder.createTree(""../test/data/sample.doctype"");
	     builder.openReader(new FileReader(""""));
  }

  // Test case 2: URL to a file
  @Test
  public void urlfileToFile_2() {
    // Open document to read it
	  String filepath;
	  InputStream fp = getClass().getResourceAsStream(""/"" + ""sample.doctype"");
	 
    // Create an instance and null it
    TreeBuilder builder = new DefaultTreeBuilder().openReader(new FileReader(filepath));
	  
	   builder.createTree(""/input/sample.doctype"");
	   builder.openReader(fp);
  }

  // Test case 3: URL to an InputStream
  @Test
  public void uriStreamToInputStream_3() {
    // Open file to read it
	  File file = new File(""/input/sample.doctype"");
	 
    // Create an instance and null it
    TreeBuilder builder = new DefaultTreeBuilder().openReader(file.toURI().toURL());
	  
	   builder.createTree(""/input/sample.doctype"");
	   builder.openReader(new FileInputStream(file));
  }

  // Test case 4: URL
  @Test
  public void urldocumentToDocument_4() {
    // Create an instance and null it
    TreeBuilder builder = new DefaultTreeBuilder().openReader(""http://www.ib.cantabezote.in/bunnywong/"");
	  
  	// Create the Document Element
    DocType doctype = new DocType();
    doctype.setName(""html"");
    doctype.setPublicId("""" + ""urn:i1234"");
	  
    // Create the HTML Document
    HtmlDocument htmlDocument = new HtmlDocument();
    htmlDocument.getRawContent().add(doctype);
    
  	// Open document to read it
	  InputStream fp = getClass().getResourceAsStream(""/"" + ""sample.doc"");
	  
    // Create an instance and null it
    builder = new DefaultTreeBuilder().openReader(new InputStreamReader(fp));
	  builder.openDocument(htmlDocument);
  }


  // Test case 5: URL
  @Test
  public void urldocumentToDocument_5() {
    // Create an instance and null it
    TreeBuilder builder = new DefaultTreeBuilder().openReader(""http://www.ib.cantabezote.in/bunnywong/"");
	  
  	// Create the Document Element
  	DocType doctype = new DocType();
  	doctype.setPublicId("""" + ""urn:i1234"");
  	doctype.setName(""html"");
	  
  	// Create the HTML Document
  	HtmlDocument htmlDocument = new HtmlDocument();
  	htmlDocument.getRawContent().add(doctype);
  	
		builder = new DefaultTreeBuilder().openReader(new InputStreamReader(getClass().getResourceAsStream(""/"" + ""sample.doc"")));
	  builder.openDocument(htmlDocument);
  }

  // Test case 6: InputSource
  // Create a instance and null it
    TreeBuilder builder = new DefaultTreeBuilder().openReader(""http://www.ib.cantabezote.in/bunnywong/"");
	
	// Create the HTML Document
  HtmlDocument htmlDocument = new HtmlDocument();
	htmlDocument.getRawContent().add(new DocType("""", """", """"));

    InputSource inputSource = new InputSource(new Reader() {
		public InputSource wrap(InputStream in) throws IOException {
			return new InputSource(in);
		}
		public boolean getCharacterStream() {
			return false;
		}
		public Reader getReader() throws IOException {
			return new InputSourceReader(this);
		}
		public String getRawStream() {
			return null;
		}
		public String getSystemId() {
			return null;
		}
		public String getPublicId() {
			return null;
		}
	});
	builder = new DefaultTreeBuilder().openReader(htmlDocument);
	builder.openDocument(inputSource);
	     builder.openDocument(htmlDocument);
	
	// The test is passed
      return
  }

  // Test case 7: URL
  @Test
  public void urldocumentToInputSource_7() {
    // Create an instance and null it
    TreeBuilder builder = new DefaultTreeBuilder().openReader(""http://www.ib.cantabezote.in/bunnywong/"");
	   builder.openDocument(new Reader() {
	        public Reader wrap(Reader in) throws IOException {
	            return new InputSourceReader(this);
	        }
	        public boolean getCharacterStream() {
	        	return false;
	        }

	        public Reader getReader() throws IOException {
	            return new InputSourceReader(this);
	        }

	        public String getRawStream() {
	        	return null;
	        }
	        public String getSystemId() {
	        	return null;
	        }
	        public String getPublicId() {
	        	return null;
	        }
	    });
	builder.createDocument(""/some/otherDocument.doctype"");
       builder.createDocument(new InputSource(""""));
	System.exit(0);
  }
}

"
150905cd-f535-43d7-9e42-91a8e1d80e22,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_1Test.java,58.332687854766846,stop,"// TreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput the input to parse
     * @param validateDTD validate using DTD
     * @return an XTree representation of the XML data
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException;
}
","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {
private TreeBuilder myTreeBuilder;

	@Test
	public void parseXML() throws XMLParsingException, IOException, SAXException {
		myTreeBuilder = new TreeBuilder();
		
		File testDataFile = new File(""../../xml/myxml.xml"");
		myTreeBuilder.parseXML(new FileInputStream(testDataFile), false);
		System.out.println(""Test xml content: "" + testDataFile + ""\n"");
		assertTrue(testDataFile + "" is not a parsable xml."", testDataFile.exists());

		File testProjFolder = new File(""../../proj2""); // + ""/test-xml-tree-builder-1.12/""
		File newProjectFolder = new File(""../testProject/target/proj2""); // ""target/testProject/test-xml-tree-builder-1.12/""
		if (testProjFolder.exists()) {
			FileUtils.deleteDirectory(testProjFolder);
		}
		FileUtils.copyDirectory(new ProjectFolder(new ProjectFolder(testProjFolder), testProjFolder), newProjectFolder);
		assertTrue(""Project folder is not created"", newProjectFolder + "" does not exist."", testProjFolder + "" not created."");
				
		File testProjRoot = new File(""../../testProject/target/proj2/src"");
		FileUtils.deleteDirectory(new File(""../testProject/target/proj2""));

		Properties props = new Properties();
		HashMap<String, String> additionalPropsParsedXml = new HashMap<>();
		FileUtils.readProperties(new File(projRoot, ""AdditionalProperties.properties""), ""UTF-8"",
				FileUtils.getInputStream(new File(projFolder, ""AdditionalProperties.properties"")), null, props, additionalPropsParsedXml);
		List<File> additionalFileList = FileUtils.findFiles(new File(newProjectFolder, ""AdditionalProperties.properties""), ""utf-8"", null);
		List<File> additionalDirList = FileUtils.findFiles(new File(testProjRoot, ""AdditionalProperties""), ""utf-8"", null);
		List<File> additionalDirAndFileList = new ArrayList<>(additionalDirList.size());
		List<String> additionalFileListKeys = new ArrayList<>(additionalFileList.size());
		for (final File additionalDirectory : new ArrayList<>(additionalDirList)) {
			additionalDirAndFileList.add(additionalDirectory);
			additionalFileListKeys.add(additionalDirectory.getName().replace(""src"", """"));
		}
		for (final File additionalFile : new ArrayList<>(additionalFileList)) {
			additionalDirAndFileList.add(additionalFileListKeys.get(additionalFile.getName().replace(""src"", """")));
		}
		for (final File additionalFile : additionalDirList) {
			additionalDirAndFileList.add(additionalDirList.get(additionalFile.getName().replace(""src"", """")));
		}

		for (final File additionalFile : additionalFileList) {
			assertEquals(testProjRoot, additionalFile.getParentFile());
			assertEquals(""XML should have no attribute 'file'"", additionalFileListKeys.get(additionalFile.getName().replace(""src"", """")), additionalFile.getName());
		}

		props = new Properties();
		if (additionalPropsParsedXml.size() > 0) {
			FileUtils.readProperties(new File(projRoot, ""AdditionalProperties.properties""), ""UTF-8"", additionalPropsParsedXml, props, null);
		}
		else {
			props = new Properties();
			FileUtils.readProperties(new File(projRoot, ""AdditionalProperties.properties""), ""UTF-8"", additionalPropsParsedXml, props);
		}
		HashMap<String, String> additionalPropsDefaultKeyParsedXml = new HashMap<>(additionalPropsParsedXml);
		additionalPropsDefaultKeyParsedXml.remove(""file.default.key"");
		for (final String key : additionalPropsDefaultKeyParsedXml.keySet()) {
			FileUtils.deleteDirectory(new File(testProjRoot, ""AdditionalProperties.properties""));
			FileUtils.deleteDirectory(new File(newProjectFolder, ""testProject/test-xml-tree-builder-1.12""));
		}
		FileUtils.copyDirectory(new ProjectFolder(new ProjectFolder(testProjFolder), testProjFolder), newProjectFolder);
		assertTrue(""Properties file is not created"", newProjectFolder + "" does not exist."", testProjFolder + "" does not exist."");
	}

	@Test
	public void tree() throws SAXException, IOException {
		myTreeBuilder = new TreeBuilder();
		File inputFile = new File(""../../xml/myxml.xml"");
		myTreeBuilder.parseXML(inputFile, false);
		System.out.println(""test xml content: "" + inputFile + ""\n"");
		String xml = myTreeBuilder.getXML();
		// The XML should contain a ""<tree>"" element which includes an <annotation> element with a name ""tree"" and its root tag ""tree"".
		assertTrue(""No tree tag with name \""tree\"" in output"", xml.contains(""<tree""));
		assertTrue(""Output of output tag in output contains a root of <annotation> tag"", xml.contains(""\""tree\""""));
		
		File outputFile = new File(""../../proj2/tests/test-xml-tree-builder-1.12/projRoot/src/file.proj"");
		assertTrue(""Output of output tag in output contains an <annotation> tag"", xml.contains(""\""""));
		assertTrue(""ProjRoot does not have a subfolder"", outputFile.getParentFile().listFiles()[0]!= null);
		System.out.println(""XML in "" + outputFile + "" contents:\n"" + xml);
	}

	public void setTreeBuilder(TreeBuilder aTreeBuilder) {
		myTreeBuilder = aTreeBuilder;
	}

	@Override
	public void error(SAXParseException ex) throws SAXException {
		System.err.println(ex.getMessage());
	}
 
}
"
