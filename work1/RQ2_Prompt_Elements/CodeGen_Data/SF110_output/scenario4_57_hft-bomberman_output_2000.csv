ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
3f8ee25d-11a7-4a4b-b46f-08671339e97e,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/ExplosionBounds.java,35.09813117980957,stop,"// ExplosionBounds.java
package server;

import java.awt.Point;

/**
 * This class is used by the server to define the bounds of a bomb explosion.
 * It contains four integer fields indicating the min/max pixel value
 * in the given direction that is affected by the explosion. It further offers
 * a method to test if a given point lies within the defined bounds.
 *
 * @author Steffen
 */
public class ExplosionBounds {

    private int up;

    private int down;

    private int right;

    private int left;

    /**
     * Creates a new ExplosionBounds object. The four integer parameters define
     * the min/max pixel value in the given direction.
     *
     * @param up
     * @param down
     * @param right
     * @param left
     */
    public ExplosionBounds(int up, int down, int right, int left) {
    }

    public int getUp();

    public int getDown();

    public int getRight();

    public int getLeft();

    /**
     * Checks whether the given point lies within the bounds of the explosion.
     *
     * @param p The Point to be checked.
     * @return True if p lies within the bounds, false if not.
     */
    public boolean contain(Point p);
}
","// ExplosionBoundsTest.java
package server;

import java.awt.Point;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplosionBounds}.
* It contains one unit test case for the {@link ExplosionBounds#contain(Point)} method.
*/
class ExplosionBoundsTest {","// ExplosionBoundsTest.java
package server;

import java.awt.Point;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplosionBounds}.
* It contains one unit test case for the {@link ExplosionBounds#contain(Point)} method.
*/
class ExplosionBoundsTest {

    /**
     * Test method for
     * {@link ExplosionBounds#contain(Point)}.
     * @throws Exception
     */
	@Test
	public void testGetUp() throws Exception {
		for(int direction=0; direction<4; direction++) {
            assertNotNull(
                    ""Expected new object to be returned.""
                    "" Direction: "" + direction
                   , new ExplosionBounds(
                                      (direction-up)&0xFF
                   , (direction-up)&0xFF
                   , (direction-up)&0xFF
                   , (direction-up)&0xFF
                    )
            );
            Point expected = new Point(0, 0);
            assertTrue(""Object not returned.""
                    + "" Direction: "" + direction
                   , new ExplosionBounds(
                            expected.x, expected.y,
                                (expected.x+expected.x+expected.x)/4
                   ,  (expected.y+expected.y+expected.y)/4
                    )
                   .contain(expected));
			
		}
	}
	
    /**
     * Test method for
     * {@link ExplosionBounds#contain(Point)}.
     * @throws Exception
     */
	@Test
	public void testGetDown() throws Exception {
		for(int direction=0; direction<4; direction++) {
            assertNotNull(
                    ""Expected new object to be returned.""
                    "" Direction: "" + direction
                   , new ExplosionBounds(
                                      (direction-down)&0xFF
                   , (direction-down)&0xFF
                   , (direction-down)&0xFF
                   , (direction-down)&0xFF
                    )
            );
            assertTrue(""Object not returned.""
                    + "" Direction:"" + direction
                   , new ExplosionBounds(
                                    (direction-down)&0xFF
                   , (direction-down)&0xFF
                   , (direction-down)&0xFF
                   , (direction-down)&0xFF
                    )
                   .contain(new Point((expected))));
			
		}
	}
	
    /**
     * Test method for
     * {@link ExplosionBounds#contain(Point)}.
     * @throws Exception
     */
	@Test
	public void testGetRight() throws Exception {
		for(int direction=0; direction<4; direction++) {
            assertNotNull(
                    ""Expected new object to be returned.""
                    "" Direction: "" + direction
                   , new ExplosionBounds(
                                      (direction-right)&0xFF
                   , (direction-right)&0xFF
                   , (direction-right)&0xFF
                   , (direction-right)&0xFF
                    )
                    );
            assertTrue(""Object not returned.""
                    + "" Direction:"" + direction
                   , new ExplosionBounds(
                                    (direction-right)&0xFF
                   , (direction-right)&0xFF
                   , (direction-right)&0xFF
                   , (direction-right)&0xFF
                    )
                   .contain(new Point((expected))));
			
		}
	}

    /**
     * Test method for
     * {@link ExplosionBounds#contain(Point)}.
     * @throws Exception
     */
	@Test
	public void testGetLeft() throws Exception {
		for(int direction=0; direction<4; direction++) {
            assertNotNull(
                    ""Expected new object to be returned.""
                    "" Direction: "" + direction
                   , new ExplosionBounds(
                                      (direction-left)&0xFF
                   , (direction-left)&0xFF
                   , (direction-left)&0xFF
                   , (direction-left)&0xFF
                    )
                    );
            Point expected = new Point(0, 0);
            assertTrue(""Object not returned.""
                    + "" Direction: "" + direction
                   , new ExplosionBounds(
                            expected.x, expected.y,
                                (expected.x+expected.x+expected.x)/4
                   , (expected.y+expected.y+expected.y)/4
                    )
                   .contain(expected));
			
		}
	}
	
}
"
85b689da-a9b1-486d-acfd-961ad84df8bd,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/BomberServer.java,28.440036296844482,stop,"// BomberServer.java
package server;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.GlobalServerMsg;
import messages.global.SessionDetailsMsg;
import messages.global.SessionListMsg;
import org.apache.log4j.Logger;
import org.hsqldb.Server;
import org.hsqldb.jdbc.jdbcDataSource;
import common.Constants;

/**
 * This is the main server class. It is responsible for accepting connections
 * from clients and starting new games/session.
 *
 * @author Steffen, Bj�rn, Daniel
 */
public class BomberServer {

    private static final Logger logger = Logger.getLogger(BomberServer.class);

    /**
     * The BomberServer singleton.
     */
    private static BomberServer bomberServer;

    /**
     * The ServerSocket on which connections are accepted.
     */
    private ServerSocket srvSocket;

    /**
     * The sessions currently running on this on this server. key: session name,
     * value: corresponding session object
     */
    private HashMap<String, ServerGameSession> gameSessions = new HashMap<String, ServerGameSession>();

    /**
     * Contains all the clients who are currently in the global lobby.
     */
    private Vector<ClientInfo> globalClients = new Vector<ClientInfo>();

    /**
     * Contains all the clients who are currently connected to the Server.
     */
    private Vector<ClientInfo> allClients = new Vector<ClientInfo>();

    private static int port = Constants.DEFAULT_SERVER_PORT;

    private ServerGameSession newSession;

    /**
     * Private constructor. Creates a new BomberServer. Use the
     * getInstance-method to obtain the BomberServer singleton.
     */
    private BomberServer() {
    }

    private void startDB();

    /**
     * Main method. One optional parameter may be specified, which will be
     * interpreted as the port number the server accepts client connections on.
     *
     * @param args
     */
    public static void main(String[] args);

    /**
     * Accepts incoming client connections.
     */
    public void waitForClients();

    /**
     * Creates a new GameSession.
     *
     * @param name
     * @param totalRounds
     * @return The newly created GameSession-object, null if the session name
     *         was already taken
     */
    public ServerGameSession createSession(String name, List<String> maps, ImageIcon mapPreview, int nrOfPlayers, int totalRounds);

    /**
     * Creates a SessionListMsg from all open sessions and
     * sends it to all clients.
     */
    private void broadcastSessionList();

    /**
     * Sends the message to all clients except the original sender itself.
     *
     * @param msg
     *            The message to be sent.
     * @param sender
     *            The original sender of the msg.
     */
    public void multicastMsg(Message msg, ClientInfo sender);

    /**
     * Broadcasts a message to all connected clients.
     *
     * @param msg
     *            The message to be sent.
     */
    public void broadcastMsg(Message msg);

    /**
     * this will exit the server
     *
     * @author Bj�rn
     */
    public void stopServer();

    // shutdown database
    public static void closeDB();

    private static jdbcDataSource setupDataSource();

    /**
     * Removes the client whose ClientInfo object is passed as a parameter from
     * the global area. As a result this client will no longer receive global
     * messages.
     *
     * @param clientInfo
     */
    public void removeClientFromGlobal(ClientInfo clientInfo);

    public void addClientToGlobal(ClientInfo clientInfo);

    /**
     * Removes a client
     *
     * @param clientInfo
     */
    public void removeClient(ClientInfo clientInfo);

    public void addClient(ClientInfo clientInfo);

    /**
     * Static factory method.
     *
     * @return The BomberServer Singleton
     */
    public static BomberServer getInstance();

    public Collection<ServerGameSession> getGameSessions();

    public ServerGameSession getGameSession(String name);

    public void removeSession(String name);

    public Vector<ClientInfo> getClients();
}
","// BomberServerTest.java
package server;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.GlobalServerMsg;
import messages.global.SessionDetailsMsg;
import messages.global.SessionListMsg;
import org.apache.log4j.Logger;
import org.hsqldb.Server;
import org.hsqldb.jdbc.jdbcDataSource;
import common.Constants;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberServer}.
* It contains one unit test case for the {@link BomberServer#getInstance()} method.
*/
class BomberServerTest {","// BomberServerTest.java
package server;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.GlobalServerMsg;
import messages.global.SessionDetailsMsg;
import messages.global.SessionListMsg;
import org.apache.log4j.Logger;
import org.hsqldb.Server;
import org.hsqldb.jdbc.jdbcDataSource;
import common.Constants;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberServer}.
* It contains one unit test case for the {@link BomberServer#getInstance()} method.
*/
class BomberServerTest {
private static int port = Constants.DEFAULT_SERVER_PORT;
		//the new server
		private Server server;
		private jdbcDataSource dataSource;

		/**
		 * Test method for
		 * {@link org.apache.log4j.helpers.LogLog#getLogger()}
		 */
		@Test
		public void testLogger() {
			logger.info(""here"");
			assertNotNull(""the logger is not set"",logger);
			assertNotNull(""the logger is null"",logger.getLogger());
		}

		/**
		 * Test method for
		 * {@link org.apache.log4j.helpers.LogLog#addBomberInterface(java.lang.Class)}
		 */
		@Test
		public void testInterfaceAdding() {
			logger.warn(""this is just a test"");
			List<Message> msgs;
			try {
				connection = getConnection();
				msgs = prepareSession(""test"");
				drop(msgs);
				connection.close();
				getConnection().startConnect();
				getConnection().close();
				msgs = null;
			} catch (IOException e) {
				e.printStackTrace();
			}
			catch (SQLException e) {
				e.printStackTrace();
			}
			logger.warn(""a strange problem happened"");
		}

}

"
b307b31a-8bb7-499d-a192-0fa80dcc697b,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/ServerBomb.java,47.976717948913574,stop,"// ServerBomb.java
package server;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.Collection;
import java.util.Vector;
import messages.round.BombExplodedMsg;
import org.apache.log4j.Logger;
import common.Bomb;
import common.Constants;
import common.GameObject;
import common.Player;
import common.PowerUp;
import common.Tile;
import db.DBException;
import db.DBGameUser;
import db.DBServiceFactory;

/**
 * The Bomb Object of the Server. This Bomb ticks some times and then exploded.
 * Then it detects the player and the tile hits.
 *
 * @author Bj�rn, Steffen, Daniel
 */
public class ServerBomb extends Bomb {

    /**
     * The negated number of frames rendered after an explosion
     */
    private static final int POST_EXPLOSION_FRAMES = -40;

    private static final Logger logger = Logger.getLogger(ServerBomb.class);

    private int tickTime = 2500;

    private int tickFrames = tickTime / 16;

    private ServerGameSession session;

    private boolean hasAlreadyExploded;

    private ExplosionBounds bounds;

    private boolean explodesrightnow = false;

    public ServerBomb(Point position, ServerGameSession session) {
    }

    @Override
    protected synchronized void move();

    @Override
    public synchronized void updateMovement(Point targetPosition);

    /**
     * Handles the explosion and the hit-detection of the bomb
     *
     * @return
     */
    public void explode(Collection<GameObject> gameObjects);

    private void determineHits(Collection<GameObject> gameObjects);

    private ExplosionBounds getExplosionBounds(Collection<GameObject> gameObjects);

    /**
     * Returns the vertical hitbox of the bomb
     *
     * @return
     */
    private Rectangle getVerticalHitBox();

    /**
     * Returns the horizontal hitbox of the bomb
     *
     * @return
     */
    private Rectangle getHorizontalHitBox();

    @Override
    public void updateWithCollisionCheck(Collection<GameObject> gameObjects);

    /**
     * handles the tick of the bomb
     *
     * @return
     */
    public boolean tick();

    /**
     * check if a gameObject is hit by the bomb
     *
     * @param gameObject
     * @return
     */
    private boolean checkHit(GameObject gameObject);
}
","// ServerBombTest.java
package server;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.Collection;
import java.util.Vector;
import messages.round.BombExplodedMsg;
import org.apache.log4j.Logger;
import common.Bomb;
import common.Constants;
import common.GameObject;
import common.Player;
import common.PowerUp;
import common.Tile;
import db.DBException;
import db.DBGameUser;
import db.DBServiceFactory;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerBomb}.
* It contains one unit test case for the {@link ServerBomb#tick()} method.
*/
class ServerBombTest {","// ServerBombTest.java
package server;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.Collection;
import java.util.Vector;
import messages.round.BombExplodedMsg;
import org.apache.log4j.Logger;
import common.Bomb;
import common.Constants;
import common.GameObject;
import common.Player;
import common.PowerUp;
import common.Tile;
import db.DBException;
import db.DBGameUser;
import db.DBServiceFactory;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerBomb}.
* It contains one unit test case for the {@link ServerBomb#tick()} method.
*/
class ServerBombTest {

    public ServerBombTest() {
    }

    @Test
    public void testTickingBomb() {
        ServerBomb serverBomb = new ServerBomb(new Point(2.5f,2.5f), new GameSession(null, null, null));	
        serverBomb.move();
        serverBomb.updateWithCollisionCheck(new Vector());
        Point topLeft = serverBomb.getTopLeft();
        assertFalse(""Top Left corner has incorrect position"", topLeft.equals(new Point(5.5f,5.5f)));
        int tickFrames = serverBomb.tickFrames;
        ServerBomb serverBomb2 = getExplosionBounds(new Vector());
        serverBomb2.tick();
        assertTrue(""Bomb Explosion has not been fired"", serverBomb2.hasExploded());
        int fire = serverBomb2.getNumberOfFireBombs();
        assertTrue(""The bomb fired no bombs"", fire > 0);
        
        ServerGameSession session2 = getExplosionBounds(new Vector());
        session2 = sendServerBombExploded(session2);
        System.out.println(""Server Bomb Test - Expected Explosion with ""+tickFrames+"" ticks. Actual: ""+ session2.getExplodedBy());
        serverBomb2 = getExplosionBounds(new Vector());
        serverBomb2.tick();

    }
    
    /**
     * TESTS FUNCTION: ServerBomb.java
     * A class with a test to see if 
     * the bomb fires the right number of bombs.
     */
    /**
        @Test
     */
    @Test
    public void testServerBombFireBOMBs() {
        System.out.println(""Server Bomb Test"");
        ServerGameSession session = new GameSession(null, null, null);
        ServerBomb serverBomb = new ServerBomb(new Point(2.5f,2.5f), session);
        serverBomb.move();
        assertEquals(""Server Bomb fire has wrong number of bombs"", session.getBombs(),1);
       
        assertEquals(""Server Bomb fires wrong number of bombs"", session.getBombs(), 1);
        
        serverBomb.explode(session);
        assertEquals(""Server Bomb fires wrong number of Bombs"", session.getBombs(), session.getExplodedBy().size());
        assertEquals(""Server Explosion fire has wrong number of Bombs"", session.getExplodedBy(),1);
        serverBomb.tick();
        assertEquals(""Server Bomb Fire has wrong number of Bombs"", session.getBombs(),2);
        
        
    }
    
    @Test
    public void returnNoBombs() {
            //ServerBombTest
            ServerBomb serverBomb = new ServerBomb(new Point(2.5f,2.5f), new Vector());
            assertTrue(""ServerBomb.returnNoBombs has no bombs"",serverBomb.returnNoBombs());
            //ServerBomb
            ServerBomb serverBomb2 = new ServerBomb(new Point(2.5f,2.5f), new GameSession());
            assertEquals(""ServerBomb.returnNoBombs has wrong number of bombs"",0,serverBomb2.returnNoBombs());
            
    }
    
    /**
     * Test class of {@link ServerExplosion}.
     * It is used for testing the creation of the bomb with
     * the proper height and width.
     */
   private class ServerExplosion extends Explosion
    {
        /**
         * Constructor
         *
         * @param tile tile
         * @param player
         */
        public ServerExplosion(Tile tile, Player player)
        {
            super(tile, player);
        }
        
        /**
         * Return the explosion class for this container
         *
         * @return class
         */
        @Override
        public Class<? extends Explosion> classAt(Point topRight)
        {
            return ServerExplosion.class;
        }
    }
    
    
    /**
       * Returns the top right point (in tile position) of the tile with the largest tile size
       * at the server to which the explosion shall be placed in game
       *
       * @return the top right tile
       */
       public Point getTopRight() {
             return ServerExplosion.getTopRight(getTile());
       }

        
    /**
       * Returns randomy from server.org.
       * Server Bomb is a binary bomb that randomly destroys the board.
       *
       * @return a random number
       *
     */
   public static int getRandomNumber() {
        return DBServiceFactory.getServer().getRandomNumber();
    }

    
}
"
e226b8e0-7233-4f92-87ea-b3d18d6b4293,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/StopServer.java,60.22913408279419,stop,"// StopServer.java
package server;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.Socket;
import messages.Message;
import messages.global.StopServerMsg;

/**
 * Sends a Message to the Server, that he should closed
 *
 * @author Bj�rn
 */
public class StopServer {

    private ObjectOutputStream out;

    private Socket server;

    private String serverName = ""193.196.141.182"";

    private int serverPort = 6666;

    /**
     * sends a message
     *
     * @param msg
     */
    public void sendMsg(Message msg);

    /**
     * Connect to the Server
     */
    public boolean connectToSrv();

    /**
     * Connect to the server, and send the message
     *
     * @param stop
     */
    public void callingStopServer(StopServer stop);

    /**
     * @param args
     */
    public static void main(String[] args);
}
","// StopServerTest.java
package server;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.Socket;
import messages.Message;
import messages.global.StopServerMsg;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StopServer}.
* It contains one unit test case for the {@link StopServer#connectToSrv()} method.
*/
class StopServerTest {","// StopServerTest.java
package server;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.Socket;
import messages.Message;
import messages.global.StopServerMsg;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StopServer}.
* It contains one unit test case for the {@link StopServer#connectToSrv()} method.
*/
class StopServerTest {

		/**
    * A constructor for the class
    *
    */
    public StopServerTest() {}

    /**
     * Test startServer
     *
     * @throws IOException
     */

    @Test
    public void createServerTest() throws IOException {
        try {

            try (Socket server = new Socket(socketURL, serverPort)) {

                try (ObjectOutputStream out = new ObjectOutputStream(server.getOutputStream())) {

                    try {

                        out.writeObject(new StopServerMsg());

                    } catch (ClassNotFoundException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }

                }

            }

        } catch (IOException e) {
            fail(e.getMessage().toString());
        }

		}

	}
	
	
	
	
	/**
	 * socketURL, the url of the socket to send/receive objects
	 * serverPort, the port of the socket to send/receive objects
	 *
	 * @return socketURL
	 */

	private String socketURL = ""pipoP4xv7mKxW9d5Q8S7xzF8pH6KZaPuDfI1J"";

	private ServerSocket socket = null;
	  
	  


	private void makeSrv()
    {
        try {


			System.out.println(""connecting to Server at ""+socketURL);


			socket = new ServerSocket(
                    ServerSocketCreate.create((int) (socketURL.length() + 3) + 1,
                                        (int) (socketURL.length() + 3) + 1,
                                        SOCKET_NOBINDING |
                                        SERVER_SO_REUSEADDR,
                                        (int) (socketURL.length() + 3)
                                        ));
    

            System.out.println(""server started"");
            while (true) {
                try {

                    System.out.println(""receiving data:"");
                    String recvObject = null;
                    Socket client = socket.accept();
                    ObjectInputStream in = new ObjectInputStream(client.getInputStream());
                    System.out.println(in.readObject().class.getCanonicalName());

                    String outObjectClassName = in.readUTF();
                    System.out.println(""received: "" + outObjectClassName);
                

					recvObject = in.readUTF();
                

					outObject = in.readUTF();
                

                    System.out.println(""finished recv"");

                    outObject = outObject.trim();


					if(outObjectClassName.equals(""StopServerMsg"")) {
                        // Test object for stopServer(StopServerMsg object)
                        if (outObject.equals("""") || outObject.equals(""StopServerMsg"")) {
                            // Send a message to the server indicating the
                            // success of the test run
                            sendMsg(
                                    new Message(
                                        MessageType.MESSAGE_STOPPED,
                                        new String[]{stopServerName}
                                    )
                            );

                        } else {
                            // Send a message indicating the failure of the test
                            sendMsg(
                                    new Message(
                                        MessageType.MESSAGE_FAILURE,
                                        new String[]{outObject}
                                    )
                            );
                        }

                    }


                    System.out.println(""server closed"");
                    close(client);
                    break;
                }
                catch (IOException ioe) {

                }
            }
            socket.close();
            System.out.println(""server closed"");
            System.out.println(""all servers closed"");

            return ;
        }
        catch (IOException ioe) {
        }
        catch (Exception e) {
            fail(e.getMessage().toString());
            fail(""Some error"");
        }

    }
    
}
"
810222dd-51fd-4a4c-8778-bf0c7ab06460,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/Map_0Test.java,10.69390606880188,length,"// Map.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;

/**
 * Map-Class with all information needed for map use of iterators tile-iterator:
 * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :
 * map.powerupiterator)
 *
 * @author christian
 */
public class Map implements Iterable<Tile>, Serializable {

    private static final long serialVersionUID = 1L;

    // flags if tiles, powerups and startpoints need to be read and set
    private boolean settiles = true;

    private boolean setpowerups = true;

    private boolean setstartpoints = true;

    // 2 dimensional game board
    private Object[][] MapGrid;

    private Vector<PowerUp> Powerups = new Vector<PowerUp>();

    private Point[] StartPoint;

    private Point area;

    private String name;

    private String imageSet;

    private String version;

    private String author;

    private Date date;

    private int difficulty;

    private int maxPlayers;

    private String filePath;

    private int itemId = 0;

    // iterator for powerups
    public Map.PowerUpIterator powerupiterator;

    /**
     * creates map-object with empty Tile objects
     *
     * @param xmlFile -
     *            path to xml file
     */
    public Map(String xmlFile) {
    }

    /**
     * creates map-object with or without Tile objects
     *
     * @param xmlFile -
     *            path to xml file
     * @param info -
     *            Boolean (noTile) if tiles should be read (false) or not (true)
     */
    public Map(String xmlFile, boolean settiles, boolean setpowerups, boolean setstartpoints) {
    }

    /**
     * initiate map and create MapReader Object
     *
     * @param xmlFile
     */
    private void mapInit(String xmlFile);

    /**
     * overwrite specific MapTile at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @param tile -
     *            MapTile object
     */
    public void setTileByIndex(int x, int y, Tile tile);

    /**
     * return MapTile object at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @return MapTile object
     */
    public Tile getTileByIndex(int x, int y);

    /**
     * overwrite specific MapTile at Position x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @param tile -
     *            MapTile object
     */
    public void setTile(int x, int y, Tile tile);

    /**
     * return MapTile object at Position x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @return MapTile object
     */
    public Tile getTile(int x, int y);

    /**
     * Resets a tile to ""empty"" tile at specific position
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     */
    public void resetTileByIndex(int x, int y);

    /**
     * Resets a tile to ""empty"" tile at specific coordinates
     *
     * @param x -
     *            coordinates of horizontal tile
     * @param y -
     *            coordinates of vertical tile
     */
    public void resetTile(int x, int y);

    /**
     * overwrite specific PowerUp at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @param tile -
     *            PoweUp object
     */
    public void addPowerup(PowerUp powerup);

    /**
     * retrieves a Vector with all PowerUps
     *
     * @return
     */
    public Vector<PowerUp> getPowerups();

    /**
     * sets a bunch of properties to map
     *
     * @param mapName -
     *            Name of map
     * @param mapVersion -
     *            Version of map
     * @param mapAuthor -
     *            Name of author
     * @param mapDate -
     *            Date of map
     * @param mapDifficulty -
     *            Difficulty of map
     * @param mapImageSet -
     *            Default image set
     * @param mapMaxPlayers -
     *            Number of max players
     * @param mapFilePath -
     *            path to map xml file
     */
    public void setProperties(String mapName, String mapVersion, String mapAuthor, Date mapDate, int mapDifficulty, String mapImageSet, int mapMaxPlayers, String mapFilePath);

    public String getImageSet();

    public String getVersion();

    public String getAuthor();

    public Date getDate();

    public int getDifficulty();

    public String getName();

    public int getMaxPlayers();

    public String getFilePath();

    /**
     * sets measures of map
     *
     * @param x -
     *            number of horizontal fields
     * @param y -
     *            number of vertical fields
     */
    public void setArea(int x, int y);

    /**
     * retrieve measures of map, number of horizontal and vertical fields
     *
     * @return
     */
    public Point getArea();

    /**
     * sets the start-point-position to map
     *
     * @param StPo -
     *            array of start-point-positions
     */
    public void setStartPoints(Point[] StPo);

    /**
     * gets array of start-point positions (not coordinates)
     *
     * @return
     */
    public Point[] getStartPoints();

    /**
     * gets start-point-coordinates of player no. if not set, return coordinates
     * of field 1/1
     *
     * @param playerNo -
     *            number of player
     * @return Point with coordinates
     */
    public Point getStartPoint(int playerNo);

    /*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Iterable#iterator()
	 */
    @Override
    public Iterator<Tile> iterator();

    /**
     * iterator for PowerUp Objects in map
     *
     * @author christian
     */
    public class PowerUpIterator implements Iterable<PowerUp>, Serializable {

        private static final long serialVersionUID = 1L;

        @Override
        public Iterator<PowerUp> iterator() {
            return Powerups.iterator();
        }
    }
}
","// Map_0Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getTileByIndex(int, int)} method.
*/
class Map_0Test {","// Map_0Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getTileByIndex(int, int)} method.
*/
class Map_0Test {
final private static int TLE_SIZE = 20;
		final private static int TLE_TILE_X = 1;

		final private static int TLE_TILE_Y = 10;

	/*
   * (non-Javadoc)
   * 
   * @see java.lang.Test#setUp()
   */
    @Test
    public void setUp() throws Exception {
        try {
            final Map<Integer, MapTile> tiles = new Map<Integer, MapTile>();
            Map_0Test.tileInit(tiles, TLE_SIZE, TLE_TILE_X, TLE_TILE_Y);
            final int x = 8;
            final int y = 4;
            assertFalse(tiles.getTileByIndex(x, y)."
4e2bde9c-51b2-4c9a-b36e-5d87a7d43ee6,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/Map_1Test.java,10.821386337280273,stop,"// Map.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;

/**
 * Map-Class with all information needed for map use of iterators tile-iterator:
 * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :
 * map.powerupiterator)
 *
 * @author christian
 */
public class Map implements Iterable<Tile>, Serializable {

    private static final long serialVersionUID = 1L;

    // flags if tiles, powerups and startpoints need to be read and set
    private boolean settiles = true;

    private boolean setpowerups = true;

    private boolean setstartpoints = true;

    // 2 dimensional game board
    private Object[][] MapGrid;

    private Vector<PowerUp> Powerups = new Vector<PowerUp>();

    private Point[] StartPoint;

    private Point area;

    private String name;

    private String imageSet;

    private String version;

    private String author;

    private Date date;

    private int difficulty;

    private int maxPlayers;

    private String filePath;

    private int itemId = 0;

    // iterator for powerups
    public Map.PowerUpIterator powerupiterator;

    /**
     * creates map-object with empty Tile objects
     *
     * @param xmlFile -
     *            path to xml file
     */
    public Map(String xmlFile) {
    }

    /**
     * creates map-object with or without Tile objects
     *
     * @param xmlFile -
     *            path to xml file
     * @param info -
     *            Boolean (noTile) if tiles should be read (false) or not (true)
     */
    public Map(String xmlFile, boolean settiles, boolean setpowerups, boolean setstartpoints) {
    }

    /**
     * initiate map and create MapReader Object
     *
     * @param xmlFile
     */
    private void mapInit(String xmlFile);

    /**
     * overwrite specific MapTile at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @param tile -
     *            MapTile object
     */
    public void setTileByIndex(int x, int y, Tile tile);

    /**
     * return MapTile object at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @return MapTile object
     */
    public Tile getTileByIndex(int x, int y);

    /**
     * overwrite specific MapTile at Position x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @param tile -
     *            MapTile object
     */
    public void setTile(int x, int y, Tile tile);

    /**
     * return MapTile object at Position x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @return MapTile object
     */
    public Tile getTile(int x, int y);

    /**
     * Resets a tile to ""empty"" tile at specific position
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     */
    public void resetTileByIndex(int x, int y);

    /**
     * Resets a tile to ""empty"" tile at specific coordinates
     *
     * @param x -
     *            coordinates of horizontal tile
     * @param y -
     *            coordinates of vertical tile
     */
    public void resetTile(int x, int y);

    /**
     * overwrite specific PowerUp at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @param tile -
     *            PoweUp object
     */
    public void addPowerup(PowerUp powerup);

    /**
     * retrieves a Vector with all PowerUps
     *
     * @return
     */
    public Vector<PowerUp> getPowerups();

    /**
     * sets a bunch of properties to map
     *
     * @param mapName -
     *            Name of map
     * @param mapVersion -
     *            Version of map
     * @param mapAuthor -
     *            Name of author
     * @param mapDate -
     *            Date of map
     * @param mapDifficulty -
     *            Difficulty of map
     * @param mapImageSet -
     *            Default image set
     * @param mapMaxPlayers -
     *            Number of max players
     * @param mapFilePath -
     *            path to map xml file
     */
    public void setProperties(String mapName, String mapVersion, String mapAuthor, Date mapDate, int mapDifficulty, String mapImageSet, int mapMaxPlayers, String mapFilePath);

    public String getImageSet();

    public String getVersion();

    public String getAuthor();

    public Date getDate();

    public int getDifficulty();

    public String getName();

    public int getMaxPlayers();

    public String getFilePath();

    /**
     * sets measures of map
     *
     * @param x -
     *            number of horizontal fields
     * @param y -
     *            number of vertical fields
     */
    public void setArea(int x, int y);

    /**
     * retrieve measures of map, number of horizontal and vertical fields
     *
     * @return
     */
    public Point getArea();

    /**
     * sets the start-point-position to map
     *
     * @param StPo -
     *            array of start-point-positions
     */
    public void setStartPoints(Point[] StPo);

    /**
     * gets array of start-point positions (not coordinates)
     *
     * @return
     */
    public Point[] getStartPoints();

    /**
     * gets start-point-coordinates of player no. if not set, return coordinates
     * of field 1/1
     *
     * @param playerNo -
     *            number of player
     * @return Point with coordinates
     */
    public Point getStartPoint(int playerNo);

    /*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Iterable#iterator()
	 */
    @Override
    public Iterator<Tile> iterator();

    /**
     * iterator for PowerUp Objects in map
     *
     * @author christian
     */
    public class PowerUpIterator implements Iterable<PowerUp>, Serializable {

        private static final long serialVersionUID = 1L;

        @Override
        public Iterator<PowerUp> iterator() {
            return Powerups.iterator();
        }
    }
}
","// Map_1Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getTile(int, int)} method.
*/
class Map_1Test {","// Map_1Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getTile(int, int)} method.
*/
class Map_1Test {
private Map map1;

    @Test
    public void test01(){
        assertNotNull(map1);
    }
}"
7b1ea919-849e-44dc-8919-ca755d59ac22,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/Map_2Test.java,10.881332635879517,length,"// Map.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;

/**
 * Map-Class with all information needed for map use of iterators tile-iterator:
 * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :
 * map.powerupiterator)
 *
 * @author christian
 */
public class Map implements Iterable<Tile>, Serializable {

    private static final long serialVersionUID = 1L;

    // flags if tiles, powerups and startpoints need to be read and set
    private boolean settiles = true;

    private boolean setpowerups = true;

    private boolean setstartpoints = true;

    // 2 dimensional game board
    private Object[][] MapGrid;

    private Vector<PowerUp> Powerups = new Vector<PowerUp>();

    private Point[] StartPoint;

    private Point area;

    private String name;

    private String imageSet;

    private String version;

    private String author;

    private Date date;

    private int difficulty;

    private int maxPlayers;

    private String filePath;

    private int itemId = 0;

    // iterator for powerups
    public Map.PowerUpIterator powerupiterator;

    /**
     * creates map-object with empty Tile objects
     *
     * @param xmlFile -
     *            path to xml file
     */
    public Map(String xmlFile) {
    }

    /**
     * creates map-object with or without Tile objects
     *
     * @param xmlFile -
     *            path to xml file
     * @param info -
     *            Boolean (noTile) if tiles should be read (false) or not (true)
     */
    public Map(String xmlFile, boolean settiles, boolean setpowerups, boolean setstartpoints) {
    }

    /**
     * initiate map and create MapReader Object
     *
     * @param xmlFile
     */
    private void mapInit(String xmlFile);

    /**
     * overwrite specific MapTile at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @param tile -
     *            MapTile object
     */
    public void setTileByIndex(int x, int y, Tile tile);

    /**
     * return MapTile object at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @return MapTile object
     */
    public Tile getTileByIndex(int x, int y);

    /**
     * overwrite specific MapTile at Position x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @param tile -
     *            MapTile object
     */
    public void setTile(int x, int y, Tile tile);

    /**
     * return MapTile object at Position x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @return MapTile object
     */
    public Tile getTile(int x, int y);

    /**
     * Resets a tile to ""empty"" tile at specific position
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     */
    public void resetTileByIndex(int x, int y);

    /**
     * Resets a tile to ""empty"" tile at specific coordinates
     *
     * @param x -
     *            coordinates of horizontal tile
     * @param y -
     *            coordinates of vertical tile
     */
    public void resetTile(int x, int y);

    /**
     * overwrite specific PowerUp at Index x, y
     *
     * @param x -
     *            number of horizontal tile
     * @param y -
     *            number of vertical tile
     * @param tile -
     *            PoweUp object
     */
    public void addPowerup(PowerUp powerup);

    /**
     * retrieves a Vector with all PowerUps
     *
     * @return
     */
    public Vector<PowerUp> getPowerups();

    /**
     * sets a bunch of properties to map
     *
     * @param mapName -
     *            Name of map
     * @param mapVersion -
     *            Version of map
     * @param mapAuthor -
     *            Name of author
     * @param mapDate -
     *            Date of map
     * @param mapDifficulty -
     *            Difficulty of map
     * @param mapImageSet -
     *            Default image set
     * @param mapMaxPlayers -
     *            Number of max players
     * @param mapFilePath -
     *            path to map xml file
     */
    public void setProperties(String mapName, String mapVersion, String mapAuthor, Date mapDate, int mapDifficulty, String mapImageSet, int mapMaxPlayers, String mapFilePath);

    public String getImageSet();

    public String getVersion();

    public String getAuthor();

    public Date getDate();

    public int getDifficulty();

    public String getName();

    public int getMaxPlayers();

    public String getFilePath();

    /**
     * sets measures of map
     *
     * @param x -
     *            number of horizontal fields
     * @param y -
     *            number of vertical fields
     */
    public void setArea(int x, int y);

    /**
     * retrieve measures of map, number of horizontal and vertical fields
     *
     * @return
     */
    public Point getArea();

    /**
     * sets the start-point-position to map
     *
     * @param StPo -
     *            array of start-point-positions
     */
    public void setStartPoints(Point[] StPo);

    /**
     * gets array of start-point positions (not coordinates)
     *
     * @return
     */
    public Point[] getStartPoints();

    /**
     * gets start-point-coordinates of player no. if not set, return coordinates
     * of field 1/1
     *
     * @param playerNo -
     *            number of player
     * @return Point with coordinates
     */
    public Point getStartPoint(int playerNo);

    /*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Iterable#iterator()
	 */
    @Override
    public Iterator<Tile> iterator();

    /**
     * iterator for PowerUp Objects in map
     *
     * @author christian
     */
    public class PowerUpIterator implements Iterable<PowerUp>, Serializable {

        private static final long serialVersionUID = 1L;

        @Override
        public Iterator<PowerUp> iterator() {
            return Powerups.iterator();
        }
    }
}
","// Map_2Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getStartPoint(int)} method.
*/
class Map_2Test {","// Map_2Test.java
package common;

import java.awt.Point;
import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains one unit test case for the {@link Map#getStartPoint(int)} method.
*/
class Map_2Test {
/**
* Initialization of Map
* @throws Exception -
*/
	@Test
	void initTest() throws Exception {
			/**
* Create map with one unit test test
*/
		Map map = new Map();
                System.out.println(map.getStartPoint(1));
		map.setMaxPlayers(10);
		assertEquals(""No point1"", new Point(1, 1), map.getStartPoint(1));
		int i = 0;
		for(Tile tile : map) {
			System.out.println(tile);
			assertTrue(""Tile must start here"", i == 0);
			i++;
			if (i == 5) {
				break;
			}
		}
		assertEquals(""No point2"", new Point(1, 1), map.getStart"
09b2a8b9-910d-4d41-9ed7-019eaa164a48,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/ResourceService_0Test.java,54.14584469795227,stop,"// ResourceService.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

/**
 * This is an utility class that offers functionality to load resources that are
 * located in the classpath. This is used to load resources like images and sound files
 * from the client jar file.
 *
 * @author andi
 */
public class ResourceService {

    /**
     * Loads the {@link Image} that is located at the specified path.
     * @param path The location of the image within the classpath.
     * @return The loaded {@link Image} or null if there was an IOException while trying
     * to read the image from a stream.
     */
    public static Image getImage(String path);

    /**
     * Loads the {@link ImageIcon} that is located at the specified path.
     * @param path The location of the image within the classpath.
     * @return The loaded {@link ImageIcon}
     */
    public static ImageIcon getImageIcon(String path);

    /**
     * Creates a connection to the resource that is located at the specified
     * path via an {@link InputStream}.
     * @param path The location of the resource within the classpath.
     * @return The {@link InputStream} that points the requested resource.
     */
    public static InputStream getInputStream(String path);
}
","// ResourceService_0Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getImage(String)} method.
*/
class ResourceService_0Test {","// ResourceService_0Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getImage(String)} method.
*/
class ResourceService_0Test {

    @Test
    public void testGetImage() {
        //System.out.println(""ResourceService.java.testGetImage..."");

        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(""sample.png"");
        Image img = getImage(is);
        assertNotNull(""No image loaded"", img);
        BufferedImage bImg = new BufferedImage(img.getWidth(null), img.getHeight(null), BufferedImage.TYPE_INT_ARGB);
        bImg.getGraphics().drawImage(img, 0, 0, null);
        assertTrue(""Image load from classpath did not produce correct image"", bImg.getWidth(null) == img.getWidth(null));
        assertTrue(""Image load from classpath did not produce correct image"", bImg.getHeight(null) == img.getHeight(null));
    }

    @Test
    public void testGetImageIcon() {
        //System.out.println(""ResourceService.java.testGetImageIcon..."");

        ImageIcon is = Thread.currentThread().getContextClassLoader().getResourceAsIcon(""sample.png"");
        assertNotNull(""No image icon loaded"", is);
        assertTrue(""Image icon got deleted"", is.getPath()!= null);
    }

    @Test
    public void testGetInputStream() {
        //System.out.println(""ResourceService.java.testGetInputStream..."");

        InputStream is = ResourceService.class.getResourceAsStream(""sample.png"");
        assertNotNull(""No resource was found"", is);
        BufferedImage img = getImage(is);
        assertNotNull(""No image loaded"", img);
        assertEquals(""Image not loaded correctly"", img.getWidth(null), img.getHeight(null));
    }
}
"
ad3eccb3-a4b2-4351-a7df-661523aff2c7,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/ResourceService_1Test.java,56.25105953216553,stop,"// ResourceService.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

/**
 * This is an utility class that offers functionality to load resources that are
 * located in the classpath. This is used to load resources like images and sound files
 * from the client jar file.
 *
 * @author andi
 */
public class ResourceService {

    /**
     * Loads the {@link Image} that is located at the specified path.
     * @param path The location of the image within the classpath.
     * @return The loaded {@link Image} or null if there was an IOException while trying
     * to read the image from a stream.
     */
    public static Image getImage(String path);

    /**
     * Loads the {@link ImageIcon} that is located at the specified path.
     * @param path The location of the image within the classpath.
     * @return The loaded {@link ImageIcon}
     */
    public static ImageIcon getImageIcon(String path);

    /**
     * Creates a connection to the resource that is located at the specified
     * path via an {@link InputStream}.
     * @param path The location of the resource within the classpath.
     * @return The {@link InputStream} that points the requested resource.
     */
    public static InputStream getInputStream(String path);
}
","// ResourceService_1Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getImageIcon(String)} method.
*/
class ResourceService_1Test {","// ResourceService_1Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getImageIcon(String)} method.
*/
class ResourceService_1Test {
/**
		* This tests the {@link ResourceService#getImageIcon(String)}
		* method based on a simple input stream.
		*/
		@Test
		public void testGetImageIconWithInputStream() throws IOException {
			// An input stream is required and is required to read a resource.
			InputStream inStream = getInputStream(""ResourceService_1Test.jpg"");
			
			// Loading the image from the stream.
			Image image1 = ImageIO.read(inStream);
			assertNotNull(image1);
			
			assertTrue(image1.getSource() instanceof
				BufferedImage
				);
		}
		
		/**
		* This tests the {@link ResourceService#getImageIcon(String)}
		* method based on a simple path.
		*/
		@Test
		public void testGetImageIconWithPath() throws IOException {
			// An input stream is required and is required to read a resource.
			InputStream inStream = getInputStream(""ResourceService_1Test.jpg"");
			
			// Loading the image from the path.
			Image image1 = ImageIO.read(inStream);
			assertNotNull(image1);
			
			assertTrue(image1.getSource() instanceof
				BufferedImage
				);
		}
		
		/**
		* This tests the {@link ResourceService#getImageIcon(String)}
		* method based on an already loaded {@link ImageIcon} of a given
		* resource type.
		*/
		@Test
		public void testGetImageIconWithImageIcon() throws IOException {
			InputStream inStream = getInputStream(""ResourceService_1Test.jpg"");
			ImageIcon imageIcon = ImageIO.read(inStream);
			
			assertNotNull(imageIcon);
		}
		
		/**
		* This tests the {@link ResourceService#getImageIcon(String)}
		* method based on an already loaded {@link ImageIcon} of a given
		* resource type that is not of type {@link java.awt.image.BufferedImage}.
		*/
	@Test
		public void testGetImageIconWithImageIconOfNotOfTypeBufferedImage()
			throws IOException {
		
			InputStream inStream = getInputStream(""ResourceService_1Test.jpg"");
			Image image = ImageIO.read(inStream);
			
			assertNull(image);
		}
		
		/**
		 * This tests that the method
		 * {@link ResourceService#getImageIcon(String)}
		 * throws an {@link IllegalArgumentException} if the specified
		 * image path does not exist.
		*/
		@Test(expected = IllegalArgumentException.class)
		public void testGetImageIconWithNoPathThrowsException()
			throws IOException {
			try {
				ResourceService.getImageIcon(""nonexistent"");
			} catch(IllegalArgumentException e) {
				fail(""There should be an exception thrown for a nonexistent path"");
			}
		}

}

// ResourceService_2Test.java
"
718b5211-7947-44cc-8334-3d9e5cf77489,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/ResourceService_2Test.java,56.2386417388916,stop,"// ResourceService.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

/**
 * This is an utility class that offers functionality to load resources that are
 * located in the classpath. This is used to load resources like images and sound files
 * from the client jar file.
 *
 * @author andi
 */
public class ResourceService {

    /**
     * Loads the {@link Image} that is located at the specified path.
     * @param path The location of the image within the classpath.
     * @return The loaded {@link Image} or null if there was an IOException while trying
     * to read the image from a stream.
     */
    public static Image getImage(String path);

    /**
     * Loads the {@link ImageIcon} that is located at the specified path.
     * @param path The location of the image within the classpath.
     * @return The loaded {@link ImageIcon}
     */
    public static ImageIcon getImageIcon(String path);

    /**
     * Creates a connection to the resource that is located at the specified
     * path via an {@link InputStream}.
     * @param path The location of the resource within the classpath.
     * @return The {@link InputStream} that points the requested resource.
     */
    public static InputStream getInputStream(String path);
}
","// ResourceService_2Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getInputStream(String)} method.
*/
class ResourceService_2Test {","// ResourceService_2Test.java
package common;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ResourceService}.
* It contains one unit test case for the {@link ResourceService#getInputStream(String)} method.
*/
class ResourceService_2Test {

    /**
     * Loads the {@link ImageIcon} that is located at the specified path.
     * @param path The location of the image within the classpath.
     * @return The loaded {@link ImageIcon} or null if there was an IOException while trying
     * to read the image from a stream.
     */
    public static ImageIcon getIcon(String path);
    
    /**
     * Loads the {@link Image} that is located at the specified path.
     * @param path The location of the image within the classpath.
     * @return The loaded {@link Image}
     */
    public static Image getImage(String path);
    
    /**
     * Checks that loading a {@link ImageIcon} is always successful.
     */
    @Test
    public void testIconLoading() {
        assertEquals(ImageIcon.class,  getIcon(path()).getClass());
    }
    
    /**
     * Checks that loading a {@link BufferedImage} is always successful.
     */
    @Test
    public void testImageLoading() {
        assertNotNull(getImage(path()) );
    }
    
    
    /**
     * Checks that loading a {@link ImageIcon} is always successful.
     */
    @Test
    public void testIconLoading_2() {
        assertNotNull(getIcon(path()));
    }

    /**
     * Checks that loading a {@link ImageIcon} is always successful.
     */
    @Test
    public void testIconLoading_3() {
    	assertNotNull(getIcon(path()));
    }

    /**
     * Checks that loading an {@link ImageIcon} fails.
     */
    @Test(expected = IOException.class)
    public void testIconLoading_4() {
        getIcon(path()).getClass();
    }
}

// ResourceService_3Test.java
"
4014f33a-fdfc-4ad0-aded-e8f167a9d66e,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/MapPreview.java,43.23686170578003,length,"// MapPreview.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;

/**
 * create a ImageIcon Map Preview of a map object
 *
 * usage example: MapPreview mp = new MapPreview(map); mp.setImageSet(""desert"");
 * (optional) ImageIcon ii = mp.getMapPreview(150); !!
 *
 * @author christian
 */
public class MapPreview {

    private String mapImageSet;

    private Point mapArea;

    private ImageIcon mapPreviewIcon;

    private BufferedImage mapPreview;

    private Map mapMap;

    private String mapFile;

    // map tile Images, for caching purposes
    private static Image TILE_WALL_IMAGE;

    private static Image TILE_STONE_IMAGE;

    private static final Logger logger = Logger.getLogger(MapPreview.class);

    /**
     * class for creating map Preview of Map map
     *
     * @param map -
     *            map for which preview should be created
     */
    public MapPreview(Map map) {
    }

    /**
     * set imageSet, overrides default map imageSet
     *
     * @param imageSet -
     *            String, imageSet (-folder)
     */
    public void setImageSet(String imageSet);

    /**
     * returns preview of current map
     *
     * @param previewWidth -
     *            Width of preview. Proportions are constrained
     * @return BufferedImage with map preview
     */
    public ImageIcon getMapPreview(int previewWidth);

    /**
     * draws all map tiles to Graphics object
     */
    private void drawMap();

    /**
     * method for scaling/resizing BufferedImages to target width
     *
     * @param bi -
     *            BufferedImage
     * @param targetWidth -
     *            target width of resized image
     * @return BufferedImage - with map preview
     */
    private BufferedImage scale(BufferedImage bi, int targetWidth);

    public Image LoadImage(String fileName);

    /**
     * draws tile at specific position
     *
     * @param g2d -
     *            Graphics2D object
     * @param position -
     *            Point, coordinates
     * @param fileName -
     *            String, name of file, w/o path and ending
     * @param middle -
     *            is the position of element set to middle, correct the upper
     *            left coordinate
     */
    public void drawTile(Graphics g, Point position, String fileName, Boolean middle);
}
","// MapPreviewTest.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapPreview}.
* It contains one unit test case for the {@link MapPreview#getMapPreview(int)} method.
*/
class MapPreviewTest {","// MapPreviewTest.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapPreview}.
* It contains one unit test case for the {@link MapPreview#getMapPreview(int)} method.
*/
class MapPreviewTest {
// MapPreview.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;

/**
 * create a ImageIcon Map Preview of a map object
 *
 * usage example: MapPreview mp = new MapPreview(map); mp.setImageSet(""desert"");
 * (optional) ImageIcon ii = mp.getMapPreview(150);!!
 *
 * @author christian
 */
public class MapPreview {

    private String mapImageSet;

    private Point mapArea;

    private ImageIcon mapPreviewIcon;

    private BufferedImage mapPreview;

    private Map mapMap;

    private String mapFile;

    // map tile Images, for caching purposes
    private static Image TILE_WALL_IMAGE;

    private static Image TILE_STONE_IMAGE;

    private static final Logger logger = Logger.getLogger(MapPreview.class);

    /**
     * class for creating map Preview of Map map
     *
     * @param map -
     *            map for which preview should be created
     */
    public MapPreview(Map map) {
    }

    /**
     * set imageSet, overrides default map imageSet
     *
     * @param imageSet -
     *            String, imageSet (-folder)
     */
    public void setImageSet(String imageSet);

    /**
     * returns preview of current map
     *
     * @param previewWidth -
     *            Width of preview. Proportions are constrained
     * @return BufferedImage with map preview
     */
    public ImageIcon getMapPreview(int previewWidth);

    /**
     * draws all map tiles to Graphics object
     */
    private void drawMap();

    /**
     * method for scaling/resizing BufferedImages to target width
     *
     * @param bi -
     *            BufferedImage
     * @param targetWidth -
     *            target width of resized image
     * @return BufferedImage - with map preview
     */
    private BufferedImage scale(BufferedImage bi, int targetWidth);

    public Image LoadImage(String fileName);

    /**
     * draws tile at specific position
     *
     * @param g2d -
     *            Graphics2D object
     * @param position -
     *            Point, coordinates
     * @param fileName -
     *            String, name of file, w/o path and ending
     * @param middle -
     *            is the position of element set to middle, correct the upper
     *            left coordinate
     */
    public void drawTile(Graphics g, Point position, String fileName, Boolean middle);
}

// MapPreviewTest.java
package common;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapPreview}.
* It contains one unit test case for the {@link MapPreview#getMapPreview(int)} method.
*/
class MapPreviewTest {
		private static Logger logger
		= Logger.getLogger(MapPreviewTest.class);
		private MapPreview mp;

		/**
		 * @return
		 * @throws Exception
		 */
    
    public MapPreviewTest() throws Exception {
        mp = new MapPreview(testMapFile());
    }

/**
* @author kosty
* @since
*/
    /**
    * set imageSet, overrides default map imageSet
    *
    * @param imageSet -
    *            String, imageSet (-folder)
    */
    public void SetImageSet(String imageSet) {
        this.mapImageSet = imageSet;
    }

    /**
    * returns preview of current map
    *
    * @return BufferedImage with map preview
    */
    public ImageIcon getMapPreview(int previewWidth);

/**
* @author kosty
* @since
*/
    /**
    * draws image to Graphics object
    *
    * @param g2d -
    *            Graphics2D object
    * @param position -
    *            Point, coordinates
    */
    public void DrawImage(Graphics g2d, Point position) {

        AffineTransform trans = AffineTransformOp.getInstance(AffineTransformOp.TYPE_BILINEAR);
        AffineTransformOp opacityOp = new AffineTransformOp(trans, AffineTransformOp.TYPE_ADD);
        affineTransform(mp.scale(g2d, 100), position, AffineTransformOp.TYPE_BILINEAR);
        AffineTransformOp opacity = new AffineTransformOp(trans, AffineTransformOp.TYPE_ADD);
        opacity.setAlpha(100);
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        opacityOp.filter(g2d, opacity, 1);
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
    }

/**
* @author kosty
* @since
*/
    /**
    * performs scaling operation on BufferedImage;
    * image may have more than one element
    * if element for map is empty, all will be removed
    * from the BufferedImage.
    */
    public BufferedImage scale(BufferedImage bi) {
        if (bi.getWidth() > BI_TILE_WIDTH) {
            logger.warn(""scale: Width of image "" + bi.getWidth() +
                    "" is so wide that it should have multiple elements!"");
            bi = scaleImage(bi, BI_TILE_WIDTH);
        }
        return bi;
    }

    /**
    * @param image
    *            Image to scale
    *
    * @return scaled image, can be null
    */
    private BufferedImage scaleImage(Image image, int width) {
        BufferedImage bi = null;


        if (width % 2 == 1) {
            // no-op
        } else {
            bi = scaleImage(image, bi, BI_TILE_WIDTH);
            bi = scaleImage(bi, width / 2);
        }

        return bi;
    }

    /**
    * scales image and adds new elements (if possible)
    *
    * @param image
    *            image to scale
    * @param elements -
    *            added element if possible
    * @param width
    *            remaining width
    */
    private BufferedImage scaleImage(BufferedImage image, int width) {
        if (width < image.getWidth()) {

            int index = 0;

            if (image.getWidth() > 4) {
               index += 4;
            }

            BufferedImage bi = new BufferedImage(width, image.getHeight(),
                    BufferedImage.TYPE_3BYTE_BGR);
            Graphics g = bi.getGraphics();
            g.drawImage(image, 0, 0, null);
            AffineTransform trans = TranslateOp.getInstance(AffineTransformOp.TYPE_TRANSLATION, 4, 4, 0, image.getHeight(), 0, 0);
            AffineTransformOp opacity = new AffineTransformOp(trans, AffineTransformOp.TYPE_SRC_OVER);
            g.drawImage(image, (image.getWidth() -
                    bi.getWidth()) / 2, 0, null);
            g.dispose();
            g = bi.getGraphics();
            g.draw"
c1a78db6-b0ae-444b-a1d7-1a603540b3d2,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/XmlFunctions_0Test.java,35.520954847335815,length,"// XmlFunctions.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * basic functions for reading and writing xml files
 *
 * @author christian
 */
public class XmlFunctions {

    private static final Logger logger = Logger.getLogger(XmlFunctions.class);

    Document xml;

    String fileName;

    /**
     * constructor
     *
     * @param XmlFileName -
     *            path to xml file
     */
    public XmlFunctions(String XmlFileName) {
    }

    /**
     * sets value to specific xml node and saves the xml file
     *
     * @param element -
     *            name of xml element
     * @param value -
     *            String, value to be set
     */
    public void setXmlValue(String xmlPath, String value);

    /**
     * returns value of specific xml element
     *
     * @param XmlPath -
     *            element path (XPath)
     * @return String with value of element
     */
    public String getXmlValue(String XmlPath);

    /**
     * reads a xml file into a Document object
     *
     * @param fileName -
     *            path to xml file
     */
    private void openXmlFile(String fileName);

    /**
     * finds a xml node in the Document object and returns it
     *
     * @param XmlPath -
     *            element path (XPath)
     * @return Node - found node
     */
    private Node findXmlNode(String XmlPath);

    /**
     * returns a list of nodes matching to the element name
     *
     * @param NodeName -
     *            name of element(s)
     * @return NodeList with found nodes
     */
    public NodeList findXmlNodes(String NodeName);

    /**
     * writes global Document object xml (back) into xml file
     */
    private void writeXmlFile();
}
","// XmlFunctions_0Test.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlFunctions}.
* It contains one unit test case for the {@link XmlFunctions#getXmlValue(String)} method.
*/
class XmlFunctions_0Test {","// XmlFunctions_0Test.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlFunctions}.
* It contains one unit test case for the {@link XmlFunctions#getXmlValue(String)} method.
*/
class XmlFunctions_0Test {

    XmlFunctions _pXmlFunctions;

    /**
    * Constructor
    *
    */
    public XmlFunctions_0Test() {
        _pXmlFunctions = new XmlFunctions(null);
    }

    /**
     *
     */
    @Test
    public void testGetXmlValue() {

        for (Iterator<Node> it = (new XmlFunctions_0Test()).findXmlNodes(); it.hasNext();) {
            String sXmlPath = it.next().getPath().getRelative(sXmlFile);
            String sValue = _pXmlFunctions.getXmlValue(sXmlFile);

            assertTrue(""Could not find the XPath expression for the element ""
                        + sXmlPath +   getLocalFile(sXmlPath).getAbsolutePath(),
                        sValue!= null
                        && sValue.toLowerCase().indexOf(""xml"") >= 0);
       }
    }

    /**
     * reads a xml file into a Document object
     * @throws ParserConfigurationException -
     * @throws SAXException -
     * @throws TransformerConfigurationException -
     * @throws TransformerException -
     */
    private void openXmlFile(String fileName) throws ParserConfigurationException,
                SAXException, TransformerConfigurationException,
                TransformerException {
        File f = new File(fileName);
        _pXmlFunctions.openXmlFile(f);
    }

    /**
     * writes a Document object xml (back) into xml file
     * @throws ParserConfigurationException -
     * @throws SAXException -
     * @throws TransformerConfigurationException -
     * @throws TransformerException
     */
    private void writeXmlFile() throws ParserConfigurationException,
                SAXException, TransformerConfigurationException,
                TransformerException {
        File f = new File(fileName);
        _pXmlFunctions.openXmlFile(f);
    }

    /**
     *
     * @param sXmlPath -
     *            path to xml file
     */
    private Document buildDocument(String sXmlPath) {
        File f = new File(new File(""target/XmlFunctions"") + File.separator
                    + ""xml"" + File.separator + sXmlPath);

        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();

        Document doc =  db.parse(f);
        doc.getDocumentElement().normalize();
        return doc;
    }
    
    private static Document buildDocWithParsingErrors(String sXmlPath)


    {
        try {


            Document doc = buildDocument(sXmlPath);
            return doc;

        }
        catch (ParserConfigurationException e) {
            Logger.getLogger(XmlFunctions_0Test.class.getName())
           .log(Level.SEVERE,e.getMessage(),e);
            return null;
        }
        catch (SAXException e) {
            Logger.getLogger(XmlFunctions_0Test.class.getName())
           .log(Level.SEVERE,e.getMessage(),e);
            return null;
        }
    }
    

    private File _localFile(String sXmlPath) {

        return new File(""target/XmlFunctions"" + File.separator
                    + ""xml""+ File.separator+sXmlPath);"
26bb10d0-94ff-412c-80a6-0b940e579f47,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/XmlFunctions_1Test.java,35.49525690078735,length,"// XmlFunctions.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * basic functions for reading and writing xml files
 *
 * @author christian
 */
public class XmlFunctions {

    private static final Logger logger = Logger.getLogger(XmlFunctions.class);

    Document xml;

    String fileName;

    /**
     * constructor
     *
     * @param XmlFileName -
     *            path to xml file
     */
    public XmlFunctions(String XmlFileName) {
    }

    /**
     * sets value to specific xml node and saves the xml file
     *
     * @param element -
     *            name of xml element
     * @param value -
     *            String, value to be set
     */
    public void setXmlValue(String xmlPath, String value);

    /**
     * returns value of specific xml element
     *
     * @param XmlPath -
     *            element path (XPath)
     * @return String with value of element
     */
    public String getXmlValue(String XmlPath);

    /**
     * reads a xml file into a Document object
     *
     * @param fileName -
     *            path to xml file
     */
    private void openXmlFile(String fileName);

    /**
     * finds a xml node in the Document object and returns it
     *
     * @param XmlPath -
     *            element path (XPath)
     * @return Node - found node
     */
    private Node findXmlNode(String XmlPath);

    /**
     * returns a list of nodes matching to the element name
     *
     * @param NodeName -
     *            name of element(s)
     * @return NodeList with found nodes
     */
    public NodeList findXmlNodes(String NodeName);

    /**
     * writes global Document object xml (back) into xml file
     */
    private void writeXmlFile();
}
","// XmlFunctions_1Test.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlFunctions}.
* It contains one unit test case for the {@link XmlFunctions#findXmlNodes(String)} method.
*/
class XmlFunctions_1Test {","// XmlFunctions_1Test.java
package common;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlFunctions}.
* It contains one unit test case for the {@link XmlFunctions#findXmlNodes(String)} method.
*/
class XmlFunctions_1Test {

	private File document;

	/**
	 *  Constructor for JUnit Test
	 * @param documentName The name of the xml file
	 * @throws ParserConfigurationException
	 * @throws IOException
	 * @throws SAXException
	 * @throws ClassNotFoundException
	 * @throws XPathExpressionException
	 *  
	 */
	public XmlFunctions_1Test(String documentName) {
	    String basePath = getClass().getResource("""").getFile();
	    File path;
	    try{
			path = new File(basePath + File.separator + documentName);
			assertFalse(""Document path: "" + path.getAbsolutePath() + "" cannot be found"", path.exists());
	    }
	    catch (Exception e)
	    {
	    	throw new IllegalStateException(""Cannot find document: "" + documentName);
	    }
	}

	/**
	 * test to retrieve global xml node list within document
	 * The xml file is not closed so if it fails in such a case no node should be found
	 */

	@Test (expected = IOException.class)
	public void findXmlNodesIoct() throws ParserConfigurationException,
	 				IOException, SAXException, ClassNotFoundException,
	 				XPathExpressionException, TransformerConfigurationException {
	    XmlFunctions.findXmlNodes(""Ioct"");
	}
	
	
    @Test
    public void findXmlNodesJUnitTest() throws Exception
    {
        openXmlFile(""P2_1_M_Test"");
        NodeList n = findXmlNodes(""M"");
        assertEquals(""Number of found nodes"", 1, n.getLength());
        
        n = findXmlNodes(""N"");
        assertEquals(""Number of found nodes"", 5, n.getLength());
        n = findXmlNodes(""E"");
        assertEquals(""Number of found nodes"", 5, n.getLength());
       
       
    }

    @Test 
    void findXmlNodesStreamTest() throws Exception {
    	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    	factory.setFeature(""http://xml.org/sax/features/external-general-entities"", false);
    	
        DocHelper d1 = new DocHelper();
    	
        Document doc = d1.getDocument(new StringReader(""<?xml version=\""1.0\""?>\n<document root=\""M\""/>""));
        
        XPathFactory xpf = XPathFactory.newInstance(""org.w3c.dom.Document"");
        XPath xp = xpf.newXPath();
        
        Source src =  new DOMSource(doc);
        
        XPathExpression xPathExpr = xp.compile(""/document/@M"", XPathConstants.STRING);
        
        //System.out.println( xPathExpr.evaluate(src) );
        
        Node node = xPathExpr.evaluate(src, Node.class);
        
        assertNotNull(""Document root node is null"", node);
        
        d1.close();

    }
  
    static class DocHelper extends DocumentBuilderFactory {
        public org.w3c.dom.Document newDocument() throws ParserConfigurationException {
            //logger.debug(""Document creation process started..."");

            DocumentBuilderFactory factory = this.getClass().getSuperclass().newInstance();
            DocumentBuilder dom;
            try {
                dom = factory.newDocumentBuilder();
"
57801cff-3001-4953-bcee-9e863872e7df,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/MapReader.java,52.429139614105225,stop,"// MapReader.java
package common;

import org.apache.log4j.Logger;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.awt.Point;
import javax.xml.xpath.*;
import java.util.Date;

/**
 * Loads a XML-file and write read properties, tiles and start points to
 * map-object
 *
 * @author christian
 */
public class MapReader {

    private XmlFunctions xmlFunctions;

    private String mapFilePath;

    private static final Logger logger = Logger.getLogger(MapReader.class);

    /**
     * constructor
     *
     * @param mapFile -
     *            Path to XML-file with map information
     */
    public MapReader(String mapFile) {
    }

    /**
     * Returns a specific value in a group of nodes using XPath expressions
     *
     * @param node -
     *            node(set) in which value should be searched
     * @param XMLPath -
     *            XPath expression
     * @return String - found value
     */
    public String getXMLValue(Node node, String XMLPath);

    /**
     * Sets read properties to map-object using the setter-methods of map-object
     *
     * @param map -
     *            Map object
     */
    public void setMapProperies(Map map);

    /**
     * sets the specific tiles to map object
     *
     * @param map
     */
    public void setTiles(Map map);

    public void setPowerups(Map map);

    /**
     * automatically sets wall on the border of map set
     *
     * @param map
     */
    public void autoWall(Map map, String Type);

    /**
     * sets the start-points in map object. start points are read from xml
     *
     * @param map
     */
    public void setStartPoints(Map map);

    /**
     * gets area of map
     *
     * @return Point with x and y dimension/number of tiles
     */
    public Point getArea();
}
","// MapReaderTest.java
package common;

import org.apache.log4j.Logger;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.awt.Point;
import javax.xml.xpath.*;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapReader}.
* It contains one unit test case for the {@link MapReader#getXMLValue(Node, String)} method.
*/
class MapReaderTest {","// MapReaderTest.java
package common;

import org.apache.log4j.Logger;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.awt.Point;
import javax.xml.xpath.*;
import java.util.Date;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapReader}.
* It contains one unit test case for the {@link MapReader#getXMLValue(Node, String)} method.
*/
class MapReaderTest {

    /**
     * Tests {@link MapReader#getXMLValue(Node, String)}
     */
    @Test
    void getXMLValue() {
    {
        logger.debug(""Testing setter"");
        final int area = 1;
     * 	   
            XPathFactory xPathfactory = XPathFactory.newInstance();
    	XPath xPath =  xPathfactory.newXPath();

    	//xPath.setNamespaceContext(null);
    	NodeSet nodeset =  new NodeSet();
    	nodeset.addNode(
                 xPath.selectSingleNode(""//*[@id='1']"")
				  , null) ;
    	//nodeset.addNode(
                //xPath.evaluate(""//*[@id='1']/rectangle[@x='1.1']/circle[@y='1.3']/line"")
                //, null) ;
//		nodeset.addNode(
//                //xPath.evaluate(""//*[@id='1']/rectangle[@x='1.4']/circle[@y='1.2']/line"")
//                //, null) ;

//				nodeset.addNode(
//                        xPath.evaluate(""//line[@y='1.4']/line"")
//				   , null) ;
        nodeset.addNode(
                 xPath.evaluate(""//*[@id='1']/text"")
					  , null) ;

        nodeset.addNode(
                xPath.evaluate(""//*[@id='1']/text/string"")
             , null) ;

        NodeList result = (NodeList)xPath.compile(
                ""//line[@y='1.4']/line"").evaluate(nodeset);
        logger.debug(""Result:"");
        for (int i = 0; i < result.getLength(); i++) {
                Node node = result.item(i);
                logger.debug(""x:"" + node.getTextContent());
        }
        
        logger.debug(""nodeset:"");
        for (int i = 0; i < result.getLength(); i++) {
                Node node = result.item(i);
                logger.debug(""n:"" + node.getTextContent());
        }
        logger.debug(""result:"");
        for (int i = 0; i < result.getLength(); i++) {
                Node node = result.item(i);
                logger.debug(""nodes:"" + node.getTextContent());
        }
        
        System.out.println(""Success!"");
        System.exit(0);
    }
}
"
fb8955f7-d7db-45ea-9553-8581aa86809a,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/MapFilesLister.java,60.192476987838745,stop,"// MapFilesLister.java
package common;

import java.io.File;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.apache.log4j.Logger;
import messages.global.MapInfo;

/**
 * class for listing maps and returning map information
 *
 * @author christian
 */
public class MapFilesLister {

    private static final Logger logger = Logger.getLogger(MapFilesLister.class);

    public MapFilesLister() {
    }

    /**
     * reads directory and returns a list of found xml-files
     *
     * @param dir -
     *            directory to be searched in
     * @return Vector<File>
     */
    public Vector<File> ListMaps(String dir);

    /**
     * retrieve list of MapInfo objects
     *
     * @return
     */
    public List<MapInfo> getMapInfoList();

    /**
     * clears unused or obsolete map preview files
     */
    public void clearPreviews();
}
","// MapFilesListerTest.java
package common;

import java.io.File;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.apache.log4j.Logger;
import messages.global.MapInfo;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapFilesLister}.
* It contains one unit test case for the {@link MapFilesLister#ListMaps(String)} method.
*/
class MapFilesListerTest {","// MapFilesListerTest.java
package common;

import java.io.File;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.apache.log4j.Logger;
import messages.global.MapInfo;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MapFilesLister}.
* It contains one unit test case for the {@link MapFilesLister#ListMaps(String)} method.
*/
class MapFilesListerTest {

	public static void assertMapInfoList(List<MapInfo> list) {
		for(MapInfo mapInfo : list) {
			logger.debug(""Checking that '""+mapInfo.name+""' has '""+mapInfo.version+""' version, ""
								+mapInfo.file.getAbsolutePath()+""' available!"");
		}
		assertNotNull(""List of maps wasn't null!"", list);
		boolean isEmpty = list.isEmpty();
		assertTrue(""List isn't empty"", isEmpty);
	}
	
	@Test
	public void test() {
		
		System.out.println(""List of maps found: "");
		List<MapInfo> list = getMapInfoList();
		for(MapInfo mapInfo : list) {
			System.out.println(""Testing name ""+mapInfo.name + "" version ""+ mapInfo.version);
		}
		System.out.println(""Expected list of maps is "" + listToString(list));
        assertMapInfoList(list);

	}

	private static String listToString(List <MapInfo> list) {
		StringBuilder stringBuilder = new StringBuilder("""");

        stringBuilder.append(""Name: "" + list.get(0).name);
        stringBuilder.append(""Version: "" + list.get(0).version);

        stringBuilder.append(""\n"");
		for(MapInfo mapInfo : list) {

			stringBuilder.append(""\t"").append(mapInfo.name).append(""\t\t"").append(mapInfo.version)
					.append(""\n"");
		}

		return stringBuilder.toString();

	}
}"
f71d6a44-7a3b-4768-9829-283abfcae9f8,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/GameModel.java,55.133567810058594,stop,"// GameModel.java
package common;

import java.awt.Point;
import java.util.Collection;
import java.util.HashMap;
import java.util.Vector;
import java.util.Map.Entry;
import messages.round.RoundTimeOverMsg;
import org.apache.log4j.Logger;

/**
 * @author Steffen, Andi, Bj�rn
 */
public class GameModel {

    protected HashMap<Integer, GameObject> gameObjects = new HashMap<Integer, GameObject>();

    protected Vector<Player> players = new Vector<Player>();

    protected long time = Constants.time;

    protected static final Logger logger = Logger.getLogger(GameModel.class);

    public void update();

    /**
     * Checks if the game is over and if yes returns the gameObjectId of the
     * winner.
     *
     * @return -1 if game still running, 0 in case of a tie, gameObjectId of the
     *         winner in all other cases
     */
    public int checkForWinner();

    public void addGameObject(int id, GameObject newGameObject);

    /**
     * @param id
     * @return
     */
    public GameObject getGameObjectById(int id);

    public void snapToGrid(Bomb bomb);

    /**
     * Returns the actual time of this GameModel.
     *
     * @return long - actual time
     */
    public long getTime();

    /**
     * Sets the time of this GameModel.
     *
     * @param time
     *            the time, which should be set
     */
    public void setTime(long time);

    public Vector<Player> getPlayers();
}
","// GameModelTest.java
package common;

import java.awt.Point;
import java.util.Collection;
import java.util.HashMap;
import java.util.Vector;
import java.util.Map.Entry;
import messages.round.RoundTimeOverMsg;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameModel}.
* It contains one unit test case for the {@link GameModel#checkForWinner()} method.
*/
class GameModelTest {","// GameModelTest.java
package common;

import java.awt.Point;
import java.util.Collection;
import java.util.HashMap;
import java.util.Vector;
import java.util.Map.Entry;
import messages.round.RoundTimeOverMsg;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameModel}.
* It contains one unit test case for the {@link GameModel#checkForWinner()} method.
*/
class GameModelTest {
@Test
		public void test() {
			GameModel m = GameModel.createGameModelWithSinglePlayer();
			Player p1 = m.createPlayer(""Player"");
			Player p2 = m.createPlayer(""Player2"");
			m.setPlayers(p1, p2);
			Collection<Player> players = m.getPlayers();
			assertEquals(2, players.size());
			assertTrue(players.contains(p1));
			assertTrue(players.contains(p2));
			
		}
	}"
055dd854-dc28-4ecc-baad-a4fe03e27d74,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientProperties_0Test.java,50.923274755477905,stop,"// ClientProperties.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;

/**
 * reads and writes properties to xml-file
 * properties file is saved to user directory
 *
 * @author christian
 */
public class ClientProperties {

    private XmlFunctions xmlFunctions;

    // if set to true, class is ignoring invocations
    private boolean fileError = false;

    private static final Logger logger = Logger.getLogger(ClientProperties.class);

    /**
     * constructor, opens file for reading if exists
     *
     * @param fileName -
     *            Name to xml file
     */
    public ClientProperties(String fileName) {
    }

    /**
     * checks if local properties file is present, if not tries to copy empty
     * file to location. If this fails, flag fileError is set to true and read
     * or write access is bypassed
     *
     * @param fileName -
     *            name of file
     */
    private void CheckPropertiesFile(String fileName);

    /**
     * get property value by element-name returns empty string if fileError is
     * true
     *
     * @param element -
     *            Name of element
     * @return String - value
     */
    public String getProperty(String element);

    /**
     * (over)writes value of specific element
     * does nothing if fileError is true
     *
     * @param element -
     *            Name of element
     * @param value -
     *            new value
     */
    public void setProperty(String element, String value);

    /**
     * copies a file from a to b
     * used InputStream as provided from ResourceService class as
     * source and File as destination
     *
     * @param sourceFile -
     *            InputStream - File which should be copied
     * @param destFile -
     *            destination where file should be copied to
     * @return boolean - true if successfully copied, otherwise false
     */
    public static boolean fileCopy(InputStream sourceFile, File destFile);
}
","// ClientProperties_0Test.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientProperties}.
* It contains one unit test case for the {@link ClientProperties#getProperty(String)} method.
*/
class ClientProperties_0Test {","// ClientProperties_0Test.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientProperties}.
* It contains one unit test case for the {@link ClientProperties#getProperty(String)} method.
*/
class ClientProperties_0Test {
public ClientProperties_0Test() {
		}

        @Test
        public final void testGetProperty_null_value() {
            assertEquals("""", (String) ClientProperties.getProperty(null).getValue());
        }

        @Test
        public final void testGetProperty_file_name() {
            String file = new File("""").getCanonicalPath();
            assertEquals(""CNAME"", ClientProperties.getProperty(File.class, file).getValue());
        }

        @Test
        public final void testGetProperty_file_name_file() throws Exception {
           try {
                final File file = new File("""");
                final XmlFunctions XML = new XmlFunctions();
                final Constants CNAME = XML.createCustomConstants();

                assertEquals(""Value CNAME"", XML.createCustomConstants().getValue(File.class, file.getCanonicalPath()));

            } catch (Exception e) {
                fail(e.getMessage());
            }
        }

        @Test
        public final void testGetProperty_file_name_file_failed() {
            File fileToSet = new File("""").getCanonicalFile();
            try {
                ClientProperties.getProperty(File.class, ""CNAME"", fileToSet);
            } catch (Exception e) {
                fail(e.getMessage());
            }
        }

        @Test
        public final void testWritePropertyFile() {
            ClientProperties clientProperties = new ClientProperties();
            assertTrue(""Properties were saved to folder"", clientProperties.getPropertiesFilename().exists());

            File userFile = new File(""userProperties"");
            ClientProperties.CheckPropertiesFile(userFile);

            clientProperties.setProperty(""FARLS"", """");
            clientProperties.setProperty(""USER"", """");
            clientProperties.writePropertyFile();

            String userProperties = new String((File) UserManager.getUserProperties().clone());

            assertEquals(""User name is different from original values"", """", userProperties.substring(0, userProperties.indexOf(""USER"")));
            assertEquals(""Properties file was not saved to user directory"", userFile, clientProperties.getPropertiesFilename());
        }
}"
87082023-c22e-436b-82e5-9d5178c61077,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientProperties_1Test.java,50.862252712249756,length,"// ClientProperties.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;

/**
 * reads and writes properties to xml-file
 * properties file is saved to user directory
 *
 * @author christian
 */
public class ClientProperties {

    private XmlFunctions xmlFunctions;

    // if set to true, class is ignoring invocations
    private boolean fileError = false;

    private static final Logger logger = Logger.getLogger(ClientProperties.class);

    /**
     * constructor, opens file for reading if exists
     *
     * @param fileName -
     *            Name to xml file
     */
    public ClientProperties(String fileName) {
    }

    /**
     * checks if local properties file is present, if not tries to copy empty
     * file to location. If this fails, flag fileError is set to true and read
     * or write access is bypassed
     *
     * @param fileName -
     *            name of file
     */
    private void CheckPropertiesFile(String fileName);

    /**
     * get property value by element-name returns empty string if fileError is
     * true
     *
     * @param element -
     *            Name of element
     * @return String - value
     */
    public String getProperty(String element);

    /**
     * (over)writes value of specific element
     * does nothing if fileError is true
     *
     * @param element -
     *            Name of element
     * @param value -
     *            new value
     */
    public void setProperty(String element, String value);

    /**
     * copies a file from a to b
     * used InputStream as provided from ResourceService class as
     * source and File as destination
     *
     * @param sourceFile -
     *            InputStream - File which should be copied
     * @param destFile -
     *            destination where file should be copied to
     * @return boolean - true if successfully copied, otherwise false
     */
    public static boolean fileCopy(InputStream sourceFile, File destFile);
}
","// ClientProperties_1Test.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientProperties}.
* It contains one unit test case for the {@link ClientProperties#fileCopy(InputStream, File)} method.
*/
class ClientProperties_1Test {","// ClientProperties_1Test.java
package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.log4j.Logger;
import common.Constants;
import common.XmlFunctions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientProperties}.
* It contains one unit test case for the {@link ClientProperties#fileCopy(InputStream, File)} method.
*/
class ClientProperties_1Test {

	public String fileOutputFileName;
	
	/**
	 * @throws IllegalArgumentException -
	 * method that is throwing IllegalArgumentException if
	 * fileOutputFileName is null
	 * @throws IOException -
	 * method that throws IOException if some other error
	 * @throws ClassNotFoundException -
	 * fileOutputFileName is different than path for the file
	 */

	@Test
	public void testFileCopy_1() throws IllegalArgumentException, IOException, ClassNotFoundException {
		
		fileOutputFileName = new File(""C:\\Users\\test"", ""testProperties.xml"").getAbsolutePath();
		
		assertTrue(""fileOutputFileName is different than path for the file"", fileOutputFileName.startsWith(""C:\\""));
		
		Logger logger = Logger.getLogger(""ClientProperties_1Test_2.xml"");
		
		// reads properties from the file into a String
		ClientProperties clientProperties = new ClientProperties(fileOutputFileName);
		
		assertNull(""fileOutputFileName is same as path for the file"", clientProperties.fileOutputFileName);
		assertEquals(""properties not read"", ""hello"", clientProperties.getProperty(""hello""));
		
		StringBuilder response = new StringBuilder();
		
		String file = ""response.xml"";
		
		FileOutputStream out = null;
		
		try {
		
			File file1 = new File(file);
			file1.createNewFile();
		
			out = new FileOutputStream(file1);
		
			out.write((""<fileResponse>hello</fileResponse>"").getBytes());
			
		} catch (IOException ioe) {
			
			fileOutputFileName = clientProperties.fileOutputFileName;
	    	checkFilePath(fileOutputFileName);
			throw ioe;
		}
		
		assertTrue(""not failed to read ""+file, true);
		
		try {
		
			// read response from the file to string
			try {
				response = new StringBuilder();
				out = new FileOutputStream(fileOutputFileName);
				out.write(response.toString().getBytes());
			} catch (IOException ioe) {
			
				fileOutputFileName = clientProperties.fileOutputFileName;
				checkFilePath(fileOutputFileName);
				throw ioe;
			}
		
			assertEquals(""response not read"", response.toString());
			
		} finally {
			
			if (out!= null) out.close();
			
		}
		
	}
	
	/**
	 * checks file path
	 * if it was different for instance, file is copied
	 * to fileOutputFileName
	 * if that was done, and that is different for instance, then file is overwritten
	 * because that was done to avoid to have the wrong files in the file output
	 * directory
	 *
	 * @param filePath -
	 *            filePath is different for the property
	 */
	private void checkFilePath(String filePath) {
		
		File file = new File(""C:\\Users\\test"", ""testProperties.xml"").getAbsoluteFile();
		
		FileOutputStream out = null;
		
		try {
		file = new File(filePath);
		file.createNewFile();
		
		out = new FileOutputStream(filePath);
		} catch (Exception e) {
			
			fileOutputFileName = clientProperties.fileOutputFileName;
			checkFilePath(filePath);
			throw new IllegalArgumentException(""Could not get path for fileOutputFileName."", e);
		}
		
		assertEquals(""no file path"", filePath, clientProperties.fileOutputFileName);
		
		try {
		new File(filePath).delete();
		} catch (Exception e) {
			
			fileOutputFileName = clientProperties.fileOutputFileName;
			checkFilePath(filePath);
			throw new IllegalArgumentException(""Could not delete file on property."", e);
		}
		
		if (file.delete()) {
			
			fileOutputFileName = clientProperties.fileOutputFileName;
			checkFilePath(filePath);
			
		}
		
	}
	
	/**
	 * @throws IllegalArgumentException -
	 * method that is throwing IllegalArgumentException if
	 * fileOutputFileName is null
	 * @throws IOException -
	 * method that throws IOException if some other error
	 */
	@Test
	public void testFileCopy_2() throws IllegalArgumentException, IOException {
		
		fileOutputFileName = new File(""C:\\Users\\test"", ""tmpProperties.xml"").getAbsolutePath();
		
		ClientProperties clientProperties = new ClientProperties(fileOutputFileName);
		
		assertNull(""fileOutputFileName is same as path for the file"", clientProperties.fileOutputFileName);

		assertNull(""property is null after property was read from xml-file"", clientProperties.getProperty(""hello""));
		
		//read properties from the file into a String
		String response = new String();
		
		InputStream input = null;
		
		try {
		
			input = new FileInputStream(new File(""C:\\Users\\test"", ""tmpProperties.xml""));
		
			response = XmlFunctions.getDocumentXML(input);
			
		} catch (IOException ioe) {

			fileOutputFileName = clientProperties.fileOutputFileName;
			checkFilePath(fileOutputFileName);
"
df26cc12-b7ab-489f-9e52-3300f1b8822e,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientPlayer.java,47.482667207717896,stop,"// ClientPlayer.java
package client;

import java.awt.Point;
import org.apache.log4j.Logger;
import sound.SoundPlayer;
import common.Actor;
import common.Constants;
import common.Player;

/**
 * The client specific implemetation of a Player. This implementation will
 * notify any number of registered observers about changes to their state.
 *
 * @author Andi, Bj�rn
 */
public class ClientPlayer extends Player {

    private boolean bowlBombs = false;

    private Logger logger = Logger.getLogger(ClientPlayer.class);

    private int bombsPlanted = 0;

    private int bombDiameter = Constants.BOMB_DIAMETER;

    private int maxBombs = Constants.MIN_BOMBS;

    private long lastPlant;

    /**
     * Creates a new ClientPlayer that starts on a fixed position.
     *
     * @param position
     *            The starting location for this player.
     */
    public ClientPlayer(Point position, int id) {
    }

    /*
	 * (non-Javadoc)
	 * 
	 * @see common.Actor#preUpdate()
	 */
    @Override
    protected void preUpdate();

    /**
     * Plants a bomb on the battlefield. The bomb will be located at the current
     * position. If the user can bowl bombs the bomb get a moveVector. This will
     * trigger a notification for the observers.
     */
    public void plantBomb();

    /*
	 * (non-Javadoc)
	 * 
	 * @see common.Player#die()
	 */
    @Override
    public void die();

    /**
     * Increases the maximum number of bombs this player can plant by one. If
     * the player can already plant MAX_BOMDS bombs, this method will do
     * nothing.
     */
    public void increaseMaxBombs();

    /**
     * Resets the maximum number of bombs this player can plant by one.
     */
    public void resetMaxBombs();

    /**
     * Notifies this player that a previously planted bomb has exploded. This
     * will decrease the count of currently planted bombs.
     */
    public void plantedBombExploded();

    /**
     * Increases the diameter of the bomb, that this player can plant.
     */
    public void increaseBombDiameter();

    /**
     * Resets the diameter of the bomb, that this player can plant.
     */
    public void resetBombDiameter();

    /**
     * Sets, that player can bowl bombs
     */
    public void setBowlBombs();

    /**
     * Sets, that player can't bowl bombs
     */
    public void resetBowlBombs();

    /**
     * Returns weather the player can bowl bombs
     *
     * @return boolean can bowl bombs
     */
    public boolean canBowlBombs();
}
","// ClientPlayerTest.java
package client;

import java.awt.Point;
import org.apache.log4j.Logger;
import sound.SoundPlayer;
import common.Actor;
import common.Constants;
import common.Player;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientPlayer}.
* It contains one unit test case for the {@link ClientPlayer#canBowlBombs()} method.
*/
class ClientPlayerTest {","// ClientPlayerTest.java
package client;

import java.awt.Point;
import org.apache.log4j.Logger;
import sound.SoundPlayer;
import common.Actor;
import common.Constants;
import common.Player;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientPlayer}.
* It contains one unit test case for the {@link ClientPlayer#canBowlBombs()} method.
*/
class ClientPlayerTest {
/**
		 * Returns weather the player can bowl bombs by calling {@link #canBowlBombs()}
		 * 
		 * @return True of current player can bowl the other player's bombs
		 */
	private boolean canBePlayedByAnother() {
		return false;
	}

	/**
	 * Test case for canBowlBombs method.
	 */
	@Test
	void canBowlBombs() {
		ClientPlayer testPlayer = new ClientPlayer(new Point(), 14);
		assertFalse(canBePlayedByAnother());
		testPlayer.canBePlayedByAnother();
		assertFalse(canBePlayedByAnother());
		testPlayer.canBePlayedByAnother();
		assertTrue(canBePlayedByAnother());
	}

	/**
	 * Test case for addBombs method.
	 */
	@Test
	void addBombs() {
		ClientPlayer player = new ClientPlayer(new Point(), 1);
		assertEquals(0, player.addBombs());
		assertEquals(Integer.MAX_VALUE, player.addBombs());
		assertEquals(-1, player.addBombs());
		assertEquals(2, player.addBombs());
	}

	/**
	 * Test case for getBombs method.
	 */
	@Test
	void getBombs() {

		ClientPlayer player = new ClientPlayer(new Point(), 1);
		assertEquals(Integer.MAX_VALUE, player.getBombs());
		assertEquals(-1, player.getBombs());
		assertEquals(0, player.getBombs());
		assertEquals(0, player.getBombs());

		player = new ClientPlayer(new Point(), 101);
		assertEquals(Integer.MAX_VALUE, player.getBombs());
		assertEquals(-1, player.getBombs());
		assertEquals(0, player.getBombs());
		assertEquals(0, player.getBombs());
	}

	/**
	 * Test case for resetBombs method.
	 */
	@Test
	void resetBombs() {

		ClientPlayer player = new ClientPlayer(new Point(), 1);
		assertEquals(Integer.MAX_VALUE, player.getBombs());
		assertEquals(-1, player.getBombs());
		assertEquals(Integer.MAX_VALUE, player.getBombs());

		player = new ClientPlayer(new Point(), 100);
		assertEquals(Integer.MAX_VALUE, player.getBombs());
		assertEquals(-1, player.getBombs());
		assertEquals(Integer.MAX_VALUE, player.getBombs());
	}

	/**
	 * Test case for getBombPos method.
	 */
	@Test
	void getBombPos() {

		ClientPlayer player = new ClientPlayer(new Point(), 1);
		assertEquals(new Point(24, 20), player.getBombPos());
		assertEquals(new Point(24, 20), player.getBombPos());
	}

	/**
	 * Test case for getBombDiameter method.
	 */
	@Test
	void getBombDiameter() {

		assertEquals(5,  player.getBombDiameter());
	}

	/**
	 * Test case for setBombDiameter method.
	 */
	private static final int bombDiameter = 0;
		public  void setBombDiameter(int diameter) {
			bombDiameter = diameter;
		}
	
	/**
	* Test if player can successfully bowl a bomb
	*
	* @param player
	* @return true if can be placed on the player's position
	*/
	@Test
	public boolean canBowlBombs(Actor player) {

		return true;
	}

}
"
7d8bc58f-cad5-477f-95ee-72b3e0c32927,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientGameRound.java,11.596805095672607,length,"// ClientGameRound.java
package client;

import java.awt.Point;
import java.util.HashMap;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import org.apache.log4j.Logger;
import client.controller.LocalControl;
import client.gui.StartFrame;
import client.network.ForwardingObserver;
import client.view.BombView;
import client.view.GameCanvas;
import client.view.GameView;
import client.view.GfxFactory;
import client.view.OffGamePainter;
import client.view.PlayerView;
import client.view.PowerUpView;
import client.view.StatusView;
import client.view.TileView;
import common.Bomb;
import common.Constants;
import common.GameModel;
import common.GameObject;
import common.GameRound;
import common.Map;
import common.Player;
import common.PowerUp;
import common.Tile;

/**
 * Represents a game on the client side. This class serves as a connection
 * between the model, view and game loop.
 *
 * @author Andi, Bj�rn
 */
public class ClientGameRound extends GameRound implements Observer {

    /**
     * The GameModel instance for this game.
     */
    private GameModel model;

    /**
     * The GameView instance for this game.
     */
    private GameView view;

    /**
     * The GameLoop instance for this game.
     */
    private ClientGameLoop gameLoop;

    /**
     * The GfxFactory instance for this game.
     */
    private GfxFactory gfxFactory;

    private static final Logger logger = Logger.getLogger(ClientGameRound.class);

    private Player localPlayer;

    private final ClientGameSession session;

    private Thread offGamePainter;

    private final GameCanvas gameCanvas;

    private ForwardingObserver forwardingObserver;

    /**
     * Creates a new game that will be painted on the passed GameCanvas object.
     * When this constructor finishes, all necessary game objects will be
     * initialized, but they will lack player and map objects.
     *
     * @param gameCanvas
     *            The canvas that will be used for painting the view.
     */
    public ClientGameRound(ClientGameSession session, GameCanvas gameCanvas) {
    }

    /**
     * Adds a player to the game. Adds the player object to GameModel and
     * creates a view object for the player and adds it to the GameView.
     *
     * @param player
     *            The player to add to this game.
     */
    public void addPlayer(int id, ClientPlayer player);

    public void addBomb(int id, Bomb bomb);

    /**
     * Sets the map for this game. All tiles that are contained in the map are
     * added to the GameModel. For every tile a TileView is created and added to
     * the GameView.
     *
     * @param map=
     *            The map that will be used in this game.
     */
    public void setMap(Map map);

    /**
     * Starts this game by creating a new thread and running the game loop in
     * it.
     */
    public void start();

    /**
     * Set the local control for this game. This control will be used to move
     * the local player on the screen.
     *
     * @param localControl
     *            The local control to use.
     */
    public void setLocalControl(LocalControl localControl);

    /**
     * Called when an observable has changed. Usages:
     * <ul>
     * <li>Player plants a bomb
     * </ul>
     *
     * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
     */
    @Override
    public void update(Observable o, Object arg);

    /**
     * Searches and returns a GameObject by its id.
     *
     * @param id
     *            The id of the GameObject that should be returned.
     * @return The matching GameObject or null if the id is unknown.
     */
    public GameObject getGameObjectById(int id);

    /**
     * Updates the countdown for this GameRound. Visual and acoustic
     * notifications will be triggered.
     *
     * @param countdown
     *            The current countdown.
     */
    public void countdown(int countdown);

    /**
     * @param player
     */
    public void setLocalPlayer(Player localPlayer);

    /**
     * Finishes this game round by calculating the score and notifying the
     * session that the round has ended.
     *
     * @see common.GameRound#doPostRoundProcessing()
     */
    @Override
    public void doPostRoundProcessing();

    /**
     * Snaps the location of the given bomb to the next intersection on the
     * grid.
     *
     * @param bomb
     *            The bomb that should be relocated on the grid.
     */
    public void snapToGrid(Bomb bomb);

    /**
     * Sets the status of the round. This is used to inform the user about
     * what's happening.
     *
     * @param string
     *            The string that will be displayed to the user.
     */
    public void setStatus(String string);

    /**
     * End the game round. The action will stop but the game will still be
     * painted on the canvas.
     */
    public void endRound();

    /**
     * Terminate this round. This will stop the rendering of the game.
     */
    public void terminateRound();

    /**
     * Returns the actual time of this GameRound.
     *
     * @return long - actual time
     */
    public long getTime();

    /**
     * Sets the time of this GameRound.
     *
     * @param time
     *            the time, which should be set
     */
    public void setTime(long time);

    /**
     * {@inheritDoc}
     */
    @Override
    public void createNewTile(Point point, int id, String type, boolean bombable, boolean accessible, boolean active);

    public void toggleDisplayNames();

    public void setRoundScore(HashMap<String, Integer> rndscore);
}
","// ClientGameRoundTest.java
package client;

import java.awt.Point;
import java.util.HashMap;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import org.apache.log4j.Logger;
import client.controller.LocalControl;
import client.gui.StartFrame;
import client.network.ForwardingObserver;
import client.view.BombView;
import client.view.GameCanvas;
import client.view.GameView;
import client.view.GfxFactory;
import client.view.OffGamePainter;
import client.view.PlayerView;
import client.view.PowerUpView;
import client.view.StatusView;
import client.view.TileView;
import common.Bomb;
import common.Constants;
import common.GameModel;
import common.GameObject;
import common.GameRound;
import common.Map;
import common.Player;
import common.PowerUp;
import common.Tile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientGameRound}.
* It contains one unit test case for the {@link ClientGameRound#getGameObjectById(int)} method.
*/
class ClientGameRoundTest {","// ClientGameRoundTest.java
package client;

import java.awt.Point;
import java.util.HashMap;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import org.apache.log4j.Logger;
import client.controller.LocalControl;
import client.gui.StartFrame;
import client.network.ForwardingObserver;
import client.view.BombView;
import client.view.GameCanvas;
import client.view.GameView;
import client.view.GfxFactory;
import client.view.OffGamePainter;
import client.view.PlayerView;
import client.view.PowerUpView;
import client.view.StatusView;
import client.view.TileView;
import common.Bomb;
import common.Constants;
import common.GameModel;
import common.GameObject;
import common.GameRound;
import common.Map;
import common.Player;
import common.PowerUp;
import common.Tile;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientGameRound}.
* It contains one unit test case for the {@link ClientGameRound#getGameObjectById(int)} method.
*/
class ClientGameRoundTest {

	private final static Logger logger = Logger.getLogger(ClientGameRoundedTest.class);

    private ClientGameRound gameRound = null;

    private GameModel model = null;

    /**
     * Sets the model to be used for this game.
     * The GameModel instance may be created from another game without a Model
     * as input but it is not required to be created yet.
     */
    public void setModel(GameModel model) {
        if (this.model!= null) {
            this.model.uninit();
        }
        this.model = model;


    }

    /**
     * Retrieves the model used for the game as input.
     *
     * @return The game model this game will be used for.
     */
    public GameModel getModel() {
        return model;
    }

    /**
     * Sets the"
0b0f2696-8835-49c1-8ee7-caf64cfef6e7,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/BomberClient_0Test.java,7.533109664916992,length,"// BomberClient.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;

/**
 * This is central client class. It is responsible for globally scoped messages
 * and the creation of sessions.
 *
 * @author andi
 */
public class BomberClient extends Observable {

    private static Logger logger = Logger.getLogger(BomberClient.class);

    /**
     * The socket that is used to communicate with the server.
     */
    public Socket server;

    /**
     * The ip address of the server.
     */
    private String serverName = ""localhost"";

    /**
     * The port on the server to connect to.
     */
    private int serverPort = 6666;

    /**
     * The name of the player that is running this client.
     */
    private String playerName;

    private ClientMsgReceiver msgReceiver;

    private ClientMsgSender msgSender;

    /**
     * The id offset of this client. Generated ids will be in the range from
     * idOffset to idOffset + 1000000.
     */
    private int idOffset = -1;

    /**
     * Singleton instance
     */
    private static BomberClient instance;

    /**
     * The currently used (and sole) session.
     */
    private ClientGameSession currentSession;

    /**
     * A list of sessions that are running on the server.
     */
    private Vector<SessionDetailsMsg> availableSessions = new Vector<SessionDetailsMsg>();

    /**
     * A list of maps that are availbale on the server.
     */
    private Vector<MapInfo> availableMaps;

    private ClientGameSession requestedSession;

    /**
     * @return The current game session.
     */
    public ClientGameSession getCurrentSession();

    /**
     * Creates a new BomberClient. Use getInstance() to aquire an instance.
     *
     * @param playerName
     *            The name of the player on this client.
     */
    private BomberClient(String playerName) {
    }

    /**
     * Returns the singleton.
     *
     * @return The only BomberClient instance.
     */
    public static BomberClient getInstance();

    /**
     * Tries to connect to the server.
     *
     * @throws RuntimeException
     *             Thrown when the connection attempt was not successful.
     */
    public boolean connectToSrv();

    /**
     * Sends a message to the server. The passed object will be serialized and
     * transmitted to the server.
     *
     * @param msg
     *            The message to send.
     */
    public void sendMsg(Message msg);

    /**
     * Creates a new id that is guaranteed to be unique for this class.
     *
     * @return The next valid id for this class.
     */
    public int getNextId();

    /**
     * Sets the id offset.
     *
     * @param idOffset
     *            to set
     */
    public void setIdOffset(int idOffset);

    /**
     * Sets the current session.
     *
     * @param The
     *            ClientGameSession to set.
     */
    public void setCurrentSession(ClientGameSession currentSession);

    /**
     * Create a new session on the server. The given arguments are rolled up
     * into a SessionDetailsMsg and sent to the server.
     *
     * @param name
     *            The name for the new session.
     * @param maps
     *            A list of map names that will be used for this session
     * @param totalPlayers
     *            The total number of players.
     * @param rounds
     *            The number of rounds to play.
     */
    public void createSession(String name, List<String> maps, ImageIcon mapPreview, int totalPlayers, int rounds);

    public void openSession();

    /**
     * Requests a list of active sessions on the server.
     */
    public void requestSessionList();

    /**
     * Requests a list of available maps from the server.
     */
    public void requestMapList();

    /**
     * Returns a list of active sessions on the server. Invoke
     * requestSessionList() to update this list.
     *
     * @return
     */
    public Vector<SessionDetailsMsg> getAvailableSessions();

    /**
     * @param sessionInfos
     */
    public void setAvailableSessions(Vector<SessionDetailsMsg> sessionInfos);

    /**
     * @param maps
     */
    public void setAvailableMaps(List<MapInfo> maps);

    /**
     * @return the availableMaps
     */
    public Vector<MapInfo> getAvailableMaps();

    /**
     * Creates a session from the details specified in the given
     * SessionDetailMsg.
     *
     * @param session
     *            The session to open on this client.
     */
    public void createSession(SessionDetailsMsg sessionDetails);

    /**
     * Sets the server-name
     *
     * @author Bj�rn
     */
    public void setServerName(String serverName);

    /**
     * Sets the server-port
     *
     * @author Bj�rn
     */
    public void setServerPort(int serverPort);

    /**
     * @param sender
     * @param msg
     */
    public void addChatGlobal(String sender, String msg);

    /**
     * @param sender
     * @param msg
     */
    public void addChatSession(String sender, String msg);

    public void discardSessionRequest();

    /**
     * Closes the current session.
     */
    public void closeSession();

    /**
     * Closes the current session.
     */
    public void closeSessionAndShowHighscores();

    /**
     * Leave the current session.
     */
    public void leaveSession();

    public void closeConnection();

    public String getPlayerName();

    public void setPlayerName(String playerName);

    public void requestGlobalScore();

    public void setGlobalscores(ArrayList scores);

    public void setRoundScore(HashMap<String, Integer> rndscore);

    public void setSessionScore(HashMap<String, Integer> rndscore);

    /**
     * @param i
     */
    public void quitRunningSession(int playerId);
}
","// BomberClient_0Test.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberClient}.
* It contains one unit test case for the {@link BomberClient#getInstance()} method.
*/
class BomberClient_0Test {","// BomberClient_0Test.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberClient}.
* It contains one unit test case for the {@link BomberClient#getInstance()} method.
*/
class BomberClient_0Test {
BomberClient_0Test() {
	}

	/**
     * Test method for
     * {@link client.ClientGameSession#SessionDetailsMsg(java.util.List)}
     *.
     */
	@Test
    public void testSessionDetailsMsgList() {
        try {
            /**
             * Passing in an empty list for a session does not throw an exception.
             */
            SessionDetailsMsg tempMsg = new SessionDetailsMsg();
            "
7026efde-fcea-4b87-b16a-c25380dd0f73,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/BomberClient_1Test.java,7.53164267539978,length,"// BomberClient.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;

/**
 * This is central client class. It is responsible for globally scoped messages
 * and the creation of sessions.
 *
 * @author andi
 */
public class BomberClient extends Observable {

    private static Logger logger = Logger.getLogger(BomberClient.class);

    /**
     * The socket that is used to communicate with the server.
     */
    public Socket server;

    /**
     * The ip address of the server.
     */
    private String serverName = ""localhost"";

    /**
     * The port on the server to connect to.
     */
    private int serverPort = 6666;

    /**
     * The name of the player that is running this client.
     */
    private String playerName;

    private ClientMsgReceiver msgReceiver;

    private ClientMsgSender msgSender;

    /**
     * The id offset of this client. Generated ids will be in the range from
     * idOffset to idOffset + 1000000.
     */
    private int idOffset = -1;

    /**
     * Singleton instance
     */
    private static BomberClient instance;

    /**
     * The currently used (and sole) session.
     */
    private ClientGameSession currentSession;

    /**
     * A list of sessions that are running on the server.
     */
    private Vector<SessionDetailsMsg> availableSessions = new Vector<SessionDetailsMsg>();

    /**
     * A list of maps that are availbale on the server.
     */
    private Vector<MapInfo> availableMaps;

    private ClientGameSession requestedSession;

    /**
     * @return The current game session.
     */
    public ClientGameSession getCurrentSession();

    /**
     * Creates a new BomberClient. Use getInstance() to aquire an instance.
     *
     * @param playerName
     *            The name of the player on this client.
     */
    private BomberClient(String playerName) {
    }

    /**
     * Returns the singleton.
     *
     * @return The only BomberClient instance.
     */
    public static BomberClient getInstance();

    /**
     * Tries to connect to the server.
     *
     * @throws RuntimeException
     *             Thrown when the connection attempt was not successful.
     */
    public boolean connectToSrv();

    /**
     * Sends a message to the server. The passed object will be serialized and
     * transmitted to the server.
     *
     * @param msg
     *            The message to send.
     */
    public void sendMsg(Message msg);

    /**
     * Creates a new id that is guaranteed to be unique for this class.
     *
     * @return The next valid id for this class.
     */
    public int getNextId();

    /**
     * Sets the id offset.
     *
     * @param idOffset
     *            to set
     */
    public void setIdOffset(int idOffset);

    /**
     * Sets the current session.
     *
     * @param The
     *            ClientGameSession to set.
     */
    public void setCurrentSession(ClientGameSession currentSession);

    /**
     * Create a new session on the server. The given arguments are rolled up
     * into a SessionDetailsMsg and sent to the server.
     *
     * @param name
     *            The name for the new session.
     * @param maps
     *            A list of map names that will be used for this session
     * @param totalPlayers
     *            The total number of players.
     * @param rounds
     *            The number of rounds to play.
     */
    public void createSession(String name, List<String> maps, ImageIcon mapPreview, int totalPlayers, int rounds);

    public void openSession();

    /**
     * Requests a list of active sessions on the server.
     */
    public void requestSessionList();

    /**
     * Requests a list of available maps from the server.
     */
    public void requestMapList();

    /**
     * Returns a list of active sessions on the server. Invoke
     * requestSessionList() to update this list.
     *
     * @return
     */
    public Vector<SessionDetailsMsg> getAvailableSessions();

    /**
     * @param sessionInfos
     */
    public void setAvailableSessions(Vector<SessionDetailsMsg> sessionInfos);

    /**
     * @param maps
     */
    public void setAvailableMaps(List<MapInfo> maps);

    /**
     * @return the availableMaps
     */
    public Vector<MapInfo> getAvailableMaps();

    /**
     * Creates a session from the details specified in the given
     * SessionDetailMsg.
     *
     * @param session
     *            The session to open on this client.
     */
    public void createSession(SessionDetailsMsg sessionDetails);

    /**
     * Sets the server-name
     *
     * @author Bj�rn
     */
    public void setServerName(String serverName);

    /**
     * Sets the server-port
     *
     * @author Bj�rn
     */
    public void setServerPort(int serverPort);

    /**
     * @param sender
     * @param msg
     */
    public void addChatGlobal(String sender, String msg);

    /**
     * @param sender
     * @param msg
     */
    public void addChatSession(String sender, String msg);

    public void discardSessionRequest();

    /**
     * Closes the current session.
     */
    public void closeSession();

    /**
     * Closes the current session.
     */
    public void closeSessionAndShowHighscores();

    /**
     * Leave the current session.
     */
    public void leaveSession();

    public void closeConnection();

    public String getPlayerName();

    public void setPlayerName(String playerName);

    public void requestGlobalScore();

    public void setGlobalscores(ArrayList scores);

    public void setRoundScore(HashMap<String, Integer> rndscore);

    public void setSessionScore(HashMap<String, Integer> rndscore);

    /**
     * @param i
     */
    public void quitRunningSession(int playerId);
}
","// BomberClient_1Test.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberClient}.
* It contains one unit test case for the {@link BomberClient#connectToSrv()} method.
*/
class BomberClient_1Test {","// BomberClient_1Test.java
package client;

import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import javax.swing.ImageIcon;
import messages.Message;
import messages.global.InfoRequestMsg;
import messages.global.JoinSessionMsg;
import messages.global.MapInfo;
import messages.global.SessionDetailsMsg;
import messages.round.ClientQuitRunningSessionMsg;
import org.apache.log4j.Logger;
import client.gui.StartFrame;
import client.network.ClientMsgReceiver;
import client.network.ClientMsgSender;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BomberClient}.
* It contains one unit test case for the {@link BomberClient#connectToSrv()} method.
*/
class BomberClient_1Test {

	/**
	 * Returns the instance.
	 *
	 * @return
	 */
	public static BomberClient getInstance() {
		if (instance == null) {
			// Instance has not been created yet.
			instance = new BomberClient(Player.getPlayerName());
		}
		assertTrue(instance!= null,
                   ""A class cannot be created on an initialisation."");
		return instance;
	}
	
	/**"
018c433d-0239-47d3-b9ec-892119e96553,/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/view/GfxFactory.java,51.579599380493164,stop,"// GfxFactory.java
package client.view;

import java.awt.Image;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import javax.imageio.ImageIO;
import org.apache.log4j.Logger;
import common.ResourceService;

/**
 * @author Andreas Glauner
 * @autor Adam Kozielski
 */
public class GfxFactory {

    private HashMap<Integer, Image> wallImageCache;

    private HashMap<String, Image> tileImageCache;

    private HashMap<String, Image> powerUpImageCache;

    private HashMap<String, Image> o;

    private HashMap<Integer, Image>[] playerImageCache;

    private HashMap<Integer, Image>[] bombImageCache;

    private HashMap<Integer, Integer> idTranslator;

    private HashMap<Integer, Image>[] explosionImageCache;

    private ExplosionGfxFactory explosionGfxFactory;

    private int currentId = 1;

    private static String basePath = ""/gfx"";

    private String tileSet = ""ice"";

    private Logger logger = Logger.getLogger(GfxFactory.class);

    public GfxFactory() {
    }

    /**
     * @param id The player id.
     * @param state
     * @return
     */
    public Image getPlayerImage(int id, int state);

    public Image getTileImage(String type);

    private int translateId(int id);

    private Image loadImage(String path);

    /**
     * @param id The planter's id.
     * @return
     */
    public Image getBombImage(int id);

    /**
     * @param id The planter's id.
     * @return
     */
    public Image getBombImage(int id, int state);

    public Image getExplosionImage(int diameter, int id);

    public void setTileSet(String tileSet);

    public Image getWallImage(int state);

    /**
     * Power up image loading
     * @param type A String value describing the type of powerUp
     *  *
     */
    public Image getPowerUpImage(String type);
}
","// GfxFactoryTest.java
package client.view;

import java.awt.Image;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import javax.imageio.ImageIO;
import org.apache.log4j.Logger;
import common.ResourceService;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GfxFactory}.
* It contains one unit test case for the {@link GfxFactory#getPowerUpImage(String)} method.
*/
class GfxFactoryTest {","// GfxFactoryTest.java
package client.view;

import java.awt.Image;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import javax.imageio.ImageIO;
import org.apache.log4j.Logger;
import common.ResourceService;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GfxFactory}.
* It contains one unit test case for the {@link GfxFactory#getPowerUpImage(String)} method.
*/
class GfxFactoryTest {

		Logger log = Logger.getLogger(GfxFactoryTest.class);

/** Checks for existence of the cache. */
	@Test
	void checkImageCache() {

		assertNotNull(""The image cache has been successfully initialized."",
				wallImageCache);
		assertNotNull(""The tile cache has been successfully initialized."",
				tileImageCache);
		assertNotNull(""The powerUp images have been successfully initialized."",
				powerUpImageCache);
		assertNotNull(""The animation gif cache has been successfully initialized."",
				exposionImageCache);

		GfxFactory.log.trace(""imageCache ==============="");
		log.trace(imageCache);

		TileCache tileCache = new TileCache();
		wallImageCache.put(13, tileCache.getTileImage(""wall_8""));
		tileImageCache.put(""wall_8"", tileCache.getTileImage(""wall_8""));

		BombCache bombCache = new BombCache();
		bombImageCache.put(""bomb_1"", bombCache.getBombImage(""1""));
		bombImageCache.put(""bomb_2"", bombCache.getBombImage(""2""));
		bombImageCache.put(""bomb_3"", bombCache.getBombImage(""3""));
		bombImageCache.put(""bomb_4"", bombCache.getBombImage(""4""));

		ExplosionCache explosionCache = new ExplosionCache();
		Image image = explosionCache.getImage(""explosion"");
		Image loadedImage = explosionCache.getExplosionImage(300);
		int d = image.getWidth(ResourceService.getResource());
		int m = image.getHeight(ResourceService.getResource());

		assertEquals(""The loaded image from cache does not equal the one expected."",
				loadedImage, image);
		assertEquals(""The loaded number of tiles does not match the expected number."",
				d * m, loadedImage.getHeight(ResourceService.getResource()));
		
		TileCache tCache = new TileCache();
		assertNotNull(""The loaded image from cache is null."",
				tCache.getTileImage(""tilecache_image1""));
		
		GfxFactory.log.trace(""tileCache ==============="");
		GfxFactory.log.trace(tileCache);

		GameCache gameCache = new GameCache();
		Image image2 = gameCache.getImage(""game_game"");
		if (image2 == null) {
			throw new RuntimeException(""Failed to load game."");
		}
		GfxFactory.log.trace(""image  ==============="");
		GfxFactory.log.trace(image2);

		// GFX.getExplosionImage(""tilecache_explosion""); //Should return null.
		// GFX.getExplosionImage(""game_game""); //Should return false.


	}

    @Test
    void initializeAndLoadAll() {
        TileService tileService = ResourceService.getTileService();

    }

}
"
