ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
906f39e0-a47b-43ba-ab29-671562d4dfb0,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/FieldInfo_0Test.java,64.44146156311035,stop,"// FieldInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a Field as defined by the FIX specification.
 *
 * @author jramoyo
 */
public class FieldInfo implements FixInfo {

    /**
     * Returns whether this field is required in the specified component
     *
     * @param component - a component
     * @return whether this field is required in the specified component
     */
    public boolean isRequiredInComponent(ComponentInfo component) {
        if (requiringComponents != null) {
            return requiringComponents.contains(component);
        } else {
            return false;
        }
    }
}
","// FieldInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isRequiredInComponent(ComponentInfo)} method.
*/
class FieldInfo_0Test {","// FieldInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isRequiredInComponent(ComponentInfo)} method.
*/
class FieldInfo_0Test {
// FieldInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a Field as defined by the FIX specification.
 *
 * @author jramoyo
 */
public class FieldInfo implements FixInfo {

    /**
     * Returns whether this field is required in the specified component
     *
     * @param component - a component
     * @return whether this field is required in the specified component
     */
    public boolean isRequiredInComponent(ComponentInfo component) {
        if (requiringComponents!= null) {
            return requiringComponents.contains(component);
        } else {
            return false;
        }
    }
}

// FieldInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isRequiredInComponent(ComponentInfo)} method.
*/
class FieldInfo_0Test {
		private FieldInfo field;
		private List<ComponentInfo> components;

		class FieldInfo_0 extends FieldInfo {
			public void addField(String componentId, String name, String type) {

			}
		}
		

		List<ComponentInfo>  getComponents() {
			return this.components;
		}

		@Test
		public void testIsRequiredInComponent_nullParameter() {
			assertEquals(false, new FieldInfo_0().isRequiredInComponent(null));
		}
		
        @Test
		public void testIsRequiredInComponent_notNullParameter() {
            new FieldInfo_0().addField(""COMPONENT-ID"", ""AaD"", ""STRING"");
			assertEquals(false, new FieldInfo_0().isRequiredInComponent(""COMPONENT-ID""));
		}
		
        @Test
		public void testIsRequiredInComponent_notNullParameter_notRequired() {
			new FieldInfo_0().addField(""COMPONENT-ID"", ""AaD"", ""STRING"");
			assertEquals(true, new FieldInfo_0().isRequiredInComponent(""COMPONENT-ID""));
		}
}
"
27251f2b-d577-420d-bcae-7c45079e3c72,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/FieldInfo_1Test.java,42.896939754486084,stop,"// FieldInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a Field as defined by the FIX specification.
 *
 * @author jramoyo
 */
public class FieldInfo implements FixInfo {

    /**
     * Returns whether a given value is valid
     *
     * @param value - a value
     * @return whether a given value is valid
     */
    public boolean isValidValue(String value) {
        return validValues.keySet().contains(value);
    }
}
","// FieldInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isValidValue(String)} method.
*/
class FieldInfo_1Test {","// FieldInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isValidValue(String)} method.
*/
class FieldInfo_1Test {

	 /**
	* Test of isValidValue method, of class FieldInfo
	*/
    @Test
    public void test_IsValidValue() {
        System.out.println(""isValidValue"");
        boolean aBoolean = true;
        TreeMap<String, Object> bTreeMap = new TreeMap<String, Object>();
        List<String> aList = new ArrayList<String>();
        aList.add(""c"");
        aList.add(""a"");
        bTreeMap.put(""b"", aList);
        aTreeMap().put(""c"", aBoolean);
        boolean b = aTreeMap().isValidValue(""b"");
        boolean a = aTreeMap().isValidValue(""c"");
        assertTrue(b);
        assertTrue(a);
    }

    
    /**
	* Test of isValidValue method, of class FieldInfo.
	*/
    @Test
    public void test_isValidValue_NoField() {
        boolean b = false;
        TreeMap<String, Object> bTreeMap = new TreeMap<String, Object>();
        List<String> aList = new ArrayList<String>();
        aList.add(""a"");
        bTreeMap.put(""b"", aList);
        aTreeMap().put(""c"", b);
        boolean c = aTreeMap();
        bTreeMap().isValidValue(""c"");
        assertFalse(b);
    }
    
	/**
	* Test of isValidValue method, of class FieldInfo.
	*/
    @Test
    public void test_isValidValue_OneField() {
    	List<String> aList = new ArrayList<String>();
    	aList.add(""a"");
    	List<String> bList = new ArrayList<String>();
    	bList.add(""b"");
    	TreeMap<String, Object> aTreeMap = new TreeMap<String, Object>();
    	aTreeMap.put(""c"", true);
    	aTreeMap().put(""d"", bList);
    	aTreeMap().put(""c"", false);
    	TreeMap<String, Object> aTreeMap2 = new TreeMap<String, Object>();
    	aTreeMap2.put(""f"", true);
    	aTreeMap2.put(""c"", bList);
    	aTreeMap2().put(""c"", false);
    	aTreeMap2().put(""d"", aList);
    	aList.clear();
    	aTreeMap.put(""b"", aList);
    	aTreeMap2.put(""b"", aList);
    	boolean c = aTreeMap.isValidValue(""c"");
    	boolean d = aTreeMap2.isValidValue(""d"");
    	boolean f = aTreeMap2.isValidValue(""f"");
    	boolean c = bTreeMap.isValidValue(""c"");
    	boolean d = bTreeMap2.isValidValue(""d"");
    	boolean f = bTreeMap2.isValidValue(""f"");
    	boolean c = aTreeMap.isValidValue(""c"");
    	boolean d = aTreeMap2.isValidValue(""d"");
    	boolean f = aTreeMap2.isValidValue(""f"");
    	if (c && d && f) {
    		assertTrue(c && d);
    	} else {
    		assertFalse(c && d && f);
    	}
    }
// FieldInfo_1Test.java
}
"
cbd5f342-b2b4-485a-b605-65d6e907dc50,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_0Test.java,61.74218988418579,length,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber) {
        if (fieldsByTagNumber != null) {
            return fieldsByTagNumber.get(tagNumber);
        }
        return null;
    }
}
","// DictionaryInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(int)} method.
*/
class DictionaryInfo_0Test {","// DictionaryInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(int)} method.
*/
class DictionaryInfo_0Test {
// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber) {
        if (fieldsByTagNumber!= null) {
            return fieldsByTagNumber.get(tagNumber);
        }
        return null;
    }
}

// DictionaryInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(int)} method.
*/
class DictionaryInfo_0Test {
		//FIXME - should be put into DictionaryInfo.
	@Test
    public void testGetField(){
        
		List<FieldInfo> fieldsByTagNumber = new ArrayList<>();
		TreeMap<Integer, FieldInfo> fieldsByTag = new TreeMap<>();
		Map<Integer, List<FieldInfo>> listsByTag = new TreeMap<> ();
		
		//add a few fields
		addField(FieldInfo.INVOICE_DOCUMENT_TYPE_ID, DocumentTypeId.get(DocumentTypeId.INVOICE_DOCUMENT));
		addField(FieldInfo.INVOICE_DOCUMENT_STATUS_ID, DocumentStatusId.APPROVAL);
		addField(FieldInfo.INVOICE_DOCUMENT_REQUEST_ID, DocumentRequestId.OPTIONAL);
		addField(FieldInfo.INVOICE_ID, ""100"");
	    addField(FieldInfo.STATUS, DocumentStatus.APPROVED);
	    addField(FieldInfo.VERSION, DocumentVersion.get(DocumentVersion.FIX5_0_1, DocumentVersion.FIX50_1_1));
	    addField(FieldInfo.MESSAGE,
		     ""FIX 2.0.1, 1.27.6 (fix.28.6.1)"",
		     ""FIX 23.3.2, 1.26.2 (fix.26)"");
	    
	    fieldsByTag.put(FieldInfo.INVOICE_DOCUMENT_TYPE_ID, DocumentTypeInfo.get(DocumentTypeId.INVOICE));
	    fieldsByTag.put(FieldInfo.INVOICE_DOCUMENT_STATUS_ID, DocumentStatusInfo.get(DocumentStatusId.APPROVAL));
	    fieldsByTag.put(FieldInfo.INVOICE_DOCUMENT_REQUEST_ID, DocumentRequestInfo.get(DocumentRequestId.OPTIONAL));
	    fieldsByTag.put(FieldInfo.INVOICE_ID, ""100"");
	    fieldsByTag.put(FieldInfo.STATUS, DocumentStatus.APPROVED);
	    fieldsByTag.put(FieldInfo.VERSION, DocumentVersion.get(DocumentVersion.FIX5_0_1, DocumentVersion.FIX50_1_1));
	    
	    fieldsByTag.put(FieldInfo.MESSAGE,
		     ""FIX 2.0.1, 1.27.6 (fix.28.6.3);\nFIX 2.0.2, 1.27.6 (fix.28.6.2)"");
	    
	    addField(FieldInfo.INVOICE_DOCUMENT_STATUS_ID, DocumentStatusInfo.get(DocumentStatusId.REOPENED));
	    
		fieldsByTag.put(FieldInfo.INVOICE_DOCUMENT_REQUEST_ID, DocumentRequestInfo.get(DocumentRequestId.APPROVED));

        
		List<FieldInfo> documentsOfType = new ArrayList<FieldInfo>(11);
		document = new Document();
		document.add(documentsOfType);

		List<DocumentStatusInfo> st = new ArrayList<DocumentStatusInfo> (23);
		st.add(DocumentStatusInfo.create(DocumentStatusId.PENDING_FOR_REOPEN));
		createDocument(st );
		
		//add a bunch of entries
		addField(FieldInfo.INVOICE_DOCUMENT_STATUS_ID,DocumentStatusId.PENDING_FOR_ACTION);
		addField(FieldInfo.INVOICE_DOCUMENT_STATUS_ID,DocumentStatusId.REQUESTED);
		addField(FieldInfo.INVOICE_DOCUMENT_REQUEST_ID,DocumentRequestId.RECONFIRM_ID);
		addField(FieldInfo.INVOICE_ID, ""101"");
		addField(FieldInfo.VERSION, DocumentVersion.get(DocumentVersion.FIX5_0_1, DocumentVersion.FIX50_1_1));
		addField(FieldInfo.STATUS, DocumentStatus.PENDING_FOR_ACTION);
		addField(FieldInfo.REQUEST_STATUS_REQUEST_STATUS_ID, DocumentStatusId.APPROVED);
		List<Int> statIds = new ArrayList<Int>(23);
		statIds.add(DocumentStatuses.REQUESTED);
		createRequest(statIds);
		
		
		List<FieldInfo> stt = new ArrayList<FieldInfo> (17);
		stt.add(DocumentStatusInfo.create(DocumentStatusId.ACTION_REQUIRED));
		stt.add(DocumentStatusInfo.create(DocumentStatusId.PENDING_FOR_ACTIVATION));
		createDocument(stt );
		
	}
	
		
	/**
	 * Appends fields to entries of type {@link FieldInfo}.
	 *
	 * @param fieldsByTag - a Map of types of fields to put into a list
	 */
	private void addField(TreeMap<Integer,FieldInfo> fieldsByTag) {
		
			List<FieldInfo> list = createList();
			if (list.size()!= 0) {
				field = list.get(0).copy();
				fieldsByTag.put(FieldInfo.INVOICE_DOCUMENT_REQUEST_ID, DocumentRequests.create(field));
			}
	}
	
	/**
	 * Creates a list of entries for a field's values (fields like {@link DocumentStatus}).
	 * 
	 * @param fieldsByTag - a Map of types of fields to put into a list
	 * @return the list from where the values can be found 
	 */
	private List<FieldInfo> createList() {
		
		List<FieldInfo> list = new ArrayList<FieldInfo>(10); 
		for (List.Entry<? extends DocumentField> entry : DocumentField.Entry.getList()) {
			list.add(DocumentField.create(entry.getKey(), entry.getValue()).copy());
		}
		createList(list);
		return list;
	}
	
	/**
	 * Create a list from the values of the fields of a list.
	 * 
	 * @param list - the list
	 */
	private void createList(List<FieldInfo> list) {
		list.add(addField(fieldsByTag)); 
	}
	
	/**
	 * Creates a list of entries for a field's values (fields like {@link DocumentStatus}).
	 * 
	 * @param list - the list
	 * @return the list from where the values can be found 
	 */
	private List<FieldInfo> createRequest(List<Int> stat) {
		List<FieldInfo> list = new ArrayList<FieldInfo>(3);
		for (Int statId : stat) {
			list.add(DocumentStatuses.create(statId));
		}
		return list;
	}
	
	/**
	 * Create a map from the map of entries of type {@link DocumentStatuses}.
	 * 
	 * @param stat - a map of entries of type {@link DocumentStatuses}
	 * @return the map from where the values can be found 
	 */
	private Map<Integer, DocumentStatuses> createStatMap(List<FieldInfo> stat) {
		Map<Integer, DocumentStatuses> map = new TreeMap<Integer, DocumentStatuses>();
"
6c9255bd-39a8-4a50-91a6-9e7689953b36,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_1Test.java,57.56183886528015,stop,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name) {
        if (fieldsByName != null) {
            return fieldsByName.get(name);
        }
        return null;
    }
}
","// DictionaryInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(String)} method.
*/
class DictionaryInfo_1Test {","// DictionaryInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(String)} method.
*/
class DictionaryInfo_1Test {
// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name) {
        if (fieldsByName!= null) {
            return fieldsByName.get(name);
        }
        return null;
    }
}

// DictionaryInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(String)} method.
*/
class DictionaryInfo_1Test {
		
	/** Creates a new instance of DictionaryInfo_1Test */
	public DictionaryInfo_1Test() {
	}
	
	/*
	 * Test cases.
	 */
	@Test
	public void test1(){
		/*
		 * Initialization
		 */
	}

	@Test
	public void test2() {
		/*
		 * FieldInfo
		 */
		
		/*
		 * Set fields in DictionaryInfo
		 */
		List<FieldInfo> fields = new ArrayList<>();		
		fields.add(new DefaultFieldInfo(""Field1"", FieldInfo.Type.TEXT, null));
	

		/*
		 * Add fields in DictionaryInfo
		 */
		DictionaryInfo dictionary = new DictionaryInfo();
		assertEquals(null, dictionary.getField(""Field1""));
		dictionary.putField(""Field1"", fields);

		/*
		 * Check fields
		 */
		assertEquals(fields, dictionary.getField(""Field1""));
		assertEquals(fields, dictionary.getField(""Field1""));
		assertEquals(fields, dictionary.getField(""Field1""));
		assertEquals(1, dictionary.getDictionary().size());

	}
	
	@Test
	public void test3(){
		/*
		 * FieldInfo
		 */
		
		/*
		 * Set fields in DictionaryInfo
		 */
		List<FieldInfo> fields = new ArrayList<>();		
		fields.add(new DefaultFieldInfo(""Field1"", FieldInfo.Type.TEXT, null));
	

		/*
		 * Add fields in DictionaryInfo
		 */
	
		/*
		 * Set fields in DictionaryInfo
		 */
		DictionaryInfo dictionary = new DictionaryInfo();
		assertEquals(null, dictionary.getField(""Field1""));
		dictionary.putField(""Field1"", fields);

		/*
		 * Check fields
		 */
		assertEquals(fields, dictionary.getField(""Field1""));
		assertEquals(fields, dictionary.getField(""Field1""));
		assertEquals(fields, dictionary.getField(""Field1""));
		assertEquals(1, dictionary.getDictionary().size());

	} 

	
	@Test
	public void test4(){
		/*
		 * Test cases.
		 */

		
		/*
		 * Set fields in DictionaryInfo
		 */

		List<String> dictionary = new ArrayList<>();

		/*
		 * Add field in DictionaryInfo
		 */

		/*
		 * Set fields in DictionaryInfo
		 */

		/*
		 * Add field in DictionaryInfo
		 */
		dictionary.add(""Item1"");
		
		/*
		 * Add field in DictionaryInfo
		 */
		dictionary.put(""Item2"", ""Field2"");

		/*
		 * Add field in DictionaryInfo
		 */
		dictionary.put(""Item3"", ""Field3"");

		/*
		 * Add field in DictionaryInfo
		 */

		/*
		 * Set fields in DictionaryInfo
		 */
		dictionary.add(""Item4"");
		dictionary.add(""Item5"");
		dictionary.add(""Item6"");

		List<DictionaryInfo> dictionaryInfoList = new ArrayList<>();
		dictionaryInfoList.add(dictionary);

		//check what field in DictionaryInfo is null.
		assertEquals(1, dictionaryInfoList.size());
		List<FieldInfo> fieldInfoList = dictionary.getFields();
		assertEquals(1, fieldInfoList.size());

		
		//check how many information there are in DictionaryInfo.
		List<FieldInfo> fieldInfo = dictionary.getField(""Item1"");
		assertEquals(2, fieldInfo.size());
		
		//check if dictionaries are equal.
		assertTrue(""DictionaryInfo has item1"", dictionaryInfoList.contains(dictionary));
		assertTrue(""FieldInfo has "", fieldInfo.contains(dictionaryInfoList.iterator().next()));

		
		
	} 




    private static class FieldInfo {
        /** Field name. */
        private String name;
        public FieldInfo(String name) {
            this.name = name;
        }
        /**
         * getName()
         *
         * @return a string with the name
         */
        public String getName() {
            return name;
        }
        /**
         * setName()
         *
         * @param name - string containing the name
         */
        public void setName(String name) {
            this.name = name;
        }

       /**
        * getType()
        *
        * @return the type of object
        * @Deprecated
        */
        @Deprecated
        @Deprecated
        public FieldInfoType getType() {
            return null;
        }


        public void setType(FieldInfoType type) {

        }
    }
} 









"
6d4021c4-94b5-408f-b66a-71345cee3bc9,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_2Test.java,61.9377007484436,stop,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id) {
        if (componentsById != null) {
            return componentsById.get(id);
        }
        return null;
    }
}
","// DictionaryInfo_2Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(int)} method.
*/
class DictionaryInfo_2Test {","// DictionaryInfo_2Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(int)} method.
*/
class DictionaryInfo_2Test {
// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id) {
        if (componentsById!= null) {
            return componentsById.get(id);
        }
        return null;
    }
}

// DictionaryInfo_2Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(int)} method.
*/
class DictionaryInfo_2Test {
		private final List<ComponentInfo> componentsById = new ArrayList();

	@Test
	public void hashCode() {
	    assertEquals(componentsById.hashCode(), DictionaryInfo.class.hashCode());
	}

	@Test
	public void equals() {
		assertEquals(true, DictionaryInfo_2Test.class.equals(DictionaryInfo_2Test.class));
		assertEquals(true, DictionaryInfo_2Test.class.equals(DictionaryInfo_2Test.class));
	}

    @Test
    void putTest() {
        // put
        DictionaryInfo_2Test dictTest = new DictionaryInfo_2Test();
        dictTest.put(null, null);
        dictTest.put("""", ""1"");
        dictTest.put(""a:b:c"", ""ABC"");
        assertEquals(""1234abcd"", dictTest.get(""a:b:c"", """"));
        assertFalse(dictTest.contains(""b:c"", ""a:b:c""));
        assertNull(dictTest.get(""d:c"", ""a:b:c""));
        assertNull(dictTest.get(""x:"", """"));

        // remove
        dictTest = new DictionaryInfo_2Test();
        dictTest.put(""b:c:d:e"", ""A"");
        dictTest.put(""b:c:e"", ""B"");
        assertEquals(""ab1234abd"", dictTest.get(""b:c:d:e"", """"));
        assertFalse(dictTest.equals(new DictionaryInfo_2Test()));
        assertFalse(dictTest.equals(""ab1234abd"", ""B""));
        assertFalse(dictTest.equals(""ab1234abd"", ""A""));
        assertTrue(dictTest.equals(new DictionaryInfo_2Test()));
    }

    @Test
    void removeTest() {
        // remove
        DictionaryInfo_2Test dictTest = new DictionaryInfo_2Test();
        dictTest.put(""b:c:d:e"", ""B"");
        assertEquals(""b1234abd"", dictTest.remove(""b:c:d:e""));
        assertEquals(""b1234abd"", dictTest.remove(""b:c:e""));
        assertEquals("""", dictTest.remove(""b:c:e""));
        assertNull(dictTest.remove(""b:c:d:e""));
        assertNull(dictTest.remove(""b:c:e""));

        // contains
        assertTrue(dictTest.contains(""b:c:d:e"", """"));
        assertFalse(dictTest.contains(""b:c:d:e"", ""A""));
        assertTrue(dictTest.contains(""b:c:e"", """"));
        assertFalse(dictTest.contains(""b:c:e"", ""B""));
    }

	@Test
	public void addAndContainsTest() {
		// add
		DictionaryInfo_2Test dictTest = new DictionaryInfo_2Test();
		List<String> names = new TreeMap<String, String>();
		dictTest.add(""b:c:d:e   "", ""1"");
		dictTest.add(""b:c:e"", ""   1"");
		names.add(""b:c:e"");
		names.add(""b:c:d"");
		names.add(""b:c:d:e"");
		names.add(""b:c:d:e"");
		names.add(""b:c:d:e"");
		names.add(""b:c:d"");
		names.add(""b:c:d:e"");

		names.add(""     "");
		names.add(""     1"");
		names.add(""     2"");
		names.add(""     3"");
		names.add(""     4"");
		names.add(""     5"");
		names.add(""     6"");

		assertTrue(dictTest.contains(null, """"));
		assertTrue(dictTest.contains("""", """"));
		names.add(""c:d:e"");
		assertFalse(dictTest.contains(null, """"));
		assertFalse(dictTest.contains("""", """"));
		names.add(""a:b:c""); // contains test.
		names.add(""b:c:d""); // contains test.
		names.add(""b:c:d:e""); // not equals test.
		names.add(""b:c:d:e""); // not equals test.
	}
}
"
dffe2be0-32cb-4196-8125-d621006e3fdd,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_3Test.java,61.89364314079285,length,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name) {
        if (componentsByName != null) {
            return componentsByName.get(name);
        }
        return null;
    }
}
","// DictionaryInfo_3Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(String)} method.
*/
class DictionaryInfo_3Test {","// DictionaryInfo_3Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(String)} method.
*/
class DictionaryInfo_3Test {
// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name) {
        if (componentsByName!= null) {
            return componentsByName.get(name);
        }
        return null;
    }
}

// DictionaryInfo_3Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(String)} method.
*/
class DictionaryInfo_3Test {
		
	@Test
	public void testGetComponent_withName() {
		
		// given
		DictionaryInfo info = new DictionaryInfo();
		
		// when
		ComponentInfo component = info.getComponent(""FIX_MESSAGE_DATA_ID"");
		
		// then
		assertNotNull(component);
		assertEquals(component.getComponentType(), ""FIX_MSG_ID"");
		assertEquals(component.getDictionary(), ""DICTIONARY"");
		assertEquals(component.getVersion(), ""3.2.5"");
		assertEquals(component.getSourceID(), ""FIX_MESSAGE_DATA"");
		assertEquals(component.getCompatibility(), ""FIX_VERSION_REQUIRED"");
	}
	
	@Test
	public void testGetComponent_withVersion() {
		
		// given
		DictionaryInfo info = new DictionaryInfo();
		
		// when
		component = info.getComponent(""FIX_MESSAGE_DATA_ID"", ""3.2.5"");
		
		// then
		assertNotNull(component);
		assertEquals(component.getComponentType(), ""FIX_MSG_ID"");
		assertEquals(component.getDictionary(), ""DICTIONARY"");
		assertEquals(component.getVersion(), ""3.2.5"");
		assertEquals(component.getSourceID(), ""FIX_MESSAGE_DATA"");
		assertEquals(component.getCompatibility(), ""FIX_VERSION_REQUIRED"");
	}
	
	@Test
	public void testGetComponent_withSource() {
		
		// given
		DictionaryInfo info = new DictionaryInfo();
		
		// when
		component = info.getComponent(""FIX_MESSAGE_DATA_ID"", ""FIX_MESSAGE_TYPE_ID"");
		
		// then
		assertNotNull(component);
		assertEquals(component.getComponentType(), ""FIX_MSG_ID"");
		assertEquals(component.getDictionary(), ""DICTIONARY"");
		assertEquals(component.getVersion(), ""3.2.5"");
		assertEquals(component.getSourceID(), ""FIX_MESSAGE_TYPE_ID"");
		assertEquals(component.getCompatibility(), ""FIX_VERSION_REQUIRED"");
	}
	
	@Test
	public void testGetText() {
		
		// given
		DictionaryInfo info = new DictionaryInfo();
		
		// when
		String text = info.getText(""FIX_MESSAGE_DATA_ID"");
		
		// then
		assertNotNull(text);
		assertFalse(text.isEmpty());
		assertEquals(text, ""FIX_MESSAGE_TYPE"");
	}
	
	@Test
	public void testParse() {
		
		// given
		DictionaryInfo info = new DictionaryInfo();
		
		// if
		List<ComponentInfo> components = info.parse(new StringReader(""FIX_MESSAGE_TYPE_ID""));
		
		// then
		assertNotNull(components);
		assertTrue(components.size() <= 1);
	}
	
	@SuppressWarnings(""unused"")
	private final static class ComponentInfo
    implements Comparable<ComponentInfo> {

		private final String m_name; // FIX_MESSAGE_TYPE
		private final String m_dictionary; // ""DICTIONARY""
		private final String m_version; // ""3.2.5""
		private final String m_sourceID; // FIX_MESSAGE_DATA
		private final String m_compatibility; // FIX_VERSION_REQUIRED

		public ComponentInfo(String name, String dictionary, String version, String sourceID, String compatibility) {
			if (name.equals(""FIX_MESSAGE_DATA"")) {
				m_name = ""FIX_MESSAGE_DATA"";
				m_dictionary = dictionary;
				m_version = version;
				m_sourceID = sourceID;
				m_compatibility = compatibility;
			} else if (name.equals(""FIX_MESSAGE_TYPE"")) {
				m_name = ""FIX_MESSAGE_TYPE"";
				m_version = version;
				m_sourceID = sourceID;
				m_compatibility = compatibility;
			} else {
				assertIgnored(name, ""FIX_MESSAGE_DATA"");
				assertIgnored(dictionary, ""FIX_MESSAGE_TYPE"");
				assertIgnored(version, ""FIX_MESSAGE_DATA"");
				assertIgnored(sourceID, ""FIX_MESSAGE_DATA"");
				assertIgnored(compatibility, ""FIX_MESSAGE_TYPE"");
				assertIgnored(""FIX_MESSAGE_TYPE"", name);
			}
		}

		/**
		 * Returns the name.
		 *
		 * @return the name
		 */
		@Override
		public String getName() {
			return m_name;
		}

		/**
		 * Returns the dictionary.
		 *
		 * @return the dictionary
		 */
		@Override
		public String getDictionary() {
			return m_dictionary;
		}

		/**
		 * Returns the version.
		 *
		 * @return the version
		 */
		@Override
		public String getVersion() {
			return m_version;
		}

		/**
		 * Returns the sourceID.
		 *
		 * @return the sourceID
		 */
		@Override
		public String getSourceID() {
			return m_sourceID;
		}

		/**
		 * Returns the compatibility.
		 *
		 * @return the compatibility
		 */
		@Override
		public String getCompatibility() {
			return m_compatibility;
		}

		/**
		 * To string.
		 *
		 * @return to string
		 */
		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append(m_compatibility);
			builder.append(""["");
			builder.append(Util.encode(m_name));
			builder.append(""."");
			builder.append(Util.encode(m_dictionary));
			builder.append(""."");
			builder.append(Util.encode(m_version));
			builder.append("" : "");
			builder.append(Util.encode(Util.to_String(m_sourceID)));
			builder.append(""["");
			StringBuilder sb = new StringBuilder();
			sb.append("" "").append(Util.encode(Util.to_String(m_compatibility)));
			m_name = builder.toString();
			builder.setLength(0);
			sb.clear();
			builder.append(""\""]"");
			builder.append(Util.encode(sb));
			assertTrue(Util.isValid(builder.toString()));
			return builder.toString();
		}

		/**
		 * Tests
		 * - comparing two Components
		 * - comparing a Component with a dictionary name
		 * - comparing the dictionaries
		 *   - when version equals version
		 *   - when source id equals source ID
		 */
		public int compareTo(ComponentInfo another"
cad872dd-f3bf-4e18-9e38-1a022affd068,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_4Test.java,54.242430686950684,stop,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id) {
        if (messagesById != null) {
            return messagesById.get(id);
        } else {
            return null;
        }
    }
}
","// DictionaryInfo_4Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(int)} method.
*/
class DictionaryInfo_4Test {","// DictionaryInfo_4Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(int)} method.
*/
class DictionaryInfo_4Test {
// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id) {
        if (messagesById!= null) {
            return messagesById.get(id);
        } else {
            return null;
        }
    }
}

// DictionaryInfo_4Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(int)} method.
*/
class DictionaryInfo_4Test {
		DictionaryInfo msg;
    /**
     * @tests Constructor
     */
	public void testGetMessage_1() throws Exception {
        List<MessageInfo> messages = new ArrayList<MessageInfo>();
		TreeMap<Integer,MessageInfo> messagesById = new TreeMap<Integer,MessageInfo>();
		
    	String msgStr = """";
    	TreeMap<Integer,MessageInfo> msgById = new TreeMap<Integer,MessageInfo>();
		
    	msgStr = ""Lorem ids dogeblahasd"";
		// add the message
		msg = MessageInfo.getMessage(msgStr);
    	assertTrue(""msg should not be null"", msg!= null);
        messages.add(msg);
    	msgStr = ""Lorem id tau"";
		// verify the message id
		int id_msg = -2; // negative test id
		MessageInfo msgId = MessageInfo.getMessage(msgStr);
		assertNotNull(""No message should have been created"", msgId);
        assertEquals(""Msg id should have been created by getMessage"", id_msg, msgId.getID());
        // add message for another id
        int count = 0;
        for (int i = 1; i < 10; i++) {
        	id_msg = i;
            msgId = MessageInfo.getMessage(msgStr);
            assertNotNull(""No message should have been created"", msgId);
        	assertEquals(""Msg id should have been created by getMessage"", id_msg, msgId.getID());
        
        	count++;
        	messages.add (msgId);
        	messagesById.put(id_msg, msgId);
           }
        assertTrue(""There should have been 10 messages"", count == 10);
   
        // remove all messages (by id's) from the database
        msgById.clear();
        List<MessageInfo> noMessages = new ArrayList<MessageInfo>();
        noMessages.addAll(messages);
        List<Integer> noIds = new ArrayList<Integer>();
        noIds.addAll(messagesById.keySet());
        msgById = new TreeMap<Integer, MessageInfo>();
        List<MessageInfo> messageList = new ArrayList<MessageInfo>();
        for (MessageInfo msg : noMessages) {
            messageList.add(msg);
        }
        List<Integer> list = new ArrayList<Integer>();
        list.addAll(noIds);
        List<TestData> list2 = new ArrayList<TestData>();
        list2.add(new TestData(list));
        list2.add(new TestData(noIds));
        messageList.add(new TestData(list2));
        noMessages = valueDictionary(messageList);
        for (MessageInfo message : noMessages) {
        	deleteMessage(message);
       }

        // verify that the no messages are in the database
        List<MessageInfo> noMessageList = new ArrayList<MessageInfo>();
        noMessageList.addAll(noMessages);
        assertTrue(""Should only have messages"", noMessages.size() == 5);
        for (MessageInfo msg : noMessageList) {
        	assertTrue(""Should be absent from the database"",!msg.isPresent());
    
        	int id_msg = msg.getID();
        	int id = messagesById.get(id_msg).getID();
        	if (id == id_msg) {
                    msgById.put(id, msg);
        	}
    	}
        assertTrue(""Should have at least one message"", msgById.size() > 0);
  
        // verify that the messages exist
        List<MessageInfo> messageList2 = new ArrayList<MessageInfo>();
        deleteMessage(msg);
        List<MessageInfo> messageList3 = new ArrayList<MessageInfo>();
        List<MessageInfo> messageList4 = new ArrayList<MessageInfo>();
        List<MessageInfo> messages = new ArrayList<MessageInfo>(messagesById);
        for (MessageInfo msg : messages) {
        	messageList2.add(msg);
        }
    	for (int i = 0; i < messageList.size(); i++) {
    		if (i < 10) {
            	messageList3.add(messageList2.get(i));
            } else {
    				messageList4.add(messageList2.get(i));
    			}
        }
        assertTrue(""messages should come from one of messages"", messageList3.size() == 1);
        assertTrue(""messages should come from the other"", messageList4.size() > 0);
        assertEquals(""messages should be the same"", messageList2.size(), messageList4.size());
    	assertEquals(""deleted messages"", 4, messageList2.size() - messageList3.size());
	}
    /**
     * @tests Cloneable
     */
	// DictionaryInfo_5Test.java
	@Test
	public void testCloneable() throws Exception {
    	try {
        	MessageInfo message = null;
        	boolean isPresent = DictionaryInfo.getMessage(10).isPresent();
        	assertFalse(""isPresent should be false"", isPresent);
        	msg = DictionaryInfo.getMessage(10);
        	assertTrue(""Is present"",!msg.isPresent());
        	msg = new MessageInfo(10, true);
        	assertTrue(""msg should be present"",!msg.isPresent());
        	msg = new MessageInfo(10, true);
        	assertTrue(""msg should be present"", msg.isPresent());
        	// create one after changing a message
        	message = DictionaryInfo.getMessage(5);
        	assertTrue(""message should be present"", message!= null);
        	msg = message;

        	// add a bunch of more messages
        	int count = 0;
        	while (count < 10000) {
        		if (isPresent) {
        			throw new Exception(""message is present"");
        		} else {
            		isPresent = DictionaryInfo.getMessage(count).isPresent(); 			
        		}
        		count++;
        	}
        	assertTrue(""is not present after cloning"", isPresent);
        	return;
    	} catch (Throwable t) {
        	t.printStackTrace();
        	fail(""should not throw any exception"");
        }
	}
}
"
8bfb8047-d5fa-4cc0-8613-5c818bc8c989,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_5Test.java,61.771750688552856,stop,"// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name) {
        if (messagesByName != null) {
            return messagesByName.get(name);
        } else {
            return null;
        }
    }
}
","// DictionaryInfo_5Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(String)} method.
*/
class DictionaryInfo_5Test {","// DictionaryInfo_5Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(String)} method.
*/
class DictionaryInfo_5Test {
// DictionaryInfo.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name) {
        if (messagesByName!= null) {
            return messagesByName.get(name);
        } else {
            return null;
        }
    }
}

// DictionaryInfo_5Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(String)} method.
*/
class DictionaryInfo_5Test {
		@Test
		void testGetMessage() {
            DictionaryInfo dictionaryInfo = new DictionaryInfo();
			List<String> messageKeys = new ArrayList<>();
			messageKeys.add(""Branch1"");
			messageKeys.add(""Branch2"");
			messageKeys.add(""Branch3"");
			dictionaryInfo.setMap(messageKeys);
			assertNotNull(dictionaryInfo.getMessage(""Branch1""));
			assertNotNull(dictionaryInfo.getMessage(""Branch2""));
			assertNotNull(dictionaryInfo.getMessage(""Branch3""));
		}
}
    // DictionaryInfo.java
"
