ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
0830dc1d-1592-4839-95a3-b70975f84d4a,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/config/EnumeratedProperties.java,57.90338897705078,stop,"// EnumeratedProperties.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * Extension of {@link java.util.Properties} which allows one to specify property values which are
 * Lists of Strings.
 *
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class EnumeratedProperties extends Properties {

    /**
     * Returns the List value of the property with the supplied key. Note that one can call
     * getEnumeratedProperty() for a given key successfully if and only if setEnumeratedProperty()
     * for that key was called some time beforehand. All members of the list returned will be
     * Strings.
     *
     * @param key lookup of the enumerated property to be retrieved.
     * @return list containing String values
     */
    public List<String> getEnumeratedProperty(String key);
}
","// EnumeratedPropertiesTest.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EnumeratedProperties}.
* It contains one unit test case for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
*/
class EnumeratedPropertiesTest {","// EnumeratedPropertiesTest.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EnumeratedProperties}.
* It contains one unit test case for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
*/
class EnumeratedPropertiesTest {
private final String key = ""FOO"";
			enum FOO {
			FOO1, FOO2
			}

	@Test
    public void test() {
		EnumeratedProperties esp = new EnumeratedProperties();
		assertEquals(esp.contains(FOO), 			FOO.FOO1 == esp.getEnumeratedProperty(key));
		assertEquals(esp.contains(FOO), 			FOO.FOO2 == esp.getEnumeratedProperty(key));
		assertEquals(esp.contains(FOO), 
					!esp.containsUnset(key));
		esp.setEnumeratedProperty(key, FOO.FOO3);
		assertEquals(esp.contains(FOO.FOO3), FOO.FOO3 == esp.getEnumeratedProperty(key));
		assertTrue(Foo.FOO10 == esp.getEnumeratedProperty(key));
		assertTrue(Foo.FOO11 == esp.getEnumeratedProperty(Foo.FOO12));
    }


}
"
c5d48a1e-2831-4439-9c99-f55b85335307,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextPaneDestination.java,60.856196880340576,stop,"// JTextPaneDestination.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;

/**
 * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextPane}.
 *
 * @see OutputDestination
 * @see JTextPane
 * @author <a href=""mailto:carl.hall@gmail.com"">Carl Hall</a>
 */
public class JTextPaneDestination implements OutputDestination {

    /**
     * @return whether caret will be automatically moved to the bottom of the text area when text is
     *         appended
     */
    public boolean autoPositionCaret();
}
","// JTextPaneDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextPaneDestination}.
* It contains one unit test case for the {@link JTextPaneDestination#autoPositionCaret()} method.
*/
class JTextPaneDestinationTest {","// JTextPaneDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextPaneDestination}.
* It contains one unit test case for the {@link JTextPaneDestination#autoPositionCaret()} method.
*/
class JTextPaneDestinationTest {
/**
     * Test case which tests the auto-detecting of the auto-positioning of the caret and a null value.
     * It needs to change the state of the caret and create a BrokenJTextPane.
     */
    @Test
    void testAutoPositionCaretNull()  {
        final int MAX_SIZE = 100;
        final JTextPane tp = new JTextPane();
        tp.addHyperlinkListener( e -> Logger.getLogger( JTextPaneDestinationTest.class.getName()).log(Level.INFO, ""Added listener {0}"", e) );

        assertTrue( tp.autoPositionCaret() );
    }

    /**
     * Test case which tests the auto-detecting of the auto-positioning of the caret and a value greater
     * than {@value MAX_SIZE}.
     */
    @Test
    void testAutoPositionCaretValueGreaterMaxSize() {
        final JTextPane tp = new JTextPane();
        tp.addHyperlinkListener( e -> Logger.getLogger( JTextPaneDestinationTest.class.getName()).log(Level.INFO, ""Added listener {0}"", e) );
        try {
            assertTrue( tp.autoPositionCaret() ); 
        }
        catch (BadLocationException ex){}
        assertFalse( tp.autoPositionCaret() ); 
    }

    /**
     * Test case which tests the auto-detecting of the auto-positioning of the caret and a value less
     * than {@value MAX_SIZE}.
     */
    @Test
    void testAutoPositionCaretValueLessMaxSize() {
        final JTextPane tp = new JTextPane();
        tp.addHyperlinkListener( e -> Logger.getLogger( JTextPaneDestinationTest.class.getName()).log(Level.INFO, ""Added listener {0}"", e) );
        try {
            assertFalse( tp.autoPositionCaret() ); 
        }
        catch (BadLocationException ex){}
    }

    /**
     * The same test case as below, but with carets in the text area.
     */
    @Test
    void testSameTestCaseWithCaretInTextArea() {
        final JTextPane tp = new JTextPane();
        tp.addHyperlinkListener( e -> Logger.getLogger( JTextPaneDestinationTest.class).log(Level.INFO, ""Added listener {0}"", e) );
        assertTrue(  tp.autoPositionCaret() );
    }
}

// <editor-fold defaultstate=""collapsed"" desc=""Nested classes"">"
0dbf387e-95c2-4857-99f3-5c4e0f286de5,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextComponentDestination.java,31.943666219711304,stop,"// JTextComponentDestination.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;

/**
 * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextComponent}.
 *
 * @see OutputDestination
 * @see JTextCompnent
 * @author <a href=""mailto:carl.hall@gmail.com"">Carl Hall</a>
 */
public class JTextComponentDestination extends FilterableOutputDestination {

    /**
     * @return whether caret will be automatically moved to the bottom of the text area when text is
     *         appended
     */
    public boolean autoPositionCaret();
}
","// JTextComponentDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextComponentDestination}.
* It contains one unit test case for the {@link JTextComponentDestination#autoPositionCaret()} method.
*/
class JTextComponentDestinationTest {","// JTextComponentDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextComponentDestination}.
* It contains one unit test case for the {@link JTextComponentDestination#autoPositionCaret()} method.
*/
class JTextComponentDestinationTest {
/**
		 * Sets given parameter as argument for {@link JTextComponentDestination#autoPositionCaret()} method.
		*
		* @param autoPositionCaret argument
		 */
		public JTextComponentDestinationTest(final boolean autoPositionCaret) {
			this.autoPositionCaret = autoPositionCaret;
		}
		
		/**
		 * Tester for when {@link JTextComponentDestination#getOutputType()} is {@link OutputType#TEXT}.
		 */
        @Test
        public void autoPositionCaretTEXT() {
                assertTrue(""The result of autoPositionCaret() test should be true"", this.autoPositionCaret);
        }
}

// UnitTest.java
// Copyright (c) 1999-2004 The University of Sheffield. See the file
// ""file.html"" in the edu-most-released subversion at
// http://gate.ac.uk/gate/dotgnu/
"
cc4fd989-3db9-453c-88a4-e94757c21167,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_0Test.java,54.32820677757263,stop,"// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    /**
     * Searches for a term. If the term provided matches the last searched term, the last found
     * position is used as a starting point.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term The string for which to search.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term);
}
","// SearchableTextPane_0Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String)} method.
*/
class SearchableTextPane_0Test {","// SearchableTextPane_0Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String)} method.
*/
class SearchableTextPane_0Test {

    /**
     * Test method for 'SearchableTextPane.search(String)'
     */
    @Test
    public void testSearchString() {
        // Arrange

        String s = ""abcd"";
        List<String> list = new ArrayList<>();
        list.add(""a"");
        list.add(""b"");
        list.add(""c"");
        list.add(""d"");

        // Assert

        // Act

        // Assert
        
        // Act
        assertEquals(""abcd"", search(""Abcd""));
        // assertEquals(""aAb"", search("" aAb""));
        // assertEquals(""AaB"", search(""Ab""));
        // assertEquals(""aDa"", search(""Da""));
        assertEquals(""aBc"", search(""bc""));
        assertEquals(""aDc"", search(""dc""));
        assertEquals(""aDd"", search(""d""));
        assertEquals("""", search(""""));
        assertEquals("""", search("" ""));
        assertEquals("""", search(""\n""));
        assertEquals("""", search(""\r""));
        assertEquals("""", search(""\t""));
        assertEquals("""", search("" \t ""));
    }
}

// SearchableTextPane_0Test_1Test.java
"
de15c2e3-b908-4cc9-b575-c58bc9614fbf,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_1Test.java,54.36693501472473,length,"// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    /**
     * Searches for a term at the given starting position.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term The string for which to search.
     * @param startPos Where to start.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term, int startPos);
}
","// SearchableTextPane_1Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String, int)} method.
*/
class SearchableTextPane_1Test {","// SearchableTextPane_1Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains one unit test case for the {@link SearchableTextPane#search(String, int)} method.
*/
class SearchableTextPane_1Test {

    /**
     * Tests the {@link SearchableTextPane#search(String, int) constructor}.
     * This constructor checks that the 
     * {@link SearchableTextPane#search(String, int) search(String, int)} 
     * method returns the proper value.
     */
    @Test
    public void testSearch_0_Constructor() {
        
        {
            // An empty text
            DefaultHighlighter highlighter = new DefaultHighlighter();
            Element elementText = highlighter.getHighlightPainter().getStart();
            Document doc = highlighter.createDefaultHighlighter().createDocument(0L, document);
            DefaultHighlightPainter.Level[] newLevels = new DefaultHighlightPainter.Level[0];
            Element[] newText = newElementArray(doc.getRootElement().getDocumentElement(), newLevels);
            DefaultHighlightPainter.Level[] prevLevels = new DefaultHighlightPainter.Level[1];
            Element[] prevText = newElementArray(document.getRootElement(), prevLevels);
            
            assertTrue(elementText.getStartOffset() == 0);
            assertEquals(newText[0], elementText);
            
            {
                doc.setText(elementText.getText());
                DefaultHighlighter highlighter = new DefaultHighlighter();
                Element newRoot = highlighter.createDefaultHighlighter().createDocument(0L, doc);
                Document doc2 = newRoot.getDocument();
                Element newText2 = getText(doc2, 1L);
                DefaultHighlightPainter.Level newLevel = new DefaultHighlightPainter.Level(0, 0, 0, 0, 0, 0);
                highlighter.addExtraRange(prevText[0], newText[0], newLevel);
                highlighter.addExtraRange(newText2, newRoot.getDocument().getText(1, newText2.getEndOffset()-1), newLevel);
                
                Element newText3 = getText(doc2, 4L);
                highlighter.addExtraRange(newText3, newText2, newLevel);
                checkText(doc, newText2);
            }
            
            for (int i = 0; i < 3; i++) {
                Element newElement = highlighter.createDefaultHighlighter().createDocument(0L, doc);
                
                int newOffset1 = Utilities.getText(newElement, 0L).length();
                int newOffset2 = Utilities.getText(newElement, 1L).length();
                assertTrue(newOffset1 > 0);
                assertEquals(newOffset1, newOffset2);
                
                int newOffset5 = Utilities.getText(newElement, 5L).length();
                int newOffset6 = Utilities.getText(newElement, 6L).length();
                assertTrue(newOffset5 > 0);
                assertEquals(newOffset5, newOffset6);
                
                defaultHighlighter.removeExtraRange(prevText[0], prevText[1]);
                
                setText(doc, newText, newElement);
                checkText(doc, newText);
            }
            
            int newOffset1 = Utilities.getText(newElement, 0L).length();
            int newOffset2 = Utilities.getText(newElement, 1L).length();
            assertTrue(newOffset1 > 0);
            assertEquals(newOffset1, newOffset2);
            
            int newOffset5 = Utilities.getText(newElement, 5L).length();
            int newOffset6 = Utilities.getText(newElement, 6L).length();
            assertTrue(newOffset5 > 0);
            assertEquals(newOffset5, newOffset6);
        }
        
        {
            // A good text
            DefaultHighlighter highlighter = new DefaultHighlighter();
            Element elementText = highlighter.getHighlightPainter().getStart();
            Document doc = highlighter.createDefaultHighlighter().createDocument(0L, doc);
            DefaultHighlightPainter.Level[] newLevels = new DefaultHighlightPainter.Level[0];
            Element[] newText = newElementArray(doc.getRootElement().getDocumentElement(), newLevels);
            DefaultHighlightPainter.Level[] prevLevels = new DefaultHighlightPainter.Level[1];
            Element[] prevText = newElementArray(document.getRootElement(), prevLevels);
            
            assertTrue(elementText.getStartOffset() == 0);
            assertEquals(newText[0], elementText);
            
            checkText(doc, newText[0], true);
                
            Element newRoot = highlighter.createDefaultHighlighter().createDocument(0L, doc);
 
            Element newText2 = new Element(""NEW"");
            Element textElement = newRoot.addElement(newText2);
                
            final List<Element> textSubTree = new ArrayList<Element>();
            StringBuffer textBuffer = new StringBuffer();
            try {
                textBuffer.append(newRoot.getElement(1).getStartElement().getEndOffset()-1);
            } catch (BadLocationException e) {
                e.printStackTrace();
            }
            while (newText2.getEndOffset()-1 > 0) {
                    textSubTree.add(newRoot.getElement(newText2.getEndOffset()-1));
                }
            
            int newOffset1 = Utilities.getText(newText).length();
            int newOffset2 = Utilities.getText(textSubTree).length();
            assertTrue(newOffset1 > 0);
            assertEquals(newOffset1, newOffset2);
            
            String newText3 = newRoot.getElement(2).getStartElement().getNormalizedContent();
            checkText(doc, newText2, true, textBuffer);
            checkLanguages(newText2);
            
            int newOffset5 = Utilities.getText(newText3).length();
            int newOffset6 = Utilities.getText(textSubTree).length();
            assertTrue(newOffset5 > 0);
            assertEquals(newOffset5, new"
0b341bd7-dea8-4511-829c-151247bdaf91,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/gui/FileFollowingPane.java,54.56189703941345,length,"// FileFollowingPane.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;

/**
 * A component which allows one to view a text file to which information is being asynchronously
 * appended.
 *
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollowingPane extends JScrollPane {

    /**
     * Returns whether caret is automatically repositioned to the end of the text area when text is
     * appended to the followed file
     *
     * @return whether caret is automatically repositioned on append
     */
    public boolean autoPositionCaret();
}
","// FileFollowingPaneTest.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollowingPane}.
* It contains one unit test case for the {@link FileFollowingPane#autoPositionCaret()} method.
*/
class FileFollowingPaneTest {","// FileFollowingPaneTest.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollowingPane}.
* It contains one unit test case for the {@link FileFollowingPane#autoPositionCaret()} method.
*/
class FileFollowingPaneTest {
class AutoPositioningTextPanel extends SearchableTextPane {
				/**
				 * Constructor.
				 *
				 * @param document the document to which text is to be appended
				 */
				public AutoPositioningTextPanel(Document document) {
					super(document);
				}
				protected void autoPositionCaret() {
					try {
						int current = getDocument().getLength();
						Document doc = getDocument();
						int first = doc.getLength();
						doc.insertString(current, "" "", null);
						doc.setText(0, getDocument().getLength());
						assertNotNull(""setLength(false) should not have failed!"", current);
						assertTrue(""document text should not have been cleared"", first > 0);
						assertTrue(""document should have just been added!"", getDocument().getLength() == current);
						doc.getText(++current, 1);
						assertTrue(""document text should have been updated"", getDocument().getLength() == current - 1);
						assertTrue(""document text should be empty"", doc.getText(new Integer(first)) == """");
					}
					catch (BadLocationException e) {
						fail(""setLineSeparator(false) should not have failed!"", e);
					}
				}
				public AutoPositioningTextPanel(Document document, Font font) {
					super(document, font);
				}
				public AutoPositioningTextPanel(Document document, Font font, int size) throws BadLocationException {
					super(document, font, size);
				}
				protected AutoPositioningTextPanel(Document document, Font font, int size, boolean vertical) throws BadLocationException {
					super(document, font, size, vertical);
				}
				public AutoPositioningTextPanel(Document document, Font font, int size, boolean vertical, int startline, int endline) throws BadLocationException {
					super(document, font, size, vertical, startline, endline);
				}
		}

		// Constructor for following Pane, which does the real work.
		public FileFollowingPaneTest(FileFollower ff, OutputDestination od) {
		  	super();
		  	this.fileFollower = ff;
		  	this.od = od;
		  	this.init();
		}
		public void init() {
			try {
				fileFollower.start();
				this.fileFollowingTextPane
						.setInputDestination(new JTextComponentDestination(fileFollower.getOutputFile()));
				FileOutputStream fo = new FileOutputStream(fileFollowingTextPane.getCurrentOutputFile());
				long[] bytesToWrite = new long[(sizeHint.width+sizeHint.height)/2];
				for (long i = 0; i < sizeHint.width; i++) {
					for (long j = 0; j < sizeHint.height; j++) {
						long l = 0;
				    	l = i;
				    	l = l << 32;
				    	l = l | j;
				    	l = l << 32;
				    	l = l | (i-l)+l;
				    	fo.write(l);
					}
					l = bytesToWrite[0];
					l = l << 32;
					l = l | i;
					l = l << 32;
					l = l | (i-l)+l;
					fo.write(l);
					bytesToWrite[0] = l;
					bytesToWrite[1] = bytesToWrite[1] << 32;
					bytesToWrite[1] = bytesToWrite[1] | i;
					fo.write(bytesToWrite);
				}
				fo.flush();
				fo.close();
				assertTrue(""Output file should be written!"", fileFollowingTextPane.getTextFile().exists());
				assertTrue(""Output file should be closed!"", fileFollowingTextPane.getTextFile().isNonStrictModeEnabled());
			}
			catch (IOException e) {
				fail(""Unable to create output file!"");
			}
		}
		/**
		 * This method should throw {@link BadLocationException} when autoPositioning the appended
		 *  file position is beyond the end of the text area.
		 */
		public boolean autoPositionCaret(){
			try {
				this.fileFollowingTextPane.getText().delete(getDocument().getLength(),
						getDocument().getLength());
				this.fileFollowingTextPane.getScrollPane().getHorizontalScrollBar().setValue(0);
				this.fileFollowingTextPane.getScrollPane().setHorizontalScrollBarPolicy(
						JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
				JTextComponentDestination outputDestination =
						(JTextComponentDestination)fileFollower.getOutputFile();
				outputDestination.setOutputFile(this.fileFollowingTextPane.getCurrentOutputFile());
				if (!autoPositionCaret()) {
					assertTrue(""Output text should have been appended!"", this.fileFollowingTextPane.getTextFile().exists());
					Document document = getDocument();
					AutoPositioningTextPanel textPanel = new AutoPositioningTextPanel(document, Font.decode(""Courier 710, MS Sans Serif""));
					try {
						long p = textPanel.findPosition(document.getLength());
						throw new RuntimeException(""BadPositionException should have been thrown for the auto position, but was not"");
					}
					catch (RuntimeException t) {
						String msg = ""The autoPositionCaret should have failed, but got the exception: "";
						msg += t.getMessage();
						Logger.getLogger(""hg4hm"").log(Level.SEVERE, msg);
					}
				}
			} catch (BadLocationException e) {
			}
			return autoPositionCaret();
		}
		FileFollowingTextPane fileFollowingTextPane;
		OutputDestination fileFollowingTextPane;
		FileFollower fileFollower;
		OutputDestination fileFollowerOutputd;
		OutputDestination od;
		FileFollowingTextPane fileFollowingTextPane;
		OutputDestination fileFollowingTextPaneOutputd;
		Logger logger = Logger"
74db1412-4880-46c8-9039-558d23f77443,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_0Test.java,57.37909698486328,length,"// FileFollower.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Instances of this class 'follow' a particular text file, assmebling that
 * file's characters into Strings and sending them to instances of
 * {@link OutputDestination}. The name and behavior of this class are inspired
 * by the '-f' (follow) flag of the UNIX command 'tail'.
 *
 * @see OutputDestination
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollower {

    /**
     * Add another OutputDestination to which the followed file's contents
     * should be printed.
     *
     * @param outputDestination OutputDestination to be added
     */
    public boolean addOutputDestination(OutputDestination outputDestination);
}
","// FileFollower_0Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#addOutputDestination(OutputDestination)} method.
*/
class FileFollower_0Test {","// FileFollower_0Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#addOutputDestination(OutputDestination)} method.
*/
class FileFollower_0Test {

	static List<String> textFileContent;
	static List<File> textFileContents;
	static boolean testCondition = true;
	
    /**
     * Tests the following method with a file path.
     */
    @Test
    public void testAdd_FileFollower() {
        if (testCondition) {
                    // The following line adds a file to the list.
            final FileFollower inputDestination = new FileFollower();
            testCondition = false;
            assertNotNull(inputDestination);
            inputDestination.addFile(new File(""test.txt""));
            FileFollower outputDestination = new FileFollower();
            testCondition = false;
            assertNotNull(outputDestination);
            outputDestination.addOutputDestination(inputDestination);
        }
		// This tests a path to a file without a trailing path separator
		File testFile = new File(""file"");
		List<File> textFileContents1 = new ArrayList<File>();
        List<File> textFileContents2 = new ArrayList<File>();

        textFileContents.add(testFile);
        textFileContents1.add(new File(testFile.getParentFile(), ""textfile.go""));
        textFileContents.add(new File(testFile.getParentFile(), ""moretextfile.go""));
        textFileContents2.add(testFile);
        textFileContents.add(new File(testFile.getParentFile(), ""Textfile.go""));
        textFileContents2.add(new File(testFile.getParentFile(), ""textfile.go""));
        textFileContents.add(new File(testFile.getParentFile(), ""moretextfile.go""));
        textFileContents2.add(new File(testFile.getParentFile(), ""moresultfile.go""));

        textFileContents1.add(testFile);                
        textFileContents2.add(testFile);                
        List<File> textFileContents3 = new ArrayList<File>();
        textFileContents3.add(testFile);
        textFileContents3.add(testFile);
        listWithPathsOfContentsTest_0_1(""/"", true, testFile, textFileContents1, textFileContents2, ""file"");
        listWithPathsOfContentsTest_0_1(""/"", true, testFile, textFileContents1, textFileContents2, ""moresultfile"");
        listWithPathsOfContentsTest_0_2(""/"", true, testFile, textFileContents1, textFileContents2, ""Textfile.go"");
        listWithPathsOfContentsTest_0_2(""/"", true, testFile, textFileContents1, textFileContents2, ""moretextfile.go"");
	}
	
    /**
     * Tests a path to a file with a trailing path separator. 
     * @param testPath path to a file with a trailing path separator
     * @param inputText1 flag indicating whether input text is a file
     * @param fileContents3 file to be tested
     * @param pathContents3 paths to be tested
     * @param testCondition the condition for testing the condition
     * 
     * @since 1.0
     */
    void listWithPathsOfContentsTest_0_1(String testPath, boolean inputText1, File file, List<File> fileContents3, List<File> pathContents3, String testCondition) {
        if (testCondition) {
                    // The following line adds a file to the list.
            List<File> textFileContents;
	 
            if (inputText1) {
                // Adding a file to the list should not add a file to the following paths.
                fileContents3.add(new File(testPath));
            } else {
                // Adding a path to a file should add a path to the following paths.

                // Adding a path to a file should not add a path to the following paths.
                pathContents3.add(new File(testPath));

                // If the following conditions are met, the following paths should not be equal.
                fileContents3.add(new File(testPath));
                fileContents3.add(new File(testPath));

		// If the following conditions are met, this should add a path to the followings paths.
		pathContents3.add(new File(testPath));
                }
        }
        textFileContent = new ArrayList<File>();
        // Adding a file to the list should not add a file to the following path.
        fileContents3.add(new File(testPath));
        textFileContent = new ArrayList<File>();

        // Adding a path to a file should add a path to the following path.

        // Add both files to the list.
        textFileContents3.add(new File(testPath));
        textFileContents.add(fileContents3);

        // Adding a condition to the following file should add a path to the following conditions.
        inputText1 = true;
        pathContents3.add(new File(testPath));
        List<File> conditionTextFileContents;
        // It should not use the path to the first file.
        // There is no way that you can differentiate this from the other.
        pathContents3.add(new File(testPath));
	conditionTextFileContents = new ArrayList<File>();
        // The following conditions shall pass for all the other conditions.
        conditionTextFileContents.add(new File(testPath));
        // If the following conditions are met, the following conditions should not be equal.
        pathContents3.add(new File(testPath));
        pathContents3.add(new File(testPath));
        pathContents3.add(new File(testPath));
        // If both conditions are met, the following condition should add a path to the following conditions.
        conditionTextFileContents = new ArrayList<File>();
        conditionTextFileContents.add(new File(testPath));
        pathContents3.add(conditionTextFileContents);
        pathContents3.add(new File(testPath));
        pathContents3.add(new File(testPath));

        // Add both conditions to the list.
        inputText1 = false;
        conditionTextFileContents = new ArrayList<File>();
        // If both conditions are met, the following conditions shall fail.
        conditionTextFileContents.add(new File(testPath));
        conditionTextFileContents.add(new File(testPath));
        conditionTextFileContents.add(new File(testPath));
        // The following conditions should succeed.
        pathContents3.add(conditionTextFileContents);

        if (!testCondition) {
            // All of the following conditions should fail.
            pathContents3.add("
b40a8ad8-e08f-4020-8085-dee6355feb4f,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_1Test.java,57.136035680770874,length,"// FileFollower.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Instances of this class 'follow' a particular text file, assmebling that
 * file's characters into Strings and sending them to instances of
 * {@link OutputDestination}. The name and behavior of this class are inspired
 * by the '-f' (follow) flag of the UNIX command 'tail'.
 *
 * @see OutputDestination
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollower {

    /**
     * Remove the supplied OutputDestination from the list of OutputDestinations
     * to which the followed file's contents should be printed.
     *
     * @param outputDestination OutputDestination to be removed
     */
    public boolean removeOutputDestination(OutputDestination outputDestination);
}
","// FileFollower_1Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.
*/
class FileFollower_1Test {","// FileFollower_1Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains one unit test case for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.
*/
class FileFollower_1Test {

    /**
     * Test cases to be run by this class through the {@link FileFollower#removeOutputDestination(OutputDestination)} method,
     * where the file's contents to be printed is '-f F.txt'.
     * @throws IOException on failure
     * @throws InterruptedException on failure
     * @see FileFollower.FileFollower_1Test#removeOutputDestination(OutputDestination,OutputDestination)
     */
    @Test
    void testRemoveOutputDestination_F() throws IOException, InterruptedException {
        FileFollower f = new FileFollower(OutputDestination.STDOUT);
        f.setDestination(OutputDestination.STDOUT);
        f.setFoldersToFollow(new ArrayList<File>());
        
        f.setFile(""-f F.txt"");
        
        f.after(1);
        
        f.after(1);
        
        f.after(1);
        
        OutputDestination f1 = output(""F.txt"", ""F"");
        f1.after(1);
        
        assertEquals(f.getDestination(), OutputDestination.STDERR);
        OutputDestination.STDOUT.clear();
        assertEquals(f.getDestination(), OutputDestination.STDOUT);
    }
    
    /**
     * Test cases to be run by this class through the {@link FileFollower#removeOutputDestination(OutputDestination)} method,
     * where the file's contents to be printed is '-f F.txt'.
     * @throws IOException on failure
     * @throws InterruptedException on failure
     * @see FileFollower.FileFollower_1Test#removeOutputDestination(OutputDestination,OutputDestination)
     */
    @Test
    void testRemoveOutputDestination_S() throws IOException, InterruptedException {
        FileFollower f = new FileFollower(OutputDestination.STDERR);
        f.setDestination(OutputDestination.STDERR);
        f.setFoldersToFollow(new ArrayList<File>());
        
        f.setFile(""-f F.txt"");
        
        f.after(1);
        
        f.after(1);
        
        OutputDestination f1 = output(""F.txt"", ""F"");
        f1.after(1);
        
        assertEquals(f.getDestination(), OutputDestination.STDOUT);
        OutputDestination.STDERR.clear();
        assertEquals(f.getDestination(), OutputDestination.STDOUT);
    }
    
    /**
     * Test case to be executed when you have written one or more files to F.txt, but not 
     * to any other folder or file name, before the {@link #waitForOutputDestinationToDisappearByWaitingForAnyOutputToPrintToAFile(File)}
     * command completes (which may be the case if the file contents have already been '-f F.txt').  
     * The class 'waitForOutputDestinationToDisappearByWaitingForAnyOutputToPrintToAFile' is meant to be used when we're
     * working with the outputs of a {@link FileFollower} that are not yet {@link FileFollower#waitForOutputDestinationToDisappearByWaitingForAnyOutputToPrintToAFile(File)}. 
     */
    @Test
    void testWaitForOutputDestinationToDisappearButNotAFile() throws IOException, InterruptedException {
        FileFollower f = new FileFollower(OutputDestination.STDOUT);
        f.setDestination(OutputDestination.STDOUT);
        f.setFoldersToFollow(new ArrayList<File>());
        
        f.setFile(""-f F.txt"");
        
        output(""-"", ""F"");

        OutputDestination f1 = output(""F.txt"", ""F"");

        f.waitForOutputToDisappearByWaitingForAnyOutputToPrintToAFile();
        
        f.waitForOutputToDisappearByWaitingForAnyOutputToPrintToAFile();
        
        assertEquals(OutputDestination.STDERR, f.getDestination());
    }
    
    private void waitForOutputDestinationToDisappearByWaitingForAnyOutputToPrintToAFile() {
    	int exitCode = 0;
        while (exitCode!= 1 || File.exists(""F.txt"")) {
            logger.log(Level.WARNING, ""Waiting for any file to print to F..."");
            Thread.sleep(100);
        }
    }
    
    private void assertOutputDestinationToDisappearByWaitingForAnyOutputToPrintToAFile() {
        File expectedFile = new File(""F.txt"");
        File actualFile = new File(""F.txt"");
        
        assertSame(expectedFile, actualFile);
        
        assertTrue(expectedFile.exists());
    }
    
    private static String output(String fileName, String fileExtension) {
        return OutputDestination.STDOUT.outputToString() + ""\""  "" + fileName + ""  "" + fileExtension;
    }

    /**
     * An output destination, used by {@link FileFollower#waitForOutputToDisappearByWaitingForAnyOutputToPrintToAFile()}
     */
    public static class OutputDestination {
        
        //private static int numThreads = 1;
        
        public static List<OutputDestination> getOutputDestinations(List<File> foldersToFolders) {
            //numThreads = 1;
            synchronized (OutputDestination.class) {
                assert numThreads > 1;
                //assert (numThreads % 2 == 1);
                List<OutputDestination> destinations = new ArrayList<OutputDestination>();
                
                OutputDestination dest1 = new FileFollower().waitForOutputToDisappearByWaitingForAnyOutputToPrintToAFile();
                OutputDestination dest2 = new FileFollower().waitForOutputToDisappearByWaitingForAnyOutputToPrintToAFile();
                assert dest1.equals(dest2);
                
                for (File folder : foldersToFolders) {
                    for (File file : folder.listFiles(FileFollower.fileNameFilter)) {
                        destinations.add(new FileFollower().waitForOutputToDisappearByWaitingForAnyOutputToPrintToAFile(file));
                    }
                }
                
                assert!dest1.equals(dest2);
                for (OutputDestination dest : destinations) {
                    assert dest.equals(dest2)"
d53e8dbd-32f0-42a6-8cf9-1b5ce0ca2346,/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FollowApp.java,11.209583759307861,length,"// FollowApp.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This class' main() method is the entry point into the Follow application.
 *
 * @see #main(String[])
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FollowApp {

    /**
     * Gets an image icon from the resource path.
     *
     * @param clazz The class to use as an entry point to the resource path. Image
     *            path should be relative to this class.
     * @param iconNameKey The resource key name where the image is defined.
     * @return An image icon based on the URL generated from the value of
     *         iconNameKey. null if no URL can be found.
     */
    public static ImageIcon getIcon(Class<?> clazz, String iconNameKey);
}
","// FollowAppTest.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains one unit test case for the {@link FollowApp#getIcon(Class, String)} method.
*/
class FollowAppTest {","// FollowAppTest.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains one unit test case for the {@link FollowApp#getIcon(Class, String)} method.
*/
class FollowAppTest {
private static final int WINDOW_HEIGHT = 300;
		private static final int WINDOW_BORDER = 100;
		private static final int WINDOW_HEIGHT2 = 200;
		private static final int WINDOW_WIDTH= 900;
		private static final int WINDOW_HEIGHT2 = 200;
    private static final int WINDOW_WIDTH2 = 500;
		private static final int BUTTONS_HIGH = 8;
    private static final int BUTTONS_LOW = 2;
		

    private static Logger LOG = Logger.getLogger(""followapplog"");
	
	/**
	 * Gets the application's resource path.
	 *
	 * @return The path to the application's resource directory.
	 */
	private static String getResourcePath() {"
