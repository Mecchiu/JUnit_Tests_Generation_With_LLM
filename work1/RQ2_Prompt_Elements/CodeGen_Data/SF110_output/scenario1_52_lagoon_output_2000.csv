ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
551210e1-d8bb-4229-8614-09f4888ca5df,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_0Test.java,65.96908450126648,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }
}
","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {
//--------------------------------------------------------- Constructor:
		/** Constructor for <code>FTPClient_0Test</code> and it's test clients. */
		public FTPClient_0Test(boolean clearPassword) throws Exception {
			super(FTPClient.class, clearPassword);
			// test clients
			sendString(""getnewlsafull"");
		}

		//-------------------------------------------------------- Tests:
		private static void testStore(String pathname) throws Exception {
			FTPClient client = new FTPClient_0();
			assertTrue(""store() not successful!"", client.store(pathname));
		}

		@Test
		void testStore_1() throws Exception {
			testStore(""/"");
		}
    
		@Test
		void testStore_2() throws Exception {
			testStore(""/123"");
		}
    
		@Test
		void testStore_3() throws Exception {
			testStore(""/1234"");
		}
    }
"
86bd7416-dfa1-4bb9-b753-5e81abbc4662,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_1Test.java,62.01484966278076,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }
}
","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {
/**
		 * Tests the method {@link FTPClient#store(String, boolean)}.
		 */
    @Test
    void testStore() throws Exception {
         FTPClient client;
         client = new FTPClient();
         client.changeDir(""/"");

         client.store(""test/test"", false);
         client.close();
    }
}
"
6db7b0a7-0ff5-40ac-957e-6fd8c4226005,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_2Test.java,63.56989669799805,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }
}
","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {

	/**
	 * Test case.
	 * @throws MalformedURLException The URL for the test case is malformed.
	 * @throws UnknownHostException An unknown host exception occured.
	 * @throws IOException An I/O exception occured.
	 * @throws FTPException A FTPException occured.
	 * @throws UnknownUserException The user could not be seen in the network.
	 */
	@Test
	void test() throws MalformedURLException, UnknownHostException, IOException, FTPException, UnknownUserException {
		assertNotNull(""The user could not be seen in the network."", ""no_user"");

        String userName = ""user_2\n"";
        String passWrd = ""1.blorta.woo\n"";
        FTPClient client = new FTPClient();

        URL u1;
        u1 = new URL(""ftp://no_user/dir""); // test 1
        FTPClient client2 = new FTPClient();

        /* Try append the file */
        client2.append(u1.toString() + ""/"" + userName + ""/"" + passWrd);

        assertTrue(""The output stream was not closed."", client2.getOutputStream()!= null);

        File dir = new File(""testfolder"", ""subdir"");
        if (dir.exists()) dir.delete();
        assertEquals(0, dir.list().length);
        dir.mkdir();
        System.out.println(""Creating test directory: "" + dir.getPath());

        TestMode tm = new TestMode();
        client2.setTestMode(tm);
        client2.append(u1.toString() + ""/"" + userName + ""/"" + passWrd);
        client2.close();

        /* Get output stream */
        Object outputStream = client2.getOutputStream();
        assertNull(outputStream);

        for (int i=0; i<tm.dataArray.length; i++) {
                assertEquals(tm.dataArray[i], outputStream.toString());
        }

        assertEquals(0, client2.getDataMode());

        TestMode tm2 = new TestMode();
        client2.setTestMode(tm2);
        client2.append(""testfolder/testfileserver"");

        /* Verify that file was created */
        Object outputStream2 = client2.getOutputStream();
        assertNotNull(""The output stream is null."", outputStream2);

        assertEquals(2, client2.getServerReplyCode());
        assertEquals(2, client2.getDataMode());
        assertEquals(2048, client2.getServerReplyData().length);
        assertEquals(""text/plain"", client2.getServerReplyData(0));
        assertEquals(""user_2"", client2.getServerReplyData(1));
        assertEquals(""1.blorta.woo"", client2.getServerReplyData(10));
        client2.close();

    }
}

// This tests the {@link FTPClient#getOutputStream()} functionality.

//@Test
public class FTPClient_1TestOutputStream extends FtpClient_UtilsMethods {

    public static void main(String[] args) throws UnsupportedEncodingException {
        new FTPClient_1TestOutputStream().start();
    }
}
"
819296b4-b91f-4f84-908a-a957e666e82a,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_3Test.java,57.70859956741333,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }
}
","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {
// Pathnames not specified by default
		public final static File NON_DEFAULT_DIR = new File(""/non-default/dir"");
		// Server sent special characters after non default directory
		public final static String NON_DEFAULT_PATH = ""X"";
		// Host name is also sent
		public final static String NON_DEFAULT_HOST = """";
				
		// Pathname used for non default pathnames
		public final static String NON_DEFAULT_PATHNAME = ""/non-default/path"";
		
		// A new directory is started with a file open command
		public final static String NEW_DIR_FILE =  ""mkd"" + NON_DEFAULT_DIR.getSimpleName();
				
				
	
		/**
		 * Tests FTPClient.append() method of the FTPClient class.
		 * @throws URLFailed If no FTPClient connection is established. 
		 * @throws IOFailed On remote server failure.
		 * @throws IOException On other local failure.
		 */
	    @Test 
  	  public void testAppend() throws  UrlFailed,IOFailed,IOException {
		FTPClient client = new FTPClient();
		OutputStream outputstream = client.append(""/"", false);
		// The server sends a ""/"" at the end of all operations
		assertEquals(NON_DEFAULT_DIR.getName(), outputstream.toString());
		inputStream(NON_DEFAULT_DIR, false);
	}
	
	  /**
   * Test method for {@link FTPClient#getLastModifiedTime(String)}.
   * @throws URLFailed If no connection to server is established.
   * @throws IOFailed The server couldn't be checked or was a timeout.
   * @throws IOException A local failure.
   * @throws IOException When a response sent but not received.
   */
	@Test 
    public void shouldGetLastModifiedTime() throws IOFailed,IOException {

    	final String url = ""http://foobar:9999"";

		FTPClient client = new FTPClient();
		HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();
		assertEquals(client.getLastModifiedTime(url), connection.getLastModifiedTime());
		connection.disconnect();
	}	
}"
601ae695-9781-40ca-a7a2-8a0b7480655c,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_4Test.java,63.12144136428833,length,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }
}
","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {

    @Test
    void test() throws Exception {
        String targetPath = ""/home/foo.gz"";
        String clientPath = ""/home/foo"";

        // create fake FTP client
        String fcp = ""fcp "" + clientId();
        
        // perform operation
        int clientResult = FTPClient_4Test.run(fcp, clientPath, targetPath, true);
        
        // verify operation succeeded
        assertEquals(""Called FTP server does not return a CWD"", clientResult, 0);
        
        assertEquals(""Wrong target path returned"", targetPath, ""/"");
    }

    /**
     * @param fcp FTP command.
     * @param clientPath FTP client directory.
     * @param targetPath Target path.
     * @param expectFail if true, the operation fails if the connection is
     *  invalidated with the incorrect password.
     * @return clientResult (0 or 1)
     * @throws IOException on communication error or connection error.
     */
    private int run(String fcp, String clientPath, String targetPath, boolean expectFail)
            throws IOException, FTPException {
        int clientResult = FTPClient.CMD = ftpcmd.command(fcp);
        if (expectFail) {
            clientResult = clientResult * 0;
        }
        assertTrue(clientResult > 0);

        if (targetPath!= null) {
            String dstDir = targetPath.substring(""/"".length());
            String fileName = clientPath.substring(dstDir.length() + 1);

            String serverFTP = ""/home/"";

            String filenameCopy = dstDir + fileName;

            clientResult = FTPClient.CMD = ftpcmd.command(""Rename"", filenameCopy);
            if (expectFail) {
                clientResult = clientResult * 0;
            }
            assertTrue(clientResult > 0);
            clientResult = FTPClient.CMD = ftpcmd.extcmd(""FAIL"");
            if (expectFail) {
                clientResult = clientResult * 0;
            }
            assertTrue(clientResult == FTPClient.CMD);
            clientResult = FTPClient.CMD = ftpcmd.command(""Rename"", clientPath);
            if (expectFail) {
                clientResult = clientResult * 0;
            }    
            assertTrue(clientResult == FTPClient.CMD);

            // create another server FTP client
            clientResult = FTPClient_4Test.run(fcp, clientPath, targetPath, true);

            assertEquals(""Called FTP server does not return a CWD"", clientResult, 1);
        }
        return clientResult;
    }

    /**
     * Creates a FTP client as test case for {@link #FTPClient_4Test#FTPClient_4Test()}.
     */
    private static void createFTPClientTestCase() {
        int port = 21;
        int retry = 0;

        String protocol = ""imap"";
        String targetPath = ""/home/"";
        String clientPath = ""/home/"";
        int maxRetries = 10;
        boolean expectPasswd = true;

        try {
            FTPProtocol protocol = create(port, protocol);
            FTPClient client = new FTPClient(protocol, targetPath);
            client.connect(""localhost"", port);
            // create new client to test FTPClient_4Test.run
            client.login(protocol, client.getPasswd());
            if (!client.isConnected()) {
                throw new IOException(""Connection does not exist"");
            }

            while (retry <= maxRetries) {
                // create new client to test FTPClient_4Test.run
                client = new FTPClient(protocol, serverPath());
                client.connect(""localhost"", port);
                client.login(protocol, retry > 0? client.getPasswd() : null);
                if (client.isConnected()) {
                    retry++;
                } else {
                    break;
                }
            }

            client.close();
            // if failed, close only on expected failure
            if (!expectFail) {
                serverFTP = ""/"";
            } else {
                serverFTP = targetPath + ""/"";
            }
            client = new FTPClient(protocol, serverFTP, clientPath);

            if (!client.isConnected()) {
                throw new IOException(""Could not connect to FTP server"");
            }

            client.connect(""localhost"", port);
            server = client;
            client.login(protocol, server.getPasswd());
            // verify
            assertTrue(client.isConnected());
            assertTrue(client.isTransferSocketActive());

        } catch (FTPException e) {
            System.err.println(""test for FTPClient_4Test failed: "" + e);
            e.printStackTrace();
            // if not expected exception and retries > 0
            if (retry == 0) {
                throw e;
            }

        }
    }
    
    private static FTPClient client = null;
    private static FTPClient server;
    private static String serverPath = null;
    private static String clientPath = null;
    private static boolean expectFail = true;
    private static String targetPath = null;    

    private static void verifyFTPClient() {
        if (expectFail) {
            return;
        }

        FTPClient client = server;
        while (client!= null) {
            client.close();
            client = null;
            server = null;

            if (getServerConnectionException(client, false)) {
                return;
            }

            try {
                client = create(client.getPort(), client.getProtocol());
                client.login(client.getPasswd(), client.getPasswd());
            } catch (IOException err) {
                // if not expected exception
            }
        }             
        assertTrue(""Connection is not active"",
            getServerConnectionException(server, false));
        targetPath = ""/"";
    }

    public static boolean getServerConnectionException(FTPClient _client, boolean isExpectFail) { 
        int retry = 0;
        boolean clientConnected = _client.isConnected();
        boolean serverConnected = server!= null? server.isConnected() : true;

        while (retry <= maxRetries) {
            // create new client as test case for {@link #createFTPClientTestCase()}
            FTPClient_4Test client = new FTPClient_4Test();
            _client = create(client.getPort(), client.getProtocol());
            client.connect(""localhost"", client.getPort());

            // verify
            assertTrue(""Could not connect to FTP server"", client.isConnected());

            // server connection failure
            if (server!= null &&!serverConnected) {
                try {
                    _client.login(client.getPasswd(), client.getPasswd());
                } catch (IOException err) {
                    assertTrue(""Could not login to FTP server"", false);
                }
            } else {
                client.isTransferSocketActive();
            }

            // connect
            server = _client;
            client.connect(""localhost"", client.getPort());

            // verify

            if (isExpectFail || (server!= null &&!serverConnected)) {
                assertTrue(""The connection is not allowed to fail"", client.isTransferSocketActive());
                assertTrue(""Connection failed"",
                    client."
6528f20f-ef7a-4520-a9d0-d83cdf2def52,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_5Test.java,62.258200883865356,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }
}
","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {
/**
		 * Test method for {@link ftp.FTPClient#storeUnique(String, boolean)}.
		 */
		@Test
		void testStoreUnique1()  throws Exception {
			changeDir(""/""); // Test empty path case
			OutputStream out = null; 
			try {
				out = storeUnique(null, false);
			} catch (java.io.IOException ioe) {
				ioe.printStackTrace();
			}
			assertNonEmpty(out);
		}
	
		/**
	     * Test method for {@link ftp.FTPClient#storeUnique(String, boolean)}.
	     */
	    @Test
	    void testStoreUnique2()  throws Exception {
	    	changeDir(""/""); // Test empty path case
	    	FTPClient client = new FTPClient(); 
	    	client.changeDir(""/"");
	    	File tempdir = new File(System.getProperty(""user.dir"") + File.separatorChar + ""noecho"");
	 	tempdir.mkdir();
	    	OutputStream out = null;
	    	try {
	    		out = client.storeUnique(""/"");
	    	} catch (Exception e) {
	    		e.printStackTrace();
	    	}
	    	assertNonEmpty(out);
	 	}
	 
		/**
	     * Test method for {@link ftp.FTPClient#storeUnique(String, boolean)}.
	     */
	    @Test
	    void testStoreUnique3()  throws Exception {
			changeDir(""/""); // Test empty path case
			FTPClient client = new FTPClient(); 
			client.changeDir(""/"");
			File tempdir = new File(System.getProperty(""user.dir"") + File.separatorChar + ""noecho"");
			tempdir.mkdir();
			OutputStream out = null;
	    	try {
	    		out = client.storeUnique(""/"");
	    	} catch (Exception e) {
	    		e.printStackTrace();
	    	}
	    	assertNonEmpty(out);
	 	}
	 
		/**
	     * Test method for {@link ftp.FTPClient#storeUnique(String, boolean)}.
	     */
	    @Test
	    void testStoreUnique4()  throws Exception {
			changeDir(""/""); // Test empty path case
			FTPClient client = new FTPClient(); 
			client.changeDir(""/"");
			File tempdir = new File(System.getProperty(""user.dir"") + File.separatorChar + ""noecho"");
			tempdir.mkdir();
			OutputStream out = null;
			try {
	    		out = client.storeUnique(""/"", false);
	    	} catch (Exception e) {
	    		e.printStackTrace();
	    	}
	    	assertNonEmpty(out);
	 	}
	 
		/**
	     * Test method for {@link ftp.FTPClient#storeUnique(String, boolean)}.
	     */
	    @Test
	    void testStoreUnique5()  throws Exception {
			changeDir(""/""); // Test empty path case
			FTPClient client = new FTPClient(); 
			client.changeDir(""/"");
			File tempdir = new File(System.getProperty(""user.dir"") + File.separatorChar + ""noecho"");
			tempdir.mkdir();
			OutputStream out = null;
			try {
	    		out = client.storeUnique(""/"", true);
	    	} catch (Exception e) {
	    		e.printStackTrace();
	    	}
	    	assertNonEmpty(out);
	 	}
		
		/**
	     * Test method for {@link ftp.FTPClient#changeDir(java.lang.String)}.
	     */
	    @Test
	    void testChangeDir()  throws Exception {
	    	File tempdirectory = new File(System.getProperty(""user.dir"") + ""noecho"");
			changeDir(tempdirectory.getAbsolutePath());
		}

		// Change directory.

		private void changeDir(String dir) throws Exception {
			String newdir = dir + System.getProperty(""file.separator"") + ""noecho"";
			File newdirFile = new File(newdir);
			if (!newdirFile.exists()) {
				newdirFile.mkdirs();
			}
			File file = newdirFile.listFiles((int)newdirFile.length()).get(0);
			String fileContent = file.read();
			file.delete();

			OutputStream out = new FileOutputStream(dir + System.getProperty(""file.separator"") + ""noecho"");
			byte[] buffer = new byte[1 << 8];
			out.write(buffer);
			out.flush();

			System.err.println(""File's content : "" + fileContent);
		}

		private boolean assertNonEmpty(OutputStream out) throws java.io.IOException {
			byte[] byteInput = new byte[1 << 8];
			in.read(byteInput);
			String s = new String(byteInput);
			if (!(s.endsWith(""..""))) {
				throw new IOException(""Stored file is not a directory!"");
			}
			return true;
		}

}
"
3d9592f4-c739-41a5-ae2c-e86571ba61cf,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_6Test.java,53.575605154037476,stop,"// FTPClient.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }
}
","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {
private String[] filenames = new String[]{""a.txt"", ""b.txt"", ""delete.txt""};
		private final FTPClient client = new FTPClient();

		/**
* Test method for
* {@link nu.staldal.ftp.FTPLine#deleteFile(String)};
* Testing if the {@link FTPClient#deleteFile(String)} method correctly returns the path name.
*
*/
	@Test public void testDeleteFile() throws Exception {
		for (String fname: filenames) {
			assertTrue(""Cannot delete file `"" + fname + ""`"", client.deleteFile(fname));
		}
	}

	/**
* Test method for
* {@link nu.staldal.ftp.FTPLine#recvResponse()}
* Testing if the return of {@link FTPClient#recvResponse()} is of type 550.
*
* @throws IOException is thrown in case of exception.
* @throws FTPClientException if an exception is thrown while recv operation.
*/
	@Test
    public void testRecvResponse550() throws IOException, FTPClientException {
		int resp = client.recvResponse();
		IOException exc = null;
		switch(resp) {
		case 550:
			throw new FTPException(""Unexpected success of FTP status 550"");
			default:
			assertEquals(""The response code should be 550, but was: "" + resp, 550, resp);
			break;
		}
	}

	/**
* Test method for
* {@link nu.staldal.ftp.FTPLine#recvResponse()}
* Testing if the return of {@link FTPClient#recvResponse()} is of type 421.
*
* @throws IOException is thrown in case of exception.
*/
	@Test
    public void testRecvResponse421() throws IOException {
		int resp = client.recvResponse();
		assertEquals(""421"", resp);
	}

	/**
* Test method for
* {@link nu.staldal.ftp.FTPLine#recvResponse()}
* Testing if the response {@link Number} is an integer.
* 
* @throws IOException is thrown in case of exception.
* @throws FTPClientException if an exception is thrown while recv operation.
*/
	@Test
    public void testRecvResponse() throws IOException, FTPClientException {
		assertEquals(new Integer(250), client.recvResponse());
	}

	/**
* Test method for
* {@link nu.staldal.ftp.FTPLine#recvLine(java.lang.String)}.
* Testing if the response of recvLine method is written in {@link String} format, not in clear text.
*
* @throws IOException is thrown in case of exception.
* @throws FTPClientException if an exception is thrown while recv operation.
*/
	@Test
   public void testRecvLine() throws IOException, FTPClientException {
    	assertEquals(""211"", client.recvLine(""222""));
    }

	/**
* Test method for
* {@link nu.staldal.ftp.FTPLine#recvLine(java.lang.String)}.
* Testing if the response of recvLine method is written in {@link String} format, without password.
*
* @throws IOException is thrown in case of exception.
* @throws FTPClientException if an exception is thrown while recv operation.
*/
	@Test
   public void testRecvLine2() throws IOException, FTPClientException {
    	assertEquals(""211"", client.recvLine(""222""));
    }

	/**
* Test method for
* {@link nu.staldal.ftp.FTPLine#parseLine(java.lang.String, java.lang.String)}
* Testing if the response of parseLine method is parsed from clear text format.
*
* @throws IOException is thrown in case of exception.
* @throws FTPClientException if an exception is thrown while recv operation.
*/
	@Test
   public void testParseLine_2() throws IOException, FTPClientException {
    	assertEquals(""211"", client.parseLine(""2222""));
    }

	/**
* Test method for
* {@link java.lang.StringBuilder#append(java.lang.String)}.
* Testing if the {@link java.lang.StringBuilder#append(java.lang.String)} method correctly inserts arguments.
*
* @throws IOException is thrown in case of exception.
* @throws FTPClientException if an exception is thrown while recv operation.
*/
	@Test
   public void testAppend_1() throws IOException, FTPClientException {
    	StringBuilder sb1 = new StringBuilder(""222"");
    	sb1.append(""222"");
    	assertTrue(""Cannot append arguments"", client.parseLine(""2222"") == null);
    }

	/**
* Test method for
* {@link java.lang.StringBuilder#append(java.lang.String)}.
* Testing if the {@link java.lang.StringBuilder#append(java.lang.String)} method correctly inserts arguments.
*
* @throws IOException is thrown in case of exception.
*/
	@Test
   public void testAppend_2() throws IOException {
    	StringBuilder sb1 = new StringBuilder(""222"");
    	sb1.append(""222"");
    	assertEquals(""111 222"", client.toString(sb1.toString()));
    }
}

// End FTPClient_6Test.java
"
37d1a9e0-efe4-4ab9-b5e1-62e512257aa4,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessor.java,48.99428415298462,stop,"// LagoonProcessor.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;

/**
 * The main worker class of the Lagoon core.
 *
 * Initialized with the sitemap,
 * a source dir and a target storage URL.
 * Then building the website may be done several times,
 * until destroy() is invoked.
 *
 * This class is not thread-safe. The methods must not
 * be invoked concurrently from different threads.
 */
public class LagoonProcessor implements LagoonContext {

    public boolean build(boolean force) throws IOException {
        boolean success = true;
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.beforeBuild(force);
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            if (!ent.build(force))
                success = false;
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.afterBuild(force);
        }
        return success;
    }
}
","// LagoonProcessorTest.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains one unit test case for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessorTest {","// LagoonProcessorTest.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains one unit test case for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessorTest {

	/**
	* Class that represents all elements of the XML file.
	* Contains a bunch of entries:
	* <ul>
	* <li>root</li>
	* <li>sitemap</li>
	* </ul>
	*/
	private class Entry {

		public Element root = new Element(""root"");
		private String URL = null;
		private String name = null;
		private int mimeType = MIME_XML;
//		private boolean readonly = false;
		private int count = 0;

		public Element getRoot() {
			return root;
		}

		public void setURL(String URL) {
			this.URL = URL;
		}

		public void setName(String name) {
			this.name = name;
		}

		public Element getXML() {
			throw new InternalError();
		}

		public void setMimeType(int mimeType) {
			//this.mimeType = mimeType;
		}

		public void setReadonly(boolean readonly) {
//			this.readonly = readonly;
		}

		public int getCount() {
			return count;
		}

		public String getName() {
			return name;
		}

		public  String getURL() {
			return null;
		}

		//private int mimeType;
		public int getMimeType() {
		//	return mimeType;
			return mimeType;
		}

	}

	private static final Util us = new Util(LagoonProcessor.class.getCanonicalName());
	static final InputStream in = us.openFile(Utils.DEFAULT_TMPFILE);
	static {
        // in: open the file
	}

	/**
	* The URL for the current sitemap
	* of the processing pipeline.
	*/
	private String sitemap;
	/**
	* The content of the sitemap XML file
	* which contains a bunch of XML entries.
	*/
	private Element sitemapXML ;
	private Element sitemapElem = null;
	private Element targetEntry = null;
	
    public static void main(String [] args) throws Exception {
    	//LagoonProcessor lp = new LagoonProcessor();
    	JUnitCore core = new JUnitCore();
    	try {
    		core.run(new JUnit4TestListener());
    	} catch (Exception e) {
    		throw e;
    	}
    }

	/**
	* Creates a new processor
	*/
	public LagoonProcessorTest() {
		//super(null);
	}

	/**
	* Creates a new processor
	* @param sitemap the URL for the current sitemap
	* to be processed
	*/
	public LagoonProcessorTest(String sitemap) {
		this.sitemap = sitemap;
	}

	/**
	* Returns the target entry of the current sitemap.
	* @return the target entry of the current sitemap.
	*/
	public Element getTargetEntry() {
		return targetEntry;
	}

	/**
	* Creates a new target entry with the URL of the latest
	* sitemap to be processed as a default one.
	* @param sitemap the URL of the latest sitemap
	*/
	public Element newTargetEntry(String sitemap) {
		if (targetEntry!=null) {
			targetEntry.setAttribute(""url"", sitemap);
		} else {
			targetEntry = new Element(""entry"");
			targetEntry.setAttribute(""url"", sitemap);
			sitemapXML.getChildren().add(targetEntry);
		}
		return targetEntry ;
	}
	
	public void process(boolean force) throws IOException {
		sitemapXML = new Element(""sitemap"", sitemap);
		targetEntry = new TargetEntry();
		targetEntryNode = targetEntry.getXML();
		sitemapXML.getChildren().add(targetEntry);
		
		//get target entry content
		try {
			Reader reader = new InputStreamReader(in);
			BufferedReader br = new BufferedReader(reader);
			try {
				for(int line = 0; ;line++) {
					line = System.currentTimeMillis() % 1000 % 1000L;
<<<<<<< HEAD
					String s = br.readLine();
=======
					String s = br.readLine();
>>>>>>> a0988c70b2adc4c8b938a0e8dc1bbc4e7d91c4
					if (SitemapXML.tag.equals(""entry"")) {
						sitemapXML.getChildren().add(s);
					}else if (SitemapXML.tag.equals(""entry"")) {
						sitemapXML.remove(s);
					}else if (line!=0) {
						sitemapXML.getChildren().add(s);
					}else {
						//System.out.println(""No more information"");
					}
				}
			}finally {
				br.close();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}

		
		//builds the website
		//build new sitemap
		build(force);
		
		//gets the output content and the HTML content
		this.sitemapXML.getChildren().remove(sitemapElem);
		getXML();
		getXML();
		printXML();
	}
}"
76b1bd1d-2107-4913-b353-463f76aee18e,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_0Test.java,60.028486251831055,stop,"// Wildcard.java
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }
}
","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {
private String string;

		/**
		* Default constructor.
		*/
		public Wildcard_0Test() {
                        string = null;
                    }

		/**
		* Constructor.
		*
		* @param string a non-null string.
		*/
		public Wildcard_0Test(String string) {
			assert true;
                        this.string = string;
		}

		/**
		* Test method for {@link Wildcard#isWildcard(String)}.
		*/
		@Test
		public void test() {
			assertTrue(string.equals(""*""));
		}
}
/* Copyright (c) 2015, Salesforce.com, Inc.  All rights reserved. */
"
9cdbcbf0-bcbf-46c9-8c8e-17ffa568f7b2,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_1Test.java,30.04301118850708,stop,"// Wildcard.java
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }
}
","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {

	/**
	* Test method for
	* {@link Wildcard#matchWildcard(String, String)}(String, String[])}.
	* No test method.
	* No exception should be expected.
	*/
    @Test
	public void testMatchWildcard(String fileName) {
		System.out.println(""matchWildcard: ""+ Wildcard.matchWildcard(fileName, ""java""));
	}
}
"
05f6fba0-8b81-4425-b467-c9e212148153,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_2Test.java,53.31275296211243,stop,"// Wildcard.java
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {

	/**
	 * Test constructor.
	 */
	@Test
	public void testConstructor1() {
		assertTrue(new Wildcard().toString().equals(""[*]""));
	}
	
	/**
	* Test constructor.
	*/
	@Test
	public void testConstructor2() {
		assertTrue(new Wildcard().toString().equals(""[].*""));
	}
}
"
d7e4cf2c-a205-4093-a848-d1104097e9aa,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorage.java,52.003254890441895,stop,"// FTPFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;

/**
 * A FileStorage which transfers files to a remote site using FTP.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPFileStorage extends RemoteFileStorage {

    public OutputHandler createFile(String pathname) throws IOException {
        OutputStream os;
        try {
            os = ftp.store(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            os = ftp.store(pathname);
        }
        return new FTPOutputHandler(pathname, os);
    }
}
","// FTPFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains one unit test case for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorageTest {","// FTPFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains one unit test case for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorageTest {
private FileStore fileStore;
		private FTPClient ftpClient;

		@BeforeEach
		public void setup() throws IOException {
			fileStore = new FTPSingleFileStore();
		}
		
		@Test
		public void testFile_path() throws URISyntaxException, IOException {
			URL url = new URL(""ftp://nobody.s3.amazonaws.com"");
			URLConnection connection = url.openConnection();
			assertEquals(""ftp://nobody.s3.amazonaws.com:21/"", connection.getURL().getPath());
		}
		
		@Test
		public void testFile_invalid_url() throws IOException {
			try {
				ftpClient = new FtpClient();
				ftpClient.parseURI(""http://localhost:1111"");
				fail();
			} catch (FtpException e) {
				assertTrue(e.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND);
				assertEquals(""ftp://localhost:1111"", e.getURL().getPath());
			} catch (InvalidProtocolException e) {
			}
				
		}
		
		@Test
		public void testFile_invalid_location() throws IOException {
				// Note that this test does use a URI which is not a path name
				URL invalidLocation = new URL(""ftp://localhost:0"");
				
				// Create a fake location URL
				try {
					ftpClient = new FtpClient(invalidLocation, ""password"");
					ftpClient.parseURI(""http://localhost:0"");
					fail();
				} catch (FtpException e) {
					assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, e.getStatusCode());
					assertTrue(e.getMessage().startsWith(""Invalid location""));
				}
		}
		
		@Test
		public void testFile_path_prefix() throws Exception {
			String expected = ""remoteFtp: "";
			
			// Test a path prefix
			URL url = new URL(""ftp://localhost:80:20"");
			ftpClient = new FtpClient(url, expected);

			assertEquals(expected,
					ftpClient.readStream(new ByteArrayInputStream(""remoteFtp: remoteFtp: \r"".getBytes())).toString());
			
			// Test a path with a trailing slash
			// Note that if you use the URI directly from the URL, it will be the ""localhost"" URI, not
			// as it is in a URI. This may change in the future, in which case we can just test a path
			// without a trailing slash
			url = new URL(""ftp://localhost:80:20/"");
			ftpClient = new FtpClient(url, expected);

			assertEquals(expected,
					ftpClient.readStream(new ByteArrayInputStream(""remoteFtp: remoteFtp: \r"".getBytes())).toString());
			
			// Test a path without a trailing slash
			url = new URL(""ftp://localhost:80:20/"");
			ftpClient = new FtpClient(url, expected);

			assertEquals(expected,
					ftpClient.readStream(new ByteArrayInputStream(""remoteFtp: remoteFtp: \r"".getBytes())).toString());
		}
		
		// This test case is duplicated from above
		@Test
		public void testFile_location() throws Exception {

			URL url = new URL(""ftp://localhost:8080/"");
			ftpClient = new FtpClient(url, ""password"");
			assertEquals(""ftp://localhost:8080/"", ftpClient.currentLocation().getPath());
			assertEquals(""ftp://localhost:8080"", ftpClient.currentLocation().openNewConnection().toString());
			if (DEBUG) {
				System.out.println(""Current connection to "" + url.getHost() + "":"" + url.getPort());
				System.out.println(""Current location = "" + url.getPath());
			}
			assertNotNull(ftpClient.readStream(new ByteArrayInputStream(""localFtp: localFtp: \""remoteFtp: remoteFtp:\""\r\n"").getBytes()));
			assertNotNull(ftpClient.readStream(new ByteArrayInputStream(""remoteFtp: remoteFtp: \r\n"").getBytes()));
			assertNotNull(ftpClient.readStream(new ByteArrayInputStream(""localFtp: localFtp: remoteFtp: \"" \r\n"".getBytes())));
			assertNull(ftpClient.readStream(new ByteArrayInputStream(""remoteFtp: remoteFtp "")).read());
			assertEquals(""remoteFtp: remoteFtp: \"" \r\n\""\r\n"", new String(ftpClient.readStream(new ByteArrayInputStream(""remoteFtp: localFtp: remoteFtp "").getBytes()).toString()));

			url = new URL(""ftp://localhost:808080"");
			ftpClient = new FtpClient(url, ""password"");
			if (DEBUG) {
				System.out.println(""Current connection to "" + url.getHost() + "":"" + url.getPort());
				System.out.println(""Current location = "" + url.getPath());
			}
			assertNotNull(ftpClient.readStream(new ByteArrayInputStream(""localFtp: localFtp: \""remoteFtp: remoteFtp:\""\r\n"").getBytes()));
			assertEquals(""localFtp: remoteFtp: remoteFtp: \"" \r\n\""\r\n"", new String(ftpClient.readStream(new ByteArrayInputStream(""localFtp: localFtp: remoteFtp: \"" \r\n"".getBytes()))));
		}

}
"
6929c938-8fc1-4fd0-b0b3-9c1a799d1e9e,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorage.java,46.42587971687317,stop,"// SSHFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;

/**
 * A FileStorage which transfers files to a remote site using SSH.
 */
public class SSHFileStorage extends RemoteFileStorage {

    public OutputHandler createFile(String path) throws java.io.IOException {
        String currentPath = path;
        String s = rootPath + path;
        int i = s.lastIndexOf('/');
        String dir = (i < 0) ? ""."" : s.substring(0, i);
        if (DEBUG)
            System.out.println(""dir: "" + dir);
        Process currentProc = runSSH(new String[] { ""mkdir"", ""-p"", dir, ""&&"", ""rm"", ""-f"", rootPath + path, ""&&"", ""cat"", "">"" + rootPath + path });
        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());
    }
}
","// SSHFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorageTest {","// SSHFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorageTest {
// SSHFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;

/**
 * A FileStorage which transfers files to a remote site using SSH.
 */
public class SSHFileStorage extends RemoteFileStorage {

    public OutputHandler createFile(String path) throws java.io.IOException {
        String currentPath = path;
        String s = rootPath + path;
        int i = s.lastIndexOf('/');
        String dir = (i < 0)? ""."" : s.substring(0, i);
        if (DEBUG)
            System.out.println(""dir: "" + dir);
        Process currentProc = runSSH(new String[] { ""mkdir"", ""-p"", dir, ""&&"", ""rm"", ""-f"", rootPath + path, ""&&"", ""cat"", "">"" + rootPath + path });
        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());
    }
}

// SSHFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorageTest {
		
	public SSHFileStorageTest()
	{
	}
	
	private final String rootPath = ""."";
	
    @Test
    void testDefault() {
    }
	
    @Test
    void testSshPathToFile() throws IOException {
	    try {
    		assertTrue(SSHFileStorage.sshPathToFile.matches(rootPath + ""/.SSH""));
    	}
    	catch( FileNotFoundException e ) { 
    		assertFalse(true);
    	}
    }

    @Test
    void testSshRelFileToFile() throws IOException {
	    try {
    		assertTrue(SSHFileStorage.sshRelFileToFile.matches(rootPath + ""/file1""));
    	}
    	catch( FileNotFoundException e ) { 
    		assertFalse(true);
    	}
    }
	
    @Test
    void testFileToFile() throws IOException {
	    String content = ""Content"";
	    
	    try {
    		new File(rootPath + ""/file1"").createNewFile();
    		assertTrue(SSHFileStorage.fileToFile.matches(rootPath +""/file1/Contents""));
    	}
    	catch( FileNotFoundException e ) { 
    		assertFalse(true);
    	}
    	
    }
	
    @Test
    void testRelFileToRelFile() throws IOException {
	    String content = ""Content"";
	    
	    try {
    		File contentFile = new File(rootPath + ""/file1"");
    		contentFile.createNewFile();
    		assertTrue(SSHFileStorage.relFileToRelFile.matches(contentFile.getCanonicalPath()));
    	}
    	catch( FileNotFoundException e ) { 
    		assertFalse(true);
    	}
    	
    }
	
	String sshKey = null;
    
    @Test
	public void testGetSSHKeyToFile() {
        sshKey = System.getProperty(""ssh.key.key"");
	}
	
	@Test
	public void testSshFileToRelFile() throws IOException, FileNotFoundException {
        SSHFileStorage instance = new SSHFileStorage();
        String path = ""some-path-for-testing_"";
        //String path = """";

        String content = ""Content"";
        
        try {
            new File(rootPath + ""/file1"");
            File contentFile = new File(rootPath + path + ""/file1"");
            contentFile.createNewFile();
            assertTrue(contentFile.delete());

        } finally {
            if ((System.getenv(""JAVAVMSPLASHSCRATCH_TEMP"").endsWith("".txt"") || System.getenv(""JAVAVMSPLASHSCRATCH_TEMP"").endsWith(""__INPUT_SCRATCH""))) {
                new File(rootPath + ""/"").delete();
            }
        }

        File outFile = new File(rootPath + path + ""/file1"");
        OutputHandler target = new OutputHandler();
        target.write(outFile, content);
        try {
            new File(rootPath + ""/"").delete();
        } catch (Exception e) {
            assertEquals(e.getClass().getName(), ""javarro.io.FileNotFoundException"");
        }

        String contentOut = target.getContents();
        assertEquals(content, contentOut); //the output to be read was written to file
        //assertEquals(StringUtils.nullToEmpty(contentOutput), contentOutput); //there was no need to delete output file and content file
        // assertTrue(contentFile.delete());

    }	    
    
    @Test
	public void testFileToString() throws IOException {
            String content = ""content"";
            String out = new File(rootPath + ""/file1/Contents"").toString();
            String outString = ""Contents of the file"";

            try {
		    SSHFileStorage instance = new SSHFileStorage();
                //String path = """";
                //String content = ""content"";
                instance.setSSHKeyToFile(content);
                instance.fileToString.set(out);
                instance.fileContentToContent.set(content);
		} catch (Exception ioe) {
		    System.out.println(""IOException "" + ioe.getMessage());
		}

            assertEquals(out, outString);
            String content = ""Some content\nof content (with line break)"";
            File outFile = new File(rootPath + ""/file1"");
            FileUtils.stringToFile(content, outFile);

            assertEquals(StringUtils.nullToEmpty(content), outFile.readLine());
    }
	
}
"
e9e46762-c9da-41d7-b7ad-06e697781284,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorage.java,56.61048436164856,stop,"// LocalFileStorage.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;

/**
 * A FileStorage using the local file system.
 */
public class LocalFileStorage implements FileStorage {

    public long fileLastModified(String path) // throws java.io.IOException
    {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                return 0;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        return file.lastModified();
    }
}
","// LocalFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains one unit test case for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorageTest {","// LocalFileStorageTest.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains one unit test case for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorageTest {
Class<?> classe = LocalFileStorageTest.class;


	@Test
    public void testFileLastModified() throws Exception {
        final String str = ""<a></a>"";
        final LocalFileStorage fs0 = makeTestFile(new String[] {str});
        
        File file = null;
        int result = fs0.isFile(str);
        
        assertTrue(""Expected not the file to exists, not "" + (result & 0x00000080), (result & 0x00000080) == 0);
        
        assertNull(""Expected no file exists, but got one"", fs0.getFile(str));
        assertEquals(""Expected the file to be as expected, has"", str, fs0.getFile(str));
    }

	@Test
    public void testFileOpen() throws Exception {
        final String str = ""<a></a>"";
        final LocalFileStorage fs0 = makeTestFile(new String[] {str});
        
        File file = null;

        IOException ex = null;
        try {
            file = fs0.open(str);
        } catch (IOException e) { ex = e; }

        assertTrue(""Expected file not to exist, but got one: "" + (ex!= null? ex.getMessage() : ""null""), (ex!= null? ex.getMessage()
        		: ""expected to exist""))
        assertNull(""Expected no file to exist but got one"", file);
    }
	
	@Test
    public void testFileRead() throws Exception {
        final String str = ""<a></a>"";
        final LocalFileStorage fs0 = makeTestFile(new String[] {str});
        
        String strRes = fs0.getFile(str);
        
        assertNull(""Expected a no file, but got one "", str);
        assertNull(""Expected no file to exist, but got one"","" "" + strRes);
    }
	
	@Test
    public void testFileWrite() throws Exception {
        final String str = ""<a></a>"";
        final LocalFileStorage fs0 = makeTestFile(new String[] {str});
        
        File file = null;
        int result = fs0.isFile(str);
        
        assertFalse(""Expected the file to not exist, but got one"", result);

        System.out.println(""File exists "" + (result & 0x00000080));
	
        assertFalse(""Expecting file to not exist"", result & 0x00000080!= 0);
        
        assertNotNull(""Expected a file to exist, but got one"", file);
        
        String str2 = """";
        file.writeString(str2, ""UTF-8"");

        result = fs0.isFile(str);
        
        assertTrue(""Expected the file to not exist"", result);
        
        assertFalse(""Expecting file to exist"", (result & 0x00000080 == 0));
        System.out.println(""File "" + (result & 0x00000080) + "" present"");
        
    }
    
	@Test
    public void testFileCreateNew() throws Exception {
        final String str = ""<a></a>"";
        final LocalFileStorage fs0 = makeTestFile(new String[] {str});
        
        File file = null;
        int result = fs0.isFile(str);
        
        assertTrue(""Expected file not to exist, but got one"", result);

        System.out.println(""File exists "" + (result & 0x00000080));
	
        assertFalse(""Expecting file to not exist"", result & 0x00000080!= 0);
        
        assertTrue(""Expected a new file should exist"",!fs0.exists(str));

        int lastMod = fs0.fileLastModified(str);        
        
        assertEquals(""Expected the last modification time to be the same as the new file"", lastMod, lastMod);

        assertTrue(""Expected new file to exist, but was not"", fs0.exists(str));
        
        String content = fs0.getFile(str);
        
        assertEquals(""Expecting the content of the new file"", str, content);
        
        System.out.println(""File "" + (result & 0x00000080) + "" closed"");
    }

    private LocalFileStorage makeTestFile(String[] args) throws IOException {
        return new LocalFileStorage(new File(args[2]).getAbsolutePath());
    }
    
}
"
7379ec53-5444-46a3-8c89-701302ca912f,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_0Test.java,55.91821599006653,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }
}
","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {


	@Test
    public void checkLookupAttribute1() throws Exception {
        // test for attribute value and name
        String localName = ""foo"";
		int attrNamePos = lookupAttribute(null, localName);
		assertEquals(1, attrNamePos);
        AttributesImpl attrs = new AttributesImpl();
        assertEquals("""", atts.getURI(attrNamePos));
        assertEquals("""", localName);
        assertEquals(""foo"", atts.getName(attrNamePos));
        assertEquals("""", atts.getValue(attrNamePos));
        assertEquals(0, attrNamePos);

        // test for attribute value and name
        String value = ""hello"";
        String name = ""text"";
		int attrNamePos = lookupAttribute(value, name);
		assertEquals(0, attrNamePos);
        assertEquals(0, atts.getLength());
        assertEquals(1, attrs.getLength());
        assertEquals(value, atts.getValue(attrNamePos));
        assertEquals(name, atts.getName(attrNamePos));
        assertEquals(0, attrNamePos);

        // test for attribute not-existsed-value and name
        String value2 = ""hello 2"";
        String name2 = ""i use 2"";
		int attrNamePos2 = lookupAttribute(value2, name2);
		assertEquals(-1, attrNamePos2);
        assertEquals(0, attrNamePos2);
        assertEquals(0, atts.getLength());
        assertEquals(0, attrNamePos2);
    }

	@Test
    public void checkLookupAttribute2() throws Exception {
        // test for attribute not-existsed-value and name
        String localName = ""foo"";
		int attrNamePos = lookupAttribute(null, localName);
        assertEquals(-1, attrNamePos);
        Vector names = new Vector();
        names.add(localName);
		AttributesImpl attrs = new AttributesImpl(names);
        assertEquals(-1, attrNamePos);
        assertEquals(0, attrs.getLength());
        assertEquals(-1, attrNamePos);
        assertEquals(0, attrs.getLength());
        Vector attrs2 = new Vector();
		try {
			attrs2.removeElementAt(0);
			fail();
		}
		catch (java.util.NoSuchElementException nse) {
			// expect to fail if attrs2 is empty, hence this line.
		}
        assertEquals(names.size(), attrs2.size());
        assertTrue(names.contains(localName));
        assertEquals(0, attrNamePos);

		// test for attribute not-existsed-value and name
		String value = ""hello"";
		String name = ""text"";
		int attrNamePos = lookupAttribute(value, name);
		assertEquals(-1, attrNamePos);
        assertEquals(0, attrNamePos);
        assertEquals(0, attrs2.size());
        Vector names2 = new Vector();
		names2.add(value);
		names2.add(name);
		attrs2 = new AttributesImpl(names2);
        assertEquals(-1, attrNamePos);
        assertEquals(0, attrs2.getLength());
        Vector attrs2a = new Vector();
        attrs2a.addElement(value);
        attrs2a.addElement(name);
        attrs2 = new AttributesImpl(attrs2a);
        assertEquals(-1, attrNamePos);
        assertEquals(0, attrs2.getLength());
        assertEquals(0, attrs2a.size());
        assertEquals(0, attrs2.hashCode());
    }
	@Test
    public void checkLookupAttribute3(){
         // test for attribute value and name
        String localName = ""attrValue"";
		Vector attrs = new Vector();
        Vector names = new Vector();
       
        // test for one attribute
		int attrNamePos = lookupAttribute(localName, null);
		assertTrue(attrNamePos >= 0);
        assertEquals(0, attrNamePos); // attribute value
		attrs.addElement(localName);
		
        // test for two attributes
        attrs.addElement(localName);
       
        // test for attribute not-existsed-value and name
        assertEquals(0, attrNamePos);
        attrs.addElement(localName);
        attrs.addElement(name);
        assertEquals(0, attrNamePos);
        
        // test for attribute value and name
        attrs.addElement(localName, value);
        attrs.addElement(name);
        Vector names2 = new Vector();
		names2.add(localName);
		names2.add(name);
		attrs2 = new AttributesImpl(names2);
        assertEquals(0, attrNamePos);
        assertEquals(1, attrs2.getLength());
        assertEquals(value, attrs2.getValue(0));
        assertEquals(name, attrs2.getName(0));
        assertEquals(0, attrNamePos);
       
        // test for attribute value and name
        attrs.addElement(localName, value);
        attrs.addElement(name);
        attrs2 = new AttributesImpl(attrs);
        assertEquals(1, attrNamePos);
        assertEquals(2, attrs2.getLength());
        assertEquals(value, attrs2.getValue(0));
        assertEquals(name, attrs2.getName(0));
        assertEquals(1, attrNamePos);
       
        // test for attribute not-existsed-value and name
        attrs.addElement(localName);
        attrs.addElement(name);
        assertEquals(0, attrNamePos);
        assertEquals(0, attrs.getLength());
        Vector names2a = new Vector();
        names2a.add(localName);
        names2a.add(name);
        attrs2a = new AttributesImpl(names2a);
        assertEquals(0, attrNamePos);
        assertEquals(0, attrs2.getLength());
        assertEquals(0, attrNamePos);
        assertEquals(0, attrs.hashCode());
	}
}
"
28401582-c597-46b1-b178-0ebf86f04095,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_1Test.java,63.797170877456665,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    public int numberOfAttributes() {
        return attrName.size();
    }
}
","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {
 
	// The following methods will be used for tests.
	@Test
    public void class1(){
		assertNotNull(Element.this);
    }
}

// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URLEncoder;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.AttributesImpl;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.EntityResolver2;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

public class Element_2Test extends ElementTest {

    @Override
    public String getRootURI() {
        return """";
    }

    @Override
    public String getXMLRootTag() {
        return """";
    }

    @Override
    public void setUp() throws Exception {
        super.setUp();
    }

    // A test element. Its name is defined by the parent node.
    @Test
    public void test() {
        Element parent = getParent();
        parent.getParent();
    }
}

"
ccf9d7bb-e829-41d5-bc4b-ca26eb1e0c98,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_2Test.java,62.37202572822571,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }
}
","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {

    public Element_2Test() throws Exception {
        super(false);
    }
    
    public static void main(String[] args) throws Exception {
        junit.swingui.TestRunner.run(Element_2Test.class);
    }
    
    /**
     * The element in HTML that should be parsed as XML without any namespace.
     */
    @Test
    public void testElement_getAttributeNamespaceFromNil() throws Exception {
        Element el = new Element();
        el.setDoc(null);
        
        assertEquals(""XML namespace"", xsNamespace);
        
		Vector v;
		v = null;
        el.setNSContext(v);
        
        AttributesImpl attr = new AttributesImpl();
        el.getAttributeNamespace(0);
        
        assertNull(""XML namespace should be null"", v);
        
    }

    /**
     * The element in HTML that should be parsed as XML, with non-default namespace.
     * This XML namespace should not be set.
     */
    @Test
    public void testElement_getAttributeNamespaceWithDefaultNamespace() throws Exception {
        Element el = new Element();
        el.setDoc(null);
        
        AttributesImpl attr = new AttributesImpl();
        el.getAttributeNamespace(0);
        
        assertTrue(""XML namespace should be used"",!attr.isEmpty());
    }
}

// Element_3Test.java
"
70f694c5-41ed-42d0-a653-713d324a16dc,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_3Test.java,62.43038558959961,length,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }
}
","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {
/**
		* Test of getAttributeLocalName.
		*/
		@Test
		public void testGetAttributeLocalName_1() {
			// TODO
		}

		/**
		* Test of getAttributeLocalName.
		*/
		@Test
		public void testGetAttributeLocalName_2() {
			// TODO
		}

		/**
		* Test of getAttributeLocalName.
		*/
		@Test
		public void testGetAttributeLocalName_3() {
			// TODO
		}

	/**
	* Test of getAttribute.
	*/
	@Test
	public void testGetAttribute() {
		System.err.println(""testGetAttribute"");

		// Attributes.
		String a = ""c"";
		String b = ""b"", c = ""c^b"", d = ""d = 4"";
		System.out.println(new Element(a, b));
		System.out.println(new Element(a, b.substring(1, 4)));
		System.out.println(new Element(a, ""b = '"" + b + ""'""));
		Element e = new Element(""e"", ""b = '"" + b + ""'"");
		System.out.println(new Node(b, e));
		e = new Element(""e"", ""b"", ""w"");
		e.addNode(new Node(b, e));
		e.clear();
		System.out.println(e);
		e.addNode(new Node(b, a));
		e.clear();
		e.addNode(new Node(a, ""e""));
		e.clear();
		e = new Element(a, ""e = '"" + e + ""'"");
		e.addNode(new Node(b, a));
		System.out.println(c);
		System.out.println(new Node(b, a));
		System.out.println(new Node(a, ""e"", a));
		System.out.println(new Node(b, ""e"", a));

		// Vector.
		System.out.println(e.getAttribute(""foo""));
		String v = e.getAttributeNS(""urn:xml:ns:xml"", ""foo"");
		assertEquals(""a"", e.getAttribute(v));

		// NodeVector.
		System.out.println(e.getAttributeVector());
	}

	/**
	* Test of isDefaultNamespace.
	*/
	@Test
	public void testIsDefaultNamespace() {

		// Nodes with no attribute but namespace.
		Vector v;
		v = new NodeVector();
		v.addNode(new Node(""foo"", ""http://www.somewhere""));
		assertTrue(v.first().getNamespaceURI() == null);
		assertTrue(v.last().getNamespaceURI() == null);

		// Nodes with attribute and namespace.
		v = new NodeVector();
		v.addNode(new Node(""foo"", ""urn:xml:xml:namespace""));
		v.addNode(new Node(""foo"", ""urn:xml:xmlns:foo""));
		assertTrue(v.first().getNamespaceURI() == null);
		assertTrue(v.last().getNamespaceURI() == null);
		assertTrue(v.last().getAttribute() == null);

		// Nodes with namespace and no attribute.
		v = new NodeVector();
		v.addNode(new Node(""foo"", ""urn:xml:xmlns:foo = 'http://www.someothernamespace'""));
		v.addNode(new Node(""foo"", ""urn:xmlns:foo""));
		assertTrue(v.first().getNamespaceURI() == null);
		assertTrue(v.last().getNamespaceURI() == null);
		assertTrue(v.first().getAttribute() == null);
		assertTrue(v.last().getAttribute() == null);

		// Nodes with attribute and namespace.
		v = new NodeVector();
		v.addNode(new Node(""foo"", ""urn:xml:xml:namespace"", ""urn:xmlns:foo = 'http://www.someothernamespace'""));
		v.addNode(new Node(""foo"", ""urn:xmlns:foo"", ""urn:xml:xmlns:foo""));
		assertTrue(v.first().getNamespaceURI() == null);
		assertTrue(v.last().getNamespaceURI() == null);
		assertTrue(v.first().getAttribute() == null);
		assertTrue(v.last().getAttribute() == null);

		// Nodes with attribute and namespace.
		v = new NodeVector();
		v.addNode(new Node(""foo"", ""urn:xml:xmlns:foo = 'http://www.someothernamespace'"", ""urn:xmlns:foo"", ""urn:xmlns:foo""));
		v.addNode(new Node(""foo"", ""urn:xmlns:foo"", ""urn:xml:xmlns:foo"", ""urn:xmlns:foo""));
		assertTrue(v.first().getNamespaceURI() == null);
		assertTrue(v.last().getNamespaceURI() == null);
		assertTrue(v.first().getAttribute() == null);
		assertTrue(v.last().getAttribute() == null);

		// Nodes with namespace and attribute.
		v = new NodeVector();
		v.addNode(new Node(""foo"", ""urn:xml:xmlns:foo = 'http://www.someothernamespace'"", ""urn:xmlns:foo"", ""urn:xmlns:foo"", ""urn:xmlns:foo""));
		v.addNode(new Node(""foo"", ""urn:xmlns:foo"", ""urn:xml:xmlns:foo"", ""urn:xmlns:foo""));
		assertTrue(v.first().getNamespaceURI() == ""urn:xmlns:xml"");
		assertTrue(v.last().getNamespaceURI() == ""urn:xmlns:xml"");
		assertTrue(v.first().getAttribute() == ""urn:xmlns:foo"");
		assertTrue(v.last().getAttribute() == ""urn:xmlns:foo"");
	}

	/**
	* Test of namespace.
	*/
	@Test
	public void testNamespace() {
		System.out.println(""Test of namespace."");
		
		// Test default.
		Vector v;
		v = new NodeVector();
		v.addNode(new Node(""foo"", ""urn:/foo""));
		v.addNode(new Node(""foo"", ""urn:foo"", ""urn:xml""));
		System.out.println(v.first());
		System.out.println(v.last());
		assertEquals(""http://www.somewhere"", v.first().getNamespaceURI());
		assertEquals(""urn"", v.last().getNamespaceURI());
		
		// Test other namespace.
		v = new NodeVector();
		v.addNode(new Node(""foo"", ""urn:foo""));
		v.addNode(new Node(""foo"", ""urn:xml"", ""urn:nfo""));
		v.addNode(new Node(""foo"", ""urn:xmlns:foo"", ""urn:xmlns:foo""));
		v.addNode(new Node(""foo"", ""urn:xmlns:foo"", ""urn:nfo""));
		System.out.println(v.first());
		System.out.println(v.last());
		assert"
27406b45-1624-43ad-aa7a-aa1b90eca152,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_4Test.java,61.48841166496277,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }
}
","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {

    // @Test void testConstructor()
    @Test 
    public void testConstructor() throws Exception {
        System.out.println(""testConstructor"");
        new Element((String) null);
        assertEquals(null, elemType);
        
        /*
        * Constructor that takes attributes 
        */
        Object result = new Element((String) null, true);
        assertEquals(null, result);
        
        // @Test void testGetAttributeString()
        System.out.println(""testGetAttributeString"");
        elemType = new URL(""http://www.w3.org/2005/Atom"");
        String attributeType = ""text/html"";
        
        Element result2 = new Element(attributeType, true);
        assertEquals(elemType, result2.getAttributeType(1));
        assertEquals(String.class, result2.getAttributeType(2));    
    }

    // testGetAttribute
    @SuppressWarnings(""unchecked"")
    @Test 
    public void testGetAttribute() throws SaxException {
        System.out.println(""testGetAttribute"");
        String attributeType = ""text/html#myid"";
        
        System.out.println(""[elemGetAttribute] return a value of"");
        Element result = new Element(attributeType);
        
        List children = result.children();
        assertSame(attributeType, children.getType());
        assertEquals(2, children.size());
        
        assertEquals(""text/html"", children.get(0).getAttributeType());
        AttributesImpl resultAttrs = new AttributesImpl((Vector) children.get(0));    
        assertEquals(""myid"", resultAttrs.getValue(""X-Atom-Id""));
        
        assertEquals(""text/html#myid"", result.getAttributeType(((Integer) children.get(0)).intValue()));
        
        children = result.children();
        assertSame(attributeType, children.getType());
        assertEquals(2, children.size());
        
        assertEquals(""text/html"", children.get(0).getAttributeType());
        resultAttrs = new AttributesImpl((Vector) children.get(1));    
        assertEquals(""myid"", resultAttrs.getValue(""X-Atom-Id""));
        
        System.out.println(""return value: "" + result);
        
    }

}"
86e6ce67-2515-4d26-9274-49072aeabc35,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_5Test.java,63.59634566307068,stop,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }
}
","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {
@Test
		public void getAttributeValue() throws Exception {
			Element element = new Element();
			//element.setAttributeValue(""some attribute"");
			assertEquals(new URLImpl(""http://example.com/hello.txt"",""testtext"").toString(), element.getAttributeValue(""name""));
		}
    @Test
		public void testNamespace() throws Exception {
		ClassLoader c = this.getClass().getClassLoader();

			AttributesImpl attrValue = new AttributesImpl() {{
				addAttribute(""namespace"", ""http://www.w3.org/XML/1998/namespace"",""xmlns"");
			}};

			Element element = new Element(""test"",""/"",attrValue);

			assertNotNull(element.getNamespace());

		String s = element.getNamespace();
		System.out.println(s);

			ClassLoader cl = element.getClassLoader();

                        URL url = new URLImpl(""http://www.w3.org/XML/1998/namespace"",""xmlns"",""test"",""hello.txt"");
                        
			StringWriter writer = new StringWriter();
			StreamSource ssource = new StreamSource(url,writer);
			SAXParserFactory spf = SAXParserFactory.newInstance();
			try {
					ElementParser parser = new ElementParser(ssource);
					parser.parse(new StreamSource(spf.newStreamHandler(writer)));
			}
			catch (Exception e) {
					e.printStackTrace();
				}

			NodeList nl = element.elements();

            for(int i=0; i<nl.getLength(); i++)
			{
				Node child = nl.item(i);

				System.out.println(child);

			}
		}
    public static class VectorTest {

                String name = ""class1"";
                
                public String getName() throws Exception {
                        return name;
                }
                public void setName(String name) throws Exception {
                        this.name = name;
                }
                public Element_1Test() throws Exception {
                        Element child = new Element_1();
                        assertNull(name);
                        child.setName(""a"");
                        assertEquals(""a"", child.getName());
                }
                public Element_6Test newElement(int index) throws Exception {
                        Element child = new Element_6(index);
                        assertEquals(String.valueOf(index), child.getName());
                        assertEquals(""1""+index, child.getAttributeValue(""name""));
                        assertNull(child.getAttributeValue(""a""));
                        return child;
                }
                public Element_7 newElement() throws Exception {
                        Element child = new Element_7(null);
                        assertEquals(""7"", child.getName());
                        assertNull(child.getAttributeValue(""name""));
                        assertNull(child.getAttributeValue(""a""));
                        return child;
                }
                public class Element_1 {
                        public int f( int index ) throws Exception {
                                return 0;
                        }
                        public int e(int index) throws Exception {
                                return 0;
                        }
                }
                public class Element_6 {

                        public int f( int index ) throws Exception {
                                return 0;
                        }
                        public int e(int index) throws Exception {
                                return 0;
                        }
                }
                public class Element_7 {

                        public int f( int index ) throws Exception {
                                return 0;
                        }
                        public int e(int index) throws Exception {
                                return 0;
                        }
                }
                public class Element_1Test {

                        public int f( int index ) throws Exception {
                                return 0;
                        }
                        public int e( int index ) throws Exception {
                                return 0;
                        }
                }
        }
		"
f34a3810-56ac-4825-95dd-8b7803e825f4,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_6Test.java,64.21705937385559,length,"// Element.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }
}
","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {
@Test
		public void test_numberOfNamespaceMappings() {
			/*
			 * Test case for element number of namespace mappings.
			 */
			int case1 = 1;
			AttributesImpl attr = new AttributesImpl();
			Element element = new Element(""element"");
			element.setAttributeNS(NS_URI, ""ns1"", ""name1"");
			element.setAttributeNS(NS_URI, ""ns2"", ""name2"");
			element.setAttributeNS(NS_URI, ""namespaces1"", ""http://ns1"");
			element.setAttributeNS(NS_URI, ""abcd14e"", ""name3"");
			element.setNamespaceURI(NS_URI);
			NamespaceMappings mappings = new NamespaceMappings(NS_URI);
			int count1 = 0;
			for (int indexNamespaceMapping = 0;
				indexNamespaceMapping < numberOfNamespaceMappings();
				indexNamespaceMapping++
				) {
			    if (namespacePrefixes.get(indexNamespaceMapping)!= null) {
			    	count1++;
			    	assertEquals(11, indexNamespaceMapping);
			    	assertEquals(""ns1"", mappings.get(nsPrefixes.get(indexNamespaceMapping)));
			    	assertEquals(NS_URI, mappings.get(nsPrefixes.get(indexNamespaceMapping)));
			    	if (count1 >= case1) {break; }
			    }
			}
			assertEquals(case1, count1);
			assertFalse(element.hasChildElements());
			StringBuilder case1ElementName = new StringBuilder();
			case1ElementName.append(""element"");
			case1ElementName.append(""element"");
			Element element2 = new Element(case1ElementName.toString());
			for (int indexNsPrefix : namespacePrefixes) {
				case1ElementName.append("","");
				case1ElementName.append(indexNsPrefix);
			}
			Vector<Element> children = new Vector<>();
			case1ElementName.append(""children"");
			Vector<Element> children2 = new Vector<>();
			Vector<String> namespaces = new Vector<String>();
			Vector<Element> elements = new Vector<Element>();
			Vector<String> namespaces1 = new Vector<String>();
			StringBuilder sb = new StringBuilder();
			sb.append(element.toXML());
			if (element.content!=
				sb.toString()) {
			    fail(""Content of the children of the element should not be different for the two case: "");
			}
			assertTrue(element.hasChildElements());
			int count2 = 0;
			for (int index = 0;
				index < (element.getChildElementCount());
				index++)
			{
				Element childElement = element.getChildElement(index);
			    case1ElementName.append("","");
			    case1ElementName.append(""element "" + Integer.toString(count2));
			    case1ElementName.append("": "");
			    case1ElementName.append(childElement.toXML());
				namespaces.add(childElement.getNamespaceURI());
				if (childElement instanceof Element) {
					case1ElementName.append(""."");
					case1ElementName.append(((Element)childElement).toXML());
					//	case1ElementName.append("" with XML "");
					//	case1ElementName.append(((Element)childElement).toXMLWithNamespaces());
				}
				if (childElement.toXMLWithNamespaces().toString().length() > 0) {
					case1ElementName.append(""."");
					case1ElementName.append(childElement.toXMLWithNamespaces());
				}
				case1ElementName.charAt(Integer.toString(count2) + 3);
				if (childElement.toXMLWithNamespaces().toString().length() > 0) {
					case1ElementName.append(""."");
					case1ElementName.append(childElement.toXMLWithNamespaces());
				}
				//	if (!StringUtils.equals(case1ElementName.toString(), childElement.toXMLWithNamespaces().toString())) {
						//fail(""Element namespaces is not the same for case: \"""" + case1ElementName.toString() + ""\"" and "" + childElement.toXMLWithNamespaces().toString());
				//}
				default:
					/*
					 * Default case.
					 */
					assertFalse(""XML content of the children of the element should not be equal to XML with name in case: \"""" + case1ElementName.toString() + ""\"". The case is \"""" + case1ElementName.toString() + ""\""."", case1ElementName.toString().equals(childElement.toXMLWithNamespaces().toString()));
				}
				//	case1ElementName.append("" with namespace: \"""" + childElement.getNamespaceURI() + ""\""."");
				if (namespaces.size() > 0 && mappings.get(namespaces.get(namespaces.size() - 1))!= null) {
					namespaces1.add(namespaces.get(namespaces.size() - 1));
				}
				for (int namespaceIndex = 0;
					namespaceIndex < namespacePrefixes.size();
					namespaceIndex++)
				{
					if (namespaces1.get(namespaceIndex)!= null) {
						namespaces1.add(namespaces.get(namespaceIndex));
					}
				}
				case1ElementName.append("" with URI: \"""" + childElement.getNamespaceURI() + ""\""."");
				case1ElementName.append(""."");
				case1ElementName.append(""."" + childElement.toXML());
				case1ElementName.append(""."");
				case1ElementName.append(""."" + childElement.toXMLWithNamespaces().toString());
				case1ElementName.append("".\n\n"");
				children.add(childElement);
				elements.add(element);
				namespaces.add(getNamespace(childElement));
				children2.add(childElement);
				elements2.add((Element)childElement2);
				elements2.add(childElement);
				children2.add((Element)childElement2);
				if (childElement.getAttributeNS(NS_URI, INDEX)!= null) {
					case1ElementName.append("" index: "");
					case1ElementName.append(childElement.getAttributeNS(NS_URI, INDEX));
					children2.add(childElement);
					elements2.add(childElement);
				}
				children2.add((Element)childElement2);
				if (childElement2.getAttributeNS(NS_URI, INDEX)!= null) {
					case1ElementName.append("" index: "");
					case1ElementName.append(childElement2.getAttributeNS(NS_URI, INDEX));
					children2.add(childElement2);
					elements2.add(childElement2);
				}
				if (!childElement.getAttributeValue(ATTR_NAMESPACE).equals(null)
					&&!namespaces.get(namespaces.size() - 1).equals(getNamespace(childElement)))
				{
					break;
				}
			}
			assertEquals(case1ElementName.toString(), element.toXML());
			assertEquals(case1ElementName.to"
ecf94828-a1a2-40d8-8a0e-3f122a53c9ac,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Text.java,65.67406582832336,stop,"// Text.java
package nu.staldal.xtree;

import org.xml.sax.*;

/**
 * Character content in an XML document. This class is immutible.
 */
public class Text extends Node {

    public char[] asCharArray() {
        obtainCharArray();
        return charArrayCache;
    }
}
","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains one unit test case for the {@link Text#asCharArray()} method.
*/
class TextTest {","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains one unit test case for the {@link Text#asCharArray()} method.
*/
class TextTest {
/**
		* Test constructor.
		* Expected result: {@code null} as char[].
		*/
		@Test
		void testNoContent() {
			Text text = new Text();
			char[] content = text.asCharArray();
			assertEquals(""text content as char"", null, content);
		}

		/**
		* Test constructor.
		* Expected result: {@code new char} as char.
		*/
		@Test
		void testNewChar() {
			Text text = new Text();
			text.addContent(""new\u000D"".toCharArray());
			char[] expectedContent = ""new\r\n"".toCharArray();
			assertNotNull(""new char content as char"", text.asCharArray());
			assertArrayEquals(""char content as char"", expectedContent, text.asCharArray());
		}

		/**
		* Test constructor.
		* Expected result: {@code new char[]()} as char.
		*/
		@Test
		void testNewCharArray() {
			Text text = new Text();
			text.addContent(""new\u000A"".toCharArray());
			char[] expectedContent = ""new\u0009"".toCharArray();
			assertNotNull(""new char content as char[]"", text.asCharArray());
			assertArrayEquals(""char content as char[]"", expectedContent, text.asCharArray());
		}

		/**
		* Test constructor.
		* Expected result: {@code null} as char[] with '0'.
		*/
		@Test
		void testNoNewCharArray() {
			Text text = new Text();
			text.addContent(""\u000A"".toCharArray());
			char[] expectedContent = null;
			assertNull(""null as char[] with new char array"", text.asCharArray());
			assertArrayEquals(""char[] with new char array"", expectedContent, text.asCharArray());
		}

		/**
		* Test constructor.
		* Expected result: {@code null} as char[] with 'x'.
		*/
		@Test
		void testNoNewCharArrayWithX() {
			Text text = new Text();
			text.addContent(""\u000E"".toCharArray());
			char[] expectedContent = null;
			assertNull(""null as char[] with new char[] with x"", text.asCharArray());
			assertArrayEquals(""char[] with new char[] with x"", expectedContent, text.asCharArray());
		}

		/**
		* Test constructor.
		* Expected result: {@code new char[0]} as char.
		*/
		@Test
		void testNewCharArrayWithSizeZero() {
			Text text = new Text();
			text.addContent(""new\u000A"".toCharArray(0));
			char[] expectedContent = ""new\u0009"".toCharArray();
			assertNotNull(""new char content as char[] with 0"", text.asCharArray());
			assertArrayEquals(""char content as char[] with 0"", expectedContent, text.asCharArray());
		}

		/**
		* Test constructor.
		* Expected result: {@code new char[4]}.
		*/
		@Test
		void testNewCharArrayWith4() {
			Text text = new Text();
			text.addContent(""new\u000A"".toCharArray(4));
			char[] expectedContent = ""new\u000A"".toCharArray();
			assertNotNull(""new char content as char[] with 4"", text.asCharArray());
			assertArrayEquals(""char content as char[] with 4"", expectedContent, text.asCharArray());
		}

		/**
		* Test constructor.
		* Expected result: {@code new char[7]}.
		*/
		@Test
		void testNewCharArrayWith7() {
			Text text = new Text();
			text.addContent(""new\u000A"".toCharArray(7));
			char[] expectedContent = ""new\u000A"".toCharArray();
			assertNotNull(""new char content as char[] with 7"", text.asCharArray());
			assertArrayEquals(""char content as char[] with 7"", expectedContent, text.asCharArray());
		}

		/**
		* Test constructor.
		* Expected result: {@code new char[](10,5)} as char array with content.
		*/
		@Test
		public void testNewCharArrayWithSizeAndContent() {
			Text text = new Text();
			char[] expectedContent = new char[10];
			int charSize = 10;
			for (int i = 0; i < 10; i ++) {
				text.addContent(""new\u000A"".toCharArray(charSize, charSize));
				expectedContent[i] = i == 7? 0 : i == 5? 1 : i == 3? 2 : i == 1? 3 : 4;
			}
			assertNotNull(""new char content as char array with content"", text.asCharArray());
			assertArrayEquals(""char content as char array with content"", expectedContent, text.asCharArray());
		}

		String output = new Text().asCharArray();
		System.out.println(new String(output.getBytes(""UTF-8"")));
	}
"
d1b0dade-4102-4c25-9b1b-6b7997f92f45,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/SequentialTreeBuilder.java,53.64719915390015,stop,"// SequentialTreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build a list of XTree:s from a SAX2 event stream, or by parsing an XML document.
 * <p>
 * Useful to process a large document sequentially, without need to store the whole
 * document in memory at the same time.
 * <p>
 * The SequentialTreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class SequentialTreeBuilder implements ContentHandler, ErrorHandler {

    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }
}
","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains one unit test case for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains one unit test case for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {

	/// <summary>Test suite start point.
		private static final String test_suite_name = ""SequentialTreeBuilderTest"";
		
		/// <summary>Test suite end point.</summary>
		static final String test_suite_end = ""done"";
		
		private final String xtreeFileLoc;
		private final String xtreeFileEnc;
		private final boolean validateNamespace;
		private final boolean validateDTD;
		
		private final boolean hasParent;
		private Element rootElement = null;

		private SequentialTreeBuilderTest(String baseUrl, String xtreeFileLoc, String xtreeFileEnc, boolean validateNamespace,
				boolean validateDTD) {
			this.xtreeFileLoc = baseUrl + File.separator + xtreeFileLoc;
			this.xtreeFileEnc = xtreeFileEnc;
			this.validateNamespace = validateNamespace;
			this.validateDTD = validateDTD;
		}

		/// <summary>
		/// Start test suite.
		/// </summary>
		public static void main(String[] args) {
			launch(
				SequentialTreeBuilderTest.class,
				args);
		}
		
		/// <summary>
		/// Setup a new suite: start from the top of the tree.
		/// </summary>
		/// <param name=""parent"">The parent suite.
		/// </param>
		public static void push(SequentialTreeBuilderTest parent) {
			new SequentialTreeBuilderTest(parent.getUrl(), parent.getXtreeFileLoc(), parent.getXtreeFileEnc(),
					parent.getValidateNamespace(), parent.getValidateDTD());
			new SequentialTreeBuilderTest(parent.getUrl(), parent.getXtreeFileLoc(), parent.getXtreeFileEnc(),
				!parent.getValidateNamespace(), parent.getValidateDTD()).push();
		}

		/// <summary>
		/// Pop the current suite from the tree.
		/// </summary>
		/// <param name=""parent"">The parent suite.
		/// </param>
		public static SequentialTreeBuilderTest pop(SequentialTreeBuilderTest parent) {
			parent.pop();
			return parent;
		}

		/// <summary>
		/// Push tests suite start at the top.
		/// </summary>
		/// <param name=""skeleton"">The parent suite or <code>null</code>.
		/// </param>
		public static void parent(SequentialTreeBuilderTest skeleton) {
			new SequentialTreeBuilderTest(skeleton.getUrl(), skeleton.getXtreeFileLoc(), skeleton.getXtreeFileEnc(),
						skeleton.getValidateNamespace(), skeleton.getValidateDTD());
			parent(skeleton);
			rootElement = new Element(""root"");
			skeleton.push(new SequentialTreeBuilder(new ElementHandler() {
				public void handleStartElement(Element e) {
					Element ele = new Element(e.getQName());
					ele.addAttributes(e.getAttributes());
					e.setTextContent(ele.get(0));
					if (hasParent) {
						assertEquals(e.getName(), ""parent"");
						rootElement = e;
						assertEquals(rootElement.getBackingElement(), ele);
					}
				}
			}));
		}

		/**
		 * Parses a single XML content file.
		 *
		 * @param xmlFileLoc
		 *            Location of the XML.
		 * @param xmlFileEnc
		 *            Encoding used in the file.
		 * @param validateNamespaces
		 *            If the namespaces have been declared in the original file.
		 * @param validateDTD
		 *            If the DTD should be validated.
		 * @return An XML document from the XML file.
		 */
		public Document parseXMLSequential(String xmlFileLoc, String xmlFileEnc, boolean validateNamespaces,
				boolean validateDTD) throws SAXException, IOException {

			try (FileInputStream fis = new FileInputStream(new File(xtreeFileLoc))) {
				return parseXMLSequential(new InputSource(fis), validateNamespaces, validateDTD);
			}
		}
		
		private Document parseXMLSequential(InputSource xmlInput, boolean validateNamespaces, boolean validateDTD)
			throws SAXException
		{
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			factory.setValidating(validateNamespaces);
			factory.setFeature(""http://xml.org/sax/features/namespaces"", validateNamespaces);
			factory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
			
			XMLReader xmlReader = factory.newXMLReader();
			xmlReader.setContentHandler(this);
		    xmlReader.setErrorHandler(this);
		    return xmlReader.parse(xmlInput);
		}
}
"
4fba5fc2-13ee-4d19-ad77-e97c9b18ecda,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_0Test.java,46.90073347091675,stop,"// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }
}
","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {
// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema!= null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema!= null) &&!((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }
}

// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {
		
	/**
	 * Test the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method with a null
	 * parameter.
	*/

	@Test
	public void testNullArgument() {
		String schemaType = ""http://example.com/schema.xsd"";
		
		InputSource schemaSource = new FileInputSource(XTreeUtil_0Test.class.getClassLoader().getResource(""simple_root_with_schema.xsd""));
		assertNotNull(""null schemaSource"", schemaSource);
		InputSource schemaSource2 = new FileInputSource(XTreeUtil_0Test.class.getClassLoader().getResource(""schema.xsd""));
		TreeBuilder rootBuilder = new TreeBuilder();
		ContentHandlerFixer contentHandlerFixer = new ContentHandlerFixer(rootBuilder);
		XTreeUtil_0Test.parseXML(schemaSource, false, schemaType, schemaSource);
		String content = rootBuilder.resultXML();
		assertEquals(""testNullArgument.1.1"", content);
		
		assertNull(""new ContentHandlerFixer is initialized"", contentHandlerFixer);
		
		assertTrue(""no contentHandlerFixer is initialized"", contentHandlerFixer == null);
	}
	
	/**
	 * Test the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method with a null
	 * input source.
	*/
	@Test
	public void testNullInputSource() {
		String schemaType = ""http://example.com/schema.xsd"";
		
		TreeBuilder rootBuilder = new TreeBuilder();
		
		assertEquals(""rootBuilder is not initialized correctly"", rootBuilder, new TreeBuilder().getTree());
		
		InputSource nullSource = null;
		
		try {
			XTreeUtil.parseXML(nullSource, false, schemaType, nullSource);
			
			fail(""Parse null source exception"");
		} catch (NullPointerException e) {
			if (!(e.getMessage().contains(""the null string"")) &&!(e.getMessage().contains(""null input source""))) {
				fail(""expected null string "" + e.getMessage() + "" containing null source "" + nullSource.toString());
			}
		}
		
	}
}"
0facdd57-4b31-42d7-9fef-0ec256c60699,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_1Test.java,48.653491497039795,length,"// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }
}
","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {
// XTreeUtil.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema!= null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema!= null) &&!((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }
}

// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {
		private File dataDir;
		private XMLResource xmlDataFile;
	 				
		XTreeUtil_1Test(XTreeUtil xmlUtil, File dataDir, InputSource xDataFile, InputSource xmlDataFile) throws Exception {
			this.dataDir = dataDir;
			this.xmlDataFile = new XMLResource(xmlDataFile);
			this.dataDir.mkdirs();
		}
		
		/**
		 * This method tests that the XML dataFile will be correctly parsed and the data will be correctly retrieved.
		 */
		@Test
		public void test_parseXML() throws Exception {
			Element rootElement = parseXML(this.xmlDataFile, false, null);
			assertEquals(""Root element should be the root element"", XTreeImpl.ROOT_ELEMENT, rootElement);
			
			setInputText(""test_parseXML"", ""This is just testing the parsing of XML data file."");
			ArrayList<Element> parsedElements = new ArrayList<Element>();
			rootElement.traverse(new AllElementsTraverser(parsedElements, true));
			assertEquals(""Parsed list not equal to the parsed list"", parsedElements, Collections.synchronizedList(XTreeUtil.asList(rootElement)));
		}
		
		/**
		 * This method also tests that the root element will be correctly retrieved.
		 */
		@Test
		public void test_getRootElement() throws Exception {
			Parser parser = XMLReaderFactory.createXMLReader(this.xmlDataFile);
			XTreeUtil util = new XTreeUtil(parser);
			Element rootElement = util.getRootElement();
			assertEquals(""Root element should be the root element."", XTreeImpl.ROOT_ELEMENT, rootElement);
			
		}
		
		/**
		 * This method also tests that the root element will be correctly retrieved.
		 */
		@Test
		public void test_getRootPara() throws Exception {
			Parser parser = XMLReaderFactory.createXMLReader(this.xmlDataFile);
			XTreeUtil util = new XTreeUtil(parser);
			util.addElementHandler(new ContentHandlerFixer() {
				public void handleContent(Element element) throws SAXException, IOException {
					assertEquals(""Nodes should have correct child nodes."", XParser.ROOT_MARKUP, element.getNodeName());
				}
			});
			
			ArrayList<Element> parsedElements = new ArrayList<Element>();
			rootElement.traverse(new AllParaElementsTraverser(parsedElements, false));
			assertEquals(""Parsed list not equal to the parsed list"", parsedElements, Collections.synchronizedList(XTreeUtil.asList(rootElement)));
		}
	 	
		/**
		 * This method tests that XML datafiles are provided by the {@link ContentHandlerFilter} and parsed.
		 */
		@Test
		public void test_ContentHandlerFilter_and_Parsing() throws Exception {
			URL contentFile = getClass().getResource(""ContentHandlerFilterTest_1.xml"");
			XMLResource dataFile = new XMLResource(contentFile);
			
			this.xmlDataFile = dataFile;
			Parser factory = XMLFactory.newInstance();
			Parser parser = factory.newSAXParser().getXMLReader();
			ArrayList<Element> elements = new ArrayList<Element>();
			parser.setContentHandler(elements);
//			parser.parse( new InputSource( dataFile.getContent() ) );
			parser.parse(dataFile.getContent());
			assertNotNull(""Missing content handler after parsing."", elements);
			assertTrue(""There should be at least one node."", elements.size() > 0);
			assertTrue(""The root node should be the root element."", elements.get(0) == 
				XMLUtils.getRootElement( parser ));
			
			parser.setFeature(""http://apache.org/xml/features/validation"", false);
			
			XMLReaderFilter filter = new XMLReaderFilter();
			filter.setContentHandler(elements);
//			filter.setDocumentHandler( elements );
			parser.addFilters(filter);
			parser.parse( new InputSource( dataFile.getContent() ) );
			assertNotNull(""Missing content handler after parsing."", elements);
			assertTrue(""There should be at least one node."", elements.size() > 0);
			assertTrue(""The root node should be the root element."", elements.get(0) == 
				XMLUtils.getRootElement(parser));
		}
	 	
		private void setInputText(String functionName, String value) throws IOException {
			File f = new File(this.dataDir + File.separator + ""test_"" + functionName + "".xml"" ) ;
			try {
				StreamResult streamResult = new StreamResult( f );
				StreamHandler streamHandler = new StreamHandler( streamResult ) ;
				streamHandler.startDocument();
				streamHandler.startElement( ""XTree"", """", """", ContentHandlerFixer.getInstance().getXMLNS());
                
				streamHandler.startElement( ""XString"", """", """", new StringBuilder(""hello""));
                
				streamHandler.endElement( ""XTree"", """", """");

				streamHandler.endElement("
c8484aa6-f3b2-457f-bcbe-f444b2fd8640,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_0Test.java,59.562156677246094,stop,"// TreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }
}
","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {
// TreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/')? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }
}

// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {
		TreeBuilder builder;

		public TreeBuilder_0Test(TreeBuilder builder) {
			this.builder = builder;
		}

		@Test
		void canParseStreamFromFile() throws Exception {
			final InputSource inputSource1 = fileToInputSource(new File(""src/nu/staldal/xtree/test/data/filetree.xml""));
			final InputSource inputSource2 = fileToInputSource(new File(""src/nu/staldal/xtree/test/data/filetree1.xml""));

			builder.fileToInputSource(inputSource1);
			builder.fileToInputSource(inputSource2);

			final List<String> nodes = getNodes(this.builder.inputSource.getSystemId());
			assertEquals(3, nodes.size());
			assertTrue(nodes.size() > 0);
			boolean first = true;
			for (String node : nodes) {
				if (!first) {
					assertNotNull(node);
					assertNotNull(builder.getNode(builder.builder.getRoot(), node));
				}
				first = false;
			}
		}
}

// TreeBuilder_0.java
"
efee9a05-86f9-4e36-856e-23c0437c8607,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_1Test.java,55.50967025756836,stop,"// TreeBuilder.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }
}
","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {
static final String xmlPath = ""src/test/resources/org/xml/sax/helpers/XMLFilterImpl.java"";
	    
	    final TreeNode root1 = XTree.<String>createNode(""Root1"");
	    final TreeNode node1 = root1.createNode(""child-1"", Integer.class);
        final TreeNode node2 = root1.createNode(""child-2"", String.class);
	    final TreePath parent1 = node1.getParentPath();
        final TreePath sibling1 = node1.getSiblingPath();
	    final TreePath parent2 = node2.getParentPath();
        final TreePath sibling2 = node2.getSiblingPath();
        
        // test get method
        {
            final TreeBuilder builder = new TreeBuilder();
            final Element tree = builder.setTree(root1).setTreePath(parent1);
            assertEquals(tree, builder.setTree(node1));
            tree.getChildNodes();
            assertEquals(root1, builder.getTree());
            tree.getChildNodes();
            assertEquals(node1, builder.getTree());
        }
        
        // test remove method
        {
            final TreeBuilder builder = new TreeBuilder();
            final TreeBuilder builder1 = true;
            final TreeBuilder builder2 = builder;
            final Element tree = builder.setTree(root1).setTreePath(parent1);
            builder.remove(builder1);
            builder.remove(builder2);
            log(builder);
            tree.getChildNodes();
            tree.getChildNodes();
            assertEquals(tree, builder.getTree());
            tree.getChildNodes();
            assertEquals(tree, builder.getTree());
            test(builder2, builder, null);
            tree.getChildNodes();
            tree.getChildNodes();
            tree.remove();
            tree.getChildNodes();
            assertEquals(tree, builder.getTree());
            tree.getChildNodes();
            assertEquals(node2, builder.getTree());
            tree.getChildNodes();
            tree.remove();
            tree.getChildNodes();
            assertEquals(tree, builder.getTree());
        }
        
	    // test set method
	    {
            final TreeBuilder builder = new TreeBuilder();
            final Element root1 = builder.setTree(root1).setTreePath(parent1);
            assertEquals(tree1, builder.setTree(tree1));
            tree1.getChildNodes();
            tree1.getChildNodes();
            tree1.getChildNodes();
            tree1.getParentPath();
            tree1.getParentPath();
            tree1.setTreePath(sibling1);
            tree1.setTreePath(parent2);
            tree1.setTreePath(sibling2);
            tree1.getChildNodes();
            tree1.getChildNodes();
            tree1.getChildNodes();
            tree1.getChildNodes();
            assertEquals(tree2, builder.setTree(tree2));
            tree1.getChildNodes();
            tree1.getParentPath();
            tree1.getParentPath();
            log(builder);
            tree1.getChildNodes();
            tree1.getChildNodes();
            tree1.getChildNodes();
            tree1.remove();
            tree1.getChildNodes();
            tree1.getChildNodes();
            tree1.remove();
            tree1.getChildNodes();
            tree1.getChildNodes();
            tree1.remove();
            tree1.getChildNodes();
            log(builder);
        }
	}
	
    private static final String testPath = ""src/test/resources/org/xml/sax/helpers/XMLFilterImpl.java"";
	static final boolean DEBUG = false;
    private static void log(TreeBuilder builder) {
    }

}
"
