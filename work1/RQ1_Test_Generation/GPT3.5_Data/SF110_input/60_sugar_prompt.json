[
  {
    "numberTests": "ten",
    "original_code": "// DefaultFSPath.java\n/**\r\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\r\n *\r\n * All rights reserved.\r\n *\r\n * This file is part of FSPath.\r\n *\r\n * FSPath is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * FSPath is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with FSPath.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\n/*\r\n * DefaultFSPath.java\r\n *\r\n * Created on 18 September 2006, 00:25\r\n *\r\n */\r\npackage net.sf.sugar.fspath;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.text.DateFormat;\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport javax.xml.namespace.QName;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport javax.xml.parsers.DocumentBuilderFactory;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport net.sf.sugar.fspath.xpath.RegexFunctionResolver;\r\nimport org.w3c.dom.Attr;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n *  The default implementation of the FSPath interface.\r\n *  This class uses the JDK\u0027s XPath implementation as the basis for\r\n *  FSPath queries.\r\n *  On instantiation, a DOM is created of the filesystem metadata starting form the \u003ccode\u003erootDirectory\u003c/code\u003e.\r\n *  This DOM can then be queried using standard XML tools.\r\n *  \u003cbr/\u003e\r\n *  Whilst this approach has been relatively quick to implement, it is still tied to the limitations of XPath.\r\n *  Future implementations of this class are likely to implement the FSPath language fully themselves wthout relying on XPath.\r\n *  \u003cbr/\u003e\r\n *  todo: develop some front end substitution to enable the short queries i.e. /var/www etc\r\n *\r\n * @author keith\r\n *  $Id$\r\n */\r\npublic class DefaultFSPath implements FSPath {\r\n\r\n    /**\r\n     *  Escape characters, we must escape any characters that are\r\n     *  illegal in XML attribute text.\r\n     *\r\n     *  i.e. \u0026amp; \" \u003c \u003e\r\n     */\r\n    private Map escapeChars;\r\n\r\n    private DocumentBuilder documentBuilder;\r\n\r\n    private XPath xpath;\r\n\r\n    private Document dom;\r\n\r\n    /**\r\n     *  The date format used to correspond to the xs:date format i.e. yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSS\r\n     */\r\n    private DateFormat format;\r\n\r\n    private File rootDirectory;\r\n\r\n    public DefaultFSPath() {\r\n        //used for unit test instantiation\r\n        this.xpath \u003d XPathFactory.newInstance().newXPath();\r\n        //this.xpath.setNamespaceContext(new FSNamespaceContext());\r\n        //this effectively enables the user of our custom XPath function\r\n        //fs:match()\r\n        this.xpath.setXPathFunctionResolver(new RegexFunctionResolver());\r\n        this.escapeChars \u003d this.createEscapeCharsMap();\r\n        this.format \u003d new SimpleDateFormat(\"yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSS\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of DefaultFSPath, based on the directory supplied\r\n     */\r\n    public DefaultFSPath(File currentDir) {\r\n        this();\r\n        this.rootDirectory \u003d currentDir;\r\n        //check if file is a directory\r\n        if (!currentDir.isDirectory()) {\r\n            throw new InstantiationError(\"the java.io.File specified must be a Directory\");\r\n        }\r\n        try {\r\n            this.createDocumentBuilder();\r\n            //build DOM representation\r\n            this.dom \u003d this.buildDOM(currentDir);\r\n        } catch (ParserConfigurationException pce) {\r\n            pce.printStackTrace();\r\n            throw new InstantiationError(\"FSDom threw a ParserConfigurationException : \" + pce.getMessage());\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n            throw new InstantiationError(\"FSDom threw an IOException : \" + ioe.getMessage());\r\n        }\r\n    }\r\n\r\n    protected Map createEscapeCharsMap() {\r\n        Map\u003cString, String\u003e escapeChars \u003d new HashMap\u003cString, String\u003e();\r\n        escapeChars.put(\"\u0026\", \"\u0026#26;\");\r\n        escapeChars.put(\"\u003c\", \"\u0026#3c;\");\r\n        escapeChars.put(\"\u003e\", \"\u0026#3e;\");\r\n        escapeChars.put(\"\\\"\", \"\u0026#22;\");\r\n        return escapeChars;\r\n    }\r\n\r\n    protected void createDocumentBuilder() throws ParserConfigurationException {\r\n        try {\r\n            this.documentBuilder \u003d DocumentBuilderFactory.newInstance().newDocumentBuilder();\r\n        } catch (ParserConfigurationException pce) {\r\n            pce.printStackTrace();\r\n            throw pce;\r\n        }\r\n    }\r\n\r\n    protected Document buildDOM(File currentDir) throws IOException {\r\n        Document dom \u003d this.documentBuilder.newDocument();\r\n        dom.appendChild(this.createChildElement(dom, currentDir));\r\n        return dom;\r\n    }\r\n\r\n    private Element createChildElement(Document dom, File currentFile) throws IOException {\r\n        Element currentElement \u003d null;\r\n        if (currentFile.isDirectory()) {\r\n            currentElement \u003d dom.createElement(FSPathAttributes.dir.name());\r\n            //recurse and create child elements for all its children\r\n            File[] children \u003d currentFile.listFiles();\r\n            if (children !\u003d null) {\r\n                for (int i \u003d 0; i \u003c children.length; i++) {\r\n                    currentElement.appendChild(this.createChildElement(dom, children[i]));\r\n                }\r\n            }\r\n        } else {\r\n            currentElement \u003d dom.createElement(FSPathAttributes.file.name());\r\n        }\r\n        currentElement.setAttribute(FSPathAttributes.name.name(), currentFile.getName());\r\n        currentElement.setAttribute(FSPathAttributes.absolutePath.name(), currentFile.getAbsolutePath());\r\n        //optional for speed?\r\n        currentElement.setAttribute(FSPathAttributes.canRead.name(), Boolean.toString(currentFile.canRead()));\r\n        //optional for speed?\r\n        currentElement.setAttribute(FSPathAttributes.canWrite.name(), Boolean.toString(currentFile.canWrite()));\r\n        currentElement.setAttribute(FSPathAttributes.canonicalPath.name(), currentFile.getCanonicalPath());\r\n        //optional for speed?\r\n        currentElement.setAttribute(FSPathAttributes.exists.name(), Boolean.toString(currentFile.exists()));\r\n        currentElement.setAttribute(FSPathAttributes.isAbsolute.name(), Boolean.toString(currentFile.isAbsolute()));\r\n        currentElement.setAttribute(FSPathAttributes.isDirectory.name(), Boolean.toString(currentFile.isDirectory()));\r\n        currentElement.setAttribute(FSPathAttributes.isFile.name(), Boolean.toString(currentFile.isFile()));\r\n        currentElement.setAttribute(FSPathAttributes.isHidden.name(), Boolean.toString(currentFile.isHidden()));\r\n        currentElement.setAttribute(FSPathAttributes.lastModified.name(), this.format.format(new Date(currentFile.lastModified())));\r\n        currentElement.setAttribute(FSPathAttributes.length.name(), Long.toString(currentFile.length()));\r\n        currentElement.setAttribute(FSPathAttributes.parent.name(), currentFile.getParent());\r\n        currentElement.setAttribute(FSPathAttributes.path.name(), currentFile.getPath());\r\n        return currentElement;\r\n    }\r\n\r\n    /**\r\n     *  Calls this.query(expression, XPathConstants.NODESET)\r\n     *\r\n     *  Note : This method MUST be passed an expression which returns a nodeset.\r\n     *\r\n     *  @param expression the FSPath expression to execute.\r\n     *  @returns \u003ccode\u003eFSPathResultList\u003c/code\u003e the FSPathResult objects contained\r\n     *  in this list will be of type \u003ccode\u003ejava.io.File\u003c/code\u003e,\r\n     *  \u003ccode\u003ejava.lang.Double\u003c/code\u003e, \u003ccode\u003ejava.lang.Boolean\u003c/code\u003e,\r\n     *  \u003ccode\u003ejava.lang.String\u003c/code\u003e\r\n     */\r\n    public FSPathResultList query(String expression) {\r\n        return this.query(expression, XPathConstants.NODESET);\r\n    }\r\n\r\n    /**\r\n     */\r\n    public FSPathResultList query(String expression, QName returnType) {\r\n        FSPathResultList results \u003d new FSPathResultListImpl();\r\n        try {\r\n            if (XPathConstants.NODESET.equals(returnType)) {\r\n                NodeList nodelist \u003d (NodeList) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODESET);\r\n                if (nodelist.getLength() \u003e 0) {\r\n                    for (int i \u003d 0; i \u003c nodelist.getLength(); i++) {\r\n                        processNode(nodelist.item(i), results);\r\n                    }\r\n                }\r\n                return results;\r\n            }\r\n            if (XPathConstants.NODE.equals(returnType)) {\r\n                Node node \u003d (Node) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODE);\r\n                processNode(node, results);\r\n                return results;\r\n            }\r\n            if (XPathConstants.BOOLEAN.equals(returnType)) {\r\n                Boolean result \u003d (Boolean) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.BOOLEAN);\r\n                results.add(new FSPathResult(result));\r\n                return results;\r\n            }\r\n            if (XPathConstants.NUMBER.equals(returnType)) {\r\n                Double result \u003d (Double) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NUMBER);\r\n                results.add(new FSPathResult(result));\r\n                return results;\r\n            }\r\n            if (XPathConstants.STRING.equals(returnType)) {\r\n                String result \u003d (String) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.STRING);\r\n                results.add(new FSPathResult(result));\r\n                return results;\r\n            }\r\n        } catch (XPathExpressionException xpee) {\r\n            System.out.println(\"Invalid FSPath expression : \" + xpee.getCause().getMessage());\r\n        } catch (IllegalArgumentException iae) {\r\n            iae.printStackTrace();\r\n            System.out.println(\"IllegalArgumentException\");\r\n        } catch (ParseException pe) {\r\n            pe.printStackTrace();\r\n            System.out.println(\"ParseException\");\r\n        }\r\n        return results;\r\n    }\r\n\r\n    private void processNode(Node node, FSPathResultList results) throws XPathExpressionException, IllegalArgumentException, ParseException {\r\n        //as the only elements in our dom are files or directories we will try to\r\n        //create File objects of those nodes.\r\n        if (node.getNodeType() \u003d\u003d Node.ELEMENT_NODE) {\r\n            String fileName \u003d node.getAttributes().getNamedItem(FSPathAttributes.absolutePath.name()).getNodeValue();\r\n            //System.out.println(\"Filename : \" + fileName);\r\n            results.add(new FSPathResult(new File(fileName)));\r\n            return;\r\n        }\r\n        if (node.getNodeType() \u003d\u003d Node.ATTRIBUTE_NODE) {\r\n            Attr attr \u003d (Attr) node;\r\n            //now work out which attirutes were Dates, Longs and Strings\r\n            if (FSPathAttributes.absolutePath.name().equals(attr.getName()) | FSPathAttributes.canonicalPath.name().equals(attr.getName()) | FSPathAttributes.name.name().equals(attr.getName()) | FSPathAttributes.parent.name().equals(attr.getName()) | FSPathAttributes.path.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(attr.getValue()));\r\n                return;\r\n            }\r\n            if (FSPathAttributes.canRead.name().equals(attr.getName()) | FSPathAttributes.canWrite.name().equals(attr.getName()) | FSPathAttributes.exists.name().equals(attr.getName()) | FSPathAttributes.isAbsolute.name().equals(attr.getName()) | FSPathAttributes.isDirectory.name().equals(attr.getName()) | FSPathAttributes.isFile.name().equals(attr.getName()) | FSPathAttributes.isHidden.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(new Boolean(attr.getValue())));\r\n                return;\r\n            }\r\n            if (FSPathAttributes.lastModified.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(this.format.parse(attr.getValue())));\r\n                return;\r\n            }\r\n            if (FSPathAttributes.length.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(Double.parseDouble(attr.getValue())));\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    public File getRootDirectory() {\r\n        return this.rootDirectory;\r\n    }\r\n}\r\n",
    "package": "net.sf.sugar.fspath",
    "classname": "DefaultFSPath",
    "id": "/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/DefaultFSPath_0Test.java",
    "test_prompt": "// DefaultFSPath_0Test.java\n/*\n * DefaultFSPath.java\n *\n * Created on 18 September 2006, 00:25\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport net.sf.sugar.fspath.xpath.RegexFunctionResolver;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultFSPath}.\n* It contains ten unit test cases for the {@link DefaultFSPath#query(String)} method.\n*/\nclass DefaultFSPath_0Test {",
    "method_signature": "query(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// FSPathFactory.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n/*\n * FSPathFactory.java\n *\n * Created on 06 April 2008, 17:04\n *\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\n\n/**\n * @author kbishop\n */\npublic class FSPathFactory {\n\n    /**\n     * Creates a new instance of FSPathFactory\n     */\n    public FSPathFactory() {\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the current user directory (System.getProperty(\"user.dir\")) to search from.\n     */\n    public static FSPath newFSPath() {\n        return new DefaultFSPath(new File(System.getProperty(\"user.dir\")));\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the directory provided to search from.\n     */\n    public static FSPath newFSPath(File file) {\n        return new DefaultFSPath(file);\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the directory path String provided to search from.\n     */\n    public static FSPath newFSPath(String path) {\n        return new DefaultFSPath(new File(path));\n    }\n}\n",
    "package": "net.sf.sugar.fspath",
    "classname": "FSPathFactory",
    "id": "/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathFactory_0Test.java",
    "test_prompt": "// FSPathFactory_0Test.java\n/*\n * FSPathFactory.java\n *\n * Created on 06 April 2008, 17:04\n *\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathFactory}.\n* It contains ten unit test cases for the {@link FSPathFactory#newFSPath()} method.\n*/\nclass FSPathFactory_0Test {",
    "method_signature": "newFSPath()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// FSPathResultListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultListImpl extends ArrayList\u003cFSPathResult\u003e implements FSPathResultList {\n\n    /**\n     * Creates a new instance of FSPathResultListImpl\n     */\n    public FSPathResultListImpl() {\n    }\n\n    /**\n     *  A convenience method for defining custom filesystem interaction\n     *  across the whole list of results.\n     *\n     *  This method loops through the results and calls the call(Result result)\n     *  method of the Callback class passed to it for each individual result.\n     *\n     *  @param Callback - a custom implementation of the Callback interface.\n     *  @throws IOException\n     */\n    public FSPathResultList each(Callback callback) throws IOException {\n        for (FSPathResult result : this) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    /**\n     *  Deletes each file contained in this FSPathResultList.\n     *  \u003cbr/\u003e\n     *  \u003cpre\u003e\n     *  ************************************************************************\n     *  *               IMPORTANT !!!!!    Use with caution                    *\n     *  *   This method makes it extremely easy to trash your filesystem       *\n     *  *   Its advised that FSPath queries are tested thouroughly before use  *\n     *  *   in order to verify which files would be deleted                    *\n     *  *                                                                      *\n     *  ************************************************************************\n     *  \u003c/pre\u003e\n     *  @returns FSPathResultModificationListImpl - all successfully deleted files\u003cbr/\u003e\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @throws IOException - NOTE this method does not currently thrown an IOException\n     *  @throws OperationNotPermittedException - this exception will be thrown if\u003cbr/\u003e\n     *  The FSPathResult objects contained in this FSPathResultList don\u0027t contain\u003cbr/\u003e\n     *  java.io.File objects\u003cbr/\u003e\n     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).\n     */\n    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Delete is only permitted on FSPathResult objects containing a File object\");\n        }\n        FSPathResultModificationList deletionList \u003d new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            try {\n                File file \u003d result.getFile();\n                boolean success \u003d file.delete();\n                if (success) {\n                    deletionList.addSuccess(result);\n                } else {\n                    deletionList.addFailure(result);\n                }\n            } catch (Exception e) {\n                //todo: log this ?\n                deletionList.addFailure(result);\n            }\n        }\n        return deletionList;\n    }\n\n    /**\n     *  This method will copy each file contained in this FSPathResultList to the\n     *  destination path supplied.\n     *\n     *  @param String - the destination path which you would like to copy files to.\n     *\n     *  @returns FSPathResultModificationListImpl - all successfully copied files\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @param String the absolute or realtive path of the destination Directory\n     *  @throws IOException - NOTE this is currently not thrown by this method.\n     *  @throws OperationNotPermittedException - this exception is thrown upon\n     *  the following conditions :\u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  1)  The FSPathResult objects contained in this FSPathResultList don\u0027t contain\u003cbr/\u003e\n     *      java.io.File objects\u003cbr/\u003e\n     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).\u003cbr/\u003e\n     *  2)  The directory denoted by the destination path doesn\u0027t exist.\u003cbr/\u003e\n     *  3)  The destination path doesn\u0027t resolve to a directory.\u003cbr/\u003e\n     *  4)  The destination path isn\u0027t writeable.\u003cbr/\u003e\n     *  5)  The current java process doesn\u0027t have sufficient priveledges to\u003cbr/\u003e\n     *      access the destination path.\u003cbr/\u003e\n     */\n    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        File destinationDir \u003d new File(destinationDirPath);\n        try {\n            if (!destinationDir.exists()) {\n                throw new OperationNotPermittedException(\"Unable to copy to a directory that doesn\u0027t exist\");\n            }\n            if (!destinationDir.isDirectory()) {\n                throw new OperationNotPermittedException(\"Destination path \" + destinationDir.getAbsolutePath() + \" does not resolve to a directory\");\n            }\n            if (!destinationDir.canWrite()) {\n                throw new OperationNotPermittedException(\"Desination path \" + destinationDir.getAbsolutePath() + \" is not writable\");\n            }\n        } catch (SecurityException se) {\n            throw new OperationNotPermittedException(\"The current process does not have sufficent priveledges to access \" + destinationDir.getAbsolutePath(), se);\n        }\n        FSPathResultModificationList results \u003d new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File destinationFile \u003d new File(destinationDir + result.getFile().getName());\n            try {\n                FileReader inputReader \u003d new FileReader(result.getFile());\n                FileWriter outputReader \u003d new FileWriter(destinationFile);\n                int charsRead \u003d 0;\n                while ((charsRead \u003d inputReader.read()) !\u003d -1) {\n                    outputReader.write(charsRead);\n                }\n                inputReader.close();\n                outputReader.close();\n                results.addSuccess(new FSPathResult(destinationFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(destinationFile));\n            }\n        }\n        return results;\n    }\n\n    public boolean isListOfFiles() {\n        return (this.size() \u003e 0 \u0026\u0026 this.get(0).getFile() !\u003d null);\n    }\n\n    /**\n     *  Renames each file in the FSPathResultList based on a regex match\n     *  expression and a replace expression.\n     *  \u003cbr/\u003e\n     *  This method is designed to enable simple renaming i.e. renaming from\u003cbr/\u003e\n     *  \"a.txt\" to \"b.txt\" but also complex renaming using regular expressions.\u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  Example simple renaming : \u003cbr/\u003e\n     *  \u003cpre\u003efspath.query(\"/dir[@name\u003d\u0027logs\u0027]/file[@name\u003d\u0027error.log\u0027]\").rename(\"error.log\", \"error.log.1\");\u003c/pre\u003e \u003cbr/\u003e\n     *  This would work fine for a single file but not much use for multiple files.\u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  Example complex renaming : \u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  Imagine a directory full of files with a format such as : \u003cbr/\u003e\n     *  \u003cpre\u003e\n     *  appLog-01_01_2008.log.1\n     *  appLog-01_01_2008.log.2\n     *  ...\n     *  \u003c/pre\u003e\n     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their\u003cbr/\u003e\n     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)\u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  The following code expression would work :\u003cbr/\u003e\n     *  \u003cpre\u003efspath.query(\"dir[@name \u003d \u0027logs\u0027]/file\").rename(\"(.*)\\.log\\.([0-9]+)\", \"$1_$2.log\");\u003c/pre\u003e \u003cbr/\u003e\n     *  Here the matchExpression has two capturing groups, one being everything up to the \u0027.log\u0027 in the filename, \u003cbr/\u003e\n     *  and the other being the number after the \".log.\" .\u003cbr/\u003e\n     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,\u003cbr/\u003e\n     *  followed by a \"_\" then the text in the second capturing group and then \".log\".\n     */\n    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        Pattern pattern \u003d Pattern.compile(matchExpression);\n        FSPathResultModificationList results \u003d new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File origFile \u003d null;\n            File newFile \u003d null;\n            try {\n                origFile \u003d result.getFile();\n                Matcher matcher \u003d pattern.matcher(origFile.getName());\n                String newName \u003d matcher.replaceAll(replaceExpresion);\n                newFile \u003d new File(newName);\n                origFile.renameTo(newFile);\n                results.addSuccess(new FSPathResult(newFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(newFile));\n            }\n        }\n        return results;\n    }\n\n    /**\n     *  Moves each file in the list to the specified desination path.\n     *\n     *  This method effecively calls copy() and then delete() on itself.\n     *  If any file fails to sucessfully copy, then this method \u0027fails fast\u0027\n     *  and returns the results of the copy. This should prevent the situation arising\n     *  where the copied files are completely deleted.\n     *  If the copy suceeds, then it will attempt to delete the original files.\n     *\n     *  @param String - the directory path to move the files to.\n     *  @throws OperationNotPermittedException - see the comments for \u003ccode\u003ecopy\u003c/code\u003e\n     */\n    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"move is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        FSPathResultModificationList copyResults \u003d this.copy(destinationPath);\n        //if we detect a failure then cease what we\u0027re doing and return the results so far\n        if (copyResults.hasFailures()) {\n            return copyResults;\n        }\n        //if we\u0027re happy with the copy, delete the original files,\n        //and return the results of the deletion\n        return this.delete();\n    }\n}\n",
    "package": "net.sf.sugar.fspath",
    "classname": "FSPathResultListImpl",
    "id": "/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_0Test.java",
    "test_prompt": "// FSPathResultListImpl_0Test.java\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultListImpl#each(Callback)} method.\n*/\nclass FSPathResultListImpl_0Test {",
    "method_signature": "each(Callback)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// FSPathResultListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultListImpl extends ArrayList\u003cFSPathResult\u003e implements FSPathResultList {\n\n    /**\n     * Creates a new instance of FSPathResultListImpl\n     */\n    public FSPathResultListImpl() {\n    }\n\n    /**\n     *  A convenience method for defining custom filesystem interaction\n     *  across the whole list of results.\n     *\n     *  This method loops through the results and calls the call(Result result)\n     *  method of the Callback class passed to it for each individual result.\n     *\n     *  @param Callback - a custom implementation of the Callback interface.\n     *  @throws IOException\n     */\n    public FSPathResultList each(Callback callback) throws IOException {\n        for (FSPathResult result : this) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    /**\n     *  Deletes each file contained in this FSPathResultList.\n     *  \u003cbr/\u003e\n     *  \u003cpre\u003e\n     *  ************************************************************************\n     *  *               IMPORTANT !!!!!    Use with caution                    *\n     *  *   This method makes it extremely easy to trash your filesystem       *\n     *  *   Its advised that FSPath queries are tested thouroughly before use  *\n     *  *   in order to verify which files would be deleted                    *\n     *  *                                                                      *\n     *  ************************************************************************\n     *  \u003c/pre\u003e\n     *  @returns FSPathResultModificationListImpl - all successfully deleted files\u003cbr/\u003e\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @throws IOException - NOTE this method does not currently thrown an IOException\n     *  @throws OperationNotPermittedException - this exception will be thrown if\u003cbr/\u003e\n     *  The FSPathResult objects contained in this FSPathResultList don\u0027t contain\u003cbr/\u003e\n     *  java.io.File objects\u003cbr/\u003e\n     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).\n     */\n    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Delete is only permitted on FSPathResult objects containing a File object\");\n        }\n        FSPathResultModificationList deletionList \u003d new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            try {\n                File file \u003d result.getFile();\n                boolean success \u003d file.delete();\n                if (success) {\n                    deletionList.addSuccess(result);\n                } else {\n                    deletionList.addFailure(result);\n                }\n            } catch (Exception e) {\n                //todo: log this ?\n                deletionList.addFailure(result);\n            }\n        }\n        return deletionList;\n    }\n\n    /**\n     *  This method will copy each file contained in this FSPathResultList to the\n     *  destination path supplied.\n     *\n     *  @param String - the destination path which you would like to copy files to.\n     *\n     *  @returns FSPathResultModificationListImpl - all successfully copied files\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @param String the absolute or realtive path of the destination Directory\n     *  @throws IOException - NOTE this is currently not thrown by this method.\n     *  @throws OperationNotPermittedException - this exception is thrown upon\n     *  the following conditions :\u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  1)  The FSPathResult objects contained in this FSPathResultList don\u0027t contain\u003cbr/\u003e\n     *      java.io.File objects\u003cbr/\u003e\n     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).\u003cbr/\u003e\n     *  2)  The directory denoted by the destination path doesn\u0027t exist.\u003cbr/\u003e\n     *  3)  The destination path doesn\u0027t resolve to a directory.\u003cbr/\u003e\n     *  4)  The destination path isn\u0027t writeable.\u003cbr/\u003e\n     *  5)  The current java process doesn\u0027t have sufficient priveledges to\u003cbr/\u003e\n     *      access the destination path.\u003cbr/\u003e\n     */\n    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        File destinationDir \u003d new File(destinationDirPath);\n        try {\n            if (!destinationDir.exists()) {\n                throw new OperationNotPermittedException(\"Unable to copy to a directory that doesn\u0027t exist\");\n            }\n            if (!destinationDir.isDirectory()) {\n                throw new OperationNotPermittedException(\"Destination path \" + destinationDir.getAbsolutePath() + \" does not resolve to a directory\");\n            }\n            if (!destinationDir.canWrite()) {\n                throw new OperationNotPermittedException(\"Desination path \" + destinationDir.getAbsolutePath() + \" is not writable\");\n            }\n        } catch (SecurityException se) {\n            throw new OperationNotPermittedException(\"The current process does not have sufficent priveledges to access \" + destinationDir.getAbsolutePath(), se);\n        }\n        FSPathResultModificationList results \u003d new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File destinationFile \u003d new File(destinationDir + result.getFile().getName());\n            try {\n                FileReader inputReader \u003d new FileReader(result.getFile());\n                FileWriter outputReader \u003d new FileWriter(destinationFile);\n                int charsRead \u003d 0;\n                while ((charsRead \u003d inputReader.read()) !\u003d -1) {\n                    outputReader.write(charsRead);\n                }\n                inputReader.close();\n                outputReader.close();\n                results.addSuccess(new FSPathResult(destinationFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(destinationFile));\n            }\n        }\n        return results;\n    }\n\n    public boolean isListOfFiles() {\n        return (this.size() \u003e 0 \u0026\u0026 this.get(0).getFile() !\u003d null);\n    }\n\n    /**\n     *  Renames each file in the FSPathResultList based on a regex match\n     *  expression and a replace expression.\n     *  \u003cbr/\u003e\n     *  This method is designed to enable simple renaming i.e. renaming from\u003cbr/\u003e\n     *  \"a.txt\" to \"b.txt\" but also complex renaming using regular expressions.\u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  Example simple renaming : \u003cbr/\u003e\n     *  \u003cpre\u003efspath.query(\"/dir[@name\u003d\u0027logs\u0027]/file[@name\u003d\u0027error.log\u0027]\").rename(\"error.log\", \"error.log.1\");\u003c/pre\u003e \u003cbr/\u003e\n     *  This would work fine for a single file but not much use for multiple files.\u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  Example complex renaming : \u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  Imagine a directory full of files with a format such as : \u003cbr/\u003e\n     *  \u003cpre\u003e\n     *  appLog-01_01_2008.log.1\n     *  appLog-01_01_2008.log.2\n     *  ...\n     *  \u003c/pre\u003e\n     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their\u003cbr/\u003e\n     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)\u003cbr/\u003e\n     *  \u003cbr/\u003e\n     *  The following code expression would work :\u003cbr/\u003e\n     *  \u003cpre\u003efspath.query(\"dir[@name \u003d \u0027logs\u0027]/file\").rename(\"(.*)\\.log\\.([0-9]+)\", \"$1_$2.log\");\u003c/pre\u003e \u003cbr/\u003e\n     *  Here the matchExpression has two capturing groups, one being everything up to the \u0027.log\u0027 in the filename, \u003cbr/\u003e\n     *  and the other being the number after the \".log.\" .\u003cbr/\u003e\n     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,\u003cbr/\u003e\n     *  followed by a \"_\" then the text in the second capturing group and then \".log\".\n     */\n    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        Pattern pattern \u003d Pattern.compile(matchExpression);\n        FSPathResultModificationList results \u003d new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File origFile \u003d null;\n            File newFile \u003d null;\n            try {\n                origFile \u003d result.getFile();\n                Matcher matcher \u003d pattern.matcher(origFile.getName());\n                String newName \u003d matcher.replaceAll(replaceExpresion);\n                newFile \u003d new File(newName);\n                origFile.renameTo(newFile);\n                results.addSuccess(new FSPathResult(newFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(newFile));\n            }\n        }\n        return results;\n    }\n\n    /**\n     *  Moves each file in the list to the specified desination path.\n     *\n     *  This method effecively calls copy() and then delete() on itself.\n     *  If any file fails to sucessfully copy, then this method \u0027fails fast\u0027\n     *  and returns the results of the copy. This should prevent the situation arising\n     *  where the copied files are completely deleted.\n     *  If the copy suceeds, then it will attempt to delete the original files.\n     *\n     *  @param String - the directory path to move the files to.\n     *  @throws OperationNotPermittedException - see the comments for \u003ccode\u003ecopy\u003c/code\u003e\n     */\n    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"move is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        FSPathResultModificationList copyResults \u003d this.copy(destinationPath);\n        //if we detect a failure then cease what we\u0027re doing and return the results so far\n        if (copyResults.hasFailures()) {\n            return copyResults;\n        }\n        //if we\u0027re happy with the copy, delete the original files,\n        //and return the results of the deletion\n        return this.delete();\n    }\n}\n",
    "package": "net.sf.sugar.fspath",
    "classname": "FSPathResultListImpl",
    "id": "/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_1Test.java",
    "test_prompt": "// FSPathResultListImpl_1Test.java\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultListImpl#delete()} method.\n*/\nclass FSPathResultListImpl_1Test {",
    "method_signature": "delete()",
    "suffix": "1"
  }
]