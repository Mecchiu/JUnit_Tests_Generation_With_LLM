[
  {
    "numberTests": "ten",
    "original_code": "// ModifyApprovalQueueEntryAction.java\npackage org.heal.servlet.approver;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Modifies an approval queue entry.\n *\n * @author Brad Schaefer (\u003cA HREF\u003d\"mailto:schaefer@lib.med.utah.edu\"\u003eschaefer@lib.med.utah.edu\u003c/A\u003e)\n */\npublic class ModifyApprovalQueueEntryAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        final String approvalQueueEntryId \u003d request.getParameter(\"approvalQueueEntryId\");\n        final String status \u003d request.getParameter(\"status\");\n        if (false \u003d\u003d AuthenticationTools.isApprover(request) || null \u003d\u003d approvalQueueEntryId || null \u003d\u003d status) {\n            // The user does not have the access to view this page\n            // or an Approval Queue entry id or status is missing\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        // Creates an QueuedRecordBean based on the form data\n        final QueuedRecordBean approvalEntry \u003d new QueuedRecordBean();\n        approvalEntry.setQueuedRecordId(approvalQueueEntryId);\n        approvalEntry.setComments(request.getParameter(\"comment\"));\n        approvalEntry.getShortMetadata().setMetadataId(request.getParameter(\"metadataId\"));\n        approvalEntry.setStatus(status);\n        final QueueDAO queueManager \u003d (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n        final String statusTest \u003d status.toLowerCase();\n        if (\"waiting\".equals(statusTest)) {\n            // If the status is \u0027waiting\u0027, then we just save the approval queue entry\n            approvalEntry.setType(QueueDAO.TYPE_APPROVAL);\n            queueManager.saveQueuedRecord(approvalEntry);\n        } else if (\"approved\".equals(statusTest)) {\n            approvalEntry.setType(QueueDAO.TYPE_CATALOG);\n            approvalEntry.setStatus(\"Waiting\");\n            queueManager.markRecordApproved(approvalEntry.getShortMetadata().getMetadataId());\n            queueManager.saveQueuedRecord(approvalEntry);\n        } else if (\"rejected\".equals(statusTest)) {\n            // If the status is \u0027rejected\u0027, we mark it as such in the database\n            queueManager.rejectRecord(approvalEntry.getShortMetadata().getMetadataId());\n            queueManager.dequeue(approvalEntry.getQueuedRecordId());\n        }\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        response.sendRedirect(\"showApprovalQueue\");\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.approver",
    "classname": "ModifyApprovalQueueEntryAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/approver/ModifyApprovalQueueEntryAction.java",
    "test_prompt": "// ModifyApprovalQueueEntryActionTest.java\npackage org.heal.servlet.approver;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyApprovalQueueEntryAction}.\n* It contains ten unit test cases for the {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.\n*/\nclass ModifyApprovalQueueEntryActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// ShowApprovalQueueAction.java\npackage org.heal.servlet.approver;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * An {@link org.heal.servlet.Action} which fetches the information needed to\n * display the approval queue.\n *\n * @author Brad Schaefer (\u003cA HREF\u003d\"mailto:schaefer@lib.med.utah.edu\"\u003eschaefer@lib.med.utah.edu\u003c/A\u003e)\n */\npublic class ShowApprovalQueueAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (false \u003d\u003d AuthenticationTools.isApprover(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final QueueDAO queueManager \u003d (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n        final List queue \u003d queueManager.getApprovalQueue();\n        request.setAttribute(\"approvalQueue\", queue);\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/approval/viewqueue.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.approver",
    "classname": "ShowApprovalQueueAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/approver/ShowApprovalQueueAction.java",
    "test_prompt": "// ShowApprovalQueueActionTest.java\npackage org.heal.servlet.approver;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowApprovalQueueAction}.\n* It contains ten unit test cases for the {@link ShowApprovalQueueAction#actionRequiresLogin()} method.\n*/\nclass ShowApprovalQueueActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// EditContextURLAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * An {@link Action} which is called to edit a Context URL.  If\n * there isn\u0027t an existing Context URL which can be found to edit,\n * we assume that a new Context URL should be edited.\n */\npublic class EditContextURLAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should\u0027ve been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb \u003d (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId \u003d request.getParameter(\"selectedId\");\n        // This shouldn\u0027t be necessary, but it won\u0027t hurt to check\n        if (null \u003d\u003d cmb || null \u003d\u003d selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        ContextURLBean cubToEdit \u003d new ContextURLBean();\n        for (Iterator iter \u003d cmb.getContextURLs().iterator(); iter.hasNext(); ) {\n            ContextURLBean testCub \u003d (ContextURLBean) iter.next();\n            if (testCub.getContextURLId().equals(selectedId)) {\n                cubToEdit \u003d testCub;\n                break;\n            }\n        }\n        request.setAttribute(\"ContextURLBean\", cubToEdit);\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/catalog/editContextURL.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "EditContextURLAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditContextURLAction.java",
    "test_prompt": "// EditContextURLActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditContextURLAction}.\n* It contains ten unit test cases for the {@link EditContextURLAction#actionRequiresLogin()} method.\n*/\nclass EditContextURLActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// ModifyMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * \u003cp\u003eAn {@link Action} that saves the metadata from a form into\n * the session\u0027s {@link CompleteMetadataBean} by mapping {@link MetadataModifier}s\n * to forms.  The {@link MetadataModifier} which matches the form determines\n * the next {@link Action} to execute.\u003c/p\u003e\n *\n * \u003cp\u003eThe mapping is currently defined as:\u003c/p\u003e\n *\n * \u003cul\u003e\u003cli\u003e\u0027metadata\u0027 : {@link MetadataRecordModifier}\n * \u003cli\u003e\u0027contextURL\u0027 : {@link ContextURLRecordModifier}\n * \u003cli\u003e\u0027contributor\u0027 : {@link ContributorRecordModifier}\n * \u003cli\u003e\u0027copyrightHolder\u0027 : {@link CopyrightHolderRecordModifier}\n * \u003cli\u003e\u0027controlledVocabulary\u0027 : {@link ControlledVocabularyRecordModifier}\n * \u003cli\u003e\u0027requirement\u0027 : {@link RequirementRecordModifier}\n * \u003c/ul\u003e\n */\npublic class ModifyMetadataAction implements Action {\n\n    private final Map modifierMap;\n\n    public ModifyMetadataAction() {\n        // Initializes the action map\n        Map modifierMap \u003d new HashMap();\n        modifierMap.put(\"metadata\", new MetadataRecordModifier());\n        modifierMap.put(\"contextURL\", new ContextURLRecordModifier());\n        modifierMap.put(\"contributor\", new ContributorRecordModifier());\n        modifierMap.put(\"copyrightHolder\", new CopyrightHolderRecordModifier());\n        modifierMap.put(\"controlledVocabulary\", new ControlledVocabularyRecordModifier());\n        modifierMap.put(\"requirement\", new RequirementRecordModifier());\n        modifierMap.put(\"relation\", new RelationRecordModifier());\n        modifierMap.put(\"metametadataIdentifier\", new MetametadataIdentifierRecordModifier());\n        modifierMap.put(\"metametadataContributor\", new MetametadataContributorRecordModifier());\n        // This guarantees that the action map will not be modified after initialization\n        this.modifierMap \u003d Collections.unmodifiableMap(modifierMap);\n    }\n\n    /**\n     * \u003cp\u003eThis perform method uses the \u003ccode\u003e\"type\"\u003c/code\u003e parameter to save the\n     * metadata modifications from the \u003ccode\u003erequest\u003c/code\u003e in the\n     * {@link CompleteMetadataBean} that is in the session.  If the type or\n     * \u003ccode\u003eCompleteMetadataBean\u003c/code\u003e doesn\u0027t exist, the \u003ccode\u003eresponse\u003c/code\u003e is\n     * redirected to an error page.\u003c/o\u003e\n     *\n     * \u003cp\u003eWhen a valid type and a \u003ccode\u003eCompleteMetadataBean\u003c/code\u003e is available\n     * in the session, this method uses the appropriate {@link MetadataModifier}\n     * to save the motifications to the metadata and to perform the subsequent\n     * {@link Action}.\u003c/p\u003e\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final String modifierKey \u003d request.getParameter(\"type\");\n        final CompleteMetadataBean cmb \u003d (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        if (null \u003d\u003d cmb || !modifierMap.containsKey(modifierKey)) {\n            // Not enough information in the form and/or session to process this request\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final MetadataModifier modifier \u003d (MetadataModifier) modifierMap.get(modifierKey);\n        modifier.updateMetadata(cmb, request);\n        Action nextAction \u003d modifier.getNextAction(request);\n        nextAction.perform(servlet, request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "ModifyMetadataAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyMetadataAction.java",
    "test_prompt": "// ModifyMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyMetadataAction}.\n* It contains ten unit test cases for the {@link ModifyMetadataAction#actionRequiresLogin()} method.\n*/\nclass ModifyMetadataActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// SaveMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Iterator;\n\n/**\n * An {@link org.heal.servlet.Action Action} used to save metadata\n * records.\n */\npublic class SaveMetadataAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should\u0027ve been done by ModifyMetadataAction\n        final CompleteMetadataBean metadata \u003d (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        // This shouldn\u0027t be necessary, but it won\u0027t hurt to check\n        if (null \u003d\u003d metadata) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        // Makes a best effort to prevent the session metadata object from\n        // being changed and then having a stale edit metadata form submitted,\n        // which would save bad data\n        final String metadataId \u003d metadata.getMetadataId();\n        final String formMetadataId \u003d request.getParameter(\"metadataId\");\n        if (!(null \u003d\u003d metadataId \u0026\u0026 0 \u003d\u003d formMetadataId.length()) \u0026\u0026 !formMetadataId.equals(metadataId)) {\n            request.setAttribute(\"reason\", \"Session metadataId doesn\u0027t match metadataId submitted with form.\");\n            RequestDispatcher rd \u003d request.getRequestDispatcher(\"/error/accessDenied.jsp\");\n            rd.forward(request, response);\n            return;\n        }\n        final MetadataDAO metadataServices \u003d (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        scrubMetadata(metadata);\n        try {\n            metadataServices.saveEditMetadataForm(metadata);\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n        if (null \u003d\u003d metadataId) {\n            // This is a new record, so we add it to the approval queue\n            final QueueDAO queueManager \u003d (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n            queueManager.enqueue(QueueDAO.TYPE_APPROVAL, metadata.getMetadataId());\n        }\n        request.getSession().setAttribute(\"metadata\", null);\n        response.sendRedirect(\"showMetadata?metadataId\u003d\" + metadata.getMetadataId());\n    }\n\n    /**\n     * Since we have been using negative numbers to give unique id\u0027s to\n     * complicated metadata information, this method will turn all those\n     * negative ids back to \u003ccode\u003enull\u003c/code\u003e values so that the metadata\n     * gets saved correctly.\n     *\n     * @param cmb The {@link CompleteMetadataBean} to scrub.\n     */\n    private void scrubMetadata(CompleteMetadataBean cmb) {\n        // scrubs Context URLs\n        for (Iterator iter \u003d cmb.getContextURLs().iterator(); iter.hasNext(); ) {\n            final ContextURLBean cub \u003d (ContextURLBean) iter.next();\n            final String cubId \u003d cub.getContextURLId();\n            if (null !\u003d cubId \u0026\u0026 0 \u003e Integer.parseInt(cubId)) {\n                cub.setContextURLId(null);\n            }\n        }\n        // scrubs Contributors\n        for (Iterator iter \u003d cmb.getContributorList().iterator(); iter.hasNext(); ) {\n            final ContributorBean cb \u003d (ContributorBean) iter.next();\n            final String cbId \u003d cb.getContributorId();\n            if (null !\u003d cbId \u0026\u0026 0 \u003e Integer.parseInt(cbId)) {\n                cb.setContributorId(null);\n            }\n        }\n        // scrubs Controlled Vocab\n        for (Iterator iterOne \u003d cmb.getTaxonPaths().iterator(); iterOne.hasNext(); ) {\n            final TaxonPathBean tpb \u003d (TaxonPathBean) iterOne.next();\n            final String tpbId \u003d tpb.getTaxonPathId();\n            if (null !\u003d tpbId \u0026\u0026 0 \u003e Integer.parseInt(tpbId)) {\n                tpb.setTaxonPathId(null);\n            }\n            for (Iterator iterTwo \u003d tpb.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                final TaxonBean tb \u003d (TaxonBean) iterTwo.next();\n                final String tbId \u003d tb.getTaxonId();\n                if (null !\u003d tbId \u0026\u0026 0 \u003e Integer.parseInt(tbId)) {\n                    tb.setTaxonId(null);\n                }\n            }\n        }\n        // scrubs Copyright holders\n        for (Iterator iter \u003d cmb.getCopyrightHolders().iterator(); iter.hasNext(); ) {\n            final CopyrightHolderBean chb \u003d (CopyrightHolderBean) iter.next();\n            final String chbId \u003d chb.getCopyrightHolderId();\n            if (null !\u003d chbId \u0026\u0026 0 \u003e Integer.parseInt(chbId)) {\n                chb.setCopyrightHolderId(null);\n            }\n        }\n        // scrubs metametadata identifiers\n        for (Object o : cmb.getMetametadataIdentifiers()) {\n            final MetametadataIdentifierBean mib \u003d (MetametadataIdentifierBean) o;\n            final String mibId \u003d mib.getMetametadataIdentifierId();\n            if (null !\u003d mibId \u0026\u0026 0 \u003e Integer.parseInt(mibId)) {\n                mib.setMetametadataIdentifierId(null);\n            }\n        }\n        // scrubs metametadata contributors\n        for (Object o : cmb.getMetametadataContributors()) {\n            final MetametadataContributorBean mcb \u003d (MetametadataContributorBean) o;\n            final String mcbId \u003d mcb.getMetametadataContributorId();\n            if (null !\u003d mcbId \u0026\u0026 0 \u003e Integer.parseInt(mcbId)) {\n                mcb.setMetametadataContributorId(null);\n            }\n        }\n        // scrubs requirements\n        for (Iterator iter \u003d cmb.getRequirements().iterator(); iter.hasNext(); ) {\n            final RequirementBean rb \u003d (RequirementBean) iter.next();\n            final String rbId \u003d rb.getRequirementId();\n            if (null !\u003d rbId \u0026\u0026 0 \u003e Integer.parseInt(rbId)) {\n                rb.setRequirementId(null);\n            }\n        }\n        // scrubs relations\n        for (Iterator iter \u003d cmb.getRelations().iterator(); iter.hasNext(); ) {\n            final RelationBean rb \u003d (RelationBean) iter.next();\n            final String rbId \u003d rb.getRelationId();\n            if (null !\u003d rbId \u0026\u0026 0 \u003e Integer.parseInt(rbId)) {\n                rb.setRelationId(null);\n            }\n        }\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "SaveMetadataAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/SaveMetadataAction.java",
    "test_prompt": "// SaveMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SaveMetadataAction}.\n* It contains ten unit test cases for the {@link SaveMetadataAction#actionRequiresLogin()} method.\n*/\nclass SaveMetadataActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// CreateMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.sql.SQLException;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * An {@link Action} which creates a new metadata record to edit,\n * puts it into the session, and then directs the user to the editing\n * page.\n */\npublic class CreateMetadataAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final HttpSession session \u003d request.getSession();\n        CompleteMetadataBean cmb \u003d (CompleteMetadataBean) session.getAttribute(\"metadata\");\n        if (null !\u003d cmb) {\n            response.sendRedirect(\"../catalog/concurrentMetadataEditError.jsp\");\n            return;\n        }\n        final String metadataId \u003d request.getParameter(\"basedOnMetadataId\");\n        if (null \u003d\u003d metadataId) {\n            cmb \u003d new CompleteMetadataBean();\n        } else {\n            final MetadataDAO metadataServices \u003d (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n            try {\n                cmb \u003d metadataServices.getCompleteMetadata(metadataId);\n            } catch (SQLException e) {\n                throw new ServletException(e);\n            }\n            clearIds(cmb);\n            cmb.setLocation(null);\n            cmb.setCatalogDate(null);\n            cmb.setApproveDate(null);\n            if (null !\u003d cmb.getThumbnail()) {\n                cmb.setThumbnail(null);\n            }\n            cmb.setFileSize(null);\n            cmb.setFileHeight(null);\n            cmb.setFileWidth(null);\n        }\n        cmb.setContributeDate(new Date());\n        session.setAttribute(\"metadata\", cmb);\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/healapp/editMetadata\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * Since this {@link Action} creates \u003cem\u003enew\u003c/em\u003e metadata records, we\n     * must clear the ids from an existing {@link CompleteMetadataBean} that\n     * this new record is based on.\n     *\n     * @param cmb\n     */\n    private static void clearIds(CompleteMetadataBean cmb) throws ServletException {\n        cmb.setMetadataId(null);\n        cmb.setGlobalId(null);\n        clearIdsFromList(cmb.getContextURLs());\n        clearIdsFromList(cmb.getContributorList());\n        clearIdsFromList(cmb.getCopyrightHolders());\n        clearIdsFromList(cmb.getCopyrights());\n        clearIdsFromList(cmb.getDiseaseDiagnoses());\n        clearIdsFromList(cmb.getFormats());\n        clearIdsFromList(cmb.getKeywords());\n        clearIdsFromList(cmb.getRelations());\n        clearIdsFromList(cmb.getRequirements());\n        clearIdsFromList(cmb.getTargetUserGroups());\n        // Taxons/TaxonPaths need to be handled a bit differently since\n        // they have an unusual association going on\n        String nextTaxonId \u003d \"-1\";\n        String nextTaxonPathId \u003d \"-1\";\n        for (Iterator iterOne \u003d cmb.getTaxonPaths().iterator(); iterOne.hasNext(); ) {\n            final TaxonPathBean taxonPath \u003d (TaxonPathBean) iterOne.next();\n            taxonPath.setMetadataId(null);\n            taxonPath.setTaxonPathId(nextTaxonPathId);\n            for (Iterator iterTwo \u003d taxonPath.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                final TaxonBean taxon \u003d (TaxonBean) iterTwo.next();\n                taxon.setTaxonId(nextTaxonId);\n                taxon.setTaxonPathId(null);\n                nextTaxonId \u003d String.valueOf(Integer.parseInt(nextTaxonId) - 1);\n            }\n            nextTaxonPathId \u003d String.valueOf(Integer.parseInt(nextTaxonPathId) - 1);\n        }\n    }\n\n    private static void clearIdsFromList(List objects) throws ServletException {\n        Map ids \u003d new HashMap();\n        for (Iterator iter \u003d objects.iterator(); iter.hasNext(); ) {\n            Object ob \u003d iter.next();\n            Method[] methods \u003d ob.getClass().getMethods();\n            for (int i \u003d 0; i \u003c methods.length; ++i) {\n                final String methodName \u003d methods[i].getName();\n                Object[] args \u003d new Object[1];\n                if (\"setMetadataId\".equals(methodName)) {\n                    args[0] \u003d null;\n                } else if (methodName.matches(\"^set.+Id\")) {\n                    String id;\n                    if (!ids.containsKey(methodName)) {\n                        id \u003d \"-1\";\n                    } else {\n                        id \u003d String.valueOf(Integer.parseInt((String) ids.get(methodName)) - 1);\n                    }\n                    args[0] \u003d id;\n                    ids.put(methodName, id);\n                } else {\n                    continue;\n                }\n                Class[] parameters \u003d methods[i].getParameterTypes();\n                if (1 !\u003d parameters.length || !parameters[0].equals(String.class)) {\n                    // Constructs method signature for error message\n                    StringBuffer argString \u003d new StringBuffer(\"(\");\n                    for (int j \u003d 0; j \u003c parameters.length; ++j) {\n                        argString.append(parameters[j].getName());\n                        if (j \u003c parameters.length - 1) {\n                            argString.append(\", \");\n                        }\n                    }\n                    argString.append(\")\");\n                    throw new ServletException(\"Unexpected setXXXId method found: \" + methodName + argString.toString());\n                }\n                try {\n                    methods[i].invoke(ob, args);\n                } catch (Exception e) {\n                    throw new ServletException(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "CreateMetadataAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/CreateMetadataAction.java",
    "test_prompt": "// CreateMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.sql.SQLException;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CreateMetadataAction}.\n* It contains ten unit test cases for the {@link CreateMetadataAction#actionRequiresLogin()} method.\n*/\nclass CreateMetadataActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// ModifyCatalogQueueEntryAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.FileLocator;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.sql.SQLException;\n\n/**\n * An {@link org.heal.servlet.Action Action} which is called in order to edit a metadata item which is in\n * the catalog queue.\n *\n * @author Brad Schaefer (\u003cA HREF\u003d\"mailto:schaefer@lib.med.utah.edu\"\u003eschaefer@lib.med.utah.edu\u003c/A\u003e)\n * @version 1.0\n */\npublic class ModifyCatalogQueueEntryAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        final String catalogQueueEntryId \u003d request.getParameter(\"catalogQueueEntryId\");\n        final String status \u003d request.getParameter(\"status\");\n        if (!AuthenticationTools.isCataloger(request) || null \u003d\u003d catalogQueueEntryId || null \u003d\u003d status) {\n            // The user does not have the access to view this page\n            // or the Catalog Queue entry id or status is missing,\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final String metadataId \u003d request.getParameter(\"metadataId\");\n        final QueueDAO queueManager \u003d (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n        try {\n            final String statusTest \u003d status.toLowerCase();\n            if (\"waiting\".equals(statusTest) || \"incomplete\".equals(statusTest)) {\n                // If the status is \u0027waiting\u0027, or incomplete, we just save the catalog queue entry\n                // Creates an QueuedRecordBean based on the form data\n                final QueuedRecordBean catalogEntry \u003d new QueuedRecordBean();\n                catalogEntry.setQueuedRecordId(catalogQueueEntryId);\n                catalogEntry.setComments(request.getParameter(\"comment\"));\n                catalogEntry.getShortMetadata().setMetadataId(metadataId);\n                catalogEntry.setStatus(status);\n                catalogEntry.setType(QueueDAO.TYPE_CATALOG);\n                queueManager.saveQueuedRecord(catalogEntry);\n            } else if (\"cataloged\".equals(statusTest)) {\n                // If the status is \u0027cataloged\u0027 we mark it as such in the database,\n                // and copy the file to the content directory\n                MetadataDAO metadataServices \u003d (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n                FileLocator fileLocator \u003d (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n                ShortMetadataBean metadata \u003d metadataServices.getShortMetadata(metadataId);\n                queueManager.markRecordCataloged(metadataId);\n                queueManager.dequeue(catalogQueueEntryId);\n                String sourceFile \u003d fileLocator.getUploadFilePath(metadata.getLocation());\n                String destinationFile \u003d fileLocator.getContentFilePath(metadata.getLocation());\n                if (!new File(destinationFile).exists()) {\n                    copyFile(sourceFile, destinationFile);\n                }\n            }\n        } catch (SQLException e) {\n            // TODO logging?\n        }\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        response.sendRedirect(\"showCatalogQueue\");\n    }\n\n    /**\n     * Copies a file from a sourceLocation to a destinationLocation.\n     *\n     * @param sourceLocation\n     * @param destinationLocation\n     */\n    private static void copyFile(String sourceLocation, String destinationLocation) {\n        FileChannel srcChannel \u003d null;\n        FileChannel dstChannel \u003d null;\n        try {\n            // Create channel on the source\n            srcChannel \u003d new FileInputStream(sourceLocation).getChannel();\n            // Create channel on the destination\n            dstChannel \u003d new FileOutputStream(destinationLocation).getChannel();\n            // Copy file contents from source to destination\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // Close the channels\n            if (null !\u003d srcChannel) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e) {\n                }\n            }\n            if (null !\u003d dstChannel) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "ModifyCatalogQueueEntryAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyCatalogQueueEntryAction.java",
    "test_prompt": "// ModifyCatalogQueueEntryActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.FileLocator;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyCatalogQueueEntryAction}.\n* It contains ten unit test cases for the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.\n*/\nclass ModifyCatalogQueueEntryActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// RelationRecordModifier.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Saves changes to a {@link RelationBean} and acts as\n * an {@link Action} which is called to edit a Relation.  If\n * there isn\u0027t an existing Relation which can be found to edit,\n * we assume that a new Relation should be edited.\n */\npublic class RelationRecordModifier implements Action, MetadataModifier {\n\n    private static Action NEXT_ACTION \u003d new EditMetadataAction();\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should\u0027ve been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb \u003d (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId \u003d request.getParameter(\"selectedId\");\n        // This shouldn\u0027t be necessary, but it won\u0027t hurt to check\n        if (null \u003d\u003d cmb || null \u003d\u003d selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        RelationBean rbToEdit \u003d findRelationBean(cmb.getRelations(), selectedId);\n        if (null \u003d\u003d rbToEdit) {\n            rbToEdit \u003d new RelationBean();\n        }\n        request.setAttribute(\"RelationBean\", rbToEdit);\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/catalog/editRelation.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n\n    public void updateMetadata(CompleteMetadataBean cmb, ServletRequest request) {\n        final String relationId \u003d request.getParameter(\"relationId\");\n        final String resource \u003d request.getParameter(\"resource\");\n        final String kind \u003d request.getParameter(\"kind\");\n        final String description \u003d request.getParameter(\"description\");\n        final String catalogue \u003d request.getParameter(\"catalogue\");\n        final String entry \u003d request.getParameter(\"entry\");\n        RelationBean rb \u003d findRelationBean(cmb.getRelations(), relationId);\n        if (null \u003d\u003d rb) {\n            int lowestRelationId \u003d 0;\n            for (Iterator iter \u003d cmb.getRelations().iterator(); iter.hasNext(); ) {\n                final RelationBean temp \u003d (RelationBean) iter.next();\n                final int tempId \u003d Integer.parseInt(temp.getRelationId());\n                if (tempId \u003c lowestRelationId) {\n                    lowestRelationId \u003d tempId;\n                }\n            }\n            rb \u003d new RelationBean();\n            rb.setRelationId(String.valueOf(lowestRelationId - 1));\n            cmb.addRelation(rb);\n        }\n        rb.setResource(resource);\n        rb.setKind(kind);\n        rb.setDescription(description);\n        rb.setCatalogue(catalogue);\n        rb.setEntry(entry);\n    }\n\n    public Action getNextAction(ServletRequest request) {\n        return NEXT_ACTION;\n    }\n\n    private RelationBean findRelationBean(final List relations, final String relationId) {\n        RelationBean ret \u003d null;\n        for (Iterator iter \u003d relations.iterator(); iter.hasNext(); ) {\n            RelationBean temp \u003d (RelationBean) iter.next();\n            if ((null \u003d\u003d relationId \u0026\u0026 null \u003d\u003d temp.getRelationId()) || (null !\u003d relationId \u0026\u0026 relationId.equals(temp.getRelationId()))) {\n                ret \u003d temp;\n            }\n        }\n        return ret;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "RelationRecordModifier",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/RelationRecordModifier_0Test.java",
    "test_prompt": "// RelationRecordModifier_0Test.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RelationRecordModifier}.\n* It contains ten unit test cases for the {@link RelationRecordModifier#actionRequiresLogin()} method.\n*/\nclass RelationRecordModifier_0Test {",
    "method_signature": "actionRequiresLogin()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// CancelEditMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\n\n/**\n * A simple {@link Action} which clears the session variable used\n * for editing metadata.\n */\npublic class CancelEditMetadataAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        HttpSession session \u003d request.getSession(false);\n        if (null !\u003d session) {\n            session.removeAttribute(\"metadata\");\n        }\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/catalog/editCancelled.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003efalse\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "CancelEditMetadataAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/CancelEditMetadataAction.java",
    "test_prompt": "// CancelEditMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CancelEditMetadataAction}.\n* It contains ten unit test cases for the {@link CancelEditMetadataAction#actionRequiresLogin()} method.\n*/\nclass CancelEditMetadataActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// EditControlledVocabularyAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * An {@link Action} which is called to edit a Controlled Vocabulary item.  If\n * there isn\u0027t an existing Controlled Vocabulary item which can be found to edit,\n * we assume that a new Controlled Vocabulary entry should be edited.\n */\npublic class EditControlledVocabularyAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should\u0027ve been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb \u003d (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId \u003d request.getParameter(\"selectedId\");\n        // This shouldn\u0027t be necessary, but it won\u0027t hurt to check\n        if (null \u003d\u003d cmb || null \u003d\u003d selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        TaxonBean taxonToEdit \u003d new TaxonBean();\n        TaxonPathBean taxonPathToEdit \u003d new TaxonPathBean();\n        if (null !\u003d selectedId \u0026\u0026 0 \u003c selectedId.length()) {\n            for (Iterator iterOne \u003d cmb.getTaxonPaths().iterator(); iterOne.hasNext(); ) {\n                final TaxonPathBean tempTaxonPath \u003d (TaxonPathBean) iterOne.next();\n                for (Iterator iterTwo \u003d tempTaxonPath.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                    final TaxonBean tempTaxon \u003d (TaxonBean) iterTwo.next();\n                    if (tempTaxon.getTaxonId().equals(selectedId)) {\n                        taxonToEdit \u003d tempTaxon;\n                        taxonPathToEdit \u003d tempTaxonPath;\n                    }\n                }\n            }\n        }\n        request.setAttribute(\"TaxonBean\", taxonToEdit);\n        request.setAttribute(\"TaxonPathBean\", taxonPathToEdit);\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/catalog/editControlledVocabulary.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "EditControlledVocabularyAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditControlledVocabularyAction.java",
    "test_prompt": "// EditControlledVocabularyActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditControlledVocabularyAction}.\n* It contains ten unit test cases for the {@link EditControlledVocabularyAction#actionRequiresLogin()} method.\n*/\nclass EditControlledVocabularyActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// MetadataRecordModifier.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.DateTools;\nimport javax.servlet.ServletRequest;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * \u003cp\u003eA {@link MetadataModifier} which fills the basic metadata information\n * from a \u003ccode\u003eServletRequest\u003c/code\u003e into a {@link CompleteMetadataBean}.\u003c/p\u003e\n */\npublic class MetadataRecordModifier implements MetadataModifier {\n\n    private static final Map nextActionMap;\n\n    private static final Action NEXT_ACTION_DEFAULT \u003d new EditMetadataAction();\n\n    static {\n        Map temp \u003d new HashMap();\n        temp.put(\"editContextURL\", new EditContextURLAction());\n        temp.put(\"editContributor\", new EditContributorAction());\n        temp.put(\"editCopyrightHolder\", new EditCopyrightHolderAction());\n        temp.put(\"editControlledVocab\", new EditControlledVocabularyAction());\n        temp.put(\"editRequirement\", new EditRequirementAction());\n        temp.put(\"editRelation\", new RelationRecordModifier());\n        temp.put(\"editMetametadataIdentifier\", new MetametadataIdentifierRecordModifier());\n        temp.put(\"editMetametadataContributor\", new MetametadataContributorRecordModifier());\n        temp.put(\"saveMetadata\", new SaveMetadataAction());\n        nextActionMap \u003d Collections.unmodifiableMap(temp);\n    }\n\n    public MetadataRecordModifier() {\n    }\n\n    public void updateMetadata(CompleteMetadataBean cmb, ServletRequest request) {\n        // Fills the complete metadata bean with the form information\n        cmb.setAnnotated(request.getParameter(\"annotated\"));\n        cmb.setApproveDate(DateTools.parse(request.getParameter(\"approveDate\")));\n        cmb.setArchived(request.getParameter(\"archived\"));\n        cmb.setCatalogDate(DateTools.parse(request.getParameter(\"catalogDate\")));\n        cmb.setClinicalHistory(request.getParameter(\"clinicalHistory\"));\n        // Removes any deleted Context URLs\n        List oldContextURLs \u003d cmb.getContextURLs();\n        ArrayList updatedContextURLs \u003d new ArrayList();\n        String[] contextURLs \u003d request.getParameterValues(\"contextURLs\");\n        if (null !\u003d contextURLs) {\n            for (int i \u003d 0; i \u003c contextURLs.length; ++i) {\n                final String contextURLId \u003d contextURLs[i];\n                for (Iterator iter \u003d oldContextURLs.iterator(); iter.hasNext(); ) {\n                    ContextURLBean cub \u003d (ContextURLBean) iter.next();\n                    if (cub.getContextURLId().equals(contextURLId)) {\n                        updatedContextURLs.add(cub);\n                        break;\n                    }\n                }\n            }\n        }\n        cmb.setContextURLs(updatedContextURLs);\n        cmb.setContributeDate(DateTools.parse(request.getParameter(\"contributeDate\")));\n        // Removes any deleted Contributors\n        List oldContributors \u003d cmb.getContributorList();\n        cmb.setContributors(new TreeMap());\n        String[] contributors \u003d request.getParameterValues(\"contributors\");\n        if (null !\u003d contributors) {\n            for (int i \u003d 0; i \u003c contributors.length; ++i) {\n                final String contributorId \u003d contributors[i];\n                for (Iterator iter \u003d oldContributors.iterator(); iter.hasNext(); ) {\n                    ContributorBean cb \u003d (ContributorBean) iter.next();\n                    if (cb.getContributorId().equals(contributorId)) {\n                        cmb.addContributor(cb);\n                        break;\n                    }\n                }\n            }\n        }\n        // Removes any deleted Copyright Holders\n        List oldCopyrightHolders \u003d cmb.getCopyrightHolders();\n        cmb.setCopyrightHolders(new ArrayList());\n        String[] copyrightHolders \u003d request.getParameterValues(\"copyrightHolders\");\n        if (null !\u003d copyrightHolders) {\n            for (int i \u003d 0; i \u003c copyrightHolders.length; ++i) {\n                final String copyrightHolderId \u003d copyrightHolders[i];\n                for (Iterator iter \u003d oldCopyrightHolders.iterator(); iter.hasNext(); ) {\n                    CopyrightHolderBean chb \u003d (CopyrightHolderBean) iter.next();\n                    if (chb.getCopyrightHolderId().equals(copyrightHolderId)) {\n                        cmb.addCopyrightHolder(chb);\n                        break;\n                    }\n                }\n            }\n        }\n        // Removes any deleted Controlled Vocabulary items\n        List oldTaxonPaths \u003d cmb.getTaxonPaths();\n        cmb.setTaxonPaths(new ArrayList());\n        String[] taxons \u003d request.getParameterValues(\"controlledVocab\");\n        if (null !\u003d taxons) {\n            for (Iterator iterOne \u003d oldTaxonPaths.iterator(); iterOne.hasNext(); ) {\n                final TaxonPathBean taxonPath \u003d (TaxonPathBean) iterOne.next();\n                SortedSet taxonSet \u003d new TreeSet();\n                for (Iterator iterTwo \u003d taxonPath.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                    final TaxonBean taxon \u003d (TaxonBean) iterTwo.next();\n                    for (int i \u003d 0; i \u003c taxons.length; ++i) {\n                        final String taxonId \u003d taxons[i];\n                        if (taxonId.equals(taxon.getTaxonId())) {\n                            taxonSet.add(taxon);\n                            break;\n                        }\n                    }\n                }\n                if (0 \u003c taxonSet.size()) {\n                    taxonPath.setTaxons(taxonSet);\n                    cmb.addTaxonPath(taxonPath);\n                }\n            }\n        }\n        String[] copyrightValues \u003d request.getParameterValues(\"copyrights\");\n        ArrayList copyrights \u003d new ArrayList();\n        if (null !\u003d copyrightValues) {\n            for (int i \u003d 0; i \u003c copyrightValues.length; ++i) {\n                CopyrightTextBean ctb \u003d new CopyrightTextBean();\n                ctb.setCopyrightText(copyrightValues[i]);\n                CopyrightBean cb \u003d new CopyrightBean();\n                cb.setCopyrightText(ctb);\n                copyrights.add(cb);\n            }\n        }\n        cmb.setCopyrights(copyrights);\n        cmb.setCreationDate(DateTools.parse(request.getParameter(\"creationDate\")));\n        cmb.setDescription(request.getParameter(\"description\"));\n        String[] diseaseDxValues \u003d request.getParameterValues(\"diseaseDiagnoses\");\n        ArrayList diseaseDiagnoses \u003d new ArrayList();\n        if (null !\u003d diseaseDxValues) {\n            for (int i \u003d 0; i \u003c diseaseDxValues.length; ++i) {\n                DiseaseDiagnosisBean ddb \u003d new DiseaseDiagnosisBean();\n                ddb.setDiseaseDiagnosis(diseaseDxValues[i]);\n                diseaseDiagnoses.add(ddb);\n            }\n        }\n        cmb.setDiseaseDiagnoses(diseaseDiagnoses);\n        cmb.setDuration(request.getParameter(\"duration\"));\n        cmb.setFileHeight(request.getParameter(\"fileHeight\"));\n        cmb.setFileWidth(request.getParameter(\"fileWidth\"));\n        cmb.setFileName(request.getParameter(\"filename\"));\n        cmb.setFileSize(request.getParameter(\"fileSize\"));\n        String[] formatValues \u003d request.getParameterValues(\"formats\");\n        ArrayList formats \u003d new ArrayList();\n        if (null !\u003d formatValues) {\n            for (int i \u003d 0; i \u003c formatValues.length; ++i) {\n                FormatBean fb \u003d new FormatBean();\n                fb.setFormat(formatValues[i]);\n                formats.add(fb);\n            }\n        }\n        cmb.setFormats(formats);\n        cmb.setGlobalId(request.getParameter(\"globalId\"));\n        String[] keywordValues \u003d request.getParameterValues(\"keywords\");\n        ArrayList keywords \u003d new ArrayList();\n        if (null !\u003d keywordValues) {\n            for (int i \u003d 0; i \u003c keywordValues.length; ++i) {\n                KeywordBean kb \u003d new KeywordBean();\n                kb.setKeyword(keywordValues[i]);\n                keywords.add(kb);\n            }\n        }\n        cmb.setKeywords(keywords);\n        cmb.setLearningResourceType(request.getParameter(\"learningResourceType\"));\n        cmb.setLocation(request.getParameter(\"location\"));\n        cmb.setMagnification(request.getParameter(\"magnification\"));\n        // Removes any deleted Metametadata Identifiers\n        List oldMmIdentifiers \u003d cmb.getMetametadataIdentifiers();\n        List\u003cMetametadataIdentifierBean\u003e updatedMmIdentifiers \u003d new ArrayList\u003cMetametadataIdentifierBean\u003e();\n        String[] mmIdentifiers \u003d request.getParameterValues(\"metametadataIdentifiers\");\n        if (null !\u003d mmIdentifiers) {\n            for (int i \u003d 0; i \u003c mmIdentifiers.length; ++i) {\n                final String metametadataIdentifierId \u003d mmIdentifiers[i];\n                for (Object o : oldMmIdentifiers) {\n                    MetametadataIdentifierBean mib \u003d (MetametadataIdentifierBean) o;\n                    if (metametadataIdentifierId.equals(mib.getMetametadataIdentifierId())) {\n                        updatedMmIdentifiers.add(mib);\n                        break;\n                    }\n                }\n            }\n        }\n        cmb.setMetametadataIdentifiers(updatedMmIdentifiers);\n        // Removes any deleted Metametadata Contributors\n        List oldMmContributors \u003d cmb.getMetametadataContributors();\n        List\u003cMetametadataContributorBean\u003e updatedMmContributors \u003d new ArrayList\u003cMetametadataContributorBean\u003e();\n        String[] mmContributors \u003d request.getParameterValues(\"metametadataContributors\");\n        if (null !\u003d mmContributors) {\n            for (int i \u003d 0; i \u003c mmContributors.length; ++i) {\n                final String metametadataContributorId \u003d mmContributors[i];\n                for (Object o : oldMmContributors) {\n                    MetametadataContributorBean mcb \u003d (MetametadataContributorBean) o;\n                    if (metametadataContributorId.equals(mcb.getMetametadataContributorId())) {\n                        updatedMmContributors.add(mcb);\n                        break;\n                    }\n                }\n            }\n        }\n        cmb.setMetametadataContributors(updatedMmContributors);\n        cmb.setOrientation(request.getParameter(\"orientation\"));\n        cmb.setPrivate(request.getParameter(\"private\"));\n        cmb.setPublicationName(request.getParameter(\"publicationName\"));\n        cmb.setRadiographType(request.getParameter(\"radiographType\"));\n        // TODO Removes any deleted Relations\n        List oldRelations \u003d cmb.getRelations();\n        ArrayList updatedRelations \u003d new ArrayList();\n        String[] relations \u003d request.getParameterValues(\"relations\");\n        if (null !\u003d relations) {\n            for (int i \u003d 0; i \u003c relations.length; ++i) {\n                final String relationId \u003d relations[i];\n                for (Iterator iter \u003d oldRelations.iterator(); iter.hasNext(); ) {\n                    RelationBean rb \u003d (RelationBean) iter.next();\n                    if (relationId.equals(rb.getRelationId())) {\n                        updatedRelations.add(rb);\n                        break;\n                    }\n                }\n            }\n        }\n        cmb.setRelations(updatedRelations);\n        // Removes any deleted Requirements\n        List oldRequirements \u003d cmb.getRequirements();\n        ArrayList updatedRequirements \u003d new ArrayList();\n        String[] requirements \u003d request.getParameterValues(\"requirements\");\n        if (null !\u003d requirements) {\n            for (int i \u003d 0; i \u003c requirements.length; ++i) {\n                final String requirementId \u003d requirements[i];\n                for (Iterator iter \u003d oldRequirements.iterator(); iter.hasNext(); ) {\n                    RequirementBean rb \u003d (RequirementBean) iter.next();\n                    if (rb.getRequirementId().equals(requirementId)) {\n                        updatedRequirements.add(rb);\n                        break;\n                    }\n                }\n            }\n        }\n        cmb.setRequirements(updatedRequirements);\n        cmb.setRejectDate(DateTools.parse(request.getParameter(\"rejectedDate\")));\n        cmb.setSourceCollection(request.getParameter(\"sourceCollection\"));\n        cmb.setSourceCollectionId(request.getParameter(\"sourceCollectionId\"));\n        cmb.setSpecimenType(request.getParameter(\"specimenType\"));\n        cmb.setTitle(request.getParameter(\"title\"));\n        String[] targetUserGroupValues \u003d request.getParameterValues(\"targetUserGroups\");\n        ArrayList targetUserGroups \u003d new ArrayList();\n        if (null !\u003d targetUserGroupValues) {\n            for (int i \u003d 0; i \u003c targetUserGroupValues.length; ++i) {\n                TargetUserGroupBean tug \u003d new TargetUserGroupBean();\n                tug.setTargetUserGroup(targetUserGroupValues[i]);\n                targetUserGroups.add(tug);\n            }\n        }\n        cmb.setTargetUserGroups(targetUserGroups);\n        if (null !\u003d request.getParameter(\"thumbnailLocation\")) {\n            ThumbnailBean tb \u003d new ThumbnailBean();\n            tb.setLocation(request.getParameter(\"thumbnailLocation\"));\n            tb.setFileHeight(request.getParameter(\"thumbnailFileHeight\"));\n            tb.setFileWidth(request.getParameter(\"thumbnailFileWidth\"));\n            cmb.setThumbnail(tb);\n        }\n    }\n\n    /**\n     * @param request Used to get the parameter \u003ccode\u003e\"nextAction\"\u003c/code\u003e, which\n     * \t\tdetermines what the next {@link Action} to take will be.  If no\n     * \t\t\u003ccode\u003e\"nextAction\"\u003c/code\u003e exists, a valid {@link Action} will still\n     * \t\tbe returned.\n     * @return The next {@link Action} to take after saving the metadata from\n     * \t\tthe form.\n     */\n    public Action getNextAction(ServletRequest request) {\n        Action ret;\n        String nextActionKey \u003d request.getParameter(\"nextAction\");\n        if (nextActionMap.containsKey(nextActionKey)) {\n            ret \u003d (Action) nextActionMap.get(nextActionKey);\n        } else {\n            ret \u003d NEXT_ACTION_DEFAULT;\n        }\n        return ret;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "MetadataRecordModifier",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/MetadataRecordModifier.java",
    "test_prompt": "// MetadataRecordModifierTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.DateTools;\nimport javax.servlet.ServletRequest;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataRecordModifier}.\n* It contains ten unit test cases for the {@link MetadataRecordModifier#getNextAction(ServletRequest)} method.\n*/\nclass MetadataRecordModifierTest {",
    "method_signature": "getNextAction(ServletRequest)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// EditMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.VCardBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * An {@link org.heal.servlet.Action Action} used to edit metadata\n * records.\n *\n * @author Brad Schaefer (\u003cA HREF\u003d\"mailto:schaefer@lib.med.utah.edu\"\u003eschaefer@lib.med.utah.edu\u003c/A\u003e)\n * @version 1.0\n */\npublic class EditMetadataAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final String metadataId \u003d request.getParameter(\"metadataId\");\n        CompleteMetadataBean cmb \u003d (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        if (null \u003d\u003d cmb) {\n            if (null !\u003d metadataId) {\n                // If there\u0027s no CompleteMetadataBean in the session, we try to retrieve one from\n                // the database based on the metadataId parameter\n                final MetadataDAO metadataServices \u003d (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n                try {\n                    cmb \u003d metadataServices.getCompleteMetadata(metadataId);\n                    request.getSession().setAttribute(\"metadata\", cmb);\n                } catch (SQLException e) {\n                    throw new ServletException(e);\n                    // TODO Logging?\n                }\n            } else {\n                request.setAttribute(\"reason\", \"No metadata record available to edit.\");\n                RequestDispatcher rd \u003d request.getRequestDispatcher(\"/error/accessDenied.jsp\");\n                rd.forward(request, response);\n                return;\n            }\n        } else {\n            if (null !\u003d metadataId) {\n                response.sendRedirect(\"../catalog/concurrentMetadataEditError.jsp\");\n                return;\n            }\n        }\n        if (null !\u003d cmb) {\n            // We must add target user groups to the request as a Map so that\n            // the JSP EL can easily determine whether checkboxes should be checked\n            Map targetUserGroups \u003d new HashMap();\n            for (Iterator iter \u003d cmb.getTargetUserGroups().iterator(); iter.hasNext(); ) {\n                TargetUserGroupBean tug \u003d (TargetUserGroupBean) iter.next();\n                targetUserGroups.put(tug.getTargetUserGroup().toLowerCase(), new Object());\n            }\n            request.setAttribute(\"targetUserGroups\", targetUserGroups);\n            // We add names for contributors so that they can be\n            // printed out nicely in the jsp\n            VCardBean vCard \u003d new VCardBean();\n            List contributors \u003d cmb.getContributorList();\n            for (Iterator iter \u003d contributors.iterator(); iter.hasNext(); ) {\n                ContributorBean cb \u003d (ContributorBean) iter.next();\n                vCard.setVCard(cb.getVCard());\n                if (vCard.isValidVCard()) {\n                    if (null !\u003d vCard.getFormattedName()) {\n                        cb.setTitle(vCard.getFormattedName());\n                    } else {\n                        cb.setTitle(vCard.getFirstName() + \" \" + vCard.getLastName());\n                    }\n                } else {\n                    cb.setTitle(cb.getVCard());\n                }\n            }\n            // We add names for copyright holders so that they can be\n            // printed out nicely in the jsp\n            for (Iterator iter \u003d cmb.getCopyrightHolders().iterator(); iter.hasNext(); ) {\n                CopyrightHolderBean chb \u003d (CopyrightHolderBean) iter.next();\n                vCard.setVCard(chb.getVCard());\n                if (vCard.isValidVCard()) {\n                    if (null !\u003d vCard.getFormattedName()) {\n                        chb.setTitle(vCard.getFormattedName());\n                    } else {\n                        chb.setTitle(vCard.getFirstName() + \" \" + chb.getLastName());\n                    }\n                } else {\n                    chb.setTitle(chb.getVCard());\n                }\n            }\n        }\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/catalog/editMetadata.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "EditMetadataAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditMetadataAction.java",
    "test_prompt": "// EditMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.VCardBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditMetadataAction}.\n* It contains ten unit test cases for the {@link EditMetadataAction#actionRequiresLogin()} method.\n*/\nclass EditMetadataActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// EditContributorAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContributorBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * An {@link Action} which is called to edit a Contributor.  If\n * there isn\u0027t an existing Contributor which can be found to edit,\n * we assume that a new Contributor should be edited.\n */\npublic class EditContributorAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should\u0027ve been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb \u003d (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId \u003d request.getParameter(\"selectedId\");\n        // This shouldn\u0027t be necessary, but it won\u0027t hurt to check\n        if (null \u003d\u003d cmb || null \u003d\u003d selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        ContributorBean cbToEdit \u003d new ContributorBean();\n        for (Iterator iter \u003d cmb.getContributorList().iterator(); iter.hasNext(); ) {\n            ContributorBean tempCb \u003d (ContributorBean) iter.next();\n            if (tempCb.getContributorId().equals(selectedId)) {\n                cbToEdit \u003d tempCb;\n                break;\n            }\n        }\n        request.setAttribute(\"ContributorBean\", cbToEdit);\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/catalog/editContributor.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "EditContributorAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditContributorAction.java",
    "test_prompt": "// EditContributorActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContributorBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditContributorAction}.\n* It contains ten unit test cases for the {@link EditContributorAction#actionRequiresLogin()} method.\n*/\nclass EditContributorActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// ShowCatalogQueueAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * An {@link org.heal.servlet.Action} which fetches the information needed to\n * display the catalog queue.\n *\n * @author Brad Schaefer (\u003cA HREF\u003d\"mailto:schaefer@lib.med.utah.edu\"\u003eschaefer@lib.med.utah.edu\u003c/A\u003e)\n */\npublic class ShowCatalogQueueAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final QueueDAO queueManager \u003d (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n        final List queue \u003d queueManager.getCatalogQueue();\n        request.setAttribute(\"catalogQueue\", queue);\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/catalog/viewqueue.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "ShowCatalogQueueAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/ShowCatalogQueueAction.java",
    "test_prompt": "// ShowCatalogQueueActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowCatalogQueueAction}.\n* It contains ten unit test cases for the {@link ShowCatalogQueueAction#actionRequiresLogin()} method.\n*/\nclass ShowCatalogQueueActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// EditCopyrightHolderAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * An {@link Action} which is called to edit a Copyright Holder.  If\n * there isn\u0027t an existing Copyright Holder which can be found to edit,\n * we assume that a new Copyright Holder should be edited.\n */\npublic class EditCopyrightHolderAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should\u0027ve been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb \u003d (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId \u003d request.getParameter(\"selectedId\");\n        // This shouldn\u0027t be necessary, but it won\u0027t hurt to check\n        if (null \u003d\u003d cmb || null \u003d\u003d selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        CopyrightHolderBean chbToEdit \u003d new CopyrightHolderBean();\n        for (Iterator iter \u003d cmb.getCopyrightHolders().iterator(); iter.hasNext(); ) {\n            CopyrightHolderBean tempChb \u003d (CopyrightHolderBean) iter.next();\n            if (tempChb.getCopyrightHolderId().equals(selectedId)) {\n                chbToEdit \u003d tempChb;\n                break;\n            }\n        }\n        request.setAttribute(\"CopyrightHolderBean\", chbToEdit);\n        RequestDispatcher rd \u003d request.getRequestDispatcher(\"/catalog/editCopyrightHolder.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return \u003ccode\u003etrue\u003c/code\u003e\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
    "package": "org.heal.servlet.cataloger",
    "classname": "EditCopyrightHolderAction",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/cataloger/EditCopyrightHolderAction.java",
    "test_prompt": "// EditCopyrightHolderActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditCopyrightHolderAction}.\n* It contains ten unit test cases for the {@link EditCopyrightHolderAction#actionRequiresLogin()} method.\n*/\nclass EditCopyrightHolderActionTest {",
    "method_signature": "actionRequiresLogin()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// AlphanumericFileRenamePolicy.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.multipart.DefaultFileRenamePolicy;\nimport java.io.File;\n\n/**\n * A FileRenamePolicy that strips non-alphanumeric characters.\n */\npublic class AlphanumericFileRenamePolicy extends DefaultFileRenamePolicy {\n\n    /**\n     * Eliminates non-alphanumeric characters from filenames.  Exceptions\n     * include \u003ccode\u003e\u0027 \u0027\u003c/code\u003e, \u003ccode\u003e\u0027.\u0027\u003c/code\u003e and \u003ccode\u003e\u0027_\u0027\u003c/code\u003e\n     *\n     * @param original Original file reference.\n     * @return File reference stripped of non-alphanumeric characters.\n     */\n    public File rename(File original) {\n        File ret \u003d new File(stripSpecialCharacters(original.getPath()));\n        return super.rename(ret);\n    }\n\n    String stripSpecialCharacters(String filename) {\n        // Removes all non-alphanumeric characters (except for \u0027.\u0027 and \u0027 \u0027)\n        return filename.substring(0, filename.lastIndexOf(File.separator) + 1) + filename.substring(filename.lastIndexOf(File.separator) + 1).replaceAll(\"[^\\\\w\\\\. ]\", \"\");\n    }\n}\n",
    "package": "org.heal.servlet.upload",
    "classname": "AlphanumericFileRenamePolicy",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/servlet/upload/AlphanumericFileRenamePolicy.java",
    "test_prompt": "// AlphanumericFileRenamePolicyTest.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.multipart.DefaultFileRenamePolicy;\nimport java.io.File;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AlphanumericFileRenamePolicy}.\n* It contains ten unit test cases for the {@link AlphanumericFileRenamePolicy#rename(File)} method.\n*/\nclass AlphanumericFileRenamePolicyTest {",
    "method_signature": "rename(File)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT \u003d new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT \u003d new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS \u003d new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}\u0027s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            boolean match \u003d false;\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret \u003d formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret \u003d formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String, or \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match \u003d false;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or \u003ccode\u003efalse\u003c/code\u003e\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match \u003d false;\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match \u003d true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
    "package": "org.heal.util",
    "classname": "DateTools",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_0Test.java",
    "test_prompt": "// DateTools_0Test.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#format(Date)} method.\n*/\nclass DateTools_0Test {",
    "method_signature": "format(Date)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT \u003d new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT \u003d new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS \u003d new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}\u0027s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            boolean match \u003d false;\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret \u003d formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret \u003d formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String, or \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match \u003d false;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or \u003ccode\u003efalse\u003c/code\u003e\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match \u003d false;\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match \u003d true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
    "package": "org.heal.util",
    "classname": "DateTools",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_1Test.java",
    "test_prompt": "// DateTools_1Test.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#format(Date, String)} method.\n*/\nclass DateTools_1Test {",
    "method_signature": "format(Date, String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT \u003d new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT \u003d new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS \u003d new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}\u0027s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            boolean match \u003d false;\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret \u003d formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret \u003d formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String, or \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match \u003d false;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or \u003ccode\u003efalse\u003c/code\u003e\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match \u003d false;\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match \u003d true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
    "package": "org.heal.util",
    "classname": "DateTools",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_2Test.java",
    "test_prompt": "// DateTools_2Test.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#parse(String)} method.\n*/\nclass DateTools_2Test {",
    "method_signature": "parse(String)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT \u003d new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT \u003d new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS \u003d new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}\u0027s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            boolean match \u003d false;\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret \u003d formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret \u003d formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String, or \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match \u003d false;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or \u003ccode\u003efalse\u003c/code\u003e\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match \u003d false;\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match \u003d true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
    "package": "org.heal.util",
    "classname": "DateTools",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_3Test.java",
    "test_prompt": "// DateTools_3Test.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#parse(String, String)} method.\n*/\nclass DateTools_3Test {",
    "method_signature": "parse(String, String)",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT \u003d new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT \u003d new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS \u003d new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}\u0027s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            boolean match \u003d false;\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret \u003d formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret \u003d formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String, or \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match \u003d false;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or \u003ccode\u003efalse\u003c/code\u003e\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match \u003d false;\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match \u003d true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
    "package": "org.heal.util",
    "classname": "DateTools",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_4Test.java",
    "test_prompt": "// DateTools_4Test.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#isValidDate(String)} method.\n*/\nclass DateTools_4Test {",
    "method_signature": "isValidDate(String)",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT \u003d new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT \u003d new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS \u003d new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}\u0027s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null \u003d\u003d date) {\n            return null;\n        }\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            boolean match \u003d false;\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret \u003d formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor \u003ccode\u003enull\u003c/code\u003e if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret \u003d null;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret \u003d formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String, or \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match \u003d false;\n        if (null !\u003d dateString) {\n            SimpleDateFormat formatter \u003d new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i \u003d 0; i \u003c POSSIBLE_DATE_FORMATS.length \u0026\u0026 !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match \u003d true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or \u003ccode\u003efalse\u003c/code\u003e\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match \u003d false;\n        SimpleDateFormat formatter \u003d new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match \u003d true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
    "package": "org.heal.util",
    "classname": "DateTools",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/util/DateTools_5Test.java",
    "test_prompt": "// DateTools_5Test.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#isValidDate(String, String)} method.\n*/\nclass DateTools_5Test {",
    "method_signature": "isValidDate(String, String)",
    "suffix": "5"
  },
  {
    "numberTests": "ten",
    "original_code": "// QueueDAO.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * A DAO for managing queues stored in the database\n */\npublic class QueueDAO implements Serializable {\n\n    public QueueDAO() {\n    }\n\n    public static final String TYPE_APPROVAL \u003d new String(\"approval\");\n\n    public static final String TYPE_CATALOG \u003d new String(\"catalog\");\n\n    private DataSource dataSource;\n\n    private CommonDAO cd \u003d new CommonDAO();\n\n    private MetadataDAO md \u003d new MetadataDAO();\n\n    private static final String SELECT_QUEUE_BY_TYPE \u003d \"SELECT QueuedRecordId,\" + \" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?\";\n\n    private static final String INSERT_QUEUE_ENTRY \u003d \"INSERT INTO QueuedRecords\" + \" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)\";\n\n    private static final String UPDATE_QUEUE_ENTRY \u003d \"UPDATE QueuedRecords\" + \" SET Type \u003d ?, MetadataId \u003d ?, Status \u003d ?, Comments \u003d ? WHERE\" + \" QueuedRecordId \u003d ?\";\n\n    private static final String DELETE_QUEUE_ENTRY \u003d \"DELETE FROM QueuedRecords\" + \" WHERE QueuedRecordId \u003d ?\";\n\n    public void setDataSource(final DataSource dataSource) {\n        this.dataSource \u003d dataSource;\n        cd.setDataSource(dataSource);\n        md.setDataSource(dataSource);\n    }\n\n    /**\n     * @param type The type of QueuedRecordBeans to get.\n     *\n     * @return A List of QueuedRecordBeans.\n     */\n    public List\u003cQueuedRecordBean\u003e getQueueByType(final String type) {\n        List\u003cQueuedRecordBean\u003e result \u003d null;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            result \u003d getQueue(type, conn);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the catalog queue.\n     */\n    public List\u003cQueuedRecordBean\u003e getCatalogQueue() {\n        return getQueueByType(TYPE_CATALOG);\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the approval queue.\n     */\n    public List\u003cQueuedRecordBean\u003e getApprovalQueue() {\n        return getQueueByType(TYPE_APPROVAL);\n    }\n\n    public List\u003cQueuedRecordBean\u003e getQueue(final String type, final Connection conn) throws SQLException {\n        final List\u003cQueuedRecordBean\u003e result \u003d new ArrayList\u003cQueuedRecordBean\u003e();\n        PreparedStatement ps \u003d null;\n        ResultSet rs \u003d null;\n        try {\n            ps \u003d conn.prepareStatement(SELECT_QUEUE_BY_TYPE);\n            ps.setString(1, type);\n            rs \u003d ps.executeQuery();\n            while (rs.next()) {\n                final QueuedRecordBean queueMember \u003d new QueuedRecordBean();\n                queueMember.setQueuedRecordId(rs.getString(1));\n                queueMember.getShortMetadata().setMetadataId(rs.getString(2));\n                queueMember.setStatus(rs.getString(3));\n                queueMember.setComments(rs.getString(4));\n                result.add(queueMember);\n            }\n        } finally {\n            if (rs !\u003d null) {\n                rs.close();\n            }\n            if (ps !\u003d null) {\n                ps.close();\n            }\n        }\n        for (QueuedRecordBean temp : result) {\n            final String metadataId \u003d temp.getShortMetadata().getMetadataId();\n            // Here we\u0027re putting a MetadataBean into a ShortMetadataBean reference\n            // because it\u0027s necessary for the queue display pages\n            temp.setShortMetadata(md.getMetadata(metadataId));\n        }\n        return result;\n    }\n\n    /**\n     * Saves a {@link QueuedRecordBean} to the database.\n     *\n     * @param queuedRecord A non-null QueuedRecordBean to save.\n     *\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the save is successful, false otherwise.\n     */\n    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {\n        boolean result \u003d false;\n        if (null \u003d\u003d queuedRecord) {\n            throw new IllegalArgumentException(\"queuedRecord argument must be non-null\");\n        }\n        if (null \u003d\u003d queuedRecord.getType()) {\n            throw new IllegalArgumentException(\"Cannot save a QueuedRecordBean without a type\");\n        }\n        if (null \u003d\u003d queuedRecord.getShortMetadata() || null \u003d\u003d queuedRecord.getShortMetadata().getMetadataId()) {\n            throw new IllegalArgumentException(\"Cannot save a queued record without a metadataId\");\n        }\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            saveQueuedRecord(queuedRecord, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException {\n        final boolean isUpdate \u003d null !\u003d queuedRecord.getQueuedRecordId();\n        final String sql \u003d isUpdate ? UPDATE_QUEUE_ENTRY : INSERT_QUEUE_ENTRY;\n        PreparedStatement ps \u003d null;\n        try {\n            ps \u003d conn.prepareStatement(sql);\n            ps.setString(1, queuedRecord.getType());\n            ps.setString(2, queuedRecord.getShortMetadata().getMetadataId());\n            ps.setString(3, queuedRecord.getStatus());\n            ps.setString(4, queuedRecord.getComments());\n            if (isUpdate) {\n                ps.setString(5, queuedRecord.getQueuedRecordId());\n            }\n            ps.executeUpdate();\n        } finally {\n            if (null !\u003d ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean enqueue(final String type, final String metadataId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            final QueuedRecordBean temp \u003d new QueuedRecordBean();\n            temp.setType(type);\n            temp.getShortMetadata().setMetadataId(metadataId);\n            saveQueuedRecord(temp, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean dequeue(final String queuedRecordId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            dequeue(queuedRecordId, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException {\n        PreparedStatement ps \u003d null;\n        try {\n            ps \u003d conn.prepareStatement(DELETE_QUEUE_ENTRY);\n            ps.setString(1, queuedRecordId);\n            ps.executeUpdate();\n        } finally {\n            if (null !\u003d ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean markRecordApproved(final String metadataId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"ApproveDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean markRecordCataloged(final String metadataId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            final CompleteMetadataBean cmb \u003d md.getCompleteMetadata(metadataId, conn);\n            final Date now \u003d new Date();\n            cmb.setCatalogDate(now);\n            cmb.setPublicationDate(now);\n            cmb.setPrivate(false);\n            md.saveCompleteMetadata(cmb, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean rejectRecord(final String metadataId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"RejectDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n}\n",
    "package": "org.heal.module.catalog",
    "classname": "QueueDAO",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/catalog/QueueDAO_0Test.java",
    "test_prompt": "// QueueDAO_0Test.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QueueDAO}.\n* It contains ten unit test cases for the {@link QueueDAO#getQueueByType(String)} method.\n*/\nclass QueueDAO_0Test {",
    "method_signature": "getQueueByType(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// QueueDAO.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * A DAO for managing queues stored in the database\n */\npublic class QueueDAO implements Serializable {\n\n    public QueueDAO() {\n    }\n\n    public static final String TYPE_APPROVAL \u003d new String(\"approval\");\n\n    public static final String TYPE_CATALOG \u003d new String(\"catalog\");\n\n    private DataSource dataSource;\n\n    private CommonDAO cd \u003d new CommonDAO();\n\n    private MetadataDAO md \u003d new MetadataDAO();\n\n    private static final String SELECT_QUEUE_BY_TYPE \u003d \"SELECT QueuedRecordId,\" + \" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?\";\n\n    private static final String INSERT_QUEUE_ENTRY \u003d \"INSERT INTO QueuedRecords\" + \" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)\";\n\n    private static final String UPDATE_QUEUE_ENTRY \u003d \"UPDATE QueuedRecords\" + \" SET Type \u003d ?, MetadataId \u003d ?, Status \u003d ?, Comments \u003d ? WHERE\" + \" QueuedRecordId \u003d ?\";\n\n    private static final String DELETE_QUEUE_ENTRY \u003d \"DELETE FROM QueuedRecords\" + \" WHERE QueuedRecordId \u003d ?\";\n\n    public void setDataSource(final DataSource dataSource) {\n        this.dataSource \u003d dataSource;\n        cd.setDataSource(dataSource);\n        md.setDataSource(dataSource);\n    }\n\n    /**\n     * @param type The type of QueuedRecordBeans to get.\n     *\n     * @return A List of QueuedRecordBeans.\n     */\n    public List\u003cQueuedRecordBean\u003e getQueueByType(final String type) {\n        List\u003cQueuedRecordBean\u003e result \u003d null;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            result \u003d getQueue(type, conn);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the catalog queue.\n     */\n    public List\u003cQueuedRecordBean\u003e getCatalogQueue() {\n        return getQueueByType(TYPE_CATALOG);\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the approval queue.\n     */\n    public List\u003cQueuedRecordBean\u003e getApprovalQueue() {\n        return getQueueByType(TYPE_APPROVAL);\n    }\n\n    public List\u003cQueuedRecordBean\u003e getQueue(final String type, final Connection conn) throws SQLException {\n        final List\u003cQueuedRecordBean\u003e result \u003d new ArrayList\u003cQueuedRecordBean\u003e();\n        PreparedStatement ps \u003d null;\n        ResultSet rs \u003d null;\n        try {\n            ps \u003d conn.prepareStatement(SELECT_QUEUE_BY_TYPE);\n            ps.setString(1, type);\n            rs \u003d ps.executeQuery();\n            while (rs.next()) {\n                final QueuedRecordBean queueMember \u003d new QueuedRecordBean();\n                queueMember.setQueuedRecordId(rs.getString(1));\n                queueMember.getShortMetadata().setMetadataId(rs.getString(2));\n                queueMember.setStatus(rs.getString(3));\n                queueMember.setComments(rs.getString(4));\n                result.add(queueMember);\n            }\n        } finally {\n            if (rs !\u003d null) {\n                rs.close();\n            }\n            if (ps !\u003d null) {\n                ps.close();\n            }\n        }\n        for (QueuedRecordBean temp : result) {\n            final String metadataId \u003d temp.getShortMetadata().getMetadataId();\n            // Here we\u0027re putting a MetadataBean into a ShortMetadataBean reference\n            // because it\u0027s necessary for the queue display pages\n            temp.setShortMetadata(md.getMetadata(metadataId));\n        }\n        return result;\n    }\n\n    /**\n     * Saves a {@link QueuedRecordBean} to the database.\n     *\n     * @param queuedRecord A non-null QueuedRecordBean to save.\n     *\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the save is successful, false otherwise.\n     */\n    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {\n        boolean result \u003d false;\n        if (null \u003d\u003d queuedRecord) {\n            throw new IllegalArgumentException(\"queuedRecord argument must be non-null\");\n        }\n        if (null \u003d\u003d queuedRecord.getType()) {\n            throw new IllegalArgumentException(\"Cannot save a QueuedRecordBean without a type\");\n        }\n        if (null \u003d\u003d queuedRecord.getShortMetadata() || null \u003d\u003d queuedRecord.getShortMetadata().getMetadataId()) {\n            throw new IllegalArgumentException(\"Cannot save a queued record without a metadataId\");\n        }\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            saveQueuedRecord(queuedRecord, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException {\n        final boolean isUpdate \u003d null !\u003d queuedRecord.getQueuedRecordId();\n        final String sql \u003d isUpdate ? UPDATE_QUEUE_ENTRY : INSERT_QUEUE_ENTRY;\n        PreparedStatement ps \u003d null;\n        try {\n            ps \u003d conn.prepareStatement(sql);\n            ps.setString(1, queuedRecord.getType());\n            ps.setString(2, queuedRecord.getShortMetadata().getMetadataId());\n            ps.setString(3, queuedRecord.getStatus());\n            ps.setString(4, queuedRecord.getComments());\n            if (isUpdate) {\n                ps.setString(5, queuedRecord.getQueuedRecordId());\n            }\n            ps.executeUpdate();\n        } finally {\n            if (null !\u003d ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean enqueue(final String type, final String metadataId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            final QueuedRecordBean temp \u003d new QueuedRecordBean();\n            temp.setType(type);\n            temp.getShortMetadata().setMetadataId(metadataId);\n            saveQueuedRecord(temp, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean dequeue(final String queuedRecordId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            dequeue(queuedRecordId, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException {\n        PreparedStatement ps \u003d null;\n        try {\n            ps \u003d conn.prepareStatement(DELETE_QUEUE_ENTRY);\n            ps.setString(1, queuedRecordId);\n            ps.executeUpdate();\n        } finally {\n            if (null !\u003d ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean markRecordApproved(final String metadataId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"ApproveDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean markRecordCataloged(final String metadataId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            final CompleteMetadataBean cmb \u003d md.getCompleteMetadata(metadataId, conn);\n            final Date now \u003d new Date();\n            cmb.setCatalogDate(now);\n            cmb.setPublicationDate(now);\n            cmb.setPrivate(false);\n            md.saveCompleteMetadata(cmb, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean rejectRecord(final String metadataId) {\n        boolean result \u003d false;\n        Connection conn \u003d null;\n        try {\n            conn \u003d dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"RejectDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result \u003d true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null !\u003d conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n}\n",
    "package": "org.heal.module.catalog",
    "classname": "QueueDAO",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/catalog/QueueDAO_2Test.java",
    "test_prompt": "// QueueDAO_2Test.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QueueDAO}.\n* It contains ten unit test cases for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.\n*/\nclass QueueDAO_2Test {",
    "method_signature": "saveQueuedRecord(QueuedRecordBean)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// ParameterBean.java\npackage org.heal.module.search;\n\nimport java.util.*;\n\n/**\n * This ParameterBean class stores an ArrayList of searchParameters and\n * tableList The search Parameters stores a array of ParameterNode that contains\n * information on user input in the format of columnInfo, value and relation to\n * next ParameterNode.\n * The tableList stores a list of tables that are needed to form the query. It\n * is parsed from the searchParameters.\n *\n * @author Julie Zhu\n *         Modify by Grace: Added String[] sourceCollection, rights and PrimaryArray\n *         Modified by Julie: Added Boolean variable for Hidden;\n */\npublic class ParameterBean {\n\n    private ArrayList searchParameters \u003d null;\n\n    private ArrayList tableList \u003d null;\n\n    private String[] filterArray \u003d null;\n\n    private String[] sourceCollection \u003d null;\n\n    private String[] publicationNames \u003d null;\n\n    private String[] publicationIds \u003d null;\n\n    private String rights \u003d null;\n\n    private String[] primaryArray \u003d null;\n\n    private boolean hidden \u003d false;\n\n    private String[] imaging \u003d null;\n\n    private String[] disease \u003d null;\n\n    /**\n     * Constructor\n     */\n    public ParameterBean() {\n        searchParameters \u003d new ArrayList();\n        tableList \u003d new ArrayList();\n    }\n\n    /**\n     * New constructor\n     */\n    public ParameterBean(String keywordString) {\n        searchParameters \u003d new ArrayList();\n        tableList \u003d new ArrayList();\n        makeParameterBean(keywordString);\n    }\n\n    /**\n     * Accessor method, returns the parameterNode at specified position\n     *\n     * @param position\n     *\n     * @return ParameterNode\n     */\n    public ParameterNode getParameters(int position) {\n        return (ParameterNode) searchParameters.get(position);\n    }\n\n    /**\n     * Accessor method, returns the searchParameter size\n     *\n     * @return int\n     */\n    public int size() {\n        return searchParameters.size();\n    }\n\n    /**\n     * return the filterArray\n     *\n     * @return\n     */\n    public String[] getFilterArray() {\n        return filterArray;\n    }\n\n    /**\n     * return the diseasePrecess array\n     * @return disease\n     */\n    public String[] getDisease() {\n        return disease;\n    }\n\n    /**\n     * return the imaging technique Array\n     * @return imaging\n     */\n    public String[] getImaging() {\n        return imaging;\n    }\n\n    /**\n     * return the Source collection Array\n     *\n     * @return sourceCollection\n     */\n    public String[] getSourceCollection() {\n        return sourceCollection;\n    }\n\n    /**\n     * return the usage rights array\n     *\n     * @return rights\n     */\n    public String getUsageRight() {\n        return rights;\n    }\n\n    /**\n     * return the primary audience Array\n     *\n     * @return primary\n     */\n    public String[] getPrimaryArray() {\n        return primaryArray;\n    }\n\n    /**\n     * Return the value for hidden\n     *\n     * @return\n     */\n    public boolean getHidden() {\n        return hidden;\n    }\n\n    /**\n     * Adds parameterNode into the ArrayList\n     *\n     * @param input\n     */\n    public void addParameters(ParameterNode input) {\n        searchParameters.add(input);\n    }\n\n    /**\n     * Adds filter array into the parameterBean\n     *\n     * @param filter\n     */\n    public void setFilterArray(String[] filter) {\n        filterArray \u003d filter;\n    }\n\n    /**\n     * Adds source collection array into the parameterBean\n     *\n     * @param source\n     */\n    public void setSourceCollection(String[] source) {\n        sourceCollection \u003d source;\n    }\n\n    /**\n     * Adds usage rights array into the parameterBean\n     *\n     * @param rts\n     */\n    public void setUsageRights(String rts) {\n        rights \u003d rts;\n    }\n\n    /**\n     * Adds primary audience array into the parameterBean\n     *\n     * @param primary\n     */\n    public void setPrimaryArray(String[] primary) {\n        primaryArray \u003d primary;\n    }\n\n    /**\n     * Adds imaging technique array into the parameterBean\n     * @param source\n     */\n    public void setImaging(String[] imgs) {\n        imaging \u003d imgs;\n    }\n\n    /**\n     * Adds disease precess array into the parameterBean\n     * @param rts\n     */\n    public void setDisease(String[] dis) {\n        disease \u003d dis;\n    }\n\n    /**\n     * sets the value for hidden\n     *\n     * @param value\n     */\n    public void setHidden(boolean value) {\n        hidden \u003d value;\n    }\n\n    /**\n     * This is a wrapper that calls for functions to parse the table name.\n     * If the tableList is empty, it calls for function to create the tableList,\n     * else it returns the tableList as ArrayList.\n     *\n     * @return ArrayList of tableName\n     */\n    public ArrayList getTableList() {\n        if (tableList.isEmpty()) {\n            makeTableList();\n        }\n        return tableList;\n    }\n\n    /**\n     * Checks if the table name already exists in the tableList. If not, adds the\n     * table name into the tableList.\n     *\n     * @param table\n     *\n     * @return boolean\n     */\n    private boolean tableNotFound(String table) {\n        int temp \u003d tableList.size();\n        int i \u003d 0;\n        boolean notFound \u003d true;\n        while ((i \u003c temp) \u0026\u0026 (notFound)) {\n            if (((String) tableList.get(i)).compareTo(table) \u003d\u003d 0) {\n                notFound \u003d false;\n            } else {\n                i++;\n            }\n        }\n        return notFound;\n    }\n\n    /**\n     * main function to create the tableList. Parses through the searchParameter\n     * one by one and checks for the table name.\n     */\n    private void makeTableList() {\n        int temp \u003d searchParameters.size();\n        for (int i \u003d 0; i \u003c temp; i++) {\n            ParameterNode input \u003d (ParameterNode) searchParameters.get(i);\n            String table \u003d input.getTableName();\n            if (tableNotFound(table)) {\n                tableList.add(input.getTableName());\n            }\n        }\n    }\n\n    public void setPublicationNames(String[] names) {\n        publicationNames \u003d names;\n    }\n\n    public String[] getPublicationNames() {\n        return publicationNames;\n    }\n\n    public void setPublicationIds(String[] publicationIds) {\n        this.publicationIds \u003d publicationIds;\n    }\n\n    public String[] getPublicationIds() {\n        return publicationIds;\n    }\n\n    public ParameterBean makeParameterBean(String keywordString) {\n        ParameterBean param \u003d new ParameterBean();\n        ParameterNode pam \u003d new ParameterNode();\n        String keywords \u003d \"\";\n        boolean stype \u003d false;\n        if (keywordString.equals(\"\")) {\n            keywordString \u003d \"%\";\n            //System.out.print(keywordString);\n        }\n        String relation \u003d \"AND\";\n        //dummy variable\n        String columInfo \u003d \"ALL.ALL\";\n        this.setHidden(false);\n        keywordString \u003d keywordString.trim();\n        //mapping the terms from the interface to the database tablename and columns\n        if (keywordString.length() \u003e 0) {\n            //switch to lower case\n            keywordString \u003d keywordString.toLowerCase();\n            //make \u0027 into two \u0027s so that it does not cause error for database\n            keywordString \u003d keywordString.replaceAll(\"\\\u0027\", \"\u0027\u0027\");\n            //System.out.println(keywordString);\n            //make \" separate so that it becomes a token\n            keywordString \u003d keywordString.replaceAll(\"\\\"\", \" \\\" \");\n            StringBuffer buf \u003d new StringBuffer();\n            StringTokenizer tk \u003d new StringTokenizer(keywordString);\n            String key;\n            while (tk.hasMoreTokens()) {\n                key \u003d tk.nextToken();\n                if (//if \" means exact match\n                key.compareTo(\"\\\"\") \u003d\u003d 0) {\n                    buf.delete(0, buf.length());\n                    boolean end \u003d false;\n                    while (//attach the string until the ending \" is found\n                    tk.hasMoreTokens() \u0026\u0026 end \u003d\u003d false) {\n                        key \u003d tk.nextToken();\n                        if (key.compareTo(\"\\\"\") \u003d\u003d 0) {\n                            end \u003d true;\n                            key \u003d buf.toString();\n                            stype \u003d true;\n                        } else\n                            buf.append(key + \" \");\n                    }\n                    key \u003d buf.toString();\n                    key \u003d key.trim();\n                    if (//if there is ending \", take as exact match\n                    end) {\n                        pam \u003d new ParameterNode(columInfo, key, relation, stype);\n                        this.addParameters(pam);\n                    } else //if there is no ending \", take as default \"and\" and parse the word\n                    {\n                        StringTokenizer token \u003d new StringTokenizer(key);\n                        while (token.hasMoreTokens()) {\n                            key \u003d token.nextToken();\n                            if (key.compareTo(\"or\") \u003d\u003d 0) {\n                                relation \u003d \"OR\";\n                            } else if (key.compareTo(\"and\") \u003d\u003d 0) {\n                                relation \u003d \"AND\";\n                            } else if (key.compareTo(\"NOT\") \u003d\u003d 0) {\n                                relation \u003d \"NOT\";\n                            } else {\n                                pam \u003d new ParameterNode(columInfo, key, relation);\n                                this.addParameters(pam);\n                                relation \u003d \"AND\";\n                            }\n                        }\n                    }\n                } else if (key.compareTo(\"or\") \u003d\u003d 0) {\n                    relation \u003d \"OR\";\n                } else if (key.compareTo(\"and\") \u003d\u003d 0) {\n                    relation \u003d \"AND\";\n                } else if (key.compareTo(\"not\") \u003d\u003d 0) {\n                    relation \u003d \"NOT\";\n                } else //treat as individual keyword and passes it into the parameterbean\n                {\n                    pam \u003d new ParameterNode(columInfo, key, relation);\n                    this.addParameters(pam);\n                    relation \u003d \"AND\";\n                }\n                //end of if else\n            }\n            //end of while\n        }\n        return param;\n    }\n}\n",
    "package": "org.heal.module.search",
    "classname": "ParameterBean",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/search/ParameterBean_1Test.java",
    "test_prompt": "// ParameterBean_1Test.java\npackage org.heal.module.search;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterBean}.\n* It contains ten unit test cases for the {@link ParameterBean#size()} method.\n*/\nclass ParameterBean_1Test {",
    "method_signature": "size()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// DownloadQueueBean.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/**\n * Stores a list of contentIds and a package file location and url.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class DownloadQueueBean implements Serializable {\n\n    TreeSet contentSet \u003d new TreeSet();\n\n    String packageFileLocation \u003d null;\n\n    String packageURL \u003d null;\n\n    boolean packageModifiedSinceFileCreated \u003d true;\n\n    int packageFormat \u003d -1;\n\n    /**\n     * Get a collection of content Ids.\n     */\n    public Collection getContentIds() {\n        return contentSet;\n    }\n\n    /**\n     * Returns true if the package has not been modified,\n     * the package file location is not null, the\n     * package URL is set, and the format of the\n     * package is the same as that provided and\n     * the package file exists on disk.\n     */\n    public boolean isPackageFileUpToDate(int format) {\n        if (packageModifiedSinceFileCreated || packageFileLocation \u003d\u003d null || packageURL \u003d\u003d null || format !\u003d packageFormat || !(new File(packageFileLocation)).exists()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the format for the package associated with this queue.\n     * The value will be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public int getPackageFormat() {\n        return packageFormat;\n    }\n\n    /**\n     * Sets the format for the package associated with this queue.\n     * This value should be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public void setPackageFormat(int newPackageFormat) {\n        packageFormat \u003d newPackageFormat;\n    }\n\n    /**\n     * Returns the file path to be used to access the package for this queue.\n     */\n    public String getPackageFileLocation() {\n        return packageFileLocation;\n    }\n\n    public void setPackageFileLocation(String newPackageFileLocation) {\n        packageFileLocation \u003d newPackageFileLocation;\n    }\n\n    /**\n     * Returns the URL to be used to access the package for this queue.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Sets the url used to access this package file.\n     */\n    public void setPackageURL(String newPackageURL) {\n        packageURL \u003d newPackageURL;\n    }\n\n    /**\n     * call this method right after the package file is created.\n     * This is used to track whether or not the queue has been modified\n     * since the last time the associated file was created.\n     */\n    public void setPackageFileCreated() {\n        packageModifiedSinceFileCreated \u003d false;\n    }\n\n    /**\n     * Checks whether or not the queue has changed since the last time\n     * the package was generated.  If the queue has had metadata entries\n     * added or removed since the last time the package has been\n     * generated or the package has not yet been generated yet, then this\n     * method will return true\n     * otherwise, it will return false\n     */\n    public boolean isPackageModified() {\n        return packageModifiedSinceFileCreated;\n    }\n\n    /**\n     * Adds a metadata id to the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean addToQueue(String contentId) {\n        packageModifiedSinceFileCreated \u003d true;\n        contentSet.add(contentId);\n        return true;\n    }\n\n    /**\n     * Removes a metadata id from the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean removeFromQueue(String contentId) {\n        packageModifiedSinceFileCreated \u003d true;\n        return contentSet.remove(contentId);\n    }\n\n    /**\n     * Removes all metadata id from the list of content to include in the\n     * package generated for this queue.\n     */\n    public boolean removeAllFromQueue() {\n        packageModifiedSinceFileCreated \u003d true;\n        contentSet.clear();\n        return true;\n    }\n\n    /**\n     * Deletes all package file settings (last modified, location, url)\n     * but leaves the queue of id\u0027s intact.\n     * Returns true on success.\n     */\n    public boolean clearPackageFileSettings() {\n        packageFileLocation \u003d null;\n        packageURL \u003d null;\n        packageModifiedSinceFileCreated \u003d true;\n        packageFormat \u003d -1;\n        return true;\n    }\n\n    /**\n     * Returns true if the specified metadataId is already in the queue.\n     * Otherwise, it returns false.\n     */\n    public boolean isQueuedAlready(String contentId) {\n        return contentSet.contains(contentId);\n    }\n\n    /**\n     * Returns the number of items queued for download.\n     */\n    public int getNumEntries() {\n        return contentSet.size();\n    }\n}\n",
    "package": "org.heal.module.download",
    "classname": "DownloadQueueBean",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/download/DownloadQueueBean_3Test.java",
    "test_prompt": "// DownloadQueueBean_3Test.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadQueueBean}.\n* It contains ten unit test cases for the {@link DownloadQueueBean#removeAllFromQueue()} method.\n*/\nclass DownloadQueueBean_3Test {",
    "method_signature": "removeAllFromQueue()",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// DownloadQueueBean.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/**\n * Stores a list of contentIds and a package file location and url.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class DownloadQueueBean implements Serializable {\n\n    TreeSet contentSet \u003d new TreeSet();\n\n    String packageFileLocation \u003d null;\n\n    String packageURL \u003d null;\n\n    boolean packageModifiedSinceFileCreated \u003d true;\n\n    int packageFormat \u003d -1;\n\n    /**\n     * Get a collection of content Ids.\n     */\n    public Collection getContentIds() {\n        return contentSet;\n    }\n\n    /**\n     * Returns true if the package has not been modified,\n     * the package file location is not null, the\n     * package URL is set, and the format of the\n     * package is the same as that provided and\n     * the package file exists on disk.\n     */\n    public boolean isPackageFileUpToDate(int format) {\n        if (packageModifiedSinceFileCreated || packageFileLocation \u003d\u003d null || packageURL \u003d\u003d null || format !\u003d packageFormat || !(new File(packageFileLocation)).exists()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the format for the package associated with this queue.\n     * The value will be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public int getPackageFormat() {\n        return packageFormat;\n    }\n\n    /**\n     * Sets the format for the package associated with this queue.\n     * This value should be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public void setPackageFormat(int newPackageFormat) {\n        packageFormat \u003d newPackageFormat;\n    }\n\n    /**\n     * Returns the file path to be used to access the package for this queue.\n     */\n    public String getPackageFileLocation() {\n        return packageFileLocation;\n    }\n\n    public void setPackageFileLocation(String newPackageFileLocation) {\n        packageFileLocation \u003d newPackageFileLocation;\n    }\n\n    /**\n     * Returns the URL to be used to access the package for this queue.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Sets the url used to access this package file.\n     */\n    public void setPackageURL(String newPackageURL) {\n        packageURL \u003d newPackageURL;\n    }\n\n    /**\n     * call this method right after the package file is created.\n     * This is used to track whether or not the queue has been modified\n     * since the last time the associated file was created.\n     */\n    public void setPackageFileCreated() {\n        packageModifiedSinceFileCreated \u003d false;\n    }\n\n    /**\n     * Checks whether or not the queue has changed since the last time\n     * the package was generated.  If the queue has had metadata entries\n     * added or removed since the last time the package has been\n     * generated or the package has not yet been generated yet, then this\n     * method will return true\n     * otherwise, it will return false\n     */\n    public boolean isPackageModified() {\n        return packageModifiedSinceFileCreated;\n    }\n\n    /**\n     * Adds a metadata id to the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean addToQueue(String contentId) {\n        packageModifiedSinceFileCreated \u003d true;\n        contentSet.add(contentId);\n        return true;\n    }\n\n    /**\n     * Removes a metadata id from the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean removeFromQueue(String contentId) {\n        packageModifiedSinceFileCreated \u003d true;\n        return contentSet.remove(contentId);\n    }\n\n    /**\n     * Removes all metadata id from the list of content to include in the\n     * package generated for this queue.\n     */\n    public boolean removeAllFromQueue() {\n        packageModifiedSinceFileCreated \u003d true;\n        contentSet.clear();\n        return true;\n    }\n\n    /**\n     * Deletes all package file settings (last modified, location, url)\n     * but leaves the queue of id\u0027s intact.\n     * Returns true on success.\n     */\n    public boolean clearPackageFileSettings() {\n        packageFileLocation \u003d null;\n        packageURL \u003d null;\n        packageModifiedSinceFileCreated \u003d true;\n        packageFormat \u003d -1;\n        return true;\n    }\n\n    /**\n     * Returns true if the specified metadataId is already in the queue.\n     * Otherwise, it returns false.\n     */\n    public boolean isQueuedAlready(String contentId) {\n        return contentSet.contains(contentId);\n    }\n\n    /**\n     * Returns the number of items queued for download.\n     */\n    public int getNumEntries() {\n        return contentSet.size();\n    }\n}\n",
    "package": "org.heal.module.download",
    "classname": "DownloadQueueBean",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/module/download/DownloadQueueBean_4Test.java",
    "test_prompt": "// DownloadQueueBean_4Test.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadQueueBean}.\n* It contains ten unit test cases for the {@link DownloadQueueBean#clearPackageFileSettings()} method.\n*/\nclass DownloadQueueBean_4Test {",
    "method_signature": "clearPackageFileSettings()",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// DownloadFolderTag.java\npackage org.heal.tag.download;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.FileLocator;\nimport javax.servlet.jsp.tagext.TagSupport;\n\n/**\n * A tag which is basically acts as a container for attributes which\n * nested tags will utilize.\n *\n * @version 1.0\n * @author Brad Schaefer (\u003cA HREF\u003d\"mailto:schaefer@lib.med.utah.edu\"\u003eschaefer@lib.med.utah.edu\u003c/A\u003e)\n * @see org.heal.tag.download.DownloadFolderActionTag\n */\npublic class DownloadFolderTag extends TagSupport {\n\n    public static final int UNKNOWN \u003d -1;\n\n    public static final int UNAVAILABLE \u003d 0;\n\n    public static final int ADD \u003d 1;\n\n    public static final int REMOVE \u003d 2;\n\n    public static final int REMOTE_IMAGE \u003d 3;\n\n    private DownloadQueueBean downloadQueue \u003d null;\n\n    private ShortMetadataBean shortMetadata \u003d null;\n\n    private int downloadFolderType \u003d UNAVAILABLE;\n\n    public void setDownloadQueue(DownloadQueueBean downloadQueue) {\n        this.downloadQueue \u003d downloadQueue;\n    }\n\n    public void setShortMetadata(ShortMetadataBean shortMetadata) {\n        this.shortMetadata \u003d shortMetadata;\n    }\n\n    /**\n     * This is perhaps poorly named, but this will return an\n     * integer representing whether or not a metadata record may\n     * be added to the download folder, removed from the download folder,\n     * or if the download folder is unavailable for the metadata record.\n     *\n     * @return {@link #UNAVAILABLE DownloadFolderTag.UNAVAILABLE} or\n     * {@link #ADD DownloadFolderTag.ADD} or {@link #REMOVE DownloadFolderTag.REMOVE} or\n     * {@link #REMOTE_IMAGE DownloadFolderTag.REMOTE_IMAGE}.\n     */\n    public int getDownloadFolderType() {\n        return downloadFolderType;\n    }\n\n    /**\n     * Parses the attributes so as to initialize the\n     * {@link #getDownloadFolderType() download folder type} for child tags\n     * to use.\n     *\n     * @return Always returns \u003ccode\u003eTagSupport.EVAL_BODY_INCLUDE\u003c/code\u003e\n     */\n    public int doStartTag() {\n        FileLocator locator \u003d (FileLocator) pageContext.getServletContext().getAttribute(\"healFileLocator\");\n        if (\"web page\".equals(shortMetadata.getFormat().toLowerCase()) || !shortMetadata.getLocation().toLowerCase().startsWith(locator.getServerBaseURL())) {\n            if (\"image\".equals(shortMetadata.getFormat().toLowerCase())) {\n                downloadFolderType \u003d REMOTE_IMAGE;\n            } else {\n                downloadFolderType \u003d UNAVAILABLE;\n            }\n        } else if (downloadQueue.isQueuedAlready(shortMetadata.getMetadataId())) {\n            downloadFolderType \u003d REMOVE;\n        } else {\n            downloadFolderType \u003d ADD;\n        }\n        return TagSupport.EVAL_BODY_INCLUDE;\n    }\n\n    /**\n     * Resets the internal state of the tag.\n     *\n     * @return Always returns \u003ccode\u003eTagSupport.EVAL_PAGE\u003c/code\u003e\n     */\n    public int doEndTag() {\n        // In case the servlet container re-uses this object\n        resetTag();\n        return EVAL_PAGE;\n    }\n\n    /**\n     * Resets the tag to its initial state.\n     */\n    private void resetTag() {\n        downloadFolderType \u003d UNAVAILABLE;\n        downloadQueue \u003d null;\n        shortMetadata \u003d null;\n    }\n}\n",
    "package": "org.heal.tag.download",
    "classname": "DownloadFolderTag",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTag_0Test.java",
    "test_prompt": "// DownloadFolderTag_0Test.java\npackage org.heal.tag.download;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.FileLocator;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadFolderTag}.\n* It contains ten unit test cases for the {@link DownloadFolderTag#doStartTag()} method.\n*/\nclass DownloadFolderTag_0Test {",
    "method_signature": "doStartTag()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// DownloadFolderTag.java\npackage org.heal.tag.download;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.FileLocator;\nimport javax.servlet.jsp.tagext.TagSupport;\n\n/**\n * A tag which is basically acts as a container for attributes which\n * nested tags will utilize.\n *\n * @version 1.0\n * @author Brad Schaefer (\u003cA HREF\u003d\"mailto:schaefer@lib.med.utah.edu\"\u003eschaefer@lib.med.utah.edu\u003c/A\u003e)\n * @see org.heal.tag.download.DownloadFolderActionTag\n */\npublic class DownloadFolderTag extends TagSupport {\n\n    public static final int UNKNOWN \u003d -1;\n\n    public static final int UNAVAILABLE \u003d 0;\n\n    public static final int ADD \u003d 1;\n\n    public static final int REMOVE \u003d 2;\n\n    public static final int REMOTE_IMAGE \u003d 3;\n\n    private DownloadQueueBean downloadQueue \u003d null;\n\n    private ShortMetadataBean shortMetadata \u003d null;\n\n    private int downloadFolderType \u003d UNAVAILABLE;\n\n    public void setDownloadQueue(DownloadQueueBean downloadQueue) {\n        this.downloadQueue \u003d downloadQueue;\n    }\n\n    public void setShortMetadata(ShortMetadataBean shortMetadata) {\n        this.shortMetadata \u003d shortMetadata;\n    }\n\n    /**\n     * This is perhaps poorly named, but this will return an\n     * integer representing whether or not a metadata record may\n     * be added to the download folder, removed from the download folder,\n     * or if the download folder is unavailable for the metadata record.\n     *\n     * @return {@link #UNAVAILABLE DownloadFolderTag.UNAVAILABLE} or\n     * {@link #ADD DownloadFolderTag.ADD} or {@link #REMOVE DownloadFolderTag.REMOVE} or\n     * {@link #REMOTE_IMAGE DownloadFolderTag.REMOTE_IMAGE}.\n     */\n    public int getDownloadFolderType() {\n        return downloadFolderType;\n    }\n\n    /**\n     * Parses the attributes so as to initialize the\n     * {@link #getDownloadFolderType() download folder type} for child tags\n     * to use.\n     *\n     * @return Always returns \u003ccode\u003eTagSupport.EVAL_BODY_INCLUDE\u003c/code\u003e\n     */\n    public int doStartTag() {\n        FileLocator locator \u003d (FileLocator) pageContext.getServletContext().getAttribute(\"healFileLocator\");\n        if (\"web page\".equals(shortMetadata.getFormat().toLowerCase()) || !shortMetadata.getLocation().toLowerCase().startsWith(locator.getServerBaseURL())) {\n            if (\"image\".equals(shortMetadata.getFormat().toLowerCase())) {\n                downloadFolderType \u003d REMOTE_IMAGE;\n            } else {\n                downloadFolderType \u003d UNAVAILABLE;\n            }\n        } else if (downloadQueue.isQueuedAlready(shortMetadata.getMetadataId())) {\n            downloadFolderType \u003d REMOVE;\n        } else {\n            downloadFolderType \u003d ADD;\n        }\n        return TagSupport.EVAL_BODY_INCLUDE;\n    }\n\n    /**\n     * Resets the internal state of the tag.\n     *\n     * @return Always returns \u003ccode\u003eTagSupport.EVAL_PAGE\u003c/code\u003e\n     */\n    public int doEndTag() {\n        // In case the servlet container re-uses this object\n        resetTag();\n        return EVAL_PAGE;\n    }\n\n    /**\n     * Resets the tag to its initial state.\n     */\n    private void resetTag() {\n        downloadFolderType \u003d UNAVAILABLE;\n        downloadQueue \u003d null;\n        shortMetadata \u003d null;\n    }\n}\n",
    "package": "org.heal.tag.download",
    "classname": "DownloadFolderTag",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTag_1Test.java",
    "test_prompt": "// DownloadFolderTag_1Test.java\npackage org.heal.tag.download;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.FileLocator;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadFolderTag}.\n* It contains ten unit test cases for the {@link DownloadFolderTag#doEndTag()} method.\n*/\nclass DownloadFolderTag_1Test {",
    "method_signature": "doEndTag()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// SearchResult.java\n/**\n * SearchResult.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResult implements java.io.Serializable {\n\n    private java.lang.String category;\n\n    private java.lang.String comments;\n\n    private int endIndex;\n\n    private java.lang.String query;\n\n    private org.merlot.fedsearch.type.SearchResultElement[] resultElements;\n\n    private float searchTime;\n\n    private int startIndex;\n\n    private int totalResultsCount;\n\n    public SearchResult() {\n    }\n\n    public SearchResult(java.lang.String category, java.lang.String comments, int endIndex, java.lang.String query, org.merlot.fedsearch.type.SearchResultElement[] resultElements, float searchTime, int startIndex, int totalResultsCount) {\n        this.category \u003d category;\n        this.comments \u003d comments;\n        this.endIndex \u003d endIndex;\n        this.query \u003d query;\n        this.resultElements \u003d resultElements;\n        this.searchTime \u003d searchTime;\n        this.startIndex \u003d startIndex;\n        this.totalResultsCount \u003d totalResultsCount;\n    }\n\n    /**\n     * Gets the category value for this SearchResult.\n     *\n     * @return category\n     */\n    public java.lang.String getCategory() {\n        return category;\n    }\n\n    /**\n     * Sets the category value for this SearchResult.\n     *\n     * @param category\n     */\n    public void setCategory(java.lang.String category) {\n        this.category \u003d category;\n    }\n\n    /**\n     * Gets the comments value for this SearchResult.\n     *\n     * @return comments\n     */\n    public java.lang.String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments value for this SearchResult.\n     *\n     * @param comments\n     */\n    public void setComments(java.lang.String comments) {\n        this.comments \u003d comments;\n    }\n\n    /**\n     * Gets the endIndex value for this SearchResult.\n     *\n     * @return endIndex\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * Sets the endIndex value for this SearchResult.\n     *\n     * @param endIndex\n     */\n    public void setEndIndex(int endIndex) {\n        this.endIndex \u003d endIndex;\n    }\n\n    /**\n     * Gets the query value for this SearchResult.\n     *\n     * @return query\n     */\n    public java.lang.String getQuery() {\n        return query;\n    }\n\n    /**\n     * Sets the query value for this SearchResult.\n     *\n     * @param query\n     */\n    public void setQuery(java.lang.String query) {\n        this.query \u003d query;\n    }\n\n    /**\n     * Gets the resultElements value for this SearchResult.\n     *\n     * @return resultElements\n     */\n    public org.merlot.fedsearch.type.SearchResultElement[] getResultElements() {\n        return resultElements;\n    }\n\n    /**\n     * Sets the resultElements value for this SearchResult.\n     *\n     * @param resultElements\n     */\n    public void setResultElements(org.merlot.fedsearch.type.SearchResultElement[] resultElements) {\n        this.resultElements \u003d resultElements;\n    }\n\n    /**\n     * Gets the searchTime value for this SearchResult.\n     *\n     * @return searchTime\n     */\n    public float getSearchTime() {\n        return searchTime;\n    }\n\n    /**\n     * Sets the searchTime value for this SearchResult.\n     *\n     * @param searchTime\n     */\n    public void setSearchTime(float searchTime) {\n        this.searchTime \u003d searchTime;\n    }\n\n    /**\n     * Gets the startIndex value for this SearchResult.\n     *\n     * @return startIndex\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * Sets the startIndex value for this SearchResult.\n     *\n     * @param startIndex\n     */\n    public void setStartIndex(int startIndex) {\n        this.startIndex \u003d startIndex;\n    }\n\n    /**\n     * Gets the totalResultsCount value for this SearchResult.\n     *\n     * @return totalResultsCount\n     */\n    public int getTotalResultsCount() {\n        return totalResultsCount;\n    }\n\n    /**\n     * Sets the totalResultsCount value for this SearchResult.\n     *\n     * @param totalResultsCount\n     */\n    public void setTotalResultsCount(int totalResultsCount) {\n        this.totalResultsCount \u003d totalResultsCount;\n    }\n\n    private java.lang.Object __equalsCalc \u003d null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResult))\n            return false;\n        SearchResult other \u003d (SearchResult) obj;\n        if (obj \u003d\u003d null)\n            return false;\n        if (this \u003d\u003d obj)\n            return true;\n        if (__equalsCalc !\u003d null) {\n            return (__equalsCalc \u003d\u003d obj);\n        }\n        __equalsCalc \u003d obj;\n        boolean _equals;\n        _equals \u003d true \u0026\u0026 ((this.category \u003d\u003d null \u0026\u0026 other.getCategory() \u003d\u003d null) || (this.category !\u003d null \u0026\u0026 this.category.equals(other.getCategory()))) \u0026\u0026 ((this.comments \u003d\u003d null \u0026\u0026 other.getComments() \u003d\u003d null) || (this.comments !\u003d null \u0026\u0026 this.comments.equals(other.getComments()))) \u0026\u0026 this.endIndex \u003d\u003d other.getEndIndex() \u0026\u0026 ((this.query \u003d\u003d null \u0026\u0026 other.getQuery() \u003d\u003d null) || (this.query !\u003d null \u0026\u0026 this.query.equals(other.getQuery()))) \u0026\u0026 ((this.resultElements \u003d\u003d null \u0026\u0026 other.getResultElements() \u003d\u003d null) || (this.resultElements !\u003d null \u0026\u0026 java.util.Arrays.equals(this.resultElements, other.getResultElements()))) \u0026\u0026 this.searchTime \u003d\u003d other.getSearchTime() \u0026\u0026 this.startIndex \u003d\u003d other.getStartIndex() \u0026\u0026 this.totalResultsCount \u003d\u003d other.getTotalResultsCount();\n        __equalsCalc \u003d null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc \u003d false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc \u003d true;\n        int _hashCode \u003d 1;\n        if (getCategory() !\u003d null) {\n            _hashCode +\u003d getCategory().hashCode();\n        }\n        if (getComments() !\u003d null) {\n            _hashCode +\u003d getComments().hashCode();\n        }\n        _hashCode +\u003d getEndIndex();\n        if (getQuery() !\u003d null) {\n            _hashCode +\u003d getQuery().hashCode();\n        }\n        if (getResultElements() !\u003d null) {\n            for (int i \u003d 0; i \u003c java.lang.reflect.Array.getLength(getResultElements()); i++) {\n                java.lang.Object obj \u003d java.lang.reflect.Array.get(getResultElements(), i);\n                if (obj !\u003d null \u0026\u0026 !obj.getClass().isArray()) {\n                    _hashCode +\u003d obj.hashCode();\n                }\n            }\n        }\n        _hashCode +\u003d new Float(getSearchTime()).hashCode();\n        _hashCode +\u003d getStartIndex();\n        _hashCode +\u003d getTotalResultsCount();\n        __hashCodeCalc \u003d false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc \u003d new org.apache.axis.description.TypeDesc(SearchResult.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResult\"));\n        org.apache.axis.description.ElementDesc elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"category\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"category\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"comments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"comments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"endIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"endIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"query\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"query\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"resultElements\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"resultElements\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"searchTime\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"searchTime\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"float\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"startIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"startIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"totalResultsCount\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"totalResultsCount\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
    "package": "org.merlot.fedsearch.type",
    "classname": "SearchResult",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResult_1Test.java",
    "test_prompt": "// SearchResult_1Test.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResult}.\n* It contains ten unit test cases for the {@link SearchResult#getTypeDesc()} method.\n*/\nclass SearchResult_1Test {",
    "method_signature": "getTypeDesc()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// SearchResultElement.java\n/**\n * SearchResultElement.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResultElement implements java.io.Serializable {\n\n    private java.lang.String URL;\n\n    private java.lang.String assignmentsURL;\n\n    private java.lang.String authorName;\n\n    private int avgComments;\n\n    private int avgPeerReviews;\n\n    private java.lang.String award;\n\n    private java.lang.String commentsURL;\n\n    private java.lang.String creationDate;\n\n    private java.lang.String description;\n\n    private java.lang.String detailURL;\n\n    private java.lang.String itemType;\n\n    private int numAssignments;\n\n    private int numComments;\n\n    private int numPeerReviews;\n\n    private java.lang.String peerReviewsURL;\n\n    private int relevanceRanking;\n\n    private java.lang.String title;\n\n    public SearchResultElement() {\n    }\n\n    public SearchResultElement(java.lang.String URL, java.lang.String assignmentsURL, java.lang.String authorName, int avgComments, int avgPeerReviews, java.lang.String award, java.lang.String commentsURL, java.lang.String creationDate, java.lang.String description, java.lang.String detailURL, java.lang.String itemType, int numAssignments, int numComments, int numPeerReviews, java.lang.String peerReviewsURL, int relevanceRanking, java.lang.String title) {\n        this.URL \u003d URL;\n        this.assignmentsURL \u003d assignmentsURL;\n        this.authorName \u003d authorName;\n        this.avgComments \u003d avgComments;\n        this.avgPeerReviews \u003d avgPeerReviews;\n        this.award \u003d award;\n        this.commentsURL \u003d commentsURL;\n        this.creationDate \u003d creationDate;\n        this.description \u003d description;\n        this.detailURL \u003d detailURL;\n        this.itemType \u003d itemType;\n        this.numAssignments \u003d numAssignments;\n        this.numComments \u003d numComments;\n        this.numPeerReviews \u003d numPeerReviews;\n        this.peerReviewsURL \u003d peerReviewsURL;\n        this.relevanceRanking \u003d relevanceRanking;\n        this.title \u003d title;\n    }\n\n    /**\n     * Gets the URL value for this SearchResultElement.\n     *\n     * @return URL\n     */\n    public java.lang.String getURL() {\n        return URL;\n    }\n\n    /**\n     * Sets the URL value for this SearchResultElement.\n     *\n     * @param URL\n     */\n    public void setURL(java.lang.String URL) {\n        this.URL \u003d URL;\n    }\n\n    /**\n     * Gets the assignmentsURL value for this SearchResultElement.\n     *\n     * @return assignmentsURL\n     */\n    public java.lang.String getAssignmentsURL() {\n        return assignmentsURL;\n    }\n\n    /**\n     * Sets the assignmentsURL value for this SearchResultElement.\n     *\n     * @param assignmentsURL\n     */\n    public void setAssignmentsURL(java.lang.String assignmentsURL) {\n        this.assignmentsURL \u003d assignmentsURL;\n    }\n\n    /**\n     * Gets the authorName value for this SearchResultElement.\n     *\n     * @return authorName\n     */\n    public java.lang.String getAuthorName() {\n        return authorName;\n    }\n\n    /**\n     * Sets the authorName value for this SearchResultElement.\n     *\n     * @param authorName\n     */\n    public void setAuthorName(java.lang.String authorName) {\n        this.authorName \u003d authorName;\n    }\n\n    /**\n     * Gets the avgComments value for this SearchResultElement.\n     *\n     * @return avgComments\n     */\n    public int getAvgComments() {\n        return avgComments;\n    }\n\n    /**\n     * Sets the avgComments value for this SearchResultElement.\n     *\n     * @param avgComments\n     */\n    public void setAvgComments(int avgComments) {\n        this.avgComments \u003d avgComments;\n    }\n\n    /**\n     * Gets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @return avgPeerReviews\n     */\n    public int getAvgPeerReviews() {\n        return avgPeerReviews;\n    }\n\n    /**\n     * Sets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @param avgPeerReviews\n     */\n    public void setAvgPeerReviews(int avgPeerReviews) {\n        this.avgPeerReviews \u003d avgPeerReviews;\n    }\n\n    /**\n     * Gets the award value for this SearchResultElement.\n     *\n     * @return award\n     */\n    public java.lang.String getAward() {\n        return award;\n    }\n\n    /**\n     * Sets the award value for this SearchResultElement.\n     *\n     * @param award\n     */\n    public void setAward(java.lang.String award) {\n        this.award \u003d award;\n    }\n\n    /**\n     * Gets the commentsURL value for this SearchResultElement.\n     *\n     * @return commentsURL\n     */\n    public java.lang.String getCommentsURL() {\n        return commentsURL;\n    }\n\n    /**\n     * Sets the commentsURL value for this SearchResultElement.\n     *\n     * @param commentsURL\n     */\n    public void setCommentsURL(java.lang.String commentsURL) {\n        this.commentsURL \u003d commentsURL;\n    }\n\n    /**\n     * Gets the creationDate value for this SearchResultElement.\n     *\n     * @return creationDate\n     */\n    public java.lang.String getCreationDate() {\n        return creationDate;\n    }\n\n    /**\n     * Sets the creationDate value for this SearchResultElement.\n     *\n     * @param creationDate\n     */\n    public void setCreationDate(java.lang.String creationDate) {\n        this.creationDate \u003d creationDate;\n    }\n\n    /**\n     * Gets the description value for this SearchResultElement.\n     *\n     * @return description\n     */\n    public java.lang.String getDescription() {\n        return description;\n    }\n\n    /**\n     * Sets the description value for this SearchResultElement.\n     *\n     * @param description\n     */\n    public void setDescription(java.lang.String description) {\n        this.description \u003d description;\n    }\n\n    /**\n     * Gets the detailURL value for this SearchResultElement.\n     *\n     * @return detailURL\n     */\n    public java.lang.String getDetailURL() {\n        return detailURL;\n    }\n\n    /**\n     * Sets the detailURL value for this SearchResultElement.\n     *\n     * @param detailURL\n     */\n    public void setDetailURL(java.lang.String detailURL) {\n        this.detailURL \u003d detailURL;\n    }\n\n    /**\n     * Gets the itemType value for this SearchResultElement.\n     *\n     * @return itemType\n     */\n    public java.lang.String getItemType() {\n        return itemType;\n    }\n\n    /**\n     * Sets the itemType value for this SearchResultElement.\n     *\n     * @param itemType\n     */\n    public void setItemType(java.lang.String itemType) {\n        this.itemType \u003d itemType;\n    }\n\n    /**\n     * Gets the numAssignments value for this SearchResultElement.\n     *\n     * @return numAssignments\n     */\n    public int getNumAssignments() {\n        return numAssignments;\n    }\n\n    /**\n     * Sets the numAssignments value for this SearchResultElement.\n     *\n     * @param numAssignments\n     */\n    public void setNumAssignments(int numAssignments) {\n        this.numAssignments \u003d numAssignments;\n    }\n\n    /**\n     * Gets the numComments value for this SearchResultElement.\n     *\n     * @return numComments\n     */\n    public int getNumComments() {\n        return numComments;\n    }\n\n    /**\n     * Sets the numComments value for this SearchResultElement.\n     *\n     * @param numComments\n     */\n    public void setNumComments(int numComments) {\n        this.numComments \u003d numComments;\n    }\n\n    /**\n     * Gets the numPeerReviews value for this SearchResultElement.\n     *\n     * @return numPeerReviews\n     */\n    public int getNumPeerReviews() {\n        return numPeerReviews;\n    }\n\n    /**\n     * Sets the numPeerReviews value for this SearchResultElement.\n     *\n     * @param numPeerReviews\n     */\n    public void setNumPeerReviews(int numPeerReviews) {\n        this.numPeerReviews \u003d numPeerReviews;\n    }\n\n    /**\n     * Gets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @return peerReviewsURL\n     */\n    public java.lang.String getPeerReviewsURL() {\n        return peerReviewsURL;\n    }\n\n    /**\n     * Sets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @param peerReviewsURL\n     */\n    public void setPeerReviewsURL(java.lang.String peerReviewsURL) {\n        this.peerReviewsURL \u003d peerReviewsURL;\n    }\n\n    /**\n     * Gets the relevanceRanking value for this SearchResultElement.\n     *\n     * @return relevanceRanking\n     */\n    public int getRelevanceRanking() {\n        return relevanceRanking;\n    }\n\n    /**\n     * Sets the relevanceRanking value for this SearchResultElement.\n     *\n     * @param relevanceRanking\n     */\n    public void setRelevanceRanking(int relevanceRanking) {\n        this.relevanceRanking \u003d relevanceRanking;\n    }\n\n    /**\n     * Gets the title value for this SearchResultElement.\n     *\n     * @return title\n     */\n    public java.lang.String getTitle() {\n        return title;\n    }\n\n    /**\n     * Sets the title value for this SearchResultElement.\n     *\n     * @param title\n     */\n    public void setTitle(java.lang.String title) {\n        this.title \u003d title;\n    }\n\n    private java.lang.Object __equalsCalc \u003d null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResultElement))\n            return false;\n        SearchResultElement other \u003d (SearchResultElement) obj;\n        if (obj \u003d\u003d null)\n            return false;\n        if (this \u003d\u003d obj)\n            return true;\n        if (__equalsCalc !\u003d null) {\n            return (__equalsCalc \u003d\u003d obj);\n        }\n        __equalsCalc \u003d obj;\n        boolean _equals;\n        _equals \u003d true \u0026\u0026 ((this.URL \u003d\u003d null \u0026\u0026 other.getURL() \u003d\u003d null) || (this.URL !\u003d null \u0026\u0026 this.URL.equals(other.getURL()))) \u0026\u0026 ((this.assignmentsURL \u003d\u003d null \u0026\u0026 other.getAssignmentsURL() \u003d\u003d null) || (this.assignmentsURL !\u003d null \u0026\u0026 this.assignmentsURL.equals(other.getAssignmentsURL()))) \u0026\u0026 ((this.authorName \u003d\u003d null \u0026\u0026 other.getAuthorName() \u003d\u003d null) || (this.authorName !\u003d null \u0026\u0026 this.authorName.equals(other.getAuthorName()))) \u0026\u0026 this.avgComments \u003d\u003d other.getAvgComments() \u0026\u0026 this.avgPeerReviews \u003d\u003d other.getAvgPeerReviews() \u0026\u0026 ((this.award \u003d\u003d null \u0026\u0026 other.getAward() \u003d\u003d null) || (this.award !\u003d null \u0026\u0026 this.award.equals(other.getAward()))) \u0026\u0026 ((this.commentsURL \u003d\u003d null \u0026\u0026 other.getCommentsURL() \u003d\u003d null) || (this.commentsURL !\u003d null \u0026\u0026 this.commentsURL.equals(other.getCommentsURL()))) \u0026\u0026 ((this.creationDate \u003d\u003d null \u0026\u0026 other.getCreationDate() \u003d\u003d null) || (this.creationDate !\u003d null \u0026\u0026 this.creationDate.equals(other.getCreationDate()))) \u0026\u0026 ((this.description \u003d\u003d null \u0026\u0026 other.getDescription() \u003d\u003d null) || (this.description !\u003d null \u0026\u0026 this.description.equals(other.getDescription()))) \u0026\u0026 ((this.detailURL \u003d\u003d null \u0026\u0026 other.getDetailURL() \u003d\u003d null) || (this.detailURL !\u003d null \u0026\u0026 this.detailURL.equals(other.getDetailURL()))) \u0026\u0026 ((this.itemType \u003d\u003d null \u0026\u0026 other.getItemType() \u003d\u003d null) || (this.itemType !\u003d null \u0026\u0026 this.itemType.equals(other.getItemType()))) \u0026\u0026 this.numAssignments \u003d\u003d other.getNumAssignments() \u0026\u0026 this.numComments \u003d\u003d other.getNumComments() \u0026\u0026 this.numPeerReviews \u003d\u003d other.getNumPeerReviews() \u0026\u0026 ((this.peerReviewsURL \u003d\u003d null \u0026\u0026 other.getPeerReviewsURL() \u003d\u003d null) || (this.peerReviewsURL !\u003d null \u0026\u0026 this.peerReviewsURL.equals(other.getPeerReviewsURL()))) \u0026\u0026 this.relevanceRanking \u003d\u003d other.getRelevanceRanking() \u0026\u0026 ((this.title \u003d\u003d null \u0026\u0026 other.getTitle() \u003d\u003d null) || (this.title !\u003d null \u0026\u0026 this.title.equals(other.getTitle())));\n        __equalsCalc \u003d null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc \u003d false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc \u003d true;\n        int _hashCode \u003d 1;\n        if (getURL() !\u003d null) {\n            _hashCode +\u003d getURL().hashCode();\n        }\n        if (getAssignmentsURL() !\u003d null) {\n            _hashCode +\u003d getAssignmentsURL().hashCode();\n        }\n        if (getAuthorName() !\u003d null) {\n            _hashCode +\u003d getAuthorName().hashCode();\n        }\n        _hashCode +\u003d getAvgComments();\n        _hashCode +\u003d getAvgPeerReviews();\n        if (getAward() !\u003d null) {\n            _hashCode +\u003d getAward().hashCode();\n        }\n        if (getCommentsURL() !\u003d null) {\n            _hashCode +\u003d getCommentsURL().hashCode();\n        }\n        if (getCreationDate() !\u003d null) {\n            _hashCode +\u003d getCreationDate().hashCode();\n        }\n        if (getDescription() !\u003d null) {\n            _hashCode +\u003d getDescription().hashCode();\n        }\n        if (getDetailURL() !\u003d null) {\n            _hashCode +\u003d getDetailURL().hashCode();\n        }\n        if (getItemType() !\u003d null) {\n            _hashCode +\u003d getItemType().hashCode();\n        }\n        _hashCode +\u003d getNumAssignments();\n        _hashCode +\u003d getNumComments();\n        _hashCode +\u003d getNumPeerReviews();\n        if (getPeerReviewsURL() !\u003d null) {\n            _hashCode +\u003d getPeerReviewsURL().hashCode();\n        }\n        _hashCode +\u003d getRelevanceRanking();\n        if (getTitle() !\u003d null) {\n            _hashCode +\u003d getTitle().hashCode();\n        }\n        __hashCodeCalc \u003d false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc \u003d new org.apache.axis.description.TypeDesc(SearchResultElement.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        org.apache.axis.description.ElementDesc elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"URL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"URL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"assignmentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"assignmentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"authorName\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"authorName\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"award\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"award\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"commentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"commentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"creationDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"creationDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"description\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"description\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"detailURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"detailURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"itemType\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"itemType\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numAssignments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numAssignments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"peerReviewsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"peerReviewsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"relevanceRanking\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"relevanceRanking\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField \u003d new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"title\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"title\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
    "package": "org.merlot.fedsearch.type",
    "classname": "SearchResultElement",
    "id": "/EvoSuiteBenchmark/original/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultElement_1Test.java",
    "test_prompt": "// SearchResultElement_1Test.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResultElement}.\n* It contains ten unit test cases for the {@link SearchResultElement#getTypeDesc()} method.\n*/\nclass SearchResultElement_1Test {",
    "method_signature": "getTypeDesc()",
    "suffix": "1"
  }
]