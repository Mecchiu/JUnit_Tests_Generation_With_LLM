[
  {
    "numberTests": "ten",
    "original_code": "// ASTNode.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\n\n/**\n * \u003cp\u003eTitle: Group 2 Project \u003c/p\u003e\n *\n * \u003cp\u003eClass: CEN4010 Fall 2005\u003c/p\u003e\n *\n * \u003cp\u003eDescription: Data Structure for ASTree Node\u003c/p\u003e\n *\n * \u003cp\u003eInstructor Dr. Stoeklin\u003c/p\u003e\n *\n * @author Group 2\n */\npublic class ASTNode implements Comparable, java.io.Serializable {\n\n    /**\n     * data of the node\n     */\n    String type \u003d null;\n\n    String identity \u003d null;\n\n    /**\n     * implements Comparable\n     * @param node Object\n     * @return int values 0 for same and 1 for different\n     */\n    public int compareTo(Object node) {\n        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {\n            return 1;\n        }\n        for (int i \u003d 0; i \u003c list.size(); ++i) {\n            try {\n                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) \u003d\u003d 1) {\n                    return 1;\n                }\n            } catch (IndexOutOfBoundsException ne) {\n                return 1;\n            } catch (NullPointerException np) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * children of the node\n     */\n    //IC - Added the \u003cObject\u003e tags to get rid of warnings...\n    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html\n    // SS - changed \u003cObject\u003e to \u003cASTNode\u003e and removed the casts\n    java.util.ArrayList\u003cASTNode\u003e list \u003d new java.util.ArrayList\u003cASTNode\u003e();\n\n    /**\n     * parent of the node\n     */\n    ASTNode parent \u003d null;\n\n    /**\n     * add child to node\n     * @param node ASTNode\n     */\n    public void addChild(ASTNode node) {\n        list.add(node);\n    }\n\n    /**\n     * default constructor\n     */\n    public ASTNode() {\n    }\n\n    /**\n     * construct a  node and set its parent\n     * @param p ASTNode\n     */\n    public ASTNode(ASTNode p) {\n        parent \u003d p;\n    }\n\n    /**\n     * construct a node and set data types and parent\n     * @param type String\n     * @param identity String\n     * @param p ASTNode\n     */\n    public ASTNode(String type, String identity, ASTNode p) {\n        parent \u003d p;\n        setType(type);\n        setIdentity(identity);\n    }\n\n    /**\n     * get the parent node\n     * @return ASTNode\n     */\n    public ASTNode getParent() {\n        return parent;\n    }\n\n    /**\n     * set the data element type\n     * @param t String\n     */\n    public void setType(String t) {\n        type \u003d t;\n    }\n\n    /**\n     * set the data type identity\n     * @param id String\n     */\n    public void setIdentity(String id) {\n        identity \u003d id;\n    }\n\n    /**\n     * get the data element type\n     * @return String\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * get the data element identity\n     * @return String\n     */\n    public String getIdentity() {\n        return identity;\n    }\n\n    /**\n     * concat type and identity\n     * @return String\n     */\n    public String toString() {\n        String returnString \u003d type + \" :: \" + identity;\n        return returnString;\n    }\n\n    /**\n     * display this node and all its children recursively\n     * @param wtr Writer\n     */\n    public void display(Writer wtr) {\n        try {\n            wtr.write(toString());\n        } catch (IOException ie) {\n            System.err.println(ie.getMessage());\n        }\n        int arraySize \u003d list.size();\n        for (int i \u003d 0; i \u003c arraySize; ++i) {\n            try {\n                wtr.write(\"\\n\");\n            } catch (IOException ie) {\n                System.err.println(ie.getMessage());\n            }\n            list.get(i).display(wtr);\n        }\n    }\n\n    /**\n     *  reads the node in from a file\n     * @param filename String\n     * @return ASTNode\n     */\n    public static ASTNode getTree(String filename) {\n        ObjectInputStream rdr \u003d null;\n        ASTNode rootNode \u003d null;\n        try {\n            FileInputStream flstrm \u003d new FileInputStream(new File(filename));\n            rdr \u003d new ObjectInputStream(flstrm);\n            rootNode \u003d (ASTNode) rdr.readObject();\n            rdr.close();\n        } catch (java.io.IOException ie) {\n        } finally {\n            return rootNode;\n        }\n    }\n\n    /**\n     * save the node and its children to disk\n     * @param filename String\n     */\n    public void dump(String filename) {\n        ObjectOutputStream wtr \u003d null;\n        try {\n            FileOutputStream flstrm \u003d new FileOutputStream(new File(filename));\n            wtr \u003d new ObjectOutputStream(flstrm);\n            wtr.writeObject(this);\n            wtr.close();\n        } catch (java.io.IOException ie) {\n        }\n    }\n\n    /**\n     * add this node and recursively all its children to a swing tree structure \u003cbr\u003e\n     * used to construct a JTree with the ASTree\n     * @return DefaultMutableTreeNode\n     */\n    public DefaultMutableTreeNode createTree() {\n        javax.swing.tree.DefaultMutableTreeNode node \u003d new DefaultMutableTreeNode(toString());\n        int arraySize \u003d list.size();\n        for (int i \u003d 0; i \u003c arraySize; ++i) {\n            node.add(list.get(i).createTree());\n        }\n        return node;\n    }\n}\n",
    "package": "com.soops.CEN4010.JMCA",
    "classname": "ASTNode",
    "id": "/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_0Test.java",
    "test_prompt": "// ASTNode_0Test.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ASTNode}.\n* It contains ten unit test cases for the {@link ASTNode#compareTo(Object)} method.\n*/\nclass ASTNode_0Test {",
    "method_signature": "compareTo(Object)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// ASTNode.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\n\n/**\n * \u003cp\u003eTitle: Group 2 Project \u003c/p\u003e\n *\n * \u003cp\u003eClass: CEN4010 Fall 2005\u003c/p\u003e\n *\n * \u003cp\u003eDescription: Data Structure for ASTree Node\u003c/p\u003e\n *\n * \u003cp\u003eInstructor Dr. Stoeklin\u003c/p\u003e\n *\n * @author Group 2\n */\npublic class ASTNode implements Comparable, java.io.Serializable {\n\n    /**\n     * data of the node\n     */\n    String type \u003d null;\n\n    String identity \u003d null;\n\n    /**\n     * implements Comparable\n     * @param node Object\n     * @return int values 0 for same and 1 for different\n     */\n    public int compareTo(Object node) {\n        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {\n            return 1;\n        }\n        for (int i \u003d 0; i \u003c list.size(); ++i) {\n            try {\n                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) \u003d\u003d 1) {\n                    return 1;\n                }\n            } catch (IndexOutOfBoundsException ne) {\n                return 1;\n            } catch (NullPointerException np) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * children of the node\n     */\n    //IC - Added the \u003cObject\u003e tags to get rid of warnings...\n    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html\n    // SS - changed \u003cObject\u003e to \u003cASTNode\u003e and removed the casts\n    java.util.ArrayList\u003cASTNode\u003e list \u003d new java.util.ArrayList\u003cASTNode\u003e();\n\n    /**\n     * parent of the node\n     */\n    ASTNode parent \u003d null;\n\n    /**\n     * add child to node\n     * @param node ASTNode\n     */\n    public void addChild(ASTNode node) {\n        list.add(node);\n    }\n\n    /**\n     * default constructor\n     */\n    public ASTNode() {\n    }\n\n    /**\n     * construct a  node and set its parent\n     * @param p ASTNode\n     */\n    public ASTNode(ASTNode p) {\n        parent \u003d p;\n    }\n\n    /**\n     * construct a node and set data types and parent\n     * @param type String\n     * @param identity String\n     * @param p ASTNode\n     */\n    public ASTNode(String type, String identity, ASTNode p) {\n        parent \u003d p;\n        setType(type);\n        setIdentity(identity);\n    }\n\n    /**\n     * get the parent node\n     * @return ASTNode\n     */\n    public ASTNode getParent() {\n        return parent;\n    }\n\n    /**\n     * set the data element type\n     * @param t String\n     */\n    public void setType(String t) {\n        type \u003d t;\n    }\n\n    /**\n     * set the data type identity\n     * @param id String\n     */\n    public void setIdentity(String id) {\n        identity \u003d id;\n    }\n\n    /**\n     * get the data element type\n     * @return String\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * get the data element identity\n     * @return String\n     */\n    public String getIdentity() {\n        return identity;\n    }\n\n    /**\n     * concat type and identity\n     * @return String\n     */\n    public String toString() {\n        String returnString \u003d type + \" :: \" + identity;\n        return returnString;\n    }\n\n    /**\n     * display this node and all its children recursively\n     * @param wtr Writer\n     */\n    public void display(Writer wtr) {\n        try {\n            wtr.write(toString());\n        } catch (IOException ie) {\n            System.err.println(ie.getMessage());\n        }\n        int arraySize \u003d list.size();\n        for (int i \u003d 0; i \u003c arraySize; ++i) {\n            try {\n                wtr.write(\"\\n\");\n            } catch (IOException ie) {\n                System.err.println(ie.getMessage());\n            }\n            list.get(i).display(wtr);\n        }\n    }\n\n    /**\n     *  reads the node in from a file\n     * @param filename String\n     * @return ASTNode\n     */\n    public static ASTNode getTree(String filename) {\n        ObjectInputStream rdr \u003d null;\n        ASTNode rootNode \u003d null;\n        try {\n            FileInputStream flstrm \u003d new FileInputStream(new File(filename));\n            rdr \u003d new ObjectInputStream(flstrm);\n            rootNode \u003d (ASTNode) rdr.readObject();\n            rdr.close();\n        } catch (java.io.IOException ie) {\n        } finally {\n            return rootNode;\n        }\n    }\n\n    /**\n     * save the node and its children to disk\n     * @param filename String\n     */\n    public void dump(String filename) {\n        ObjectOutputStream wtr \u003d null;\n        try {\n            FileOutputStream flstrm \u003d new FileOutputStream(new File(filename));\n            wtr \u003d new ObjectOutputStream(flstrm);\n            wtr.writeObject(this);\n            wtr.close();\n        } catch (java.io.IOException ie) {\n        }\n    }\n\n    /**\n     * add this node and recursively all its children to a swing tree structure \u003cbr\u003e\n     * used to construct a JTree with the ASTree\n     * @return DefaultMutableTreeNode\n     */\n    public DefaultMutableTreeNode createTree() {\n        javax.swing.tree.DefaultMutableTreeNode node \u003d new DefaultMutableTreeNode(toString());\n        int arraySize \u003d list.size();\n        for (int i \u003d 0; i \u003c arraySize; ++i) {\n            node.add(list.get(i).createTree());\n        }\n        return node;\n    }\n}\n",
    "package": "com.soops.CEN4010.JMCA",
    "classname": "ASTNode",
    "id": "/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_1Test.java",
    "test_prompt": "// ASTNode_1Test.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ASTNode}.\n* It contains ten unit test cases for the {@link ASTNode#getTree(String)} method.\n*/\nclass ASTNode_1Test {",
    "method_signature": "getTree(String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// ASTNode.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\n\n/**\n * \u003cp\u003eTitle: Group 2 Project \u003c/p\u003e\n *\n * \u003cp\u003eClass: CEN4010 Fall 2005\u003c/p\u003e\n *\n * \u003cp\u003eDescription: Data Structure for ASTree Node\u003c/p\u003e\n *\n * \u003cp\u003eInstructor Dr. Stoeklin\u003c/p\u003e\n *\n * @author Group 2\n */\npublic class ASTNode implements Comparable, java.io.Serializable {\n\n    /**\n     * data of the node\n     */\n    String type \u003d null;\n\n    String identity \u003d null;\n\n    /**\n     * implements Comparable\n     * @param node Object\n     * @return int values 0 for same and 1 for different\n     */\n    public int compareTo(Object node) {\n        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {\n            return 1;\n        }\n        for (int i \u003d 0; i \u003c list.size(); ++i) {\n            try {\n                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) \u003d\u003d 1) {\n                    return 1;\n                }\n            } catch (IndexOutOfBoundsException ne) {\n                return 1;\n            } catch (NullPointerException np) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * children of the node\n     */\n    //IC - Added the \u003cObject\u003e tags to get rid of warnings...\n    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html\n    // SS - changed \u003cObject\u003e to \u003cASTNode\u003e and removed the casts\n    java.util.ArrayList\u003cASTNode\u003e list \u003d new java.util.ArrayList\u003cASTNode\u003e();\n\n    /**\n     * parent of the node\n     */\n    ASTNode parent \u003d null;\n\n    /**\n     * add child to node\n     * @param node ASTNode\n     */\n    public void addChild(ASTNode node) {\n        list.add(node);\n    }\n\n    /**\n     * default constructor\n     */\n    public ASTNode() {\n    }\n\n    /**\n     * construct a  node and set its parent\n     * @param p ASTNode\n     */\n    public ASTNode(ASTNode p) {\n        parent \u003d p;\n    }\n\n    /**\n     * construct a node and set data types and parent\n     * @param type String\n     * @param identity String\n     * @param p ASTNode\n     */\n    public ASTNode(String type, String identity, ASTNode p) {\n        parent \u003d p;\n        setType(type);\n        setIdentity(identity);\n    }\n\n    /**\n     * get the parent node\n     * @return ASTNode\n     */\n    public ASTNode getParent() {\n        return parent;\n    }\n\n    /**\n     * set the data element type\n     * @param t String\n     */\n    public void setType(String t) {\n        type \u003d t;\n    }\n\n    /**\n     * set the data type identity\n     * @param id String\n     */\n    public void setIdentity(String id) {\n        identity \u003d id;\n    }\n\n    /**\n     * get the data element type\n     * @return String\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * get the data element identity\n     * @return String\n     */\n    public String getIdentity() {\n        return identity;\n    }\n\n    /**\n     * concat type and identity\n     * @return String\n     */\n    public String toString() {\n        String returnString \u003d type + \" :: \" + identity;\n        return returnString;\n    }\n\n    /**\n     * display this node and all its children recursively\n     * @param wtr Writer\n     */\n    public void display(Writer wtr) {\n        try {\n            wtr.write(toString());\n        } catch (IOException ie) {\n            System.err.println(ie.getMessage());\n        }\n        int arraySize \u003d list.size();\n        for (int i \u003d 0; i \u003c arraySize; ++i) {\n            try {\n                wtr.write(\"\\n\");\n            } catch (IOException ie) {\n                System.err.println(ie.getMessage());\n            }\n            list.get(i).display(wtr);\n        }\n    }\n\n    /**\n     *  reads the node in from a file\n     * @param filename String\n     * @return ASTNode\n     */\n    public static ASTNode getTree(String filename) {\n        ObjectInputStream rdr \u003d null;\n        ASTNode rootNode \u003d null;\n        try {\n            FileInputStream flstrm \u003d new FileInputStream(new File(filename));\n            rdr \u003d new ObjectInputStream(flstrm);\n            rootNode \u003d (ASTNode) rdr.readObject();\n            rdr.close();\n        } catch (java.io.IOException ie) {\n        } finally {\n            return rootNode;\n        }\n    }\n\n    /**\n     * save the node and its children to disk\n     * @param filename String\n     */\n    public void dump(String filename) {\n        ObjectOutputStream wtr \u003d null;\n        try {\n            FileOutputStream flstrm \u003d new FileOutputStream(new File(filename));\n            wtr \u003d new ObjectOutputStream(flstrm);\n            wtr.writeObject(this);\n            wtr.close();\n        } catch (java.io.IOException ie) {\n        }\n    }\n\n    /**\n     * add this node and recursively all its children to a swing tree structure \u003cbr\u003e\n     * used to construct a JTree with the ASTree\n     * @return DefaultMutableTreeNode\n     */\n    public DefaultMutableTreeNode createTree() {\n        javax.swing.tree.DefaultMutableTreeNode node \u003d new DefaultMutableTreeNode(toString());\n        int arraySize \u003d list.size();\n        for (int i \u003d 0; i \u003c arraySize; ++i) {\n            node.add(list.get(i).createTree());\n        }\n        return node;\n    }\n}\n",
    "package": "com.soops.CEN4010.JMCA",
    "classname": "ASTNode",
    "id": "/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_2Test.java",
    "test_prompt": "// ASTNode_2Test.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ASTNode}.\n* It contains ten unit test cases for the {@link ASTNode#createTree()} method.\n*/\nclass ASTNode_2Test {",
    "method_signature": "createTree()",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// JMCAParser.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.io.Reader;\nimport com.soops.CEN4010.JMCA.JParser.JavaParser;\nimport java.io.IOException;\nimport java.io.FileWriter;\nimport java.io.Writer;\nimport java.io.FileInputStream;\nimport java.io.File;\nimport com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;\nimport com.soops.CEN4010.JMCA.JParser.ParseException;\n\npublic class JMCAParser implements Parser {\n\n    String intermediateFile \u003d \"default.xml\";\n\n    /**\n     * parse implements parse for Parser\n     * precondition is the intermediatFile is set\n     * @param rdr Reader\n     * @return ASTNode\n     */\n    public ASTNode parse(Reader rdr) {\n        JavaParser parser \u003d new JavaParser(rdr);\n        Writer wtr \u003d null;\n        try {\n            parser.CompilationUnit();\n            wtr \u003d new FileWriter(new File(intermediateFile));\n            parser.dump(wtr);\n            System.out.println(\"Java Parser Version 1.1:  Java program parsed successfully.\");\n            wtr.close();\n            SaxProcessor saxP \u003d new SaxProcessor(new FileInputStream(new File(intermediateFile)));\n            saxP.showFile();\n            return saxP.getRootNode();\n        } catch (ParseException e) {\n            System.out.println(e.getMessage());\n            System.out.println(\"Java Parser Version 1.1:  Encountered errors during parse.\");\n            return null;\n        } catch (IOException ie) {\n            System.out.println(\"IO Error from parse : \" + ie.getMessage());\n            return null;\n        } catch (Error ex) {\n            return null;\n        } finally {\n            try {\n                if (wtr !\u003d null)\n                    wtr.close();\n            } catch (IOException ie) {\n                System.err.println(\"Error while closing intermediate file \" + intermediateFile);\n                System.err.println(ie.getMessage());\n            }\n        }\n        //           return null;\n    }\n}\n",
    "package": "com.soops.CEN4010.JMCA",
    "classname": "JMCAParser",
    "id": "/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAParser.java",
    "test_prompt": "// JMCAParserTest.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.io.Reader;\nimport com.soops.CEN4010.JMCA.JParser.JavaParser;\nimport java.io.IOException;\nimport java.io.FileWriter;\nimport java.io.Writer;\nimport java.io.FileInputStream;\nimport java.io.File;\nimport com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;\nimport com.soops.CEN4010.JMCA.JParser.ParseException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMCAParser}.\n* It contains ten unit test cases for the {@link JMCAParser#parse(Reader)} method.\n*/\nclass JMCAParserTest {",
    "method_signature": "parse(Reader)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// UILayoutDisplayAnalyzer.java\npackage com.soops.CEN4010.JMCA;\n\n/**\n * \u003cp\u003eTitle: Group 2 Project \u003c/p\u003e\n *\n * \u003cp\u003eClass: CEN4010 Fall 2005\u003c/p\u003e\n *\n * \u003cp\u003eDescription: Description: UILayoutDisplayAnalyzer implements a dummy Analyzer\n *    use for UI layout  \u003c/p\u003e\n *\n * \u003cp\u003eInstructor Dr. Stoeklin\u003c/p\u003e\n *\n * @author Group 2\n */\npublic class UILayoutDisplayAnalyzer implements Analyzer {\n\n    String filename \u003d null;\n\n    /**\n     * store the file name for formatted display purposes\n     * @param file String\n     */\n    public void setFileName(String file) {\n        filename \u003d file;\n    }\n\n    /**\n     * no operational implementation of Analyzer\n     * @param dummy ASTNode not used for dummy output\n     * @return display string\n     */\n    public String analyze(ASTNode dummy) {\n        StringBuffer output \u003d new StringBuffer();\n        //FAKE OUTPUT FOR PROTOTYPE\n        output \u003d new StringBuffer(\"\\nFile:  \");\n        output.append(filename);\n        output.append(\"\\n\");\n        output.append(\"Class: CohesionTest\\n\\n\");\n        output.append(\"Method Name                             Cohesion Level\\n\");\n        output.append(\"--------------------------------------------------------------\\n\");\n        output.append(\"deposit                                 Functional\\n\");\n        output.append(\"withdraw                                Sequential\\n\");\n        output.append(\"addCD                                   Communicational\\n\");\n        output.append(\"formDet                                 Iterative\\n\");\n        output.append(\"checkBookIn                             Conditional\\n\");\n        output.append(\"readInput                               Coincidental\\n\");\n        return output.toString();\n    }\n}\n",
    "package": "com.soops.CEN4010.JMCA",
    "classname": "UILayoutDisplayAnalyzer",
    "id": "/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/UILayoutDisplayAnalyzer.java",
    "test_prompt": "// UILayoutDisplayAnalyzerTest.java\npackage com.soops.CEN4010.JMCA;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UILayoutDisplayAnalyzer}.\n* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.\n*/\nclass UILayoutDisplayAnalyzerTest {",
    "method_signature": "analyze(ASTNode)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// JMCAAnalyzer.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.*;\n\n/**\n * \u003cp\u003eTitle: JMCAAnalyzer \u003c/p\u003e\n *\n * \u003cp\u003eDescription: implements Analyzer\u003c/p\u003e\n *\n * Group2 for CEN4010 at FSU - Fall 2005\n */\npublic class JMCAAnalyzer implements Analyzer {\n\n    private String fileName \u003d \"\";\n\n    private StringBuilder output \u003d new StringBuilder();\n\n    private java.util.HashSet\u003cString\u003e classList \u003d null;\n\n    private static final boolean DEVELOPMENT \u003d false;\n\n    /**\n     * Analyze the ASTree and return a formatted string\n     * @param root ASTNode\n     * @return String\n     */\n    public String analyze(ASTNode root) {\n        if (root \u003d\u003d null) {\n            output.append(\"File did not parse correctly\");\n            return output.toString();\n        }\n        setHeader();\n        //  for each class\n        for (ASTNode node : root.list) {\n            analyzeClass(node);\n        }\n        return output.toString();\n    }\n\n    /**\n     * top level analyzer for each class \u003cbr\u003e\n     * calls analyzeMethod for each method\n     * @param node ASTNode\n     */\n    private void analyzeClass(ASTNode node) {\n        // list of class variables\n        classList \u003d new HashSet\u003cString\u003e();\n        java.util.ArrayList\u003cASTNode\u003e methodList \u003d new ArrayList\u003cASTNode\u003e();\n        // print class header\n        output.append(\"\\nClass: \" + node.getIdentity() + \"\\n\\n\");\n        output.append(\"Method Name                             Cohesion Level\\n\");\n        output.append(\"--------------------------------------------------------------\\n\");\n        // save each class variable in classList\n        for (ASTNode childNode : node.list) {\n            if (childNode.getType().equals(\"ClassVariableDeclaration\")) {\n                classList.add(childNode.getIdentity());\n            }\n        }\n        //  do for each method\n        for (ASTNode childNode : node.list) {\n            if (childNode.getType().equals(\"MethodDeclaration\")) {\n                analyzeMethod(childNode);\n            }\n        }\n    }\n\n    // end method analyzeClass\n    /**\n     * called for each method\n     * @param node ASTNode\n     */\n    private void analyzeMethod(ASTNode node) {\n        output.append(node.getIdentity());\n        /**\n         * list of all statements\n         */\n        ArrayList\u003cStatementDS\u003e statementList \u003d new ArrayList\u003cStatementDS\u003e();\n        /**\n         * analyze all statements and add them to the statementList\n         */\n        statements(node, statementList, false, false);\n        /**\n         * HashMap of all modified variables\n         */\n        HashMap\u003cString, StatementElement\u003e modifiedVariables \u003d new HashMap\u003cString, StatementElement\u003e();\n        // build semantics for each statement\n        for (StatementDS tmpDS : statementList) {\n            if (classList.contains(tmpDS.getLVal().getElementName())) {\n                tmpDS.getLVal().setType(StatementElement.variableType.ClassVariable);\n            }\n            if (tmpDS.getType() !\u003d null) {\n                if (tmpDS.getType().equals(StatementDS.statementType.Assignment) || tmpDS.getType().equals(StatementDS.statementType.PostInc) || tmpDS.getType().equals(StatementDS.statementType.PreInc)) {\n                    tmpDS.getLVal().setModified(true);\n                    modifiedVariables.put(tmpDS.getLVal().getElementName(), tmpDS.getLVal());\n                }\n            }\n            // set for selection\n            tmpDS.getLVal().setInSelection(tmpDS.isInSelection());\n            // set for iteration\n            tmpDS.getLVal().setInIteration(tmpDS.isInIteration());\n            // add modified variables to the chain of variables affecting this element\n            ArrayList\u003cStatementElement\u003e rVals \u003d tmpDS.getRVals();\n            for (StatementElement rval : rVals) {\n                StatementElement tmpEl \u003d modifiedVariables.get(rval.getElementName());\n                if (tmpEl !\u003d null \u0026\u0026 !tmpEl.getElementName().equals(tmpDS.getLVal().getElementName())) {\n                    tmpDS.getLVal().addModifier(tmpEl);\n                } else if (!rval.getElementName().equals(tmpDS.getLVal().getElementName())) {\n                    tmpDS.getLVal().addModifier(rval);\n                }\n                if (rval.hasBeenModified()) {\n                    tmpDS.getLVal().addModifier(rval);\n                    modifiedVariables.put(rval.getElementName(), rval);\n                }\n            }\n        }\n        int modifiedClassVariables \u003d 0;\n        int classVariableWithModifiers \u003d 0;\n        int modifiedLocVariables \u003d 0;\n        boolean iterative \u003d false;\n        boolean selective \u003d false;\n        String cohesionLevel \u003d \"\";\n        boolean firstModifiedClassVariableWithModifers \u003d true;\n        ArrayList\u003cString\u003e classVarModifiers \u003d new ArrayList\u003cString\u003e();\n        // do for every Statement\n        for (StatementElement el : modifiedVariables.values()) {\n            if (el.hasBeenModified()) {\n                // class variables\n                if (el.getType() !\u003d null \u0026\u0026 el.getType().equals(StatementElement.variableType.ClassVariable)) {\n                    // selection\n                    if (el.isInSelection()) {\n                        selective \u003d true;\n                    }\n                    // iteration\n                    if (el.isInIteration()) {\n                        iterative \u003d true;\n                    }\n                    if (el.getModifiers().size() \u003e 0) {\n                        ++classVariableWithModifiers;\n                        if (firstModifiedClassVariableWithModifers) {\n                            createArrayListOfModifiers(el, classVarModifiers);\n                            firstModifiedClassVariableWithModifers \u003d false;\n                        } else {\n                            ArrayList\u003cString\u003e tmpList \u003d new ArrayList\u003cString\u003e();\n                            createArrayListOfModifiers(el, tmpList);\n                            ArrayList\u003cString\u003e unionSet \u003d new ArrayList\u003cString\u003e();\n                            // get the union of modifed variables\n                            for (String var : classVarModifiers) {\n                                for (String tmpEl : tmpList) {\n                                    if (var.equals(tmpEl)) {\n                                        unionSet.add(var);\n                                    }\n                                }\n                            }\n                            classVarModifiers \u003d unionSet;\n                        }\n                    }\n                    ++modifiedClassVariables;\n                } else {\n                    // end modified class variables\n                    ++modifiedLocVariables;\n                }\n            }\n        }\n        String cohesionType \u003d \"Coincidental\";\n        if (modifiedClassVariables \u003d\u003d 1 \u0026\u0026 modifiedLocVariables \u003d\u003d 0) {\n            cohesionType \u003d \"Functional\";\n        } else if (modifiedClassVariables \u003d\u003d 1 \u0026\u0026 classVarModifiers.size() \u003e 0) {\n            cohesionType \u003d \"Sequential\";\n        } else if (modifiedClassVariables \u003e 1 \u0026\u0026 classVarModifiers.size() \u003e 0) {\n            cohesionType \u003d \"Communicational\";\n        } else if (modifiedClassVariables \u003d\u003d 0) {\n            cohesionType \u003d \"No Class Level Assignments\";\n            //  cohesionType \u003d \"Coincidental\";\n        }\n        if (iterative) {\n            cohesionType \u003d \"Iterative\";\n        }\n        if (selective) {\n            cohesionType \u003d \"Conditional\";\n        }\n        for (int i \u003d 0; i \u003c 60 - node.getIdentity().length() - cohesionType.length(); ++i) {\n            output.append(\" \");\n        }\n        output.append(cohesionType + \"\\n\");\n        // print out a toString dump for development analysis\n        if (DEVELOPMENT) {\n            for (StatementDS tmpDS : statementList) {\n                output.append(\"     \" + tmpDS.toString() + \"\\n\");\n            }\n        }\n    }\n\n    // end method analyzeMethod\n    /**\n     * recursive method to create a chain of modifiers to a variable \u003cb\u003e\n     * using this method then :   a \u003d b + c;  d \u003d a;  e \u003d d; \u003cbr\u003e\n     *   e would contain both d and a as modifiers it is dependent on\n     * @param stE StatementElement\n     * @param list ArrayList\n     */\n    private void createArrayListOfModifiers(StatementElement stE, ArrayList\u003cString\u003e list) {\n        for (StatementElement tmpEl : stE.getModifiers()) {\n            list.add(tmpEl.getElementName());\n            if (tmpEl.getModifiers().size() \u003e 0) {\n                createArrayListOfModifiers(tmpEl, list);\n            }\n        }\n    }\n\n    /**\n     * recusive method to analyze statements\n     * @param parentNode ASTNode\n     * @param statementList ArrayList\n     * @param isInSelection boolean\n     * @param isInIteration boolean\n     */\n    private void statements(ASTNode parentNode, ArrayList\u003cStatementDS\u003e statementList, boolean isInSelection, boolean isInIteration) {\n        for (ASTNode childNode : parentNode.list) {\n            if (childNode.getType().equals(\"Selection\")) {\n                statements(childNode, statementList, true, isInIteration);\n            } else if (childNode.getType().equals(\"Iteration\")) {\n                statements(childNode, statementList, isInSelection, true);\n            } else if (childNode.getIdentity().equals(\"StatementExpression\")) {\n                StatementDS tmpDS \u003d analyzeStatement(childNode);\n                tmpDS.setInIteration(isInIteration);\n                tmpDS.setInSelection(isInSelection);\n                statementList.add(tmpDS);\n            }\n        }\n    }\n\n    /**\n     * called for each statement\n     * @param node ASTNode\n     * @return StatementDS\n     */\n    private StatementDS analyzeStatement(ASTNode node) {\n        StatementDS localDS \u003d new StatementDS();\n        int nodeCount \u003d node.list.size();\n        int currCtr \u003d 0;\n        int nxtCtr \u003d nodeCount \u003e 0 ? 1 : 0;\n        // check for preDec ++ or --\n        String firstVal \u003d node.list.get(0).getIdentity();\n        if (firstVal.equals(\"++\") || firstVal.equals(\"--\")) {\n            localDS.setType(StatementDS.statementType.PreInc);\n            currCtr++;\n        }\n        currCtr \u003d getLVal(currCtr, node.list);\n        localDS.setLVal(node.list.get(currCtr).getIdentity());\n        if (currCtr + 1 \u003d\u003d nodeCount) {\n            return localDS;\n        }\n        // have the LVAL and there is a next\n        currCtr++;\n        if (node.list.get(currCtr).getIdentity().equals(\"[\")) {\n            while (!node.list.get(currCtr).getIdentity().equals(\"]\")) {\n                currCtr++;\n            }\n            currCtr++;\n        }\n        if (currCtr + 1 \u003d\u003d nodeCount) {\n            return localDS;\n        }\n        // have the LVAL and there is a next\n        String tmpVl \u003d node.list.get(currCtr).getIdentity();\n        if (tmpVl.equals(\"(\")) {\n            localDS.setType(StatementDS.statementType.MethodCall);\n            return localDS;\n        }\n        if (tmpVl.equals(\"++\") || tmpVl.equals(\"--\")) {\n            localDS.setType(StatementDS.statementType.PostInc);\n            return localDS;\n        }\n        if (tmpVl.equals(\"+\u003d\") || tmpVl.equals(\"\u003d\") || tmpVl.equals(\"-\u003d\") || tmpVl.equals(\"\\\\\u003d\") || tmpVl.equals(\"*\u003d\")) {\n            localDS.setType(StatementDS.statementType.Assignment);\n            currCtr++;\n        }\n        getRVals(localDS, currCtr, node.list);\n        return localDS;\n    }\n\n    /**\n     * called from analyzeStatement - gets a list of RVals in assignment statements\n     * @param locDS StatementDS\n     * @param ctr int\n     * @param list ArrayList\n     */\n    private void getRVals(StatementDS locDS, int ctr, ArrayList\u003cASTNode\u003e list) {\n        // reset to true for each new rval element\n        boolean isFirstToken \u003d true;\n        String currVariable \u003d null;\n        int nodeCount \u003d list.size();\n        String currID \u003d null, nextID \u003d null;\n        StatementElement currEl \u003d null;\n        while (ctr \u003c nodeCount) {\n            currID \u003d list.get(ctr).getIdentity();\n            if (ctr + 1 \u003c nodeCount) {\n                nextID \u003d list.get(ctr + 1).getIdentity();\n            } else {\n                nextID \u003d null;\n            }\n            if (isFirstToken) {\n                currEl \u003d new StatementElement();\n                isFirstToken \u003d false;\n                if (currID.equals(\"++\") || currID.equals(\"--\")) {\n                    currEl.setModified(true);\n                }\n                if (currID.equals(\"(\")) {\n                    ctr++;\n                    continue;\n                }\n            }\n            if (nextID !\u003d null \u0026\u0026 (nextID.equals(\"++\") || nextID.equals(\"--\"))) {\n                currEl.setModified(true);\n                if (currEl.getElementName() \u003d\u003d null) {\n                    currEl.setElementName(currID);\n                }\n            }\n            if (nextID !\u003d null \u0026\u0026 (nextID.equals(\")\"))) {\n                if (currEl.getElementName() \u003d\u003d null) {\n                    currEl.setElementName(currID);\n                }\n                ctr++;\n                continue;\n            }\n            if (nextID !\u003d null \u0026\u0026 nextID.equals(\".\")) {\n                ctr +\u003d 2;\n                continue;\n            }\n            if (nextID \u003d\u003d null || isOperator(nextID)) {\n                if (currEl.getElementName() \u003d\u003d null) {\n                    currEl.setElementName(currID);\n                }\n                locDS.addRVal(currEl);\n                // set for the next element\n                isFirstToken \u003d true;\n                ctr++;\n                continue;\n            }\n            if (currID.equals(\"new\")) {\n                currEl.setType(StatementElement.variableType.ClassInitiator);\n            }\n            if (nextID !\u003d null \u0026\u0026 nextID.equals(\"(\")) {\n                if (currEl.getType() \u003d\u003d null) {\n                    currEl.setType(StatementElement.variableType.MethodCall);\n                }\n                if (currEl.getElementName() \u003d\u003d null) {\n                    currEl.setElementName(currID);\n                }\n            }\n            // ignore the array subscripts\n            if (nextID !\u003d null \u0026\u0026 nextID.equals(\"[\")) {\n                if (currEl.getElementName() \u003d\u003d null) {\n                    currEl.setElementName(currID);\n                }\n                String tmpVal \u003d list.get(ctr).getIdentity();\n                while (!tmpVal.equals(\"]\")) {\n                    ctr++;\n                    tmpVal \u003d list.get(ctr).getIdentity();\n                }\n                if (ctr \u003d\u003d nodeCount - 1) {\n                    locDS.addRVal(currEl);\n                }\n            }\n            ctr++;\n        }\n        // end while loop\n    }\n\n    /**\n     * helper function - checks for delimiters in a equation where delimiters \u003cbr\u003e\n     * are defined as arithmetic operands such as \u0027+\u0027 and \u0027-\u0027\n     * @param id String\n     * @return boolean\n     */\n    private boolean isOperator(String id) {\n        if (id \u003d\u003d null) {\n            return false;\n        }\n        if (id.equals(\"+\") || id.equals(\"-\") || id.equals(\"\\\\\") || id.equals(\"*\") || id.equals(\"\u003c\u003c\") || id.equals(\"\u003e\u003e\") || id.equals(\"%\")) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * gets the variable name for the lVal of an expression\n     * @param ctr int\n     * @param list ArrayList\n     * @return int\n     */\n    private int getLVal(int ctr, ArrayList\u003cASTNode\u003e list) {\n        // do until the LVal is found\n        // lval is an identity that does not have a \u0027.\u0027 as the next identity\n        // ie.   java.util.Type   in this instance Type is the LVal\n        int nodeCount \u003d list.size();\n        String currID \u003d null, nextID \u003d null;\n        while (ctr \u003c nodeCount) {\n            currID \u003d list.get(ctr).getIdentity();\n            if (ctr + 1 \u003c nodeCount) {\n                nextID \u003d list.get(ctr + 1).getIdentity();\n            } else {\n                return ctr;\n            }\n            if (!nextID.equals(\".\")) {\n                return ctr;\n            }\n            ctr +\u003d 2;\n        }\n        return ctr;\n    }\n\n    /**\n     * write the report header to output\n     */\n    private void setHeader() {\n        output.append(\"\\nFile:  \");\n        output.append(fileName);\n        output.append(\"\\n\");\n    }\n\n    /**\n     * Store the file name parsed for formatted display purposes\n     * @param fileName String\n     */\n    public void setFileName(String fileName) {\n        this.fileName \u003d fileName;\n    }\n}\n\n/**\n *  represents a variable in an expression\n */\nclass StatementElement {\n\n    /**\n     * marked true if this variable is modifed in the method\n     */\n    private boolean hasBeenModified \u003d false;\n\n    /**\n     * represents the variable name\n     */\n    private String elementName \u003d null;\n\n    /**\n     * set true if variable is within a if statement\n     */\n    private boolean isInSelection \u003d false;\n\n    /**\n     * set true if variable is within an interation block\n     */\n    private boolean isInIteration \u003d false;\n\n    /**\n     * list of elements that have modified this element \u003cbr\u003e\n     * a recursive descent of elements will get a chain of modifiers\n     */\n    private ArrayList\u003cStatementElement\u003e modifiers \u003d new ArrayList\u003cStatementElement\u003e();\n\n    /**\n     * add a variable to the modifier list\n     * @param rval StatementElement\n     */\n    public void addModifier(StatementElement rval) {\n        modifiers.add(rval);\n    }\n\n    /**\n     * return a reference to the modifier list\n     * @return ArrayList\n     */\n    public ArrayList\u003cStatementElement\u003e getModifiers() {\n        return modifiers;\n    }\n\n    /**\n     *  enumeration of types\n     */\n    public static enum variableType {\n\n        ClassVariable, LocalVariable, MethodCall, ClassInitiator\n    }\n\n    /**\n     * local variableType represent the type of variable this is\n     */\n    variableType type \u003d null;\n\n    /**\n     * default constructor\n     */\n    StatementElement() {\n    }\n\n    /**\n     *  setter for the variable name\n     * @param name String\n     */\n    StatementElement(String name) {\n        setElementName(name);\n    }\n\n    /**\n     * getter for the type : see enum variableType\n     * @return variableType\n     */\n    variableType getType() {\n        return type;\n    }\n\n    /**\n     * setter for the variable type\n     * @param t variableType\n     */\n    void setType(variableType t) {\n        type \u003d t;\n    }\n\n    /**\n     * setter for the name\n     * @param name String\n     */\n    void setElementName(String name) {\n        elementName \u003d name;\n    }\n\n    /**\n     * getter for the boolean flag hasBeenModified\n     * @return boolean\n     */\n    boolean hasBeenModified() {\n        return hasBeenModified;\n    }\n\n    /**\n     * getter for the variable name\n     * @return String\n     */\n    String getElementName() {\n        return elementName;\n    }\n\n    /**\n     * setter for the boolean flag has been modified\n     * @param val boolean\n     */\n    void setModified(boolean val) {\n        hasBeenModified \u003d val;\n    }\n\n    /**\n     * override of toString provides information for debugging/development\n     * @return String\n     */\n    public String toString() {\n        String tmp \u003d elementName;\n        if (hasBeenModified) {\n            tmp +\u003d \" (modified) \";\n        }\n        if (type !\u003d null) {\n            tmp +\u003d \" (\" + type.toString() + \") \";\n        }\n        for (StatementElement element : modifiers) {\n            tmp +\u003d element.toString();\n        }\n        return tmp;\n    }\n\n    /**\n     * getter for the boolean flag isInSelection\n     * @return boolean\n     */\n    boolean isInSelection() {\n        return isInSelection;\n    }\n\n    /**\n     * getter for the boolean flag isInIteration\n     * @return boolean\n     */\n    boolean isInIteration() {\n        return isInIteration;\n    }\n\n    /**\n     * setter for isInSelection\n     * @param val boolean\n     */\n    void setInSelection(boolean val) {\n        isInSelection \u003d val;\n    }\n\n    /**\n     * setter for isInIteration\n     * @param val boolean\n     */\n    void setInIteration(boolean val) {\n        isInIteration \u003d val;\n    }\n}\n\n// end class\n/**\n *   represents an expression statement \u003cbr\u003e\n *   has Statment Elements  : one lVal and 0 . . . n rVals\n */\nclass StatementDS {\n\n    private StatementElement lVal \u003d null;\n\n    private ArrayList\u003cStatementElement\u003e rValList \u003d new ArrayList\u003cStatementElement\u003e();\n\n    public static enum statementType {\n\n        PreInc, PostInc, Assignment, MethodCall\n    }\n\n    private statementType type \u003d null;\n\n    private boolean isInSelection \u003d false;\n\n    private boolean isInIteration \u003d false;\n\n    statementType getType() {\n        return type;\n    }\n\n    /**\n     * add a rVal to the list\n     * @param rv StatementElement\n     */\n    void addRVal(StatementElement rv) {\n        rValList.add(rv);\n    }\n\n    /**\n     * set statement type: see  enum statementType\n     * @param t statementType\n     */\n    void setType(statementType t) {\n        type \u003d t;\n    }\n\n    /**\n     * get a reference to the list of rVals\n     * @return ArrayList\n     */\n    ArrayList\u003cStatementElement\u003e getRVals() {\n        return rValList;\n    }\n\n    /**\n     * override of toString contains information for debugging\n     * @return String\n     */\n    public String toString() {\n        String tmp \u003d lVal.toString();\n        tmp +\u003d \" : \" + type.toString();\n        if (this.isInIteration()) {\n            tmp +\u003d \" (Iteration) \";\n        }\n        if (this.isInSelection()) {\n            tmp +\u003d \" (Selection) \";\n        }\n        for (StatementElement rVal : rValList) {\n            tmp +\u003d \" :\u003d \" + rVal.toString();\n        }\n        return tmp;\n    }\n\n    /**\n     * setter for the LVal\n     * @param rv StatementElement\n     */\n    void setLVal(StatementElement rv) {\n        lVal \u003d rv;\n    }\n\n    /**\n     * setter for the LVal\n     * @param id String\n     */\n    void setLVal(String id) {\n        lVal \u003d new StatementElement(id);\n    }\n\n    /**\n     * getter for the LVal\n     * @return StatementElement\n     */\n    StatementElement getLVal() {\n        return lVal;\n    }\n\n    /**\n     * getter for the boolean flag isInSelection\n     * @return boolean\n     */\n    boolean isInSelection() {\n        return isInSelection;\n    }\n\n    /**\n     * getter for the boolean flag isInIteration\n     * @return boolean\n     */\n    boolean isInIteration() {\n        return isInIteration;\n    }\n\n    /**\n     * setter for isInSelection\n     * @param val boolean\n     */\n    void setInSelection(boolean val) {\n        isInSelection \u003d val;\n    }\n\n    /**\n     * setter for isInIteration\n     * @param val boolean\n     */\n    void setInIteration(boolean val) {\n        isInIteration \u003d val;\n    }\n}\n",
    "package": "com.soops.CEN4010.JMCA",
    "classname": "JMCAAnalyzer",
    "id": "/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAAnalyzer.java",
    "test_prompt": "// JMCAAnalyzerTest.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMCAAnalyzer}.\n* It contains ten unit test cases for the {@link JMCAAnalyzer#analyze(ASTNode)} method.\n*/\nclass JMCAAnalyzerTest {",
    "method_signature": "analyze(ASTNode)",
    "suffix": ""
  }
]