[
  {
    "numberTests": "ten",
    "original_code": "// GenericSortedListModel.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.swing.preferences;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\nimport javax.swing.*;\r\n\r\npublic class GenericSortedListModel\u003cT extends Comparable\u003e extends AbstractListModel {\r\n\r\n    private final List\u003cT\u003e data;\r\n\r\n    private final Comparator\u003cT\u003e comparator;\r\n\r\n    public GenericSortedListModel() {\r\n        this(null);\r\n    }\r\n\r\n    public GenericSortedListModel(Comparator\u003cT\u003e comparator) {\r\n        this.data \u003d new ArrayList\u003cT\u003e();\r\n        this.comparator \u003d comparator;\r\n    }\r\n\r\n    public void setData(List\u003cT\u003e data) {\r\n        if (!this.data.equals(data)) {\r\n            int size \u003d this.data.size();\r\n            if (size \u003e 0) {\r\n                this.data.clear();\r\n                fireIntervalRemoved(this, 0, size - 1);\r\n            }\r\n            size \u003d data.size();\r\n            if (size \u003e 0) {\r\n                this.data.addAll(data);\r\n                if (comparator !\u003d null) {\r\n                    Collections.sort(this.data, comparator);\r\n                } else {\r\n                    Collections.sort(this.data);\r\n                }\r\n                fireIntervalAdded(this, 0, size - 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public List\u003cT\u003e getData() {\r\n        return new ArrayList\u003cT\u003e(data);\r\n    }\r\n\r\n    public void add(T element) {\r\n        if (!data.contains(element)) {\r\n            data.add(element);\r\n            if (comparator !\u003d null) {\r\n                Collections.sort(this.data, comparator);\r\n            } else {\r\n                Collections.sort(this.data);\r\n            }\r\n            int size \u003d data.size();\r\n            fireContentsChanged(this, 0, size - 1);\r\n        }\r\n    }\r\n\r\n    public void remove(T element) {\r\n        int index \u003d data.indexOf(element);\r\n        if (index \u003e\u003d 0) {\r\n            data.remove(index);\r\n            fireIntervalRemoved(this, index, index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the length of the list.\r\n     *\r\n     * @return the length of the list\r\n     */\r\n    public int getSize() {\r\n        return data.size();\r\n    }\r\n\r\n    /**\r\n     * Returns the value at the specified index.\r\n     *\r\n     * @param index the requested index\r\n     * @return the value at \u003ccode\u003eindex\u003c/code\u003e\r\n     */\r\n    public T getElementAt(int index) {\r\n        return data.get(index);\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.swing.preferences",
    "classname": "GenericSortedListModel",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/preferences/GenericSortedListModel.java",
    "test_prompt": "// GenericSortedListModelTest.java\npackage de.huxhorn.lilith.swing.preferences;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GenericSortedListModel}.\n* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.\n*/\nclass GenericSortedListModelTest {",
    "method_signature": "getElementAt(int)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// IndexingCallable.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.swing.callables;\r\n\r\nimport de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.FileHeader;\r\nimport de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.IndexStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;\r\nimport de.huxhorn.sulky.tasks.AbstractProgressingCallable;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.io.RandomAccessFile;\r\n\r\n/**\r\n * Should only be executed on inactive files.\r\n */\r\npublic class IndexingCallable extends AbstractProgressingCallable\u003cLong\u003e {\r\n\r\n    private final Logger logger \u003d LoggerFactory.getLogger(IndexingCallable.class);\r\n\r\n    private File dataFile;\r\n\r\n    private File indexFile;\r\n\r\n    public IndexingCallable(File dataFile, File indexFile) {\r\n        this.dataFile \u003d dataFile;\r\n        this.indexFile \u003d indexFile;\r\n    }\r\n\r\n    /**\r\n     * Computes a result, or throws an exception if unable to do so.\r\n     *\r\n     * @return computed result\r\n     * @throws Exception if unable to compute a result\r\n     */\r\n    public Long call() throws Exception {\r\n        if (!dataFile.exists()) {\r\n            throw new FileNotFoundException(\"File \u0027\" + dataFile.getAbsolutePath() + \"\u0027 does not exist!\");\r\n        }\r\n        if (!dataFile.isFile()) {\r\n            throw new FileNotFoundException(\"File \u0027\" + dataFile.getAbsolutePath() + \"\u0027 is not a file!\");\r\n        }\r\n        long fileSize \u003d dataFile.length();\r\n        setNumberOfSteps(fileSize);\r\n        FileHeaderStrategy fhs \u003d new DefaultFileHeaderStrategy();\r\n        FileHeader fileHeader \u003d fhs.readFileHeader(dataFile);\r\n        if (fileHeader !\u003d null) {\r\n            boolean sparse \u003d fileHeader.getMetaData().isSparse();\r\n            long offset \u003d fileHeader.getDataOffset();\r\n            RandomAccessFile dataRAFile \u003d null;\r\n            RandomAccessFile indexRAFile \u003d null;\r\n            Exception ex \u003d null;\r\n            long counter \u003d 0;\r\n            IndexStrategy indexStrategy \u003d new DefaultIndexStrategy();\r\n            try {\r\n                dataRAFile \u003d new RandomAccessFile(dataFile, \"r\");\r\n                indexRAFile \u003d new RandomAccessFile(indexFile, \"rw\");\r\n                indexRAFile.setLength(0);\r\n                while (offset \u003c fileSize) {\r\n                    dataRAFile.seek(offset);\r\n                    int dataSize \u003d dataRAFile.readInt();\r\n                    if (!sparse) {\r\n                        indexStrategy.setOffset(indexRAFile, counter, offset);\r\n                        offset \u003d offset + dataSize + DefaultDataStrategy.DATA_LENGTH_SIZE;\r\n                    } else {\r\n                        long index \u003d dataRAFile.readLong();\r\n                        indexStrategy.setOffset(indexRAFile, index, offset);\r\n                        offset \u003d offset + dataSize + SparseDataStrategy.DATA_LENGTH_SIZE + SparseDataStrategy.INDEX_SIZE;\r\n                    }\r\n                    counter++;\r\n                    setCurrentStep(offset);\r\n                }\r\n            } catch (IOException e) {\r\n                ex \u003d e;\r\n            } catch (InterruptedException e) {\r\n                ex \u003d e;\r\n            } finally {\r\n                closeQuietly(dataRAFile);\r\n                closeQuietly(indexRAFile);\r\n            }\r\n            if (ex !\u003d null) {\r\n                if (!indexFile.delete()) {\r\n                    if (logger.isWarnEnabled()) {\r\n                        logger.warn(\"Failed to delete index file \u0027{}\u0027!\", indexFile.getAbsolutePath());\r\n                    }\r\n                }\r\n                // rethrow\r\n                throw ex;\r\n            }\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"File \u0027{}\u0027 has {} entries.\", dataFile.getAbsolutePath(), counter);\r\n            return counter;\r\n        } else {\r\n            throw new IllegalArgumentException(\"File \u0027\" + dataFile.getAbsolutePath() + \"\u0027 is not a valid file!\");\r\n        }\r\n    }\r\n\r\n    public File getDataFile() {\r\n        return dataFile;\r\n    }\r\n\r\n    public File getIndexFile() {\r\n        return indexFile;\r\n    }\r\n\r\n    private static void closeQuietly(RandomAccessFile file) {\r\n        if (file !\u003d null) {\r\n            try {\r\n                file.close();\r\n            } catch (IOException e) {\r\n                // ignore\r\n            }\r\n        }\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.swing.callables",
    "classname": "IndexingCallable",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/callables/IndexingCallable.java",
    "test_prompt": "// IndexingCallableTest.java\npackage de.huxhorn.lilith.swing.callables;\n\nimport de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.FileHeader;\nimport de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.IndexStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;\nimport de.huxhorn.sulky.tasks.AbstractProgressingCallable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link IndexingCallable}.\n* It contains ten unit test cases for the {@link IndexingCallable#call()} method.\n*/\nclass IndexingCallableTest {",
    "method_signature": "call()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// ApplicationPreferences.java\n/*\n * Lilith - a log event viewer.\n * Copyright (C) 2007-2009 Joern Huxhorn\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\npackage de.huxhorn.lilith.swing;\n\nimport de.huxhorn.lilith.Lilith;\nimport de.huxhorn.lilith.LilithSounds;\nimport de.huxhorn.lilith.data.access.HttpStatus;\nimport de.huxhorn.lilith.data.logging.LoggingEvent;\nimport de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;\nimport de.huxhorn.lilith.swing.preferences.SavedCondition;\nimport de.huxhorn.lilith.swing.table.ColorScheme;\nimport de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;\nimport de.huxhorn.sulky.conditions.Condition;\nimport org.apache.commons.io.IOUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.awt.*;\nimport java.beans.Encoder;\nimport java.beans.Expression;\nimport java.beans.PersistenceDelegate;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.prefs.BackingStoreException;\nimport java.util.prefs.Preferences;\nimport javax.swing.*;\n\npublic class ApplicationPreferences {\n\n    public static enum SourceFiltering {\n\n        NONE, BLACKLIST, WHITELIST\n    }\n\n    private static final Preferences PREFERENCES \u003d Preferences.userNodeForPackage(ApplicationPreferences.class);\n\n    private static final String STATUS_COLORS_XML_FILENAME \u003d \"statusColors.xml\";\n\n    private static final String LEVEL_COLORS_XML_FILENAME \u003d \"levelColors.xml\";\n\n    private static final String DETAILS_VIEW_ROOT_FOLDER \u003d \"detailsView\";\n\n    public static final String DETAILS_VIEW_CSS_FILENAME \u003d \"detailsView.css\";\n\n    public static final String DETAILS_VIEW_GROOVY_FILENAME \u003d \"detailsView.groovy\";\n\n    private static final String CONDITIONS_XML_FILENAME \u003d \"savedConditions.xml\";\n\n    public static final String STATUS_COLORS_PROPERTY \u003d \"statusColors\";\n\n    public static final String LEVEL_COLORS_PROPERTY \u003d \"levelColors\";\n\n    public static final String LOOK_AND_FEEL_PROPERTY \u003d \"lookAndFeel\";\n\n    public static final String CLEANING_LOGS_ON_EXIT_PROPERTY \u003d \"cleaningLogsOnExit\";\n\n    public static final String COLORING_WHOLE_ROW_PROPERTY \u003d \"coloringWholeRow\";\n\n    public static final String SHOWING_IDENTIFIER_PROPERTY \u003d \"showingIdentifier\";\n\n    public static final String SHOWING_FULL_CALLSTACK_PROPERTY \u003d \"showingFullCallstack\";\n\n    public static final String SHOWING_STACKTRACE_PROPERTY \u003d \"showingStackTrace\";\n\n    public static final String CHECKING_FOR_UPDATE_PROPERTY \u003d \"checkingForUpdate\";\n\n    public static final String SOURCE_FILTERING_PROPERTY \u003d \"sourceFiltering\";\n\n    public static final String SOUND_LOCATIONS_PROPERTY \u003d \"soundLocations\";\n\n    public static final String MUTE_PROPERTY \u003d \"mute\";\n\n    public static final String USING_INTERNAL_FRAMES_PROPERTY \u003d \"usingInternalFrames\";\n\n    public static final String SCROLLING_TO_BOTTOM_PROPERTY \u003d \"scrollingToBottom\";\n\n    public static final String SOURCE_NAMES_PROPERTY \u003d \"sourceNames\";\n\n    public static final String APPLICATION_PATH_PROPERTY \u003d \"applicationPath\";\n\n    public static final String AUTO_OPENING_PROPERTY \u003d \"autoOpening\";\n\n    public static final String AUTO_CLOSING_PROPERTY \u003d \"autoClosing\";\n\n    public static final String IMAGE_PATH_PROPERTY \u003d \"imagePath\";\n\n    public static final String SOUND_PATH_PROPERTY \u003d \"soundPath\";\n\n    public static final String AUTO_FOCUSING_WINDOW_PROPERTY \u003d \"autoFocusingWindow\";\n\n    public static final String SOURCE_LISTS_PROPERTY \u003d \"sourceLists\";\n\n    public static final String BLACK_LIST_NAME_PROPERTY \u003d \"blackListName\";\n\n    public static final String WHITE_LIST_NAME_PROPERTY \u003d \"whiteListName\";\n\n    public static final String CONDITIONS_PROPERTY \u003d \"conditions\";\n\n    public static final String SPLASH_SCREEN_DISABLED_PROPERTY \u003d \"splashScreenDisabled\";\n\n    public static final String ASKING_BEFORE_QUIT_PROPERTY \u003d \"askingBeforeQuit\";\n\n    public static final String LOGGING_LAYOUT_GLOBAL_XML_FILENAME \u003d \"loggingLayoutGlobal.xml\";\n\n    public static final String LOGGING_LAYOUT_XML_FILENAME \u003d \"loggingLayout.xml\";\n\n    public static final String ACCESS_LAYOUT_GLOBAL_XML_FILENAME \u003d \"accessLayoutGlobal.xml\";\n\n    public static final String ACCESS_LAYOUT_XML_FILENAME \u003d \"accessLayout.xml\";\n\n    public static final String SOURCE_NAMES_XML_FILENAME \u003d \"SourceNames.xml\";\n\n    public static final String SOURCE_LISTS_XML_FILENAME \u003d \"SourceLists.xml\";\n\n    public static final String SOURCE_NAMES_PROPERTIES_FILENAME \u003d \"SourceNames.properties\";\n\n    public static final String SOUND_LOCATIONS_XML_FILENAME \u003d \"SoundLocations.xml\";\n\n    public static final String SOUND_LOCATIONS_PROPERTIES_FILENAME \u003d \"SoundLocations.properties\";\n\n    public static final String PREVIOUS_APPLICATION_PATH_FILENAME \u003d \".previous.application.path\";\n\n    private static final String OLD_LICENSED_PREFERENCES_KEY \u003d \"licensed\";\n\n    private static final String LICENSED_PREFERENCES_KEY \u003d \"licensedVersion\";\n\n    public static final String USER_HOME;\n\n    public static final String DEFAULT_APPLICATION_PATH;\n\n    private static final Map\u003cString, String\u003e DEFAULT_SOURCE_NAMES;\n\n    private static final Map\u003cString, String\u003e DEFAULT_SOUND_LOCATIONS;\n\n    private static final Map\u003cLoggingEvent.Level, ColorScheme\u003e DEFAULT_LEVEL_COLORS;\n\n    private static final Map\u003cHttpStatus.Type, ColorScheme\u003e DEFAULT_STATUS_COLORS;\n\n    private static final String PREVIOUS_OPEN_PATH_PROPERTY \u003d \"previousOpenPath\";\n\n    private static final String PREVIOUS_IMPORT_PATH_PROPERTY \u003d \"previousImportPath\";\n\n    public static final String STARTUP_LOOK_AND_FEEL;\n\n    private static final long CONDITIONS_CHECK_INTERVAL \u003d 30000;\n\n    private static final String GROOVY_SUFFIX \u003d \".groovy\";\n\n    private static final String EXAMPLE_GROOVY_BASE \u003d \"/conditions/\";\n\n    private static final String EXAMPLE_GROOVY_LIST \u003d \"conditions.txt\";\n\n    static {\n        // remove garbage\n        PREFERENCES.remove(OLD_LICENSED_PREFERENCES_KEY);\n        USER_HOME \u003d System.getProperty(\"user.home\");\n        File defaultAppPath \u003d new File(USER_HOME, \".lilith\");\n        DEFAULT_APPLICATION_PATH \u003d defaultAppPath.getAbsolutePath();\n        Map\u003cString, String\u003e defaultSoundLocations \u003d new HashMap\u003cString, String\u003e();\n        defaultSoundLocations.put(LilithSounds.SOURCE_ADDED, \"/events/SourceAdded.mp3\");\n        defaultSoundLocations.put(LilithSounds.SOURCE_REMOVED, \"/events/SourceRemoved.mp3\");\n        defaultSoundLocations.put(LilithSounds.ERROR_EVENT_ALARM, \"/events/ErrorEventAlarm.mp3\");\n        DEFAULT_SOUND_LOCATIONS \u003d Collections.unmodifiableMap(defaultSoundLocations);\n        Map\u003cString, String\u003e defaultSourceNames \u003d new HashMap\u003cString, String\u003e();\n        defaultSourceNames.put(\"127.0.0.1\", \"Localhost\");\n        DEFAULT_SOURCE_NAMES \u003d Collections.unmodifiableMap(defaultSourceNames);\n        HashMap\u003cLoggingEvent.Level, ColorScheme\u003e defaultLevelColors \u003d new HashMap\u003cLoggingEvent.Level, ColorScheme\u003e();\n        defaultLevelColors.put(LoggingEvent.Level.TRACE, new ColorScheme(new Color(0x1F, 0x44, 0x58), new Color(0x80, 0xBA, 0xD9)));\n        defaultLevelColors.put(LoggingEvent.Level.DEBUG, new ColorScheme(Color.BLACK, Color.GREEN));\n        defaultLevelColors.put(LoggingEvent.Level.INFO, new ColorScheme(Color.BLACK, Color.WHITE));\n        defaultLevelColors.put(LoggingEvent.Level.WARN, new ColorScheme(Color.BLACK, Color.YELLOW));\n        defaultLevelColors.put(LoggingEvent.Level.ERROR, new ColorScheme(Color.YELLOW, Color.RED, Color.ORANGE));\n        DEFAULT_LEVEL_COLORS \u003d Collections.unmodifiableMap(defaultLevelColors);\n        HashMap\u003cHttpStatus.Type, ColorScheme\u003e defaultStatusColors \u003d new HashMap\u003cHttpStatus.Type, ColorScheme\u003e();\n        defaultStatusColors.put(HttpStatus.Type.SUCCESSFUL, new ColorScheme(Color.BLACK, Color.GREEN));\n        defaultStatusColors.put(HttpStatus.Type.INFORMATIONAL, new ColorScheme(Color.BLACK, Color.WHITE));\n        defaultStatusColors.put(HttpStatus.Type.REDIRECTION, new ColorScheme(Color.BLACK, Color.YELLOW));\n        defaultStatusColors.put(HttpStatus.Type.CLIENT_ERROR, new ColorScheme(Color.GREEN, Color.RED, Color.ORANGE));\n        defaultStatusColors.put(HttpStatus.Type.SERVER_ERROR, new ColorScheme(Color.YELLOW, Color.RED, Color.ORANGE));\n        DEFAULT_STATUS_COLORS \u003d Collections.unmodifiableMap(defaultStatusColors);\n        STARTUP_LOOK_AND_FEEL \u003d UIManager.getLookAndFeel().getName();\n    }\n\n    private final Logger logger \u003d LoggerFactory.getLogger(ApplicationPreferences.class);\n\n    private PropertyChangeSupport propertyChangeSupport;\n\n    private File startupApplicationPath;\n\n    private File detailsViewRoot;\n\n    private ArrayList\u003cString\u003e installedLookAndFeels;\n\n    private String[] conditionScriptFiles;\n\n    private long lastConditionsCheck;\n\n    private Map\u003cLoggingEvent.Level, ColorScheme\u003e levelColors;\n\n    private Map\u003cHttpStatus.Type, ColorScheme\u003e statusColors;\n\n    private URL detailsViewRootUrl;\n\n    /**\n     * Identifier \u003d\u003e Name\n     */\n    private Map\u003cString, String\u003e sourceNames;\n\n    private long lastSourceNamesModified;\n\n    private long lastConditionsModified;\n\n    private Map\u003cString, String\u003e soundLocations;\n\n    private long lastSoundLocationsModified;\n\n    private Map\u003cString, Set\u003cString\u003e\u003e sourceLists;\n\n    private long lastSourceListsModified;\n\n    private SourceFiltering sourceFiltering;\n\n    private Set\u003cString\u003e blackList;\n\n    private Set\u003cString\u003e whiteList;\n\n    private List\u003cSavedCondition\u003e conditions;\n\n    private File groovyConditionsPath;\n\n    public ApplicationPreferences() {\n        lastSourceNamesModified \u003d -1;\n        lastConditionsModified \u003d -1;\n        propertyChangeSupport \u003d new PropertyChangeSupport(this);\n        startupApplicationPath \u003d getApplicationPath();\n        installedLookAndFeels \u003d new ArrayList\u003cString\u003e();\n        for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {\n            installedLookAndFeels.add(info.getName());\n        }\n        Collections.sort(installedLookAndFeels);\n        groovyConditionsPath \u003d new File(startupApplicationPath, \"conditions\");\n        if (groovyConditionsPath.mkdirs()) {\n            // groovy Conditions was generated, create examples...\n            installExampleConditions();\n        }\n    }\n\n    public File resolveConditionScriptFile(String input) {\n        if (!input.endsWith(GROOVY_SUFFIX)) {\n            input \u003d input + GROOVY_SUFFIX;\n        }\n        File scriptFile \u003d new File(groovyConditionsPath, input);\n        if (scriptFile.isFile()) {\n            return scriptFile;\n        }\n        return null;\n    }\n\n    public String[] getAllConditionScriptFiles() {\n        if (conditionScriptFiles \u003d\u003d null || ((System.currentTimeMillis() - lastConditionsCheck) \u003e CONDITIONS_CHECK_INTERVAL)) {\n            File[] groovyFiles \u003d groovyConditionsPath.listFiles(new GroovyConditionFileFilter());\n            if (groovyFiles !\u003d null \u0026\u0026 groovyFiles.length \u003e 0) {\n                conditionScriptFiles \u003d new String[groovyFiles.length];\n                for (int i \u003d 0; i \u003c groovyFiles.length; i++) {\n                    File current \u003d groovyFiles[i];\n                    conditionScriptFiles[i] \u003d current.getName();\n                }\n                Arrays.sort(conditionScriptFiles);\n                lastConditionsCheck \u003d System.currentTimeMillis();\n            }\n        }\n        return conditionScriptFiles;\n    }\n\n    public void installExampleConditions() {\n        String path \u003d EXAMPLE_GROOVY_BASE + EXAMPLE_GROOVY_LIST;\n        URL url \u003d ApplicationPreferences.class.getResource(path);\n        if (url \u003d\u003d null) {\n            if (logger.isErrorEnabled())\n                logger.error(\"Couldn\u0027t find resource at \" + path + \"!\");\n        } else {\n            List\u003cString\u003e lines \u003d readLines(url);\n            for (String current : lines) {\n                path \u003d EXAMPLE_GROOVY_BASE + current;\n                url \u003d ApplicationPreferences.class.getResource(path);\n                if (url \u003d\u003d null) {\n                    if (logger.isErrorEnabled())\n                        logger.error(\"Couldn\u0027t find resource at \" + path + \"!\");\n                    continue;\n                }\n                File target \u003d new File(groovyConditionsPath, current);\n                copy(url, target, true);\n            }\n        }\n    }\n\n    private void initLevelColors() {\n        if (levelColors \u003d\u003d null) {\n            File appPath \u003d getStartupApplicationPath();\n            File levelColorsFile \u003d new File(appPath, LEVEL_COLORS_XML_FILENAME);\n            if (levelColorsFile.isFile()) {\n                XMLDecoder d \u003d null;\n                try {\n                    d \u003d new XMLDecoder(new BufferedInputStream(new FileInputStream(levelColorsFile)));\n                    //noinspection unchecked\n                    levelColors \u003d (Map\u003cLoggingEvent.Level, ColorScheme\u003e) d.readObject();\n                } catch (Throwable ex) {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Exception while loading level colors from sourceListsFile \u0027\" + levelColorsFile.getAbsolutePath() + \"\u0027!\", ex);\n                    }\n                    levelColors \u003d null;\n                } finally {\n                    if (d !\u003d null) {\n                        d.close();\n                    }\n                }\n            }\n        }\n        if (levelColors !\u003d null \u0026\u0026 levelColors.size() !\u003d DEFAULT_LEVEL_COLORS.size()) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Reverting level colors to defaults.\");\n            levelColors \u003d null;\n        }\n        if (levelColors \u003d\u003d null) {\n            levelColors \u003d cloneLevelColors(DEFAULT_LEVEL_COLORS);\n        }\n    }\n\n    private Map\u003cLoggingEvent.Level, ColorScheme\u003e cloneLevelColors(Map\u003cLoggingEvent.Level, ColorScheme\u003e input) {\n        if (input !\u003d null \u0026\u0026 input.size() !\u003d DEFAULT_LEVEL_COLORS.size()) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Reverting colors to defaults.\");\n            input \u003d null;\n        }\n        if (input \u003d\u003d null) {\n            input \u003d DEFAULT_LEVEL_COLORS;\n        }\n        Map\u003cLoggingEvent.Level, ColorScheme\u003e result \u003d new HashMap\u003cLoggingEvent.Level, ColorScheme\u003e();\n        try {\n            for (Map.Entry\u003cLoggingEvent.Level, ColorScheme\u003e current : input.entrySet()) {\n                result.put(current.getKey(), current.getValue().clone());\n            }\n        } catch (Throwable e) {\n            if (logger.isErrorEnabled())\n                logger.error(\"Exception while cloning colors!\", e);\n        }\n        return result;\n    }\n\n    public void setLevelColors(Map\u003cLoggingEvent.Level, ColorScheme\u003e colors) {\n        Object oldValue \u003d getLevelColors();\n        colors \u003d cloneLevelColors(colors);\n        writeLevelColors(colors);\n        this.levelColors \u003d colors;\n        Object newValue \u003d getLevelColors();\n        propertyChangeSupport.firePropertyChange(LEVEL_COLORS_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"LevelColors set to {}.\", this.levelColors);\n    }\n\n    private void writeLevelColors(Map\u003cLoggingEvent.Level, ColorScheme\u003e colors) {\n        File appPath \u003d getStartupApplicationPath();\n        File file \u003d new File(appPath, LEVEL_COLORS_XML_FILENAME);\n        Throwable error \u003d null;\n        try {\n            BufferedOutputStream bos \u003d new BufferedOutputStream(new FileOutputStream(file));\n            XMLEncoder e \u003d new XMLEncoder(bos);\n            PersistenceDelegate delegate \u003d new EnumPersistenceDelegate();\n            e.setPersistenceDelegate(LoggingEvent.Level.class, delegate);\n            e.writeObject(colors);\n            e.close();\n        } catch (Throwable ex) {\n            error \u003d ex;\n        }\n        if (error !\u003d null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing colors!\", error);\n        }\n    }\n\n    public Map\u003cLoggingEvent.Level, ColorScheme\u003e getLevelColors() {\n        if (levelColors \u003d\u003d null) {\n            initLevelColors();\n        }\n        return cloneLevelColors(levelColors);\n    }\n\n    private void initStatusColors() {\n        if (statusColors \u003d\u003d null) {\n            File appPath \u003d getStartupApplicationPath();\n            File statusColorsFile \u003d new File(appPath, STATUS_COLORS_XML_FILENAME);\n            if (statusColorsFile.isFile()) {\n                XMLDecoder d \u003d null;\n                try {\n                    d \u003d new XMLDecoder(new BufferedInputStream(new FileInputStream(statusColorsFile)));\n                    //noinspection unchecked\n                    statusColors \u003d (Map\u003cHttpStatus.Type, ColorScheme\u003e) d.readObject();\n                } catch (Throwable ex) {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Exception while loading status colors from sourceListsFile \u0027\" + statusColorsFile.getAbsolutePath() + \"\u0027!\", ex);\n                    }\n                    statusColors \u003d null;\n                } finally {\n                    if (d !\u003d null) {\n                        d.close();\n                    }\n                }\n            }\n        }\n        if (statusColors !\u003d null \u0026\u0026 statusColors.size() !\u003d DEFAULT_STATUS_COLORS.size()) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Reverting status colors to defaults.\");\n            statusColors \u003d null;\n        }\n        if (statusColors \u003d\u003d null) {\n            statusColors \u003d cloneStatusColors(DEFAULT_STATUS_COLORS);\n        }\n    }\n\n    private Map\u003cHttpStatus.Type, ColorScheme\u003e cloneStatusColors(Map\u003cHttpStatus.Type, ColorScheme\u003e input) {\n        if (input !\u003d null \u0026\u0026 input.size() !\u003d DEFAULT_STATUS_COLORS.size()) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Reverting colors to defaults.\");\n            input \u003d null;\n        }\n        if (input \u003d\u003d null) {\n            input \u003d DEFAULT_STATUS_COLORS;\n        }\n        Map\u003cHttpStatus.Type, ColorScheme\u003e result \u003d new HashMap\u003cHttpStatus.Type, ColorScheme\u003e();\n        try {\n            for (Map.Entry\u003cHttpStatus.Type, ColorScheme\u003e current : input.entrySet()) {\n                result.put(current.getKey(), current.getValue().clone());\n            }\n        } catch (Throwable e) {\n            if (logger.isErrorEnabled())\n                logger.error(\"Exception while cloning colors!\", e);\n        }\n        return result;\n    }\n\n    public void setStatusColors(Map\u003cHttpStatus.Type, ColorScheme\u003e colors) {\n        Object oldValue \u003d getStatusColors();\n        colors \u003d cloneStatusColors(colors);\n        writeStatusColors(colors);\n        this.statusColors \u003d colors;\n        Object newValue \u003d getStatusColors();\n        propertyChangeSupport.firePropertyChange(STATUS_COLORS_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"StatusColors set to {}.\", this.statusColors);\n    }\n\n    private void writeStatusColors(Map\u003cHttpStatus.Type, ColorScheme\u003e colors) {\n        File appPath \u003d getStartupApplicationPath();\n        File file \u003d new File(appPath, STATUS_COLORS_XML_FILENAME);\n        Throwable error \u003d null;\n        try {\n            BufferedOutputStream bos \u003d new BufferedOutputStream(new FileOutputStream(file));\n            XMLEncoder e \u003d new XMLEncoder(bos);\n            PersistenceDelegate delegate \u003d new EnumPersistenceDelegate();\n            e.setPersistenceDelegate(HttpStatus.Type.class, delegate);\n            e.writeObject(colors);\n            e.close();\n        } catch (Throwable ex) {\n            error \u003d ex;\n        }\n        if (error !\u003d null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing colors!\", error);\n        }\n    }\n\n    public Map\u003cHttpStatus.Type, ColorScheme\u003e getStatusColors() {\n        if (statusColors \u003d\u003d null) {\n            initStatusColors();\n        }\n        return cloneStatusColors(statusColors);\n    }\n\n    public void setSourceFiltering(SourceFiltering sourceFiltering) {\n        Object oldValue \u003d getSourceFiltering();\n        PREFERENCES.put(SOURCE_FILTERING_PROPERTY, sourceFiltering.toString());\n        this.sourceFiltering \u003d sourceFiltering;\n        propertyChangeSupport.firePropertyChange(SOURCE_FILTERING_PROPERTY, oldValue, sourceFiltering);\n        if (logger.isInfoEnabled())\n            logger.info(\"SourceFiltering set to {}.\", this.sourceFiltering);\n    }\n\n    private void initSourceLists() {\n        File appPath \u003d getStartupApplicationPath();\n        File sourceListsFile \u003d new File(appPath, SOURCE_LISTS_XML_FILENAME);\n        if (sourceListsFile.isFile()) {\n            long lastModified \u003d sourceListsFile.lastModified();\n            if (sourceLists !\u003d null \u0026\u0026 lastSourceListsModified \u003e\u003d lastModified) {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Won\u0027t reload source lists.\");\n                return;\n            }\n            XMLDecoder d \u003d null;\n            try {\n                d \u003d new XMLDecoder(new BufferedInputStream(new FileInputStream(sourceListsFile)));\n                //noinspection unchecked\n                sourceLists \u003d (Map\u003cString, Set\u003cString\u003e\u003e) d.readObject();\n                lastSourceListsModified \u003d lastModified;\n            } catch (Throwable ex) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"Exception while loading source lists from sourceListsFile \u0027\" + sourceListsFile.getAbsolutePath() + \"\u0027!\", ex);\n                }\n                sourceLists \u003d new HashMap\u003cString, Set\u003cString\u003e\u003e();\n            } finally {\n                if (d !\u003d null) {\n                    d.close();\n                }\n            }\n        } else if (sourceLists \u003d\u003d null) {\n            sourceLists \u003d new HashMap\u003cString, Set\u003cString\u003e\u003e();\n        }\n    }\n\n    public Map\u003cString, Set\u003cString\u003e\u003e getSourceLists() {\n        initSourceLists();\n        return new HashMap\u003cString, Set\u003cString\u003e\u003e(sourceLists);\n    }\n\n    public void setSourceLists(Map\u003cString, Set\u003cString\u003e\u003e sourceLists) {\n        Object oldValue \u003d getSourceLists();\n        writeSourceLists(sourceLists);\n        Object newValue \u003d getSourceLists();\n        blackList \u003d null;\n        whiteList \u003d null;\n        propertyChangeSupport.firePropertyChange(SOURCE_LISTS_PROPERTY, oldValue, newValue);\n    }\n\n    public SourceFiltering getSourceFiltering() {\n        if (sourceFiltering !\u003d null) {\n            return sourceFiltering;\n        }\n        String sf \u003d PREFERENCES.get(SOURCE_FILTERING_PROPERTY, \"NONE\");\n        try {\n            sourceFiltering \u003d SourceFiltering.valueOf(sf);\n        } catch (IllegalArgumentException e) {\n            sourceFiltering \u003d SourceFiltering.NONE;\n        }\n        return sourceFiltering;\n    }\n\n    public void initDetailsViewRoot(boolean overwriteAlways) {\n        detailsViewRoot \u003d new File(startupApplicationPath, DETAILS_VIEW_ROOT_FOLDER);\n        if (detailsViewRoot.mkdirs()) {\n            if (logger.isInfoEnabled())\n                logger.info(\"Created directory {}.\", detailsViewRoot.getAbsolutePath());\n        }\n        try {\n            detailsViewRootUrl \u003d detailsViewRoot.toURI().toURL();\n        } catch (MalformedURLException e) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Exception while creating detailsViewRootUrl for \u0027{}\u0027!\", detailsViewRoot.getAbsolutePath());\n            }\n            detailsViewRootUrl \u003d null;\n        }\n        {\n            String resourcePath \u003d \"/detailsView/\" + DETAILS_VIEW_CSS_FILENAME;\n            String historyBasePath \u003d \"/detailsView/history/detailsView.css/\";\n            File detailsViewCssFile \u003d new File(detailsViewRoot, DETAILS_VIEW_CSS_FILENAME);\n            initIfNecessary(detailsViewCssFile, resourcePath, historyBasePath, overwriteAlways);\n        }\n        {\n            String resourcePath \u003d \"/detailsView/\" + DETAILS_VIEW_GROOVY_FILENAME;\n            String historyBasePath \u003d \"/detailsView/history/detailsView.groovy/\";\n            File detailsViewGroovyFile \u003d new File(detailsViewRoot, DETAILS_VIEW_GROOVY_FILENAME);\n            initIfNecessary(detailsViewGroovyFile, resourcePath, historyBasePath, overwriteAlways);\n        }\n    }\n\n    private void initIfNecessary(File file, String resourcePath, String historyBasePath, boolean overwriteAlways) {\n        boolean delete \u003d false;\n        if (overwriteAlways) {\n            delete \u003d true;\n        } else if (file.isFile()) {\n            byte[] available \u003d null;\n            try {\n                FileInputStream availableFile \u003d new FileInputStream(file);\n                available \u003d getMD5(availableFile);\n            } catch (FileNotFoundException e) {\n                // ignore\n            }\n            byte[] current \u003d getMD5(getClass().getResourceAsStream(resourcePath));\n            if (Arrays.equals(available, current)) {\n                // we are done already. The current version is the latest version.\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"The current version of {} is also the latest version.\", file.getAbsolutePath());\n                }\n                return;\n            }\n            if (available !\u003d null) {\n                // check older versions if available\n                URL historyUrl \u003d getClass().getResource(historyBasePath + \"history.txt\");\n                if (historyUrl !\u003d null) {\n                    List\u003cString\u003e historyList \u003d readLines(historyUrl);\n                    for (String currentLine : historyList) {\n                        InputStream is \u003d getClass().getResourceAsStream(historyBasePath + currentLine + \".md5\");\n                        if (is !\u003d null) {\n                            DataInputStream dis \u003d new DataInputStream(is);\n                            byte[] checksum \u003d new byte[16];\n                            try {\n                                dis.readFully(checksum);\n                                if (Arrays.equals(available, checksum)) {\n                                    if (logger.isInfoEnabled()) {\n                                        logger.info(\"Found old version of {}: {}\", file.getAbsolutePath(), currentLine);\n                                    }\n                                    delete \u003d true;\n                                    break;\n                                }\n                            } catch (IOException e) {\n                                if (logger.isWarnEnabled()) {\n                                    logger.warn(\"Exception while reading checksum of \" + currentLine + \"!\", e);\n                                }\n                            } finally {\n                                try {\n                                    dis.close();\n                                } catch (IOException e) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                // we couldn\u0027t calculate the checksum. Try to delete it...\n                delete \u003d true;\n            }\n        }\n        URL resourceUrl \u003d ApplicationPreferences.class.getResource(resourcePath);\n        if (resourceUrl \u003d\u003d null) {\n            if (logger.isErrorEnabled())\n                logger.error(\"Couldn\u0027t find resource {}!\", resourcePath);\n            return;\n        }\n        copy(resourceUrl, file, delete);\n    }\n\n    private void copy(URL source, File target, boolean overwrite) {\n        if (overwrite) {\n            if (target.isFile()) {\n                if (target.delete()) {\n                    if (logger.isInfoEnabled())\n                        logger.info(\"Deleted {}. \", target.getAbsolutePath());\n                } else {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Tried to delete {} but couldn\u0027t!\", target.getAbsolutePath());\n                    }\n                }\n            }\n        }\n        if (!target.isFile()) {\n            InputStream is \u003d null;\n            FileOutputStream os \u003d null;\n            try {\n                os \u003d new FileOutputStream(target);\n                is \u003d source.openStream();\n                IOUtils.copy(is, os);\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Initialized file at \u0027{}\u0027 with data from \u0027{}\u0027.\", target.getAbsolutePath(), source);\n                }\n            } catch (IOException e) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"Exception while initializing \u0027\" + target.getAbsolutePath() + \"\u0027 with data from \u0027\" + source + \"\u0027.!\", e);\n                }\n            } finally {\n                IOUtils.closeQuietly(is);\n                IOUtils.closeQuietly(os);\n            }\n        } else {\n            if (logger.isInfoEnabled())\n                logger.info(\"Won\u0027t overwrite \u0027{}\u0027.\", target.getAbsolutePath());\n        }\n    }\n\n    /**\n     * Returns a list of strings containing all non-empty, non-comment lines found in the given URL.\n     * Commented lines start with a #.\n     *\n     * @param url the URL to read the lines from.\n     * @return a List of type String containing all non-empty, non-comment lines.\n     */\n    private List\u003cString\u003e readLines(URL url) {\n        List\u003cString\u003e result \u003d new ArrayList\u003cString\u003e();\n        BufferedReader reader \u003d null;\n        try {\n            reader \u003d new BufferedReader(new InputStreamReader(url.openStream()));\n            for (; ; ) {\n                String currentLine \u003d reader.readLine();\n                if (currentLine \u003d\u003d null) {\n                    break;\n                }\n                currentLine \u003d currentLine.trim();\n                if (!\"\".equals(currentLine) \u0026\u0026 !currentLine.startsWith(\"#\")) {\n                    result.add(currentLine);\n                }\n            }\n        } catch (IOException e) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while reading lines from \" + url + \"!\", e);\n        } finally {\n            if (reader !\u003d null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n        return result;\n    }\n\n    public File getDetailsViewRoot() {\n        if (detailsViewRoot !\u003d null) {\n            return detailsViewRoot;\n        }\n        initDetailsViewRoot(false);\n        return detailsViewRoot;\n    }\n\n    public URL getDetailsViewRootUrl() {\n        if (detailsViewRootUrl !\u003d null) {\n            return detailsViewRootUrl;\n        }\n        initDetailsViewRoot(false);\n        return detailsViewRootUrl;\n    }\n\n    public boolean isValidSource(String source) {\n        if (source \u003d\u003d null) {\n            return false;\n        }\n        SourceFiltering filtering \u003d getSourceFiltering();\n        switch(filtering) {\n            case BLACKLIST:\n                return !isBlackListed(source);\n            case WHITELIST:\n                return isWhiteListed(source);\n        }\n        return true;\n    }\n\n    public boolean isBlackListed(String source) {\n        if (blackList \u003d\u003d null) {\n            String listName \u003d getBlackListName();\n            initSourceLists();\n            blackList \u003d sourceLists.get(listName);\n            if (blackList \u003d\u003d null) {\n                // meaning there was no list of the given blacklist name.\n                if (logger.isInfoEnabled())\n                    logger.info(\"Couldn\u0027t find blacklist \u0027{}\u0027!\", listName);\n                setSourceFiltering(SourceFiltering.NONE);\n                setBlackListName(\"\");\n                return true;\n            }\n        }\n        return blackList.contains(source);\n    }\n\n    public void setBlackListName(String name) {\n        Object oldValue \u003d getBlackListName();\n        PREFERENCES.put(BLACK_LIST_NAME_PROPERTY, name);\n        Object newValue \u003d getBlackListName();\n        propertyChangeSupport.firePropertyChange(BLACK_LIST_NAME_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"BlackListName set to {}.\", newValue);\n    }\n\n    public String getBlackListName() {\n        return PREFERENCES.get(BLACK_LIST_NAME_PROPERTY, \"\");\n    }\n\n    public boolean isWhiteListed(String source) {\n        if (whiteList \u003d\u003d null) {\n            String listName \u003d getWhiteListName();\n            initSourceLists();\n            whiteList \u003d sourceLists.get(listName);\n            if (whiteList \u003d\u003d null) {\n                // meaning there was no list of the given blacklist name.\n                if (logger.isInfoEnabled())\n                    logger.info(\"Couldn\u0027t find whitelist \u0027{}\u0027!\", listName);\n                setSourceFiltering(SourceFiltering.NONE);\n                setWhiteListName(\"\");\n                return true;\n            }\n        }\n        return whiteList.contains(source);\n    }\n\n    public void setWhiteListName(String name) {\n        Object oldValue \u003d getWhiteListName();\n        PREFERENCES.put(WHITE_LIST_NAME_PROPERTY, name);\n        Object newValue \u003d getWhiteListName();\n        propertyChangeSupport.firePropertyChange(WHITE_LIST_NAME_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"WhiteListName set to {}.\", newValue);\n    }\n\n    public String getWhiteListName() {\n        return PREFERENCES.get(WHITE_LIST_NAME_PROPERTY, \"\");\n    }\n\n    public void setLookAndFeel(String name) {\n        Object oldValue \u003d getLookAndFeel();\n        PREFERENCES.put(LOOK_AND_FEEL_PROPERTY, name);\n        Object newValue \u003d getLookAndFeel();\n        propertyChangeSupport.firePropertyChange(LOOK_AND_FEEL_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"LookAndFeel set to {}.\", newValue);\n    }\n\n    public String getLookAndFeel() {\n        String result \u003d PREFERENCES.get(LOOK_AND_FEEL_PROPERTY, STARTUP_LOOK_AND_FEEL);\n        if (!installedLookAndFeels.contains(result)) {\n            result \u003d STARTUP_LOOK_AND_FEEL;\n            if (logger.isInfoEnabled())\n                logger.info(\"Look and Feel corrected to \\\"{}\\\".\", result);\n        }\n        return result;\n    }\n\n    private void initConditions() {\n        File appPath \u003d getStartupApplicationPath();\n        File conditionsFile \u003d new File(appPath, CONDITIONS_XML_FILENAME);\n        if (conditionsFile.isFile()) {\n            long lastModified \u003d conditionsFile.lastModified();\n            if (conditions !\u003d null \u0026\u0026 lastConditionsModified \u003e\u003d lastModified) {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Won\u0027t reload conditions.\");\n                return;\n            }\n            XMLDecoder d \u003d null;\n            try {\n                d \u003d new XMLDecoder(new BufferedInputStream(new FileInputStream(conditionsFile)));\n                //noinspection unchecked\n                conditions \u003d (List\u003cSavedCondition\u003e) d.readObject();\n                lastConditionsModified \u003d lastModified;\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Loaded conditions {}.\", conditions);\n            } catch (Throwable ex) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"Exception while loading conditions from file \u0027\" + conditionsFile.getAbsolutePath() + \"\u0027!\", ex);\n                }\n            } finally {\n                if (d !\u003d null) {\n                    d.close();\n                }\n            }\n        }\n        if (conditions \u003d\u003d null) {\n            conditions \u003d new ArrayList\u003cSavedCondition\u003e();\n        }\n    }\n\n    public SavedCondition resolveSavedCondition(Condition condition) {\n        if (condition \u003d\u003d null) {\n            return null;\n        }\n        initConditions();\n        for (SavedCondition current : conditions) {\n            if (condition.equals(current.getCondition())) {\n                try {\n                    return current.clone();\n                } catch (CloneNotSupportedException e) {\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    public SavedCondition resolveSavedCondition(String conditionName) {\n        if (conditionName \u003d\u003d null) {\n            return null;\n        }\n        initConditions();\n        for (SavedCondition current : conditions) {\n            if (conditionName.equals(current.getName())) {\n                try {\n                    return current.clone();\n                } catch (CloneNotSupportedException e) {\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    public List\u003cSavedCondition\u003e getConditions() {\n        initConditions();\n        // perform deep clone... otherwise no propchange would be fired.\n        ArrayList\u003cSavedCondition\u003e result \u003d new ArrayList\u003cSavedCondition\u003e(conditions.size());\n        for (SavedCondition current : conditions) {\n            try {\n                result.add(current.clone());\n            } catch (CloneNotSupportedException e) {\n                // ignore\n            }\n        }\n        return result;\n    }\n\n    public void setConditions(List\u003cSavedCondition\u003e conditions) {\n        Object oldValue \u003d getConditions();\n        writeConditions(conditions);\n        Object newValue \u003d getConditions();\n        propertyChangeSupport.firePropertyChange(CONDITIONS_PROPERTY, oldValue, newValue);\n    }\n\n    public void setAutoOpening(boolean autoOpening) {\n        Object oldValue \u003d isAutoOpening();\n        PREFERENCES.putBoolean(AUTO_OPENING_PROPERTY, autoOpening);\n        Object newValue \u003d isAutoOpening();\n        propertyChangeSupport.firePropertyChange(AUTO_OPENING_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isAutoOpening() {\n        return PREFERENCES.getBoolean(AUTO_OPENING_PROPERTY, true);\n    }\n\n    public void setShowingIdentifier(boolean showingIdentifierWithName) {\n        Object oldValue \u003d isShowingIdentifier();\n        PREFERENCES.putBoolean(SHOWING_IDENTIFIER_PROPERTY, showingIdentifierWithName);\n        Object newValue \u003d isShowingIdentifier();\n        propertyChangeSupport.firePropertyChange(SHOWING_IDENTIFIER_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isShowingIdentifier() {\n        return PREFERENCES.getBoolean(SHOWING_IDENTIFIER_PROPERTY, true);\n    }\n\n    public void setSplashScreenDisabled(boolean splashScreenDisabled) {\n        Object oldValue \u003d isSplashScreenDisabled();\n        PREFERENCES.putBoolean(SPLASH_SCREEN_DISABLED_PROPERTY, splashScreenDisabled);\n        Object newValue \u003d isSplashScreenDisabled();\n        propertyChangeSupport.firePropertyChange(SPLASH_SCREEN_DISABLED_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isSplashScreenDisabled() {\n        return PREFERENCES.getBoolean(SPLASH_SCREEN_DISABLED_PROPERTY, false);\n    }\n\n    public void setAskingBeforeQuit(boolean askingBeforeQuit) {\n        Object oldValue \u003d isAskingBeforeQuit();\n        PREFERENCES.putBoolean(ASKING_BEFORE_QUIT_PROPERTY, askingBeforeQuit);\n        Object newValue \u003d isAskingBeforeQuit();\n        propertyChangeSupport.firePropertyChange(ASKING_BEFORE_QUIT_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isAskingBeforeQuit() {\n        return PREFERENCES.getBoolean(ASKING_BEFORE_QUIT_PROPERTY, false);\n    }\n\n    public void setShowingFullCallstack(boolean showingFullCallstack) {\n        Object oldValue \u003d isShowingFullCallstack();\n        PREFERENCES.putBoolean(SHOWING_FULL_CALLSTACK_PROPERTY, showingFullCallstack);\n        Object newValue \u003d isShowingFullCallstack();\n        propertyChangeSupport.firePropertyChange(SHOWING_FULL_CALLSTACK_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isShowingFullCallstack() {\n        return PREFERENCES.getBoolean(SHOWING_FULL_CALLSTACK_PROPERTY, false);\n    }\n\n    public void setShowingStackTrace(boolean showingStackTrace) {\n        Object oldValue \u003d isShowingStackTrace();\n        PREFERENCES.putBoolean(SHOWING_STACKTRACE_PROPERTY, showingStackTrace);\n        Object newValue \u003d isShowingStackTrace();\n        propertyChangeSupport.firePropertyChange(SHOWING_STACKTRACE_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isShowingStackTrace() {\n        return PREFERENCES.getBoolean(SHOWING_STACKTRACE_PROPERTY, true);\n    }\n\n    public void setCleaningLogsOnExit(boolean cleaningLogsOnExit) {\n        Object oldValue \u003d isCleaningLogsOnExit();\n        PREFERENCES.putBoolean(CLEANING_LOGS_ON_EXIT_PROPERTY, cleaningLogsOnExit);\n        Object newValue \u003d isCleaningLogsOnExit();\n        propertyChangeSupport.firePropertyChange(CLEANING_LOGS_ON_EXIT_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isCleaningLogsOnExit() {\n        return PREFERENCES.getBoolean(CLEANING_LOGS_ON_EXIT_PROPERTY, false);\n    }\n\n    public void setColoringWholeRow(boolean coloringWholeRow) {\n        Object oldValue \u003d isColoringWholeRow();\n        PREFERENCES.putBoolean(COLORING_WHOLE_ROW_PROPERTY, coloringWholeRow);\n        Object newValue \u003d isColoringWholeRow();\n        propertyChangeSupport.firePropertyChange(COLORING_WHOLE_ROW_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isColoringWholeRow() {\n        return PREFERENCES.getBoolean(COLORING_WHOLE_ROW_PROPERTY, false);\n    }\n\n    public void setCheckingForUpdate(boolean checkingForUpdate) {\n        Object oldValue \u003d isCheckingForUpdate();\n        PREFERENCES.putBoolean(CHECKING_FOR_UPDATE_PROPERTY, checkingForUpdate);\n        Object newValue \u003d isCheckingForUpdate();\n        propertyChangeSupport.firePropertyChange(CHECKING_FOR_UPDATE_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isCheckingForUpdate() {\n        return PREFERENCES.getBoolean(CHECKING_FOR_UPDATE_PROPERTY, true);\n    }\n\n    public void setAutoClosing(boolean autoClosing) {\n        Object oldValue \u003d isAutoClosing();\n        PREFERENCES.putBoolean(AUTO_CLOSING_PROPERTY, autoClosing);\n        Object newValue \u003d isAutoClosing();\n        propertyChangeSupport.firePropertyChange(AUTO_CLOSING_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isAutoClosing() {\n        return PREFERENCES.getBoolean(AUTO_CLOSING_PROPERTY, false);\n    }\n\n    public File getImagePath() {\n        String imagePath \u003d PREFERENCES.get(IMAGE_PATH_PROPERTY, USER_HOME);\n        File result \u003d new File(imagePath);\n        if (!result.isDirectory()) {\n            result \u003d new File(USER_HOME);\n        }\n        return result;\n    }\n\n    public void setImagePath(File imagePath) {\n        if (!imagePath.isDirectory()) {\n            throw new IllegalArgumentException(\"\u0027\" + imagePath.getAbsolutePath() + \"\u0027 is not a directory!\");\n        }\n        Object oldValue \u003d getImagePath();\n        PREFERENCES.put(IMAGE_PATH_PROPERTY, imagePath.getAbsolutePath());\n        Object newValue \u003d getImagePath();\n        propertyChangeSupport.firePropertyChange(IMAGE_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public File getPreviousOpenPath() {\n        String imagePath \u003d PREFERENCES.get(PREVIOUS_OPEN_PATH_PROPERTY, USER_HOME);\n        File result \u003d new File(imagePath);\n        if (!result.isDirectory()) {\n            result \u003d new File(USER_HOME);\n        }\n        return result;\n    }\n\n    public void setPreviousOpenPath(File openPath) {\n        if (!openPath.isDirectory()) {\n            throw new IllegalArgumentException(\"\u0027\" + openPath.getAbsolutePath() + \"\u0027 is not a directory!\");\n        }\n        Object oldValue \u003d getPreviousOpenPath();\n        PREFERENCES.put(PREVIOUS_OPEN_PATH_PROPERTY, openPath.getAbsolutePath());\n        Object newValue \u003d getPreviousOpenPath();\n        propertyChangeSupport.firePropertyChange(PREVIOUS_OPEN_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public File getPreviousImportPath() {\n        String imagePath \u003d PREFERENCES.get(PREVIOUS_IMPORT_PATH_PROPERTY, USER_HOME);\n        File result \u003d new File(imagePath);\n        if (!result.isDirectory()) {\n            result \u003d new File(USER_HOME);\n        }\n        return result;\n    }\n\n    public void setPreviousImportPath(File importPath) {\n        if (!importPath.isDirectory()) {\n            throw new IllegalArgumentException(\"\u0027\" + importPath.getAbsolutePath() + \"\u0027 is not a directory!\");\n        }\n        Object oldValue \u003d getPreviousImportPath();\n        PREFERENCES.put(PREVIOUS_IMPORT_PATH_PROPERTY, importPath.getAbsolutePath());\n        Object newValue \u003d getPreviousImportPath();\n        propertyChangeSupport.firePropertyChange(PREVIOUS_IMPORT_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public File getSoundPath() {\n        String soundPath \u003d PREFERENCES.get(SOUND_PATH_PROPERTY, USER_HOME);\n        File result \u003d new File(soundPath);\n        if (!result.isDirectory()) {\n            result \u003d new File(USER_HOME);\n        }\n        return result;\n    }\n\n    public void setSoundPath(File soundPath) {\n        if (!soundPath.isDirectory()) {\n            throw new IllegalArgumentException(\"\u0027\" + soundPath.getAbsolutePath() + \"\u0027 is not a directory!\");\n        }\n        Object oldValue \u003d getSoundPath();\n        PREFERENCES.put(SOUND_PATH_PROPERTY, soundPath.getAbsolutePath());\n        Object newValue \u003d getSoundPath();\n        propertyChangeSupport.firePropertyChange(SOUND_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public void setMute(boolean mute) {\n        Object oldValue \u003d isMute();\n        PREFERENCES.putBoolean(MUTE_PROPERTY, mute);\n        Object newValue \u003d isMute();\n        propertyChangeSupport.firePropertyChange(MUTE_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isMute() {\n        return PREFERENCES.getBoolean(MUTE_PROPERTY, false);\n    }\n\n    public void setLicensed(boolean licensed) {\n        Object oldValue \u003d isLicensed();\n        if (licensed) {\n            PREFERENCES.put(LICENSED_PREFERENCES_KEY, Lilith.APP_VERSION);\n        } else {\n            PREFERENCES.remove(LICENSED_PREFERENCES_KEY);\n        }\n        Object newValue \u003d isLicensed();\n        propertyChangeSupport.firePropertyChange(LICENSED_PREFERENCES_KEY, oldValue, newValue);\n    }\n\n    public boolean isLicensed() {\n        return Lilith.APP_VERSION.equals(PREFERENCES.get(LICENSED_PREFERENCES_KEY, null));\n    }\n\n    public void setApplicationPath(File applicationPath) {\n        if (applicationPath.mkdirs()) {\n            if (logger.isInfoEnabled())\n                logger.info(\"Created directory {}.\", applicationPath.getAbsolutePath());\n        }\n        if (!applicationPath.isDirectory()) {\n            throw new IllegalArgumentException(\"\u0027\" + applicationPath.getAbsolutePath() + \"\u0027 is not a directory!\");\n        }\n        // !!!\n        Object oldValue \u003d getStartupApplicationPath();\n        PREFERENCES.put(APPLICATION_PATH_PROPERTY, applicationPath.getAbsolutePath());\n        Object newValue \u003d getApplicationPath();\n        propertyChangeSupport.firePropertyChange(APPLICATION_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public File getApplicationPath() {\n        String appPath \u003d PREFERENCES.get(APPLICATION_PATH_PROPERTY, DEFAULT_APPLICATION_PATH);\n        File result \u003d new File(appPath);\n        if (result.mkdirs()) {\n            if (logger.isInfoEnabled())\n                logger.info(\"Created directory {}.\", result.getAbsolutePath());\n        }\n        return result;\n    }\n\n    /**\n     * The StartupApplicationPath is initialized on application startup via ApplicationPreferences.getApplicationPath.\n     * If a part of the application needs the application path it should *always* use this method instead of\n     * getApplicationPath() since the application path might change while this one will always stay\n     * the same.\n     * \u003cp/\u003e\n     * A switch of the application path while the application is running isn\u0027t safe so it\u0027s changed for real\n     * upon next restart.\n     *\n     * @return the application path at startup time.\n     */\n    public File getStartupApplicationPath() {\n        return startupApplicationPath;\n    }\n\n    public void setUsingInternalFrames(boolean usingInternalFrames) {\n        Object oldValue \u003d isUsingInternalFrames();\n        PREFERENCES.putBoolean(USING_INTERNAL_FRAMES_PROPERTY, usingInternalFrames);\n        Object newValue \u003d isUsingInternalFrames();\n        propertyChangeSupport.firePropertyChange(USING_INTERNAL_FRAMES_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isUsingInternalFrames() {\n        return PREFERENCES.getBoolean(USING_INTERNAL_FRAMES_PROPERTY, true);\n    }\n\n    public void setAutoFocusingWindow(boolean autoFocusingWindow) {\n        Object oldValue \u003d isAutoFocusingWindow();\n        PREFERENCES.putBoolean(AUTO_FOCUSING_WINDOW_PROPERTY, autoFocusingWindow);\n        Object newValue \u003d isAutoFocusingWindow();\n        propertyChangeSupport.firePropertyChange(AUTO_FOCUSING_WINDOW_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isAutoFocusingWindow() {\n        return PREFERENCES.getBoolean(AUTO_FOCUSING_WINDOW_PROPERTY, false);\n    }\n\n    public void setSourceNames(Map\u003cString, String\u003e sourceNames) {\n        Object oldValue \u003d getSourceNames();\n        writeSourceNames(sourceNames);\n        Object newValue \u003d getSourceNames();\n        propertyChangeSupport.firePropertyChange(SOURCE_NAMES_PROPERTY, oldValue, newValue);\n    }\n\n    public Map\u003cString, String\u003e getSourceNames() {\n        File appPath \u003d getStartupApplicationPath();\n        File sourceNamesFile \u003d new File(appPath, SOURCE_NAMES_XML_FILENAME);\n        if (sourceNamesFile.isFile()) {\n            if (loadSourceNamesXml(sourceNamesFile)) {\n                return new HashMap\u003cString, String\u003e(sourceNames);\n            }\n        }\n        sourceNamesFile \u003d new File(appPath, SOURCE_NAMES_PROPERTIES_FILENAME);\n        if (sourceNamesFile.isFile()) {\n            if (loadSourceNamesProperties(sourceNamesFile)) {\n                return new HashMap\u003cString, String\u003e(sourceNames);\n            }\n        }\n        return new HashMap\u003cString, String\u003e(DEFAULT_SOURCE_NAMES);\n    }\n\n    public Map\u003cString, String\u003e getSoundLocations() {\n        File appPath \u003d getStartupApplicationPath();\n        File file \u003d new File(appPath, SOUND_LOCATIONS_XML_FILENAME);\n        if (file.isFile()) {\n            if (loadSoundLocationsXml(file)) {\n                return new HashMap\u003cString, String\u003e(soundLocations);\n            }\n        }\n        return new HashMap\u003cString, String\u003e(DEFAULT_SOUND_LOCATIONS);\n    }\n\n    public void setSoundLocations(Map\u003cString, String\u003e soundLocations) {\n        Object oldValue \u003d getSoundLocations();\n        writeSoundLocations(soundLocations);\n        Object newValue \u003d getSoundLocations();\n        propertyChangeSupport.firePropertyChange(SOUND_LOCATIONS_PROPERTY, oldValue, newValue);\n    }\n\n    public void resetSoundLocations() {\n        if (logger.isInfoEnabled())\n            logger.info(\"Initializing preferences with default sound locations.\");\n        setSoundLocations(DEFAULT_SOUND_LOCATIONS);\n    }\n\n    public void addPropertyChangeListener(PropertyChangeListener listener) {\n        propertyChangeSupport.addPropertyChangeListener(listener);\n    }\n\n    public void removePropertyChangeListener(PropertyChangeListener listener) {\n        propertyChangeSupport.removePropertyChangeListener(listener);\n    }\n\n    public void reset() {\n        final Logger logger \u003d LoggerFactory.getLogger(ApplicationPreferences.class);\n        boolean licensed \u003d isLicensed();\n        try {\n            PREFERENCES.clear();\n            resetSoundLocations();\n            setLicensed(licensed);\n            setApplicationPath(new File(DEFAULT_APPLICATION_PATH));\n        } catch (BackingStoreException e) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while clearing preferences!\");\n        }\n    }\n\n    public void setScrollingToBottom(boolean scrollingToBottom) {\n        Object oldValue \u003d isScrollingToBottom();\n        PREFERENCES.putBoolean(SCROLLING_TO_BOTTOM_PROPERTY, scrollingToBottom);\n        Object newValue \u003d isScrollingToBottom();\n        propertyChangeSupport.firePropertyChange(SCROLLING_TO_BOTTOM_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isScrollingToBottom() {\n        return PREFERENCES.getBoolean(SCROLLING_TO_BOTTOM_PROPERTY, true);\n    }\n\n    private boolean loadSoundLocationsXml(File file) {\n        long lastModified \u003d file.lastModified();\n        if (soundLocations !\u003d null \u0026\u0026 lastSoundLocationsModified \u003e\u003d lastModified) {\n            if (logger.isDebugEnabled())\n                logger.debug(\"Won\u0027t reload sound locations.\");\n            return true;\n        }\n        Map\u003cString, String\u003e props \u003d loadPropertiesXml(file);\n        if (props !\u003d null) {\n            lastSoundLocationsModified \u003d lastModified;\n            soundLocations \u003d props;\n            return true;\n        }\n        return false;\n    }\n\n    private boolean writeSoundLocations(Map\u003cString, String\u003e sourceNames) {\n        File appPath \u003d getStartupApplicationPath();\n        File file \u003d new File(appPath, SOUND_LOCATIONS_XML_FILENAME);\n        return writePropertiesXml(file, sourceNames, \"Sound locations\");\n    }\n\n    private boolean loadSourceNamesXml(File file) {\n        long lastModified \u003d file.lastModified();\n        if (sourceNames !\u003d null \u0026\u0026 lastSourceNamesModified \u003e\u003d lastModified) {\n            if (logger.isDebugEnabled())\n                logger.debug(\"Won\u0027t reload source names.\");\n            return true;\n        }\n        Map\u003cString, String\u003e props \u003d loadPropertiesXml(file);\n        if (props !\u003d null) {\n            lastSourceNamesModified \u003d lastModified;\n            sourceNames \u003d props;\n            return true;\n        }\n        return false;\n    }\n\n    private boolean loadSourceNamesProperties(File sourceNamesFile) {\n        long lastModified \u003d sourceNamesFile.lastModified();\n        if (sourceNames !\u003d null \u0026\u0026 lastSourceNamesModified \u003e\u003d lastModified) {\n            if (logger.isDebugEnabled())\n                logger.debug(\"Won\u0027t reload source names.\");\n            return true;\n        }\n        Map\u003cString, String\u003e props \u003d loadProperties(sourceNamesFile);\n        if (props !\u003d null) {\n            lastSourceNamesModified \u003d lastModified;\n            sourceNames \u003d props;\n            return true;\n        }\n        return false;\n    }\n\n    private boolean writeSourceNames(Map\u003cString, String\u003e sourceNames) {\n        File appPath \u003d getStartupApplicationPath();\n        File file \u003d new File(appPath, SOURCE_NAMES_XML_FILENAME);\n        return writePropertiesXml(file, sourceNames, \"Source names\");\n    }\n\n    private boolean writeSourceLists(Map\u003cString, Set\u003cString\u003e\u003e sourceLists) {\n        File appPath \u003d getStartupApplicationPath();\n        File file \u003d new File(appPath, SOURCE_LISTS_XML_FILENAME);\n        XMLEncoder e \u003d null;\n        Throwable error \u003d null;\n        try {\n            BufferedOutputStream bos \u003d new BufferedOutputStream(new FileOutputStream(file));\n            e \u003d new XMLEncoder(bos);\n            e.writeObject(sourceLists);\n        } catch (FileNotFoundException ex) {\n            error \u003d ex;\n        } finally {\n            if (e !\u003d null) {\n                e.close();\n            }\n        }\n        if (error !\u003d null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing source lists!\", error);\n            return false;\n        }\n        return true;\n    }\n\n    private boolean writeConditions(List\u003cSavedCondition\u003e conditions) {\n        File appPath \u003d getStartupApplicationPath();\n        File file \u003d new File(appPath, CONDITIONS_XML_FILENAME);\n        XMLEncoder e \u003d null;\n        Throwable error \u003d null;\n        try {\n            BufferedOutputStream bos \u003d new BufferedOutputStream(new FileOutputStream(file));\n            e \u003d new XMLEncoder(bos);\n            e.writeObject(conditions);\n            if (logger.isInfoEnabled())\n                logger.info(\"Wrote conditions {}.\", conditions);\n        } catch (FileNotFoundException ex) {\n            error \u003d ex;\n        } finally {\n            if (e !\u003d null) {\n                e.close();\n            }\n        }\n        if (error !\u003d null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing source lists!\", error);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @noinspection MismatchedQueryAndUpdateOfCollection\n     */\n    private Map\u003cString, String\u003e loadPropertiesXml(File file) {\n        InputStream is \u003d null;\n        try {\n            is \u003d new BufferedInputStream(new FileInputStream(file));\n            Properties props \u003d new Properties();\n            props.loadFromXML(is);\n            Map\u003cString, String\u003e result \u003d new HashMap\u003cString, String\u003e();\n            for (Object keyObj : props.keySet()) {\n                String key \u003d (String) keyObj;\n                String value \u003d (String) props.get(key);\n                if (value !\u003d null) {\n                    result.put(key, value);\n                }\n            }\n            return result;\n        } catch (IOException e) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Couldn\u0027t load properties from \u0027\" + file.getAbsolutePath() + \"\u0027!\", e);\n            }\n        } finally {\n            IOUtils.closeQuietly(is);\n        }\n        return null;\n    }\n\n    /**\n     * @noinspection MismatchedQueryAndUpdateOfCollection\n     */\n    private boolean writePropertiesXml(File file, Map\u003cString, String\u003e sourceNames, String comment) {\n        Properties output \u003d new Properties();\n        for (Map.Entry\u003cString, String\u003e entry : sourceNames.entrySet()) {\n            String key \u003d entry.getKey();\n            String value \u003d entry.getValue();\n            if (value !\u003d null) {\n                output.put(key, value);\n            }\n        }\n        OutputStream os \u003d null;\n        Throwable error \u003d null;\n        try {\n            os \u003d new BufferedOutputStream(new FileOutputStream(file));\n            output.storeToXML(os, comment, \"UTF-8\");\n        } catch (FileNotFoundException e) {\n            error \u003d e;\n        } catch (IOException e) {\n            error \u003d e;\n        } finally {\n            IOUtils.closeQuietly(os);\n        }\n        if (error !\u003d null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing source names!\", error);\n            return false;\n        }\n        return true;\n    }\n\n    private Map\u003cString, String\u003e loadProperties(File file) {\n        InputStream is \u003d null;\n        try {\n            is \u003d new BufferedInputStream(new FileInputStream(file));\n            Properties props \u003d new Properties();\n            props.load(is);\n            Map\u003cString, String\u003e result \u003d new HashMap\u003cString, String\u003e();\n            for (Object keyObj : props.keySet()) {\n                String key \u003d (String) keyObj;\n                String value \u003d (String) props.get(key);\n                if (value !\u003d null) {\n                    result.put(key, value);\n                }\n            }\n            return result;\n        } catch (IOException e) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Couldn\u0027t load properties from \u0027\" + file.getAbsolutePath() + \"\u0027!\", e);\n            }\n        } finally {\n            IOUtils.closeQuietly(is);\n        }\n        return null;\n    }\n\n    public void writeLoggingColumnLayout(boolean global, List\u003cPersistentTableColumnModel.TableColumnLayoutInfo\u003e layoutInfos) {\n        File appPath \u003d getStartupApplicationPath();\n        File file;\n        if (global) {\n            file \u003d new File(appPath, LOGGING_LAYOUT_GLOBAL_XML_FILENAME);\n        } else {\n            file \u003d new File(appPath, LOGGING_LAYOUT_XML_FILENAME);\n        }\n        writeColumnLayout(file, layoutInfos);\n    }\n\n    public void writeAccessColumnLayout(boolean global, List\u003cPersistentTableColumnModel.TableColumnLayoutInfo\u003e layoutInfos) {\n        File appPath \u003d getStartupApplicationPath();\n        File file;\n        if (global) {\n            file \u003d new File(appPath, ACCESS_LAYOUT_GLOBAL_XML_FILENAME);\n        } else {\n            file \u003d new File(appPath, ACCESS_LAYOUT_XML_FILENAME);\n        }\n        writeColumnLayout(file, layoutInfos);\n    }\n\n    public List\u003cPersistentTableColumnModel.TableColumnLayoutInfo\u003e readLoggingColumnLayout(boolean global) {\n        File appPath \u003d getStartupApplicationPath();\n        File file;\n        if (global) {\n            file \u003d new File(appPath, LOGGING_LAYOUT_GLOBAL_XML_FILENAME);\n        } else {\n            file \u003d new File(appPath, LOGGING_LAYOUT_XML_FILENAME);\n        }\n        return readColumnLayout(file);\n    }\n\n    public List\u003cPersistentTableColumnModel.TableColumnLayoutInfo\u003e readAccessColumnLayout(boolean global) {\n        File appPath \u003d getStartupApplicationPath();\n        File file;\n        if (global) {\n            file \u003d new File(appPath, ACCESS_LAYOUT_GLOBAL_XML_FILENAME);\n        } else {\n            file \u003d new File(appPath, ACCESS_LAYOUT_XML_FILENAME);\n        }\n        return readColumnLayout(file);\n    }\n\n    private boolean writeColumnLayout(File file, List\u003cPersistentTableColumnModel.TableColumnLayoutInfo\u003e layoutInfos) {\n        XMLEncoder e \u003d null;\n        Throwable error \u003d null;\n        try {\n            BufferedOutputStream bos \u003d new BufferedOutputStream(new FileOutputStream(file));\n            e \u003d new XMLEncoder(bos);\n            e.writeObject(layoutInfos);\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Wrote layouts {} to file \u0027{}\u0027.\", layoutInfos, file.getAbsolutePath());\n            }\n        } catch (FileNotFoundException ex) {\n            error \u003d ex;\n        } finally {\n            if (e !\u003d null) {\n                e.close();\n            }\n        }\n        if (error !\u003d null) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Exception while writing layouts to file \u0027\" + file.getAbsolutePath() + \"\u0027!\", error);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private List\u003cPersistentTableColumnModel.TableColumnLayoutInfo\u003e readColumnLayout(File file) {\n        XMLDecoder d \u003d null;\n        List\u003cPersistentTableColumnModel.TableColumnLayoutInfo\u003e result;\n        try {\n            d \u003d new XMLDecoder(new BufferedInputStream(new FileInputStream(file)));\n            //noinspection unchecked\n            result \u003d (List\u003cPersistentTableColumnModel.TableColumnLayoutInfo\u003e) d.readObject();\n        } catch (Throwable ex) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Exception while loading layouts from file \u0027{}\u0027\u0027:\", file.getAbsolutePath(), ex.getMessage());\n            }\n            result \u003d null;\n        } finally {\n            if (d !\u003d null) {\n                d.close();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Quick \u0026 dirty MD5 checksum function.\n     * Returns null in case of error.\n     *\n     * @param input the input\n     * @return the checksum\n     */\n    public static byte[] getMD5(InputStream input) {\n        if (input \u003d\u003d null) {\n            return null;\n        }\n        MessageDigest messageDigest;\n        try {\n            messageDigest \u003d MessageDigest.getInstance(\"MD5\");\n            byte[] buffer \u003d new byte[1024];\n            for (; ; ) {\n                int read \u003d input.read(buffer);\n                if (read \u003c 0) {\n                    break;\n                }\n                messageDigest.update(buffer, 0, read);\n            }\n            return messageDigest.digest();\n        } catch (Throwable t) {\n            final Logger logger \u003d LoggerFactory.getLogger(ApplicationPreferences.class);\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while calculating checksum!\", t);\n        } finally {\n            try {\n                input.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n        return null;\n    }\n\n    public void flush() {\n        try {\n            PREFERENCES.flush();\n        } catch (BackingStoreException e) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while flushing preferences!\", e);\n        }\n    }\n\n    /**\n     * As described in http://weblogs.java.net/blog/malenkov/archive/2006/08/how_to_encode_e.html\n     */\n    static class EnumPersistenceDelegate extends PersistenceDelegate {\n\n        protected boolean mutatesTo(Object oldInstance, Object newInstance) {\n            return oldInstance \u003d\u003d newInstance;\n        }\n\n        protected Expression instantiate(Object oldInstance, Encoder out) {\n            Enum e \u003d (Enum) oldInstance;\n            return new Expression(e, e.getClass(), \"valueOf\", new Object[] { e.name() });\n        }\n    }\n}\n",
    "package": "de.huxhorn.lilith.swing",
    "classname": "ApplicationPreferences",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/ApplicationPreferences_8Test.java",
    "test_prompt": "// ApplicationPreferences_8Test.java\npackage de.huxhorn.lilith.swing;\n\nimport de.huxhorn.lilith.Lilith;\nimport de.huxhorn.lilith.LilithSounds;\nimport de.huxhorn.lilith.data.access.HttpStatus;\nimport de.huxhorn.lilith.data.logging.LoggingEvent;\nimport de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;\nimport de.huxhorn.lilith.swing.preferences.SavedCondition;\nimport de.huxhorn.lilith.swing.table.ColorScheme;\nimport de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;\nimport de.huxhorn.sulky.conditions.Condition;\nimport org.apache.commons.io.IOUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.awt.*;\nimport java.beans.Encoder;\nimport java.beans.Expression;\nimport java.beans.PersistenceDelegate;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.prefs.BackingStoreException;\nimport java.util.prefs.Preferences;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ApplicationPreferences}.\n* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.\n*/\nclass ApplicationPreferences_8Test {",
    "method_signature": "getMD5(InputStream)",
    "suffix": "8"
  },
  {
    "numberTests": "ten",
    "original_code": "// ConditionalBorder.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.swing.table.renderer;\r\n\r\nimport java.awt.*;\r\nimport javax.swing.border.AbstractBorder;\r\n\r\n/**\r\n * This is basically a mutable, simplified LineBorder-EmptyBorder combination.\r\n */\r\npublic class ConditionalBorder extends AbstractBorder {\r\n\r\n    private static final long serialVersionUID \u003d -2372658104457011019L;\r\n\r\n    private int thickness;\r\n\r\n    private int innerThickness;\r\n\r\n    private Color borderColor;\r\n\r\n    public ConditionalBorder(Color color) {\r\n        this(color, 1, 0);\r\n    }\r\n\r\n    public ConditionalBorder(Color color, int thickness) {\r\n        this(color, thickness, 0);\r\n    }\r\n\r\n    public ConditionalBorder(Color color, int thickness, int innerThickness) {\r\n        setBorderColor(color);\r\n        setThickness(thickness);\r\n        setInnerThickness(innerThickness);\r\n    }\r\n\r\n    /**\r\n     * Paints the border for the specified component with the\r\n     * specified position and size.\r\n     *\r\n     * @param c      the component for which this border is being painted\r\n     * @param g      the paint graphics\r\n     * @param x      the x position of the painted border\r\n     * @param y      the y position of the painted border\r\n     * @param width  the width of the painted border\r\n     * @param height the height of the painted border\r\n     */\r\n    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\r\n        if (borderColor !\u003d null \u0026\u0026 thickness \u003e 0) {\r\n            Color oldColor \u003d g.getColor();\r\n            g.setColor(borderColor);\r\n            for (int i \u003d 0; i \u003c thickness; i++) {\r\n                g.drawRect(x + i, y + i, width - i - i - 1, height - i - i - 1);\r\n            }\r\n            g.setColor(oldColor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the insets of the border.\r\n     *\r\n     * @param c the component for which this border insets value applies\r\n     */\r\n    public Insets getBorderInsets(Component c) {\r\n        int actualThickness \u003d thickness + innerThickness;\r\n        return new Insets(actualThickness, actualThickness, actualThickness, actualThickness);\r\n    }\r\n\r\n    /**\r\n     * Reinitialize the insets parameter with this Border\u0027s current Insets.\r\n     *\r\n     * @param c      the component for which this border insets value applies\r\n     * @param insets the object to be reinitialized\r\n     */\r\n    public Insets getBorderInsets(Component c, Insets insets) {\r\n        int actualThickness \u003d thickness + innerThickness;\r\n        insets.left \u003d actualThickness;\r\n        insets.top \u003d actualThickness;\r\n        insets.right \u003d actualThickness;\r\n        insets.bottom \u003d actualThickness;\r\n        return insets;\r\n    }\r\n\r\n    /**\r\n     * Returns the color of the border.\r\n     *\r\n     * @return the color of the border.\r\n     */\r\n    public Color getBorderColor() {\r\n        return borderColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the border.\r\n     *\r\n     * @param borderColor the color of the border.\r\n     */\r\n    public void setBorderColor(Color borderColor) {\r\n        this.borderColor \u003d borderColor;\r\n    }\r\n\r\n    /**\r\n     * Returns the inner thickness of the border.\r\n     *\r\n     * @return Returns the inner thickness of the border.\r\n     */\r\n    public int getInnerThickness() {\r\n        return innerThickness;\r\n    }\r\n\r\n    /**\r\n     * Sets the inner thickness of the border.\r\n     *\r\n     * @param innerThickness Returns the inner thickness of the border.\r\n     */\r\n    public void setInnerThickness(int innerThickness) {\r\n        if (innerThickness \u003c 0) {\r\n            throw new IllegalArgumentException(\"innerThickness must not be negative!\");\r\n        }\r\n        this.innerThickness \u003d innerThickness;\r\n    }\r\n\r\n    /**\r\n     * Returns the thickness of the border.\r\n     *\r\n     * @return Returns the thickness of the border.\r\n     */\r\n    public int getThickness() {\r\n        return thickness;\r\n    }\r\n\r\n    /**\r\n     * Sets the thickness of the border.\r\n     *\r\n     * @param thickness the thickness of the border.\r\n     */\r\n    public void setThickness(int thickness) {\r\n        if (thickness \u003c 0) {\r\n            throw new IllegalArgumentException(\"thickness must not be negative!\");\r\n        }\r\n        this.thickness \u003d thickness;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the border is opaque.\r\n     */\r\n    public boolean isBorderOpaque() {\r\n        return innerThickness \u003d\u003d 0 \u0026\u0026 thickness \u003e 0 \u0026\u0026 borderColor !\u003d null;\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.swing.table.renderer",
    "classname": "ConditionalBorder",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_0Test.java",
    "test_prompt": "// ConditionalBorder_0Test.java\npackage de.huxhorn.lilith.swing.table.renderer;\n\nimport java.awt.*;\nimport javax.swing.border.AbstractBorder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConditionalBorder}.\n* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.\n*/\nclass ConditionalBorder_0Test {",
    "method_signature": "getBorderInsets(Component)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// ConditionalBorder.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.swing.table.renderer;\r\n\r\nimport java.awt.*;\r\nimport javax.swing.border.AbstractBorder;\r\n\r\n/**\r\n * This is basically a mutable, simplified LineBorder-EmptyBorder combination.\r\n */\r\npublic class ConditionalBorder extends AbstractBorder {\r\n\r\n    private static final long serialVersionUID \u003d -2372658104457011019L;\r\n\r\n    private int thickness;\r\n\r\n    private int innerThickness;\r\n\r\n    private Color borderColor;\r\n\r\n    public ConditionalBorder(Color color) {\r\n        this(color, 1, 0);\r\n    }\r\n\r\n    public ConditionalBorder(Color color, int thickness) {\r\n        this(color, thickness, 0);\r\n    }\r\n\r\n    public ConditionalBorder(Color color, int thickness, int innerThickness) {\r\n        setBorderColor(color);\r\n        setThickness(thickness);\r\n        setInnerThickness(innerThickness);\r\n    }\r\n\r\n    /**\r\n     * Paints the border for the specified component with the\r\n     * specified position and size.\r\n     *\r\n     * @param c      the component for which this border is being painted\r\n     * @param g      the paint graphics\r\n     * @param x      the x position of the painted border\r\n     * @param y      the y position of the painted border\r\n     * @param width  the width of the painted border\r\n     * @param height the height of the painted border\r\n     */\r\n    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\r\n        if (borderColor !\u003d null \u0026\u0026 thickness \u003e 0) {\r\n            Color oldColor \u003d g.getColor();\r\n            g.setColor(borderColor);\r\n            for (int i \u003d 0; i \u003c thickness; i++) {\r\n                g.drawRect(x + i, y + i, width - i - i - 1, height - i - i - 1);\r\n            }\r\n            g.setColor(oldColor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the insets of the border.\r\n     *\r\n     * @param c the component for which this border insets value applies\r\n     */\r\n    public Insets getBorderInsets(Component c) {\r\n        int actualThickness \u003d thickness + innerThickness;\r\n        return new Insets(actualThickness, actualThickness, actualThickness, actualThickness);\r\n    }\r\n\r\n    /**\r\n     * Reinitialize the insets parameter with this Border\u0027s current Insets.\r\n     *\r\n     * @param c      the component for which this border insets value applies\r\n     * @param insets the object to be reinitialized\r\n     */\r\n    public Insets getBorderInsets(Component c, Insets insets) {\r\n        int actualThickness \u003d thickness + innerThickness;\r\n        insets.left \u003d actualThickness;\r\n        insets.top \u003d actualThickness;\r\n        insets.right \u003d actualThickness;\r\n        insets.bottom \u003d actualThickness;\r\n        return insets;\r\n    }\r\n\r\n    /**\r\n     * Returns the color of the border.\r\n     *\r\n     * @return the color of the border.\r\n     */\r\n    public Color getBorderColor() {\r\n        return borderColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the border.\r\n     *\r\n     * @param borderColor the color of the border.\r\n     */\r\n    public void setBorderColor(Color borderColor) {\r\n        this.borderColor \u003d borderColor;\r\n    }\r\n\r\n    /**\r\n     * Returns the inner thickness of the border.\r\n     *\r\n     * @return Returns the inner thickness of the border.\r\n     */\r\n    public int getInnerThickness() {\r\n        return innerThickness;\r\n    }\r\n\r\n    /**\r\n     * Sets the inner thickness of the border.\r\n     *\r\n     * @param innerThickness Returns the inner thickness of the border.\r\n     */\r\n    public void setInnerThickness(int innerThickness) {\r\n        if (innerThickness \u003c 0) {\r\n            throw new IllegalArgumentException(\"innerThickness must not be negative!\");\r\n        }\r\n        this.innerThickness \u003d innerThickness;\r\n    }\r\n\r\n    /**\r\n     * Returns the thickness of the border.\r\n     *\r\n     * @return Returns the thickness of the border.\r\n     */\r\n    public int getThickness() {\r\n        return thickness;\r\n    }\r\n\r\n    /**\r\n     * Sets the thickness of the border.\r\n     *\r\n     * @param thickness the thickness of the border.\r\n     */\r\n    public void setThickness(int thickness) {\r\n        if (thickness \u003c 0) {\r\n            throw new IllegalArgumentException(\"thickness must not be negative!\");\r\n        }\r\n        this.thickness \u003d thickness;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the border is opaque.\r\n     */\r\n    public boolean isBorderOpaque() {\r\n        return innerThickness \u003d\u003d 0 \u0026\u0026 thickness \u003e 0 \u0026\u0026 borderColor !\u003d null;\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.swing.table.renderer",
    "classname": "ConditionalBorder",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_1Test.java",
    "test_prompt": "// ConditionalBorder_1Test.java\npackage de.huxhorn.lilith.swing.table.renderer;\n\nimport java.awt.*;\nimport javax.swing.border.AbstractBorder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConditionalBorder}.\n* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n*/\nclass ConditionalBorder_1Test {",
    "method_signature": "getBorderInsets(Component, Insets)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// PersistentTableColumnModel.java\npackage de.huxhorn.lilith.swing.table.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.DefaultTableColumnModel;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.\r\n */\r\npublic class PersistentTableColumnModel extends DefaultTableColumnModel {\r\n\r\n    protected List\u003cTableColumn\u003e allTableColumns \u003d new ArrayList\u003cTableColumn\u003e();\r\n\r\n    /**\r\n     * Creates an extended table column model.\r\n     */\r\n    public PersistentTableColumnModel() {\r\n        allTableColumns \u003d new ArrayList\u003cTableColumn\u003e();\r\n        initColumns();\r\n    }\r\n\r\n    /**\r\n     * Should be implemented by subclasses if needed.\r\n     */\r\n    protected void initColumns() {\r\n    }\r\n\r\n    /**\r\n     * Sets the visibility of the specified TableColumn.\r\n     * The call is ignored if the TableColumn is not found in this column model\r\n     * or its visibility status did not change.\r\n     * \u003cp/\u003e\r\n     *\r\n     * @param column  the column to show/hide\r\n     * @param visible its new visibility status\r\n     */\r\n    // listeners will receive columnAdded()/columnRemoved() event\r\n    public void setColumnVisible(TableColumn column, boolean visible) {\r\n        if (!visible) {\r\n            super.removeColumn(column);\r\n        } else {\r\n            // find the visible index of the column:\r\n            // iterate through both collections of visible and all columns, counting\r\n            // visible columns up to the one that\u0027s about to be shown again\r\n            int noVisibleColumns \u003d tableColumns.size();\r\n            int noInvisibleColumns \u003d allTableColumns.size();\r\n            int visibleIndex \u003d 0;\r\n            for (int invisibleIndex \u003d 0; invisibleIndex \u003c noInvisibleColumns; ++invisibleIndex) {\r\n                TableColumn visibleColumn \u003d (visibleIndex \u003c noVisibleColumns ? tableColumns.get(visibleIndex) : null);\r\n                TableColumn testColumn \u003d allTableColumns.get(invisibleIndex);\r\n                if (testColumn \u003d\u003d column) {\r\n                    if (visibleColumn !\u003d column) {\r\n                        super.addColumn(column);\r\n                        super.moveColumn(tableColumns.size() - 1, visibleIndex);\r\n                    }\r\n                    // ####################\r\n                    return;\r\n                }\r\n                if (testColumn \u003d\u003d visibleColumn) {\r\n                    ++visibleIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes all columns in this model visible\r\n     */\r\n    public void setAllColumnsVisible() {\r\n        int noColumns \u003d allTableColumns.size();\r\n        for (int columnIndex \u003d 0; columnIndex \u003c noColumns; ++columnIndex) {\r\n            TableColumn visibleColumn \u003d (columnIndex \u003c tableColumns.size() ? tableColumns.get(columnIndex) : null);\r\n            TableColumn invisibleColumn \u003d allTableColumns.get(columnIndex);\r\n            if (visibleColumn !\u003d invisibleColumn) {\r\n                super.addColumn(invisibleColumn);\r\n                super.moveColumn(tableColumns.size() - 1, columnIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks wether the specified column is currently visible.\r\n     *\r\n     * @param aColumn column to check\r\n     * @return visibility of specified column (false if there is no such column at all. [It\u0027s not visible, right?])\r\n     */\r\n    public boolean isColumnVisible(TableColumn aColumn) {\r\n        return (tableColumns.indexOf(aColumn) \u003e\u003d 0);\r\n    }\r\n\r\n    /**\r\n     * Append \u003ccode\u003ecolumn\u003c/code\u003e to the right of exisiting columns.\r\n     * Posts \u003ccode\u003ecolumnAdded\u003c/code\u003e event.\r\n     *\r\n     * @param column The column to be added\r\n     * @throws IllegalArgumentException if \u003ccode\u003ecolumn\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e\r\n     * @see #removeColumn\r\n     */\r\n    @Override\r\n    public void addColumn(TableColumn column) {\r\n        allTableColumns.add(column);\r\n        super.addColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Removes \u003ccode\u003ecolumn\u003c/code\u003e from this column model.\r\n     * Posts \u003ccode\u003ecolumnRemoved\u003c/code\u003e event.\r\n     * Will do nothing if the column is not in this model.\r\n     *\r\n     * @param column the column to be added\r\n     * @see #addColumn\r\n     */\r\n    @Override\r\n    public void removeColumn(TableColumn column) {\r\n        int allColumnsIndex \u003d allTableColumns.indexOf(column);\r\n        if (allColumnsIndex !\u003d -1) {\r\n            allTableColumns.remove(allColumnsIndex);\r\n        }\r\n        super.removeColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Moves the column from \u003ccode\u003eoldIndex\u003c/code\u003e to \u003ccode\u003enewIndex\u003c/code\u003e.\r\n     * Posts  \u003ccode\u003ecolumnMoved\u003c/code\u003e event.\r\n     * Will not move any columns if \u003ccode\u003eoldIndex\u003c/code\u003e equals \u003ccode\u003enewIndex\u003c/code\u003e.\r\n     *\r\n     * @throws IllegalArgumentException if either \u003ccode\u003eoldIndex\u003c/code\u003e or\r\n     *                                  \u003ccode\u003enewIndex\u003c/code\u003e\r\n     *                                  are not in [0, getColumnCount() - 1]\r\n     * @param\toldIndex\t\t\tindex of column to be moved\r\n     * @param\tnewIndex\t\t\tnew index of the column\r\n     */\r\n    @Override\r\n    public void moveColumn(int oldIndex, int newIndex) {\r\n        if ((oldIndex \u003c 0) || (oldIndex \u003e\u003d getColumnCount()) || (newIndex \u003c 0) || (newIndex \u003e\u003d getColumnCount())) {\r\n            throw new IllegalArgumentException(\"moveColumn() - Index out of range\");\r\n        }\r\n        TableColumn fromColumn \u003d tableColumns.get(oldIndex);\r\n        TableColumn toColumn \u003d tableColumns.get(newIndex);\r\n        int allColumnsOldIndex \u003d allTableColumns.indexOf(fromColumn);\r\n        int allColumnsNewIndex \u003d allTableColumns.indexOf(toColumn);\r\n        if (oldIndex !\u003d newIndex) {\r\n            allTableColumns.remove(allColumnsOldIndex);\r\n            allTableColumns.add(allColumnsNewIndex, fromColumn);\r\n        }\r\n        super.moveColumn(oldIndex, newIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of columns in this model.\r\n     *\r\n     * @param onlyVisible if set only visible columns will be counted\r\n     * @return the number of columns in the \u003ccode\u003etableColumns\u003c/code\u003e array\r\n     * @see\t#getColumns\r\n     */\r\n    public int getColumnCount(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.size() : allTableColumns.size());\r\n    }\r\n\r\n    /**\r\n     * Returns an \u003ccode\u003eEnumeration\u003c/code\u003e of all the columns in the model.\r\n     *\r\n     * @param onlyVisible if set all invisible columns will be missing from the enumeration.\r\n     * @return an \u003ccode\u003eEnumeration\u003c/code\u003e of the columns in the model\r\n     */\r\n    public Iterator\u003cTableColumn\u003e getColumns(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.iterator() : allTableColumns.iterator());\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first column whose identifier equals \u003ccode\u003eidentifier\u003c/code\u003e.\r\n     * Position is the the index in all visible columns if \u003ccode\u003eonlyVisible\u003c/code\u003e is true or\r\n     * else the index in all columns.\r\n     *\r\n     * @return the index of the first column whose identifier\r\n     *         equals \u003ccode\u003eidentifier\u003c/code\u003e\r\n     * @throws IllegalArgumentException if \u003ccode\u003eidentifier\u003c/code\u003e\r\n     *                                  is \u003ccode\u003enull\u003c/code\u003e, or if no\r\n     *                                  \u003ccode\u003eTableColumn\u003c/code\u003e has this\r\n     *                                  \u003ccode\u003eidentifier\u003c/code\u003e\r\n     * @param\tidentifier the identifier object to search for\r\n     * @param\tonlyVisible if set searches only visible columns\r\n     * @see\t\t#getColumn\r\n     */\r\n    public int getColumnIndex(Object identifier, boolean onlyVisible) {\r\n        if (identifier \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Identifier is null\");\r\n        }\r\n        List\u003cTableColumn\u003e columns \u003d (onlyVisible ? tableColumns : allTableColumns);\r\n        int noColumns \u003d columns.size();\r\n        TableColumn column;\r\n        for (int columnIndex \u003d 0; columnIndex \u003c noColumns; ++columnIndex) {\r\n            column \u003d columns.get(columnIndex);\r\n            if (identifier.equals(column.getIdentifier())) {\r\n                return columnIndex;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"Identifier not found\");\r\n    }\r\n\r\n    public List\u003cTableColumnLayoutInfo\u003e getColumnLayoutInfos() {\r\n        final List\u003cTableColumnLayoutInfo\u003e tableColumnLayoutInfos \u003d new ArrayList\u003cTableColumnLayoutInfo\u003e(allTableColumns.size());\r\n        for (TableColumn current : allTableColumns) {\r\n            boolean visible \u003d tableColumns.contains(current);\r\n            TableColumnLayoutInfo tableColumnLayoutInfo \u003d new TableColumnLayoutInfo(current.getIdentifier().toString(), current.getWidth(), visible);\r\n            tableColumnLayoutInfos.add(tableColumnLayoutInfo);\r\n        }\r\n        return tableColumnLayoutInfos;\r\n    }\r\n\r\n    public static class TableColumnLayoutInfo implements Serializable {\r\n\r\n        private String columnName;\r\n\r\n        private int width;\r\n\r\n        private boolean visible;\r\n\r\n        public TableColumnLayoutInfo() {\r\n        }\r\n\r\n        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {\r\n            this.columnName \u003d columnName;\r\n            this.width \u003d width;\r\n            this.visible \u003d visible;\r\n        }\r\n\r\n        public int getWidth() {\r\n            return width;\r\n        }\r\n\r\n        public void setWidth(int width) {\r\n            this.width \u003d width;\r\n        }\r\n\r\n        public String getColumnName() {\r\n            return columnName;\r\n        }\r\n\r\n        public void setColumnName(String columnName) {\r\n            this.columnName \u003d columnName;\r\n        }\r\n\r\n        public boolean isVisible() {\r\n            return visible;\r\n        }\r\n\r\n        public void setVisible(boolean visible) {\r\n            this.visible \u003d visible;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TableColumnLayoutInfo[columnName\u003d\" + columnName + \", width\u003d\" + width + \", visible\u003d\" + visible + \"]\";\r\n        }\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.swing.table.model",
    "classname": "PersistentTableColumnModel",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_0Test.java",
    "test_prompt": "// PersistentTableColumnModel_0Test.java\npackage de.huxhorn.lilith.swing.table.model;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.swing.table.DefaultTableColumnModel;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistentTableColumnModel}.\n* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.\n*/\nclass PersistentTableColumnModel_0Test {",
    "method_signature": "isColumnVisible(TableColumn)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// PersistentTableColumnModel.java\npackage de.huxhorn.lilith.swing.table.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.DefaultTableColumnModel;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.\r\n */\r\npublic class PersistentTableColumnModel extends DefaultTableColumnModel {\r\n\r\n    protected List\u003cTableColumn\u003e allTableColumns \u003d new ArrayList\u003cTableColumn\u003e();\r\n\r\n    /**\r\n     * Creates an extended table column model.\r\n     */\r\n    public PersistentTableColumnModel() {\r\n        allTableColumns \u003d new ArrayList\u003cTableColumn\u003e();\r\n        initColumns();\r\n    }\r\n\r\n    /**\r\n     * Should be implemented by subclasses if needed.\r\n     */\r\n    protected void initColumns() {\r\n    }\r\n\r\n    /**\r\n     * Sets the visibility of the specified TableColumn.\r\n     * The call is ignored if the TableColumn is not found in this column model\r\n     * or its visibility status did not change.\r\n     * \u003cp/\u003e\r\n     *\r\n     * @param column  the column to show/hide\r\n     * @param visible its new visibility status\r\n     */\r\n    // listeners will receive columnAdded()/columnRemoved() event\r\n    public void setColumnVisible(TableColumn column, boolean visible) {\r\n        if (!visible) {\r\n            super.removeColumn(column);\r\n        } else {\r\n            // find the visible index of the column:\r\n            // iterate through both collections of visible and all columns, counting\r\n            // visible columns up to the one that\u0027s about to be shown again\r\n            int noVisibleColumns \u003d tableColumns.size();\r\n            int noInvisibleColumns \u003d allTableColumns.size();\r\n            int visibleIndex \u003d 0;\r\n            for (int invisibleIndex \u003d 0; invisibleIndex \u003c noInvisibleColumns; ++invisibleIndex) {\r\n                TableColumn visibleColumn \u003d (visibleIndex \u003c noVisibleColumns ? tableColumns.get(visibleIndex) : null);\r\n                TableColumn testColumn \u003d allTableColumns.get(invisibleIndex);\r\n                if (testColumn \u003d\u003d column) {\r\n                    if (visibleColumn !\u003d column) {\r\n                        super.addColumn(column);\r\n                        super.moveColumn(tableColumns.size() - 1, visibleIndex);\r\n                    }\r\n                    // ####################\r\n                    return;\r\n                }\r\n                if (testColumn \u003d\u003d visibleColumn) {\r\n                    ++visibleIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes all columns in this model visible\r\n     */\r\n    public void setAllColumnsVisible() {\r\n        int noColumns \u003d allTableColumns.size();\r\n        for (int columnIndex \u003d 0; columnIndex \u003c noColumns; ++columnIndex) {\r\n            TableColumn visibleColumn \u003d (columnIndex \u003c tableColumns.size() ? tableColumns.get(columnIndex) : null);\r\n            TableColumn invisibleColumn \u003d allTableColumns.get(columnIndex);\r\n            if (visibleColumn !\u003d invisibleColumn) {\r\n                super.addColumn(invisibleColumn);\r\n                super.moveColumn(tableColumns.size() - 1, columnIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks wether the specified column is currently visible.\r\n     *\r\n     * @param aColumn column to check\r\n     * @return visibility of specified column (false if there is no such column at all. [It\u0027s not visible, right?])\r\n     */\r\n    public boolean isColumnVisible(TableColumn aColumn) {\r\n        return (tableColumns.indexOf(aColumn) \u003e\u003d 0);\r\n    }\r\n\r\n    /**\r\n     * Append \u003ccode\u003ecolumn\u003c/code\u003e to the right of exisiting columns.\r\n     * Posts \u003ccode\u003ecolumnAdded\u003c/code\u003e event.\r\n     *\r\n     * @param column The column to be added\r\n     * @throws IllegalArgumentException if \u003ccode\u003ecolumn\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e\r\n     * @see #removeColumn\r\n     */\r\n    @Override\r\n    public void addColumn(TableColumn column) {\r\n        allTableColumns.add(column);\r\n        super.addColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Removes \u003ccode\u003ecolumn\u003c/code\u003e from this column model.\r\n     * Posts \u003ccode\u003ecolumnRemoved\u003c/code\u003e event.\r\n     * Will do nothing if the column is not in this model.\r\n     *\r\n     * @param column the column to be added\r\n     * @see #addColumn\r\n     */\r\n    @Override\r\n    public void removeColumn(TableColumn column) {\r\n        int allColumnsIndex \u003d allTableColumns.indexOf(column);\r\n        if (allColumnsIndex !\u003d -1) {\r\n            allTableColumns.remove(allColumnsIndex);\r\n        }\r\n        super.removeColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Moves the column from \u003ccode\u003eoldIndex\u003c/code\u003e to \u003ccode\u003enewIndex\u003c/code\u003e.\r\n     * Posts  \u003ccode\u003ecolumnMoved\u003c/code\u003e event.\r\n     * Will not move any columns if \u003ccode\u003eoldIndex\u003c/code\u003e equals \u003ccode\u003enewIndex\u003c/code\u003e.\r\n     *\r\n     * @throws IllegalArgumentException if either \u003ccode\u003eoldIndex\u003c/code\u003e or\r\n     *                                  \u003ccode\u003enewIndex\u003c/code\u003e\r\n     *                                  are not in [0, getColumnCount() - 1]\r\n     * @param\toldIndex\t\t\tindex of column to be moved\r\n     * @param\tnewIndex\t\t\tnew index of the column\r\n     */\r\n    @Override\r\n    public void moveColumn(int oldIndex, int newIndex) {\r\n        if ((oldIndex \u003c 0) || (oldIndex \u003e\u003d getColumnCount()) || (newIndex \u003c 0) || (newIndex \u003e\u003d getColumnCount())) {\r\n            throw new IllegalArgumentException(\"moveColumn() - Index out of range\");\r\n        }\r\n        TableColumn fromColumn \u003d tableColumns.get(oldIndex);\r\n        TableColumn toColumn \u003d tableColumns.get(newIndex);\r\n        int allColumnsOldIndex \u003d allTableColumns.indexOf(fromColumn);\r\n        int allColumnsNewIndex \u003d allTableColumns.indexOf(toColumn);\r\n        if (oldIndex !\u003d newIndex) {\r\n            allTableColumns.remove(allColumnsOldIndex);\r\n            allTableColumns.add(allColumnsNewIndex, fromColumn);\r\n        }\r\n        super.moveColumn(oldIndex, newIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of columns in this model.\r\n     *\r\n     * @param onlyVisible if set only visible columns will be counted\r\n     * @return the number of columns in the \u003ccode\u003etableColumns\u003c/code\u003e array\r\n     * @see\t#getColumns\r\n     */\r\n    public int getColumnCount(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.size() : allTableColumns.size());\r\n    }\r\n\r\n    /**\r\n     * Returns an \u003ccode\u003eEnumeration\u003c/code\u003e of all the columns in the model.\r\n     *\r\n     * @param onlyVisible if set all invisible columns will be missing from the enumeration.\r\n     * @return an \u003ccode\u003eEnumeration\u003c/code\u003e of the columns in the model\r\n     */\r\n    public Iterator\u003cTableColumn\u003e getColumns(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.iterator() : allTableColumns.iterator());\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first column whose identifier equals \u003ccode\u003eidentifier\u003c/code\u003e.\r\n     * Position is the the index in all visible columns if \u003ccode\u003eonlyVisible\u003c/code\u003e is true or\r\n     * else the index in all columns.\r\n     *\r\n     * @return the index of the first column whose identifier\r\n     *         equals \u003ccode\u003eidentifier\u003c/code\u003e\r\n     * @throws IllegalArgumentException if \u003ccode\u003eidentifier\u003c/code\u003e\r\n     *                                  is \u003ccode\u003enull\u003c/code\u003e, or if no\r\n     *                                  \u003ccode\u003eTableColumn\u003c/code\u003e has this\r\n     *                                  \u003ccode\u003eidentifier\u003c/code\u003e\r\n     * @param\tidentifier the identifier object to search for\r\n     * @param\tonlyVisible if set searches only visible columns\r\n     * @see\t\t#getColumn\r\n     */\r\n    public int getColumnIndex(Object identifier, boolean onlyVisible) {\r\n        if (identifier \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Identifier is null\");\r\n        }\r\n        List\u003cTableColumn\u003e columns \u003d (onlyVisible ? tableColumns : allTableColumns);\r\n        int noColumns \u003d columns.size();\r\n        TableColumn column;\r\n        for (int columnIndex \u003d 0; columnIndex \u003c noColumns; ++columnIndex) {\r\n            column \u003d columns.get(columnIndex);\r\n            if (identifier.equals(column.getIdentifier())) {\r\n                return columnIndex;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"Identifier not found\");\r\n    }\r\n\r\n    public List\u003cTableColumnLayoutInfo\u003e getColumnLayoutInfos() {\r\n        final List\u003cTableColumnLayoutInfo\u003e tableColumnLayoutInfos \u003d new ArrayList\u003cTableColumnLayoutInfo\u003e(allTableColumns.size());\r\n        for (TableColumn current : allTableColumns) {\r\n            boolean visible \u003d tableColumns.contains(current);\r\n            TableColumnLayoutInfo tableColumnLayoutInfo \u003d new TableColumnLayoutInfo(current.getIdentifier().toString(), current.getWidth(), visible);\r\n            tableColumnLayoutInfos.add(tableColumnLayoutInfo);\r\n        }\r\n        return tableColumnLayoutInfos;\r\n    }\r\n\r\n    public static class TableColumnLayoutInfo implements Serializable {\r\n\r\n        private String columnName;\r\n\r\n        private int width;\r\n\r\n        private boolean visible;\r\n\r\n        public TableColumnLayoutInfo() {\r\n        }\r\n\r\n        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {\r\n            this.columnName \u003d columnName;\r\n            this.width \u003d width;\r\n            this.visible \u003d visible;\r\n        }\r\n\r\n        public int getWidth() {\r\n            return width;\r\n        }\r\n\r\n        public void setWidth(int width) {\r\n            this.width \u003d width;\r\n        }\r\n\r\n        public String getColumnName() {\r\n            return columnName;\r\n        }\r\n\r\n        public void setColumnName(String columnName) {\r\n            this.columnName \u003d columnName;\r\n        }\r\n\r\n        public boolean isVisible() {\r\n            return visible;\r\n        }\r\n\r\n        public void setVisible(boolean visible) {\r\n            this.visible \u003d visible;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TableColumnLayoutInfo[columnName\u003d\" + columnName + \", width\u003d\" + width + \", visible\u003d\" + visible + \"]\";\r\n        }\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.swing.table.model",
    "classname": "PersistentTableColumnModel",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_1Test.java",
    "test_prompt": "// PersistentTableColumnModel_1Test.java\npackage de.huxhorn.lilith.swing.table.model;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.swing.table.DefaultTableColumnModel;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistentTableColumnModel}.\n* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.\n*/\nclass PersistentTableColumnModel_1Test {",
    "method_signature": "getColumnCount(boolean)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// PersistentTableColumnModel.java\npackage de.huxhorn.lilith.swing.table.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.DefaultTableColumnModel;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.\r\n */\r\npublic class PersistentTableColumnModel extends DefaultTableColumnModel {\r\n\r\n    protected List\u003cTableColumn\u003e allTableColumns \u003d new ArrayList\u003cTableColumn\u003e();\r\n\r\n    /**\r\n     * Creates an extended table column model.\r\n     */\r\n    public PersistentTableColumnModel() {\r\n        allTableColumns \u003d new ArrayList\u003cTableColumn\u003e();\r\n        initColumns();\r\n    }\r\n\r\n    /**\r\n     * Should be implemented by subclasses if needed.\r\n     */\r\n    protected void initColumns() {\r\n    }\r\n\r\n    /**\r\n     * Sets the visibility of the specified TableColumn.\r\n     * The call is ignored if the TableColumn is not found in this column model\r\n     * or its visibility status did not change.\r\n     * \u003cp/\u003e\r\n     *\r\n     * @param column  the column to show/hide\r\n     * @param visible its new visibility status\r\n     */\r\n    // listeners will receive columnAdded()/columnRemoved() event\r\n    public void setColumnVisible(TableColumn column, boolean visible) {\r\n        if (!visible) {\r\n            super.removeColumn(column);\r\n        } else {\r\n            // find the visible index of the column:\r\n            // iterate through both collections of visible and all columns, counting\r\n            // visible columns up to the one that\u0027s about to be shown again\r\n            int noVisibleColumns \u003d tableColumns.size();\r\n            int noInvisibleColumns \u003d allTableColumns.size();\r\n            int visibleIndex \u003d 0;\r\n            for (int invisibleIndex \u003d 0; invisibleIndex \u003c noInvisibleColumns; ++invisibleIndex) {\r\n                TableColumn visibleColumn \u003d (visibleIndex \u003c noVisibleColumns ? tableColumns.get(visibleIndex) : null);\r\n                TableColumn testColumn \u003d allTableColumns.get(invisibleIndex);\r\n                if (testColumn \u003d\u003d column) {\r\n                    if (visibleColumn !\u003d column) {\r\n                        super.addColumn(column);\r\n                        super.moveColumn(tableColumns.size() - 1, visibleIndex);\r\n                    }\r\n                    // ####################\r\n                    return;\r\n                }\r\n                if (testColumn \u003d\u003d visibleColumn) {\r\n                    ++visibleIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes all columns in this model visible\r\n     */\r\n    public void setAllColumnsVisible() {\r\n        int noColumns \u003d allTableColumns.size();\r\n        for (int columnIndex \u003d 0; columnIndex \u003c noColumns; ++columnIndex) {\r\n            TableColumn visibleColumn \u003d (columnIndex \u003c tableColumns.size() ? tableColumns.get(columnIndex) : null);\r\n            TableColumn invisibleColumn \u003d allTableColumns.get(columnIndex);\r\n            if (visibleColumn !\u003d invisibleColumn) {\r\n                super.addColumn(invisibleColumn);\r\n                super.moveColumn(tableColumns.size() - 1, columnIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks wether the specified column is currently visible.\r\n     *\r\n     * @param aColumn column to check\r\n     * @return visibility of specified column (false if there is no such column at all. [It\u0027s not visible, right?])\r\n     */\r\n    public boolean isColumnVisible(TableColumn aColumn) {\r\n        return (tableColumns.indexOf(aColumn) \u003e\u003d 0);\r\n    }\r\n\r\n    /**\r\n     * Append \u003ccode\u003ecolumn\u003c/code\u003e to the right of exisiting columns.\r\n     * Posts \u003ccode\u003ecolumnAdded\u003c/code\u003e event.\r\n     *\r\n     * @param column The column to be added\r\n     * @throws IllegalArgumentException if \u003ccode\u003ecolumn\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e\r\n     * @see #removeColumn\r\n     */\r\n    @Override\r\n    public void addColumn(TableColumn column) {\r\n        allTableColumns.add(column);\r\n        super.addColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Removes \u003ccode\u003ecolumn\u003c/code\u003e from this column model.\r\n     * Posts \u003ccode\u003ecolumnRemoved\u003c/code\u003e event.\r\n     * Will do nothing if the column is not in this model.\r\n     *\r\n     * @param column the column to be added\r\n     * @see #addColumn\r\n     */\r\n    @Override\r\n    public void removeColumn(TableColumn column) {\r\n        int allColumnsIndex \u003d allTableColumns.indexOf(column);\r\n        if (allColumnsIndex !\u003d -1) {\r\n            allTableColumns.remove(allColumnsIndex);\r\n        }\r\n        super.removeColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Moves the column from \u003ccode\u003eoldIndex\u003c/code\u003e to \u003ccode\u003enewIndex\u003c/code\u003e.\r\n     * Posts  \u003ccode\u003ecolumnMoved\u003c/code\u003e event.\r\n     * Will not move any columns if \u003ccode\u003eoldIndex\u003c/code\u003e equals \u003ccode\u003enewIndex\u003c/code\u003e.\r\n     *\r\n     * @throws IllegalArgumentException if either \u003ccode\u003eoldIndex\u003c/code\u003e or\r\n     *                                  \u003ccode\u003enewIndex\u003c/code\u003e\r\n     *                                  are not in [0, getColumnCount() - 1]\r\n     * @param\toldIndex\t\t\tindex of column to be moved\r\n     * @param\tnewIndex\t\t\tnew index of the column\r\n     */\r\n    @Override\r\n    public void moveColumn(int oldIndex, int newIndex) {\r\n        if ((oldIndex \u003c 0) || (oldIndex \u003e\u003d getColumnCount()) || (newIndex \u003c 0) || (newIndex \u003e\u003d getColumnCount())) {\r\n            throw new IllegalArgumentException(\"moveColumn() - Index out of range\");\r\n        }\r\n        TableColumn fromColumn \u003d tableColumns.get(oldIndex);\r\n        TableColumn toColumn \u003d tableColumns.get(newIndex);\r\n        int allColumnsOldIndex \u003d allTableColumns.indexOf(fromColumn);\r\n        int allColumnsNewIndex \u003d allTableColumns.indexOf(toColumn);\r\n        if (oldIndex !\u003d newIndex) {\r\n            allTableColumns.remove(allColumnsOldIndex);\r\n            allTableColumns.add(allColumnsNewIndex, fromColumn);\r\n        }\r\n        super.moveColumn(oldIndex, newIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of columns in this model.\r\n     *\r\n     * @param onlyVisible if set only visible columns will be counted\r\n     * @return the number of columns in the \u003ccode\u003etableColumns\u003c/code\u003e array\r\n     * @see\t#getColumns\r\n     */\r\n    public int getColumnCount(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.size() : allTableColumns.size());\r\n    }\r\n\r\n    /**\r\n     * Returns an \u003ccode\u003eEnumeration\u003c/code\u003e of all the columns in the model.\r\n     *\r\n     * @param onlyVisible if set all invisible columns will be missing from the enumeration.\r\n     * @return an \u003ccode\u003eEnumeration\u003c/code\u003e of the columns in the model\r\n     */\r\n    public Iterator\u003cTableColumn\u003e getColumns(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.iterator() : allTableColumns.iterator());\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first column whose identifier equals \u003ccode\u003eidentifier\u003c/code\u003e.\r\n     * Position is the the index in all visible columns if \u003ccode\u003eonlyVisible\u003c/code\u003e is true or\r\n     * else the index in all columns.\r\n     *\r\n     * @return the index of the first column whose identifier\r\n     *         equals \u003ccode\u003eidentifier\u003c/code\u003e\r\n     * @throws IllegalArgumentException if \u003ccode\u003eidentifier\u003c/code\u003e\r\n     *                                  is \u003ccode\u003enull\u003c/code\u003e, or if no\r\n     *                                  \u003ccode\u003eTableColumn\u003c/code\u003e has this\r\n     *                                  \u003ccode\u003eidentifier\u003c/code\u003e\r\n     * @param\tidentifier the identifier object to search for\r\n     * @param\tonlyVisible if set searches only visible columns\r\n     * @see\t\t#getColumn\r\n     */\r\n    public int getColumnIndex(Object identifier, boolean onlyVisible) {\r\n        if (identifier \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Identifier is null\");\r\n        }\r\n        List\u003cTableColumn\u003e columns \u003d (onlyVisible ? tableColumns : allTableColumns);\r\n        int noColumns \u003d columns.size();\r\n        TableColumn column;\r\n        for (int columnIndex \u003d 0; columnIndex \u003c noColumns; ++columnIndex) {\r\n            column \u003d columns.get(columnIndex);\r\n            if (identifier.equals(column.getIdentifier())) {\r\n                return columnIndex;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"Identifier not found\");\r\n    }\r\n\r\n    public List\u003cTableColumnLayoutInfo\u003e getColumnLayoutInfos() {\r\n        final List\u003cTableColumnLayoutInfo\u003e tableColumnLayoutInfos \u003d new ArrayList\u003cTableColumnLayoutInfo\u003e(allTableColumns.size());\r\n        for (TableColumn current : allTableColumns) {\r\n            boolean visible \u003d tableColumns.contains(current);\r\n            TableColumnLayoutInfo tableColumnLayoutInfo \u003d new TableColumnLayoutInfo(current.getIdentifier().toString(), current.getWidth(), visible);\r\n            tableColumnLayoutInfos.add(tableColumnLayoutInfo);\r\n        }\r\n        return tableColumnLayoutInfos;\r\n    }\r\n\r\n    public static class TableColumnLayoutInfo implements Serializable {\r\n\r\n        private String columnName;\r\n\r\n        private int width;\r\n\r\n        private boolean visible;\r\n\r\n        public TableColumnLayoutInfo() {\r\n        }\r\n\r\n        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {\r\n            this.columnName \u003d columnName;\r\n            this.width \u003d width;\r\n            this.visible \u003d visible;\r\n        }\r\n\r\n        public int getWidth() {\r\n            return width;\r\n        }\r\n\r\n        public void setWidth(int width) {\r\n            this.width \u003d width;\r\n        }\r\n\r\n        public String getColumnName() {\r\n            return columnName;\r\n        }\r\n\r\n        public void setColumnName(String columnName) {\r\n            this.columnName \u003d columnName;\r\n        }\r\n\r\n        public boolean isVisible() {\r\n            return visible;\r\n        }\r\n\r\n        public void setVisible(boolean visible) {\r\n            this.visible \u003d visible;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TableColumnLayoutInfo[columnName\u003d\" + columnName + \", width\u003d\" + width + \", visible\u003d\" + visible + \"]\";\r\n        }\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.swing.table.model",
    "classname": "PersistentTableColumnModel",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_2Test.java",
    "test_prompt": "// PersistentTableColumnModel_2Test.java\npackage de.huxhorn.lilith.swing.table.model;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.swing.table.DefaultTableColumnModel;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistentTableColumnModel}.\n* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.\n*/\nclass PersistentTableColumnModel_2Test {",
    "method_signature": "getColumns(boolean)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// PersistentTableColumnModel.java\npackage de.huxhorn.lilith.swing.table.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.DefaultTableColumnModel;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.\r\n */\r\npublic class PersistentTableColumnModel extends DefaultTableColumnModel {\r\n\r\n    protected List\u003cTableColumn\u003e allTableColumns \u003d new ArrayList\u003cTableColumn\u003e();\r\n\r\n    /**\r\n     * Creates an extended table column model.\r\n     */\r\n    public PersistentTableColumnModel() {\r\n        allTableColumns \u003d new ArrayList\u003cTableColumn\u003e();\r\n        initColumns();\r\n    }\r\n\r\n    /**\r\n     * Should be implemented by subclasses if needed.\r\n     */\r\n    protected void initColumns() {\r\n    }\r\n\r\n    /**\r\n     * Sets the visibility of the specified TableColumn.\r\n     * The call is ignored if the TableColumn is not found in this column model\r\n     * or its visibility status did not change.\r\n     * \u003cp/\u003e\r\n     *\r\n     * @param column  the column to show/hide\r\n     * @param visible its new visibility status\r\n     */\r\n    // listeners will receive columnAdded()/columnRemoved() event\r\n    public void setColumnVisible(TableColumn column, boolean visible) {\r\n        if (!visible) {\r\n            super.removeColumn(column);\r\n        } else {\r\n            // find the visible index of the column:\r\n            // iterate through both collections of visible and all columns, counting\r\n            // visible columns up to the one that\u0027s about to be shown again\r\n            int noVisibleColumns \u003d tableColumns.size();\r\n            int noInvisibleColumns \u003d allTableColumns.size();\r\n            int visibleIndex \u003d 0;\r\n            for (int invisibleIndex \u003d 0; invisibleIndex \u003c noInvisibleColumns; ++invisibleIndex) {\r\n                TableColumn visibleColumn \u003d (visibleIndex \u003c noVisibleColumns ? tableColumns.get(visibleIndex) : null);\r\n                TableColumn testColumn \u003d allTableColumns.get(invisibleIndex);\r\n                if (testColumn \u003d\u003d column) {\r\n                    if (visibleColumn !\u003d column) {\r\n                        super.addColumn(column);\r\n                        super.moveColumn(tableColumns.size() - 1, visibleIndex);\r\n                    }\r\n                    // ####################\r\n                    return;\r\n                }\r\n                if (testColumn \u003d\u003d visibleColumn) {\r\n                    ++visibleIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes all columns in this model visible\r\n     */\r\n    public void setAllColumnsVisible() {\r\n        int noColumns \u003d allTableColumns.size();\r\n        for (int columnIndex \u003d 0; columnIndex \u003c noColumns; ++columnIndex) {\r\n            TableColumn visibleColumn \u003d (columnIndex \u003c tableColumns.size() ? tableColumns.get(columnIndex) : null);\r\n            TableColumn invisibleColumn \u003d allTableColumns.get(columnIndex);\r\n            if (visibleColumn !\u003d invisibleColumn) {\r\n                super.addColumn(invisibleColumn);\r\n                super.moveColumn(tableColumns.size() - 1, columnIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks wether the specified column is currently visible.\r\n     *\r\n     * @param aColumn column to check\r\n     * @return visibility of specified column (false if there is no such column at all. [It\u0027s not visible, right?])\r\n     */\r\n    public boolean isColumnVisible(TableColumn aColumn) {\r\n        return (tableColumns.indexOf(aColumn) \u003e\u003d 0);\r\n    }\r\n\r\n    /**\r\n     * Append \u003ccode\u003ecolumn\u003c/code\u003e to the right of exisiting columns.\r\n     * Posts \u003ccode\u003ecolumnAdded\u003c/code\u003e event.\r\n     *\r\n     * @param column The column to be added\r\n     * @throws IllegalArgumentException if \u003ccode\u003ecolumn\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e\r\n     * @see #removeColumn\r\n     */\r\n    @Override\r\n    public void addColumn(TableColumn column) {\r\n        allTableColumns.add(column);\r\n        super.addColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Removes \u003ccode\u003ecolumn\u003c/code\u003e from this column model.\r\n     * Posts \u003ccode\u003ecolumnRemoved\u003c/code\u003e event.\r\n     * Will do nothing if the column is not in this model.\r\n     *\r\n     * @param column the column to be added\r\n     * @see #addColumn\r\n     */\r\n    @Override\r\n    public void removeColumn(TableColumn column) {\r\n        int allColumnsIndex \u003d allTableColumns.indexOf(column);\r\n        if (allColumnsIndex !\u003d -1) {\r\n            allTableColumns.remove(allColumnsIndex);\r\n        }\r\n        super.removeColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Moves the column from \u003ccode\u003eoldIndex\u003c/code\u003e to \u003ccode\u003enewIndex\u003c/code\u003e.\r\n     * Posts  \u003ccode\u003ecolumnMoved\u003c/code\u003e event.\r\n     * Will not move any columns if \u003ccode\u003eoldIndex\u003c/code\u003e equals \u003ccode\u003enewIndex\u003c/code\u003e.\r\n     *\r\n     * @throws IllegalArgumentException if either \u003ccode\u003eoldIndex\u003c/code\u003e or\r\n     *                                  \u003ccode\u003enewIndex\u003c/code\u003e\r\n     *                                  are not in [0, getColumnCount() - 1]\r\n     * @param\toldIndex\t\t\tindex of column to be moved\r\n     * @param\tnewIndex\t\t\tnew index of the column\r\n     */\r\n    @Override\r\n    public void moveColumn(int oldIndex, int newIndex) {\r\n        if ((oldIndex \u003c 0) || (oldIndex \u003e\u003d getColumnCount()) || (newIndex \u003c 0) || (newIndex \u003e\u003d getColumnCount())) {\r\n            throw new IllegalArgumentException(\"moveColumn() - Index out of range\");\r\n        }\r\n        TableColumn fromColumn \u003d tableColumns.get(oldIndex);\r\n        TableColumn toColumn \u003d tableColumns.get(newIndex);\r\n        int allColumnsOldIndex \u003d allTableColumns.indexOf(fromColumn);\r\n        int allColumnsNewIndex \u003d allTableColumns.indexOf(toColumn);\r\n        if (oldIndex !\u003d newIndex) {\r\n            allTableColumns.remove(allColumnsOldIndex);\r\n            allTableColumns.add(allColumnsNewIndex, fromColumn);\r\n        }\r\n        super.moveColumn(oldIndex, newIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of columns in this model.\r\n     *\r\n     * @param onlyVisible if set only visible columns will be counted\r\n     * @return the number of columns in the \u003ccode\u003etableColumns\u003c/code\u003e array\r\n     * @see\t#getColumns\r\n     */\r\n    public int getColumnCount(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.size() : allTableColumns.size());\r\n    }\r\n\r\n    /**\r\n     * Returns an \u003ccode\u003eEnumeration\u003c/code\u003e of all the columns in the model.\r\n     *\r\n     * @param onlyVisible if set all invisible columns will be missing from the enumeration.\r\n     * @return an \u003ccode\u003eEnumeration\u003c/code\u003e of the columns in the model\r\n     */\r\n    public Iterator\u003cTableColumn\u003e getColumns(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.iterator() : allTableColumns.iterator());\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first column whose identifier equals \u003ccode\u003eidentifier\u003c/code\u003e.\r\n     * Position is the the index in all visible columns if \u003ccode\u003eonlyVisible\u003c/code\u003e is true or\r\n     * else the index in all columns.\r\n     *\r\n     * @return the index of the first column whose identifier\r\n     *         equals \u003ccode\u003eidentifier\u003c/code\u003e\r\n     * @throws IllegalArgumentException if \u003ccode\u003eidentifier\u003c/code\u003e\r\n     *                                  is \u003ccode\u003enull\u003c/code\u003e, or if no\r\n     *                                  \u003ccode\u003eTableColumn\u003c/code\u003e has this\r\n     *                                  \u003ccode\u003eidentifier\u003c/code\u003e\r\n     * @param\tidentifier the identifier object to search for\r\n     * @param\tonlyVisible if set searches only visible columns\r\n     * @see\t\t#getColumn\r\n     */\r\n    public int getColumnIndex(Object identifier, boolean onlyVisible) {\r\n        if (identifier \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Identifier is null\");\r\n        }\r\n        List\u003cTableColumn\u003e columns \u003d (onlyVisible ? tableColumns : allTableColumns);\r\n        int noColumns \u003d columns.size();\r\n        TableColumn column;\r\n        for (int columnIndex \u003d 0; columnIndex \u003c noColumns; ++columnIndex) {\r\n            column \u003d columns.get(columnIndex);\r\n            if (identifier.equals(column.getIdentifier())) {\r\n                return columnIndex;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"Identifier not found\");\r\n    }\r\n\r\n    public List\u003cTableColumnLayoutInfo\u003e getColumnLayoutInfos() {\r\n        final List\u003cTableColumnLayoutInfo\u003e tableColumnLayoutInfos \u003d new ArrayList\u003cTableColumnLayoutInfo\u003e(allTableColumns.size());\r\n        for (TableColumn current : allTableColumns) {\r\n            boolean visible \u003d tableColumns.contains(current);\r\n            TableColumnLayoutInfo tableColumnLayoutInfo \u003d new TableColumnLayoutInfo(current.getIdentifier().toString(), current.getWidth(), visible);\r\n            tableColumnLayoutInfos.add(tableColumnLayoutInfo);\r\n        }\r\n        return tableColumnLayoutInfos;\r\n    }\r\n\r\n    public static class TableColumnLayoutInfo implements Serializable {\r\n\r\n        private String columnName;\r\n\r\n        private int width;\r\n\r\n        private boolean visible;\r\n\r\n        public TableColumnLayoutInfo() {\r\n        }\r\n\r\n        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {\r\n            this.columnName \u003d columnName;\r\n            this.width \u003d width;\r\n            this.visible \u003d visible;\r\n        }\r\n\r\n        public int getWidth() {\r\n            return width;\r\n        }\r\n\r\n        public void setWidth(int width) {\r\n            this.width \u003d width;\r\n        }\r\n\r\n        public String getColumnName() {\r\n            return columnName;\r\n        }\r\n\r\n        public void setColumnName(String columnName) {\r\n            this.columnName \u003d columnName;\r\n        }\r\n\r\n        public boolean isVisible() {\r\n            return visible;\r\n        }\r\n\r\n        public void setVisible(boolean visible) {\r\n            this.visible \u003d visible;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TableColumnLayoutInfo[columnName\u003d\" + columnName + \", width\u003d\" + width + \", visible\u003d\" + visible + \"]\";\r\n        }\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.swing.table.model",
    "classname": "PersistentTableColumnModel",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_3Test.java",
    "test_prompt": "// PersistentTableColumnModel_3Test.java\npackage de.huxhorn.lilith.swing.table.model;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.swing.table.DefaultTableColumnModel;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistentTableColumnModel}.\n* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n*/\nclass PersistentTableColumnModel_3Test {",
    "method_signature": "getColumnIndex(Object, boolean)",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// AboutPanel.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.swing;\r\n\r\nimport de.huxhorn.sulky.swing.GraphicsUtilities;\r\nimport de.huxhorn.sulky.swing.filters.ColorTintFilter;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.awt.*;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\nimport java.awt.event.ComponentAdapter;\r\nimport java.awt.event.ComponentEvent;\r\nimport java.awt.event.MouseEvent;\r\nimport java.awt.image.BufferedImage;\r\nimport java.awt.image.BufferedImageOp;\r\nimport java.awt.image.ConvolveOp;\r\nimport java.awt.image.Kernel;\r\nimport java.beans.PropertyChangeEvent;\r\nimport java.beans.PropertyChangeListener;\r\nimport java.io.IOException;\r\nimport java.net.URL;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport javax.swing.*;\r\nimport javax.swing.event.MouseInputAdapter;\r\n\r\n// TODO: get/setMouseHandling/MouseInputMode\r\n// TODO: setVersionHeight(versionHeight);\r\n// TODO: setVersionString(versionString);\r\n// TODO: correct versionHeight if string would be outside background.\r\n// TODO: VersionString centered to bg/scroll.\r\n// TODO: relative ScrollAreas (values given as % of backgroundImage)\r\n// TODO: Handle errors in Image-Loading\r\n// TODO: offscreenImage h�chstens so gro� wie die size / nicht gesamten bg malen\r\n// TODO: paint background-color for rest of component (not only behind bg-image)\r\n// TODO: scroll-area defined by object-array containing icons and strings...\r\n// TODO: transient attributes\r\n// TODO: serialVersion\r\n// TODO: use ResourceSupport\r\n/**\r\n * \u003ccode\u003eAboutPanel\u003c/code\u003e is a component which has a background-image and a\r\n * rectangle in which a given text is scrolling (the scroll-area). You may also\r\n * specify an Image (e.g. a png-file with alpha-channel) that is drawn before\r\n * the scroll-text itself. An optional version-string may be given that will be\r\n * painted centered relative to the scroll-area.\r\n *\r\n * @author Joern Huxhorn\r\n */\r\npublic class AboutPanel extends JComponent {\r\n\r\n    private final Logger logger \u003d LoggerFactory.getLogger(AboutPanel.class);\r\n\r\n    public static final String BACKGROUND_IMAGE_RESOURCE \u003d \"background.png\";\r\n\r\n    public static final String ABOUT_IMAGE_RESOURCE \u003d \"about.png\";\r\n\r\n    public static final String TEXT_RESOURCE_PREFIX \u003d \"about.\";\r\n\r\n    public static final String SCROLL_TEXT_RESOURCE \u003d TEXT_RESOURCE_PREFIX + \"scroll.text\";\r\n\r\n    public static final String VERSION_TEXT_RESOURCE \u003d TEXT_RESOURCE_PREFIX + \"version.text\";\r\n\r\n    public static final String VERSION_HEIGHT_RESOURCE \u003d TEXT_RESOURCE_PREFIX + \"version.height\";\r\n\r\n    public static final String SCROLL_AREA_RESOURCE_BASE \u003d TEXT_RESOURCE_PREFIX + \"scroll.area.\";\r\n\r\n    public static final String SCROLL_AREA_X_RESOURCE \u003d SCROLL_AREA_RESOURCE_BASE + \"x\";\r\n\r\n    public static final String SCROLL_AREA_Y_RESOURCE \u003d SCROLL_AREA_RESOURCE_BASE + \"y\";\r\n\r\n    public static final String SCROLL_AREA_WIDTH_RESOURCE \u003d SCROLL_AREA_RESOURCE_BASE + \"width\";\r\n\r\n    public static final String SCROLL_AREA_HEIGHT_RESOURCE \u003d SCROLL_AREA_RESOURCE_BASE + \"height\";\r\n\r\n    public static final String SCROLL_AREA_TOOLTIP_TEXT_RESOURCE \u003d SCROLL_AREA_RESOURCE_BASE + \"tooltip.text\";\r\n\r\n    public static final String TEXT_RESOURCE_BUNDLE_RESOURCE \u003d \"TextResources\";\r\n\r\n    public static final int MOUSE_DISABLED \u003d 0;\r\n\r\n    public static final int MOUSE_COMPONENT \u003d 1;\r\n\r\n    public static final int MOUSE_SCROLLAREA \u003d 2;\r\n\r\n    public static final int MOUSE_BACKGROUND \u003d 3;\r\n\r\n    //private static final int SCROLL_SLEEP_TIME \u003d 50;\r\n    private static final int SCROLL_PIXELS \u003d 1;\r\n\r\n    //private static final int SCROLL_THREAD_PRIORITY \u003d Thread.NORM_PRIORITY+1;\r\n    //private final ResourceSupport resourceSupport;\r\n    private BufferedImage backgroundImage;\r\n\r\n    private BufferedImage aboutImage;\r\n\r\n    //private ImageIcon backgroundImageIcon;\r\n    //private ImageIcon aboutImageIcon;\r\n    private FontMetrics fontMetrics;\r\n\r\n    private Insets insets;\r\n\r\n    private Dimension size;\r\n\r\n    private Dimension preferredSize;\r\n\r\n    private Point offscreenOffset;\r\n\r\n    private String[] scrollLines;\r\n\r\n    private String versionText;\r\n\r\n    private String scrollAreaToolTipText;\r\n\r\n    private int versionHeight;\r\n\r\n    private int scrollPosition;\r\n\r\n    private int maxScrollPosition;\r\n\r\n    private int minScrollPosition;\r\n\r\n    private Rectangle maxScrollArea;\r\n\r\n    private Rectangle backgroundImageArea;\r\n\r\n    private Rectangle translatedBackgroundImageArea;\r\n\r\n    private Rectangle translatedScrollArea;\r\n\r\n    private Rectangle scrollArea;\r\n\r\n    private Rectangle paintArea;\r\n\r\n    private BufferedImage offscreenImage;\r\n\r\n    private BufferedImage scrollImage;\r\n\r\n    private boolean scrolling;\r\n\r\n    //private boolean offscreenInitialized \u003d false;\r\n    //private boolean scrollInitialized \u003d false;\r\n    //private boolean painted;\r\n    private int mouseEventHandling \u003d MOUSE_BACKGROUND;\r\n\r\n    //private transient Thread scrollThread;\r\n    private boolean debug;\r\n\r\n    private Timer timer;\r\n\r\n    //private String scrollText;\r\n    //private Map textBundleMap;\r\n    //private int mouseEventHandling\u003dMOUSE_DISABLED;\r\n    /**\r\n     * Creates a new \u003ccode\u003eAboutPanel\u003c/code\u003e initialized with the given parameters.\r\n     *\r\n     * @param backgroundImageUrl The URL to the Background-Image of the\r\n     *                           AboutPanel. This parameter is mandatory.\r\n     * @param scrollArea         The Rectangle inside the background-image where\r\n     *                           scrolling should take place. This parameter is optional. If it\u0027s null\r\n     *                           then the scroll-area is set to (0, 0, background.width,\r\n     *                           background.height).\r\n     */\r\n    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText) throws IOException {\r\n        this(backgroundImageUrl, scrollArea, scrollText, null, null, -1);\r\n    }\r\n\r\n    public boolean isDebug() {\r\n        return debug;\r\n    }\r\n\r\n    public void setDebug(boolean debug) {\r\n        this.debug \u003d debug;\r\n    }\r\n\r\n    /**\r\n     * Creates a new \u003ccode\u003eAboutPanel\u003c/code\u003e initialized with the given parameters.\r\n     *\r\n     * @param backgroundImageUrl The URL to the Background-Image of the\r\n     *                           AboutPanel. This parameter is mandatory.\r\n     * @param scrollArea         The Rectangle inside the background-image where\r\n     *                           scrolling should take place. This parameter is optional. If it\u0027s null\r\n     *                           then the scroll-area is set to (0, 0, background.width,\r\n     *                           background.height).\r\n     * @param versionText        The String describing the version of the program.\r\n     *                           It is painted centered to the scroll-rectangle at the specified height.\r\n     *                           This parameter is optional.\r\n     * @param versionHeight      The height at which the version-string is\r\n     *                           supposed to be painted. This parameter is optional but should be given\r\n     *                           a correct value if versionText!\u003dnull..\r\n     */\r\n    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, String versionText, int versionHeight) throws IOException {\r\n        this(backgroundImageUrl, scrollArea, scrollText, null, versionText, versionHeight);\r\n    }\r\n\r\n    /**\r\n     * Creates a new \u003ccode\u003eAboutPanel\u003c/code\u003e initialized with the given parameters.\r\n     *\r\n     * @param backgroundImageUrl The URL to the Background-Image of the\r\n     *                           AboutPanel. This parameter is mandatory.\r\n     * @param scrollArea         The Rectangle inside the background-image where\r\n     *                           scrolling should take place. This parameter is optional. If it\u0027s null\r\n     *                           then the scroll-area is set to (0, 0, background.width,\r\n     *                           background.height).\r\n     * @param imageUrl           The URL to the Image that will be painted at the\r\n     *                           start of the scroll-area. This parameter is optional.\r\n     * @param versionText        The String describing the version of the program.\r\n     *                           It is painted centered to the scroll-rectangle at the specified height.\r\n     *                           This parameter is optional.\r\n     * @param versionHeight      The height at which the version-string is\r\n     *                           supposed to be painted. This parameter is optional but should be given\r\n     *                           a correct value if versionText!\u003dnull..\r\n     */\r\n    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException {\r\n        this();\r\n        if (backgroundImageUrl \u003d\u003d null) {\r\n            throw new NullPointerException(\"backgroundImageUrl must not be null!\");\r\n        }\r\n        if (scrollText \u003d\u003d null) {\r\n            throw new NullPointerException(\"scrollText must not be null!\");\r\n        }\r\n        init(backgroundImageUrl, scrollArea, scrollText, imageUrl, versionText, versionHeight);\r\n    }\r\n\r\n    public AboutPanel() {\r\n        ActionListener timerListener \u003d new TimerActionListener();\r\n        timer \u003d new Timer(10, timerListener);\r\n        //this.resourceSupport\u003dnew ResourceSupport(this);\r\n        initAttributes();\r\n        addPropertyChangeListener(new AboutPropertyChangeListener());\r\n        addComponentListener(new AboutComponentListener());\r\n        // initializes to Label.font\r\n        setFont(null);\r\n        AboutMouseInputListener mouseInputListener \u003d new AboutMouseInputListener();\r\n        addMouseListener(mouseInputListener);\r\n        addMouseMotionListener(mouseInputListener);\r\n        //this.scrollThread\u003dnull;\r\n        setScrolling(false);\r\n        //\t\tinitResources();\r\n    }\r\n\r\n    //\tprotected void initResources()\r\n    //\t{\r\n    //\t\tinitTextBundleMap();\r\n    //\r\n    //\t\t//URL backgroundImageUrl\u003dresourceSupport.getResource(BACKGROUND_IMAGE_RESOURCE);\r\n    //\t\t//URL imageUrl\u003dresourceSupport.getResource(ABOUT_IMAGE_RESOURCE);\r\n    //\t\t//scrollText\u003dgetTextResource(SCROLL_TEXT_RESOURCE, null);\r\n    //\t\tversionText\u003dgetTextResource(VERSION_TEXT_RESOURCE, null);\r\n    //\t\tint versionHeight\u003d-1;\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tversionHeight\u003dInteger.parseInt(getTextResource(VERSION_HEIGHT_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\r\n    //\t\tRectangle scrollArea\u003dnew Rectangle(-1, -1, -1, -1);\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tscrollArea.x\u003dInteger.parseInt(getTextResource(SCROLL_AREA_X_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tscrollArea.y\u003dInteger.parseInt(getTextResource(SCROLL_AREA_Y_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tscrollArea.width\u003dInteger.parseInt(getTextResource(SCROLL_AREA_WIDTH_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tscrollArea.height\u003dInteger.parseInt(getTextResource(SCROLL_AREA_HEIGHT_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\t\tif(\tscrollArea.x \u003d\u003d -1 ||\r\n    //\t\t\tscrollArea.y \u003d\u003d -1 ||\r\n    //\t\t\tscrollArea.width \u003d\u003d -1 ||\r\n    //\t\t\tscrollArea.height \u003d\u003d -1 )\r\n    //\t\t{\r\n    //\t\t\t// ignore if scroll-area isn\u0027t fully specified\r\n    //\t\t\tscrollArea \u003d null;\r\n    //\t\t}\r\n    //\t\tinit(backgroundImageUrl, scrollArea, scrollText, imageUrl, versionText, versionHeight );\r\n    //\t\t//setScrollAreaToolTipText(getTextResource(SCROLL_AREA_TOOLTIP_TEXT_RESOURCE, null));\r\n    //\t}\r\n    //\tprotected void initTextBundleMap()\r\n    //\t{\r\n    //\t\ttextBundleMap\u003dresourceSupport.getResourceMap(TEXT_RESOURCE_BUNDLE_RESOURCE, getLocale());\r\n    //\t\tif(logger.isDebugEnabled() \u0026\u0026 textBundleMap!\u003dnull)\r\n    //\t\t{\r\n    //\t\t\tStringBuffer buffer\u003dnew StringBuffer();\r\n    //\r\n    //\t\t\tIterator iter\u003dtextBundleMap.keySet().iterator();\r\n    //\t\t\twhile(iter.hasNext())\r\n    //\t\t\t{\r\n    //\t\t\t\tObject key\u003diter.next();\r\n    //\t\t\t\tObject value\u003dtextBundleMap.get(key);\r\n    //\t\t\t\tbuffer.append(\"Key: \");\r\n    //\t\t\t\tbuffer.append(key);\r\n    //\t\t\t\tbuffer.append(\"    Value: \");\r\n    //\t\t\t\tbuffer.append(value);\r\n    //\t\t\t\tbuffer.append(\"\\n\");\r\n    //\r\n    //\t\t\t}\r\n    //\t\t\tlogger.debug(\"BundleMap \\\"\"+TEXT_RESOURCE_BUNDLE_RESOURCE+\"\\\" of class \"+getClass().getName()+\":\\n\"+buffer.toString());\r\n    //\t\t}\r\n    //\t\tif(logger.isInfoEnabled() \u0026\u0026 textBundleMap\u003d\u003dnull)\r\n    //\t\t{\r\n    //\t\t\tlogger.info(\"Couldn\u0027t find BundleMap \\\"\"+TEXT_RESOURCE_BUNDLE_RESOURCE+\"\\\" of class \"+getClass().getName()+\".\");\r\n    //\t\t}\r\n    //\t}\r\n    //\tprotected String getTextResource(final String resourceName, final String defaultValue)\r\n    //\t{\r\n    //\t\tString result\u003dnull;\r\n    //\t\tif(textBundleMap!\u003dnull)\r\n    //\t\t{\r\n    //\t\t\tresult\u003d(String)textBundleMap.get(resourceName);\r\n    //\t\t}\r\n    //\t\tif(result\u003d\u003dnull)\r\n    //\t\t{\r\n    //\t\t\tresult\u003ddefaultValue;\r\n    //\t\t\tif(logger.isDebugEnabled()) logger.debug(\"Using default-value \u0027\"+defaultValue+\"\u0027 for text-resource \u0027\"+resourceName+\"\u0027.\");\r\n    //\t\t}\r\n    //\r\n    //\t\treturn result;\r\n    //\t}\r\n    private void init(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"init called with following arguments: backgroundImageUrl\u003d\" + backgroundImageUrl + \", \" + \"scrollArea\u003d\" + scrollArea + \", scrollText\u003d\" + scrollText + \", imageUrl\u003d\" + imageUrl + \", versionText\u003d\" + versionText + \", versionHeight\u003d\" + versionHeight);\r\n        }\r\n        setBackgroundImage(backgroundImageUrl);\r\n        setScrollArea(scrollArea);\r\n        setAboutImage(imageUrl);\r\n        this.versionText \u003d versionText;\r\n        this.versionHeight \u003d versionHeight;\r\n        setScrollText(scrollText);\r\n    }\r\n\r\n    /*\r\n\tprotected synchronized boolean isPainted()\r\n\t{\r\n\t\treturn painted;\r\n\t}\r\n\r\n\tprotected synchronized void setPainted(boolean painted)\r\n\t{\r\n\t\tif(this.painted!\u003dpainted)\r\n\t\t{\r\n\t\t\tthis.painted\u003dpainted;\r\n\t\t\tnotifyAll();\r\n\t\t}\r\n\t}\r\n    */\r\n    private void initAttributes() {\r\n        //setPainted(true);\r\n        preferredSize \u003d new Dimension();\r\n        offscreenOffset \u003d new Point();\r\n        backgroundImageArea \u003d new Rectangle();\r\n        translatedScrollArea \u003d new Rectangle();\r\n        translatedBackgroundImageArea \u003d new Rectangle();\r\n        scrollArea \u003d new Rectangle();\r\n        paintArea \u003d new Rectangle();\r\n        insets \u003d getInsets();\r\n    }\r\n\r\n    public void setScrollText(String ScrollText) {\r\n        StringTokenizer st \u003d new StringTokenizer(ScrollText, \"\\n\", true);\r\n        List\u003cString\u003e lines \u003d new ArrayList\u003cString\u003e(st.countTokens() / 2);\r\n        String prevToken \u003d null;\r\n        while (st.hasMoreTokens()) {\r\n            String token \u003d st.nextToken();\r\n            if (token.equals(\"\\n\")) {\r\n                if (prevToken !\u003d null \u0026\u0026 !prevToken.equals(\"\\n\")) {\r\n                    lines.add(prevToken);\r\n                } else {\r\n                    lines.add(\"\");\r\n                }\r\n            }\r\n            prevToken \u003d token;\r\n        }\r\n        if (prevToken !\u003d null \u0026\u0026 !prevToken.equals(\"\\n\")) {\r\n            lines.add(prevToken);\r\n        }\r\n        String[] loScrollLines \u003d new String[lines.size()];\r\n        loScrollLines \u003d lines.toArray(loScrollLines);\r\n        setScrollLines(loScrollLines);\r\n    }\r\n\r\n    protected void setScrollLines(String[] scrollLines) {\r\n        if (scrollLines \u003d\u003d null) {\r\n            NullPointerException ex \u003d new NullPointerException(\"scrollLines must not be null!\");\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Parameter \u0027scrollLines\u0027 of method \u0027setScrollLines\u0027 must not be null!\", ex);\r\n            }\r\n            throw ex;\r\n        }\r\n        this.scrollLines \u003d scrollLines.clone();\r\n        flushScrollImage();\r\n    }\r\n\r\n    /**\r\n     * Sets the backgroundImage attribute of the \u003ccode\u003eAboutPanel\u003c/code\u003e object\r\n     */\r\n    public void setBackgroundImage(URL imageUrl) throws IOException {\r\n        setBackgroundImage(GraphicsUtilities.loadCompatibleImage(imageUrl));\r\n    }\r\n\r\n    /**\r\n     * Sets the backgroundImage attribute of the \u003ccode\u003eAboutPanel\u003c/code\u003e object\r\n     *\r\n     * @param BackgroundImage The new backgroundImage value\r\n     */\r\n    public void setBackgroundImage(BufferedImage BackgroundImage) {\r\n        if (backgroundImage !\u003d null) {\r\n            backgroundImage.flush();\r\n            backgroundImage \u003d null;\r\n        }\r\n        backgroundImage \u003d BackgroundImage;\r\n        updateBackgroundAttributes();\r\n    }\r\n\r\n    public void setAboutImage(URL imageUrl) throws IOException {\r\n        setAboutImage(GraphicsUtilities.loadCompatibleImage(imageUrl));\r\n    }\r\n\r\n    public void setAboutImage(BufferedImage AboutImage) {\r\n        if (aboutImage !\u003d null) {\r\n            aboutImage.flush();\r\n            aboutImage \u003d null;\r\n        }\r\n        aboutImage \u003d AboutImage;\r\n        flushScrollImage();\r\n    }\r\n\r\n    /**\r\n     * Sets the scrollArea attribute of the \u003ccode\u003eAboutPanel\u003c/code\u003e object\r\n     *\r\n     * @param ScrollArea The new scrollArea value\r\n     */\r\n    public void setScrollArea(Rectangle ScrollArea) {\r\n        if (ScrollArea !\u003d null) {\r\n            maxScrollArea \u003d backgroundImageArea.intersection(ScrollArea);\r\n        } else {\r\n            maxScrollArea \u003d (Rectangle) backgroundImageArea.clone();\r\n        }\r\n        minScrollPosition \u003d -maxScrollArea.height;\r\n        calculateAttributes();\r\n        flushScrollImage();\r\n    }\r\n\r\n    /**\r\n     * Description of the Method\r\n     */\r\n    private void flushScrollImage() {\r\n        if (scrollImage !\u003d null) {\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Flushing ScrollImage\");\r\n            scrollImage.flush();\r\n            scrollImage \u003d null;\r\n        }\r\n        setScrollPosition(minScrollPosition);\r\n    }\r\n\r\n    /**\r\n     * Description of the Method\r\n     */\r\n    private void flushOffscreenImage() {\r\n        if (offscreenImage !\u003d null) {\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Flushing OffscreenImage\");\r\n            offscreenImage.flush();\r\n            offscreenImage \u003d null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Description of the Method\r\n     */\r\n    private void updateBackgroundAttributes() {\r\n        backgroundImageArea.x \u003d 0;\r\n        backgroundImageArea.y \u003d 0;\r\n        backgroundImageArea.width \u003d backgroundImage.getWidth();\r\n        backgroundImageArea.height \u003d backgroundImage.getHeight();\r\n        calculatePreferredSize();\r\n        if (maxScrollArea !\u003d null) {\r\n            maxScrollArea \u003d maxScrollArea.intersection(backgroundImageArea);\r\n        } else {\r\n            maxScrollArea \u003d (Rectangle) backgroundImageArea.clone();\r\n        }\r\n        flushOffscreenImage();\r\n        flushScrollImage();\r\n        repaint();\r\n    }\r\n\r\n    /**\r\n     * Sets the ToolTipText that will appear if the user moves the mouse over the\r\n     * scroll-area of this component.\r\n     *\r\n     * @param toolTipText The new ScrollAreaToolTipText value\r\n     */\r\n    public void setScrollAreaToolTipText(String toolTipText) {\r\n        scrollAreaToolTipText \u003d toolTipText;\r\n    }\r\n\r\n    /**\r\n     * Gets the ScrollAreaToolTipText attribute of the \u003ccode\u003eAboutPanel\u003c/code\u003e\r\n     * object\r\n     *\r\n     * @return The ScrollAreaToolTipText value\r\n     */\r\n    public String getScrollAreaToolTipText() {\r\n        return scrollAreaToolTipText;\r\n    }\r\n\r\n    /**\r\n     * This method returns ScrollAreaToolTipText if the point of the \u003ccode\u003eMouseEvent\u003c/code\u003e\r\n     * is inside the scroll-area and \u003ccode\u003enull\u003c/code\u003e otherwise.\u003cp /\u003e\r\n     * \u003cp/\u003e\r\n     * It\u0027s needed by the \u003ccode\u003eToolTipManager\u003c/code\u003e .\r\n     *\r\n     * @param evt a \u003ccode\u003eMouseEvent\u003c/code\u003e.\r\n     * @return The toolTipText value for the \u003ccode\u003eToolTipManager\u003c/code\u003e.\r\n     */\r\n    public String getToolTipText(MouseEvent evt) {\r\n        if (handleMouseEvent(evt)) {\r\n            return scrollAreaToolTipText;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected boolean handleMouseEvent(MouseEvent evt) {\r\n        Rectangle loArea \u003d null;\r\n        if (mouseEventHandling \u003d\u003d MOUSE_BACKGROUND) {\r\n            loArea \u003d translatedBackgroundImageArea;\r\n        } else if (mouseEventHandling \u003d\u003d MOUSE_SCROLLAREA) {\r\n            loArea \u003d translatedScrollArea;\r\n        } else if (mouseEventHandling \u003d\u003d MOUSE_DISABLED) {\r\n            return false;\r\n        }\r\n        Point loPoint \u003d evt.getPoint();\r\n        if (loArea \u003d\u003d null) {\r\n            // -\u003e default: MOUSE_COMPONENT\r\n            return contains(loPoint);\r\n        }\r\n        if (loArea.contains(loPoint)) {\r\n            // MOUSE_BACKGROUND / MOUSE_SCROLLAREA\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Increases the ScrollPosition by SCROLL_PIXELS. This method is called by the\r\n     * scroll-thread and calls \u003ccode\u003esetScrollPosition\u003c/code\u003e, therefore causing a\r\n     * repaint of the scroll-area..\r\n     *\r\n     * @see #setScrollPosition\r\n     */\r\n    protected void increaseScrollPosition() {\r\n        setScrollPosition(scrollPosition + SCROLL_PIXELS);\r\n    }\r\n\r\n    /**\r\n     * Sets the scrollPosition attribute of the \u003ccode\u003eAboutPanel\u003c/code\u003e object. The\r\n     * value will be corrected according Minimum- and MaximumScrollPosition.\r\n     * Changing the scroll-position will result in a repaint of the scroll-area.\r\n     *\r\n     * @param scrollPosition The new scrollPosition value. This value indicates\r\n     *                       the height-offset of the scroll-area.\r\n     * @see #getMinimumScrollPosition\r\n     * @see #getMaximumScrollPosition\r\n     */\r\n    public void setScrollPosition(int scrollPosition) {\r\n        if (scrollPosition \u003e maxScrollPosition) {\r\n            int remainder \u003d scrollPosition % maxScrollPosition;\r\n            scrollPosition \u003d minScrollPosition + remainder;\r\n        } else if (scrollPosition \u003c minScrollPosition) {\r\n            int remainder \u003d scrollPosition % minScrollPosition;\r\n            scrollPosition \u003d maxScrollPosition + remainder;\r\n        }\r\n        if (this.scrollPosition !\u003d scrollPosition) {\r\n            this.scrollPosition \u003d scrollPosition;\r\n            repaintScrollArea();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the ScrollPosition attribute of the \u003ccode\u003eAboutPanel\u003c/code\u003e object\r\n     *\r\n     * @return this value indicates the height-offset of the scroll-area.\r\n     */\r\n    public int getScrollPosition() {\r\n        return scrollPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the MinimumScrollPosition attribute of the \u003ccode\u003eAboutPanel\u003c/code\u003e\r\n     * object. It\u0027s value is the negated value of the scroll-area-height.\r\n     *\r\n     * @return The MinimumScrollPosition value\r\n     */\r\n    public int getMinimumScrollPosition() {\r\n        return minScrollPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the MaximumScrollPosition attribute of the \u003ccode\u003eAboutPanel\u003c/code\u003e\r\n     * object. It\u0027s value is the height needed for all lines of text plus (if\r\n     * available) the height of the image with an additional empty line.\r\n     *\r\n     * @return The MaximumScrollPosition value\r\n     */\r\n    public int getMaximumScrollPosition() {\r\n        return maxScrollPosition;\r\n    }\r\n\r\n    /**\r\n     * This method creates the offscreen-image when needed (when called for the\r\n     * first time or recreated because of a changed font) and updates it on\r\n     * subsequent calls by calling \u003ccode\u003eupdateOffscreenImage()\u003c/code\u003e.\r\n     */\r\n    private void processOffscreenImage() {\r\n        Graphics2D g;\r\n        if (offscreenImage \u003d\u003d null) {\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Creating offscreen-image\");\r\n            boolean opaque \u003d false;\r\n            if (isOpaque()) {\r\n                offscreenImage \u003d GraphicsUtilities.createOpaqueCompatibleImage(backgroundImageArea.width, backgroundImageArea.height);\r\n                opaque \u003d true;\r\n            } else {\r\n                offscreenImage \u003d GraphicsUtilities.createTranslucentCompatibleImage(backgroundImageArea.width, backgroundImageArea.height);\r\n            }\r\n            g \u003d (Graphics2D) offscreenImage.getGraphics();\r\n            if (opaque) {\r\n                g.setColor(getBackground());\r\n                g.fillRect(backgroundImageArea.x, backgroundImageArea.y, backgroundImageArea.width, backgroundImageArea.height);\r\n            }\r\n            g.drawImage(backgroundImage, 0, 0, null);\r\n            if (versionText !\u003d null) {\r\n                // draw version-text...\r\n                g.setColor(getForeground());\r\n                g.drawString(versionText, maxScrollArea.x + (maxScrollArea.width - fontMetrics.stringWidth(versionText)) / 2, versionHeight);\r\n            }\r\n        } else {\r\n            g \u003d (Graphics2D) offscreenImage.getGraphics();\r\n        }\r\n        g.setFont(getFont());\r\n        drawScrollArea(g);\r\n        g.dispose();\r\n    }\r\n\r\n    /**\r\n     * Updates the offscreen-image to represent the current scroll-position. It\r\n     * calls \u003ccode\u003einitScrollImage()\u003c/code\u003e.\r\n     *\r\n     * @param g \u003ccode\u003eGraphics\u003c/code\u003e-object\r\n     */\r\n    private void drawScrollArea(Graphics2D g) {\r\n        initScrollImage();\r\n        // only draw in the scroll-area\r\n        g.setClip(scrollArea.x, scrollArea.y, scrollArea.width, scrollArea.height);\r\n        // clear background for transparent bg-images\r\n        g.setColor(getBackground());\r\n        g.fillRect(scrollArea.x, scrollArea.y, scrollArea.width, scrollArea.height);\r\n        // draw background-image\r\n        g.drawImage(backgroundImage, 0, 0, this);\r\n        // redraw version-text if available.\r\n        if (versionText !\u003d null) {\r\n            g.setColor(getForeground());\r\n            g.drawString(versionText, maxScrollArea.x + (maxScrollArea.width - fontMetrics.stringWidth(versionText)) / 2, versionHeight);\r\n        }\r\n        // draw proper part of precalculated scroll-image.\r\n        g.drawImage(scrollImage, scrollArea.x, scrollArea.y - scrollPosition, this);\r\n        if (debug) {\r\n            g.setColor(Color.YELLOW);\r\n            g.drawRect(scrollArea.x, scrollArea.y, scrollArea.width - 1, scrollArea.height - 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the scroll-image if needed. The scroll-image is as high as\r\n     * needed to contain all the scroll-lines and (if available) the image.\r\n     */\r\n    private void initScrollImage() {\r\n        int fontHeight \u003d fontMetrics.getHeight();\r\n        maxScrollPosition \u003d fontHeight * (scrollLines.length);\r\n        int additionalImageOffset \u003d 0;\r\n        int imageWidth \u003d 0;\r\n        if (aboutImage !\u003d null) {\r\n            imageWidth \u003d aboutImage.getWidth();\r\n            additionalImageOffset \u003d aboutImage.getHeight() + 2 * fontHeight;\r\n            maxScrollPosition \u003d maxScrollPosition + additionalImageOffset;\r\n        }\r\n        if (scrollImage !\u003d null \u0026\u0026 scrollImage.getHeight() !\u003d maxScrollPosition) {\r\n            flushScrollImage();\r\n        }\r\n        if (scrollImage \u003d\u003d null) {\r\n            int maxWidth \u003d imageWidth + 2 * fontHeight;\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"imageWidth\u003d{}, maxWidth\u003d{}\", imageWidth, maxWidth);\r\n            for (String scrollLine : scrollLines) {\r\n                int curWidth \u003d fontMetrics.stringWidth(scrollLine);\r\n                if (curWidth \u003e maxWidth) {\r\n                    maxWidth \u003d curWidth;\r\n                }\r\n            }\r\n            if (maxWidth \u003e maxScrollArea.width) {\r\n                if (logger.isInfoEnabled())\r\n                    logger.info(\"maxWidth\u003d{} !\u003d maxScrollArea\u003d\", maxWidth, maxScrollArea);\r\n                maxWidth \u003d maxScrollArea.width;\r\n            }\r\n            scrollArea.x \u003d maxScrollArea.x + (maxScrollArea.width - maxWidth) / 2;\r\n            scrollArea.y \u003d maxScrollArea.y;\r\n            scrollArea.width \u003d maxWidth;\r\n            scrollArea.height \u003d maxScrollArea.height;\r\n            scrollImage \u003d GraphicsUtilities.createTranslucentCompatibleImage(scrollArea.width, maxScrollPosition);\r\n            Color foreground \u003d getForeground();\r\n            Graphics2D g;\r\n            g \u003d (Graphics2D) scrollImage.getGraphics();\r\n            g.setFont(getFont());\r\n            if (aboutImage !\u003d null) {\r\n                g.drawImage(aboutImage, (((scrollArea.width - imageWidth) / 2)), fontHeight, null);\r\n            }\r\n            g.setColor(foreground);\r\n            int y \u003d fontMetrics.getAscent() + additionalImageOffset;\r\n            for (String line : scrollLines) {\r\n                g.drawString(line, (scrollArea.width - fontMetrics.stringWidth(line)) / 2, y);\r\n                y +\u003d fontHeight;\r\n            }\r\n            g.dispose();\r\n            BufferedImage copy \u003d GraphicsUtilities.createCompatibleCopy(scrollImage);\r\n            BufferedImageOp filter;\r\n            final int blurSize \u003d 10;\r\n            filter \u003d getGaussianBlurFilter(blurSize, false);\r\n            scrollImage \u003d filter.filter(scrollImage, null);\r\n            filter \u003d getGaussianBlurFilter(blurSize, true);\r\n            scrollImage \u003d filter.filter(scrollImage, null);\r\n            filter \u003d new ColorTintFilter(Color.GREEN, 1.0f);\r\n            scrollImage \u003d filter.filter(scrollImage, null);\r\n            g \u003d (Graphics2D) scrollImage.getGraphics();\r\n            g.setComposite(AlphaComposite.SrcOver);\r\n            g.drawImage(copy, 0, 0, null);\r\n            if (debug) {\r\n                g.setColor(Color.RED);\r\n                g.drawRect(0, 0, scrollImage.getWidth() - 1, scrollImage.getHeight() - 1);\r\n                g.setColor(Color.GREEN);\r\n                g.drawRect((((scrollArea.width - imageWidth) / 2)), fontHeight, aboutImage.getWidth(), aboutImage.getHeight());\r\n            }\r\n            g.dispose();\r\n            copy.flush();\r\n        }\r\n    }\r\n\r\n    public static ConvolveOp getGaussianBlurFilter(int radius, boolean horizontal) {\r\n        final Logger logger \u003d LoggerFactory.getLogger(AboutPanel.class);\r\n        if (radius \u003c 1) {\r\n            throw new IllegalArgumentException(\"Radius must be \u003e\u003d 1\");\r\n        }\r\n        int size \u003d radius * 2 + 1;\r\n        float[] data \u003d new float[size];\r\n        float sigma \u003d radius / 3.0f;\r\n        float twoSigmaSquare \u003d 2.0f * sigma * sigma;\r\n        float sigmaRoot \u003d (float) Math.sqrt(twoSigmaSquare * Math.PI);\r\n        float total \u003d 0.0f;\r\n        for (int i \u003d -radius; i \u003c\u003d radius; i++) {\r\n            float distance \u003d i * i;\r\n            int index \u003d i + radius;\r\n            data[index] \u003d (float) Math.exp(-distance / twoSigmaSquare) / sigmaRoot;\r\n            total +\u003d data[index];\r\n        }\r\n        for (int i \u003d 0; i \u003c data.length; i++) {\r\n            data[i] /\u003d total;\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"data[{}]\u003d{}\", i, data[i]);\r\n        }\r\n        Kernel kernel \u003d null;\r\n        if (horizontal) {\r\n            kernel \u003d new Kernel(size, 1, data);\r\n        } else {\r\n            kernel \u003d new Kernel(1, size, data);\r\n        }\r\n        return new ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, null);\r\n    }\r\n\r\n    /**\r\n     * Sets the font attribute of the \u003ccode\u003eAboutPanel\u003c/code\u003e object. Setting it\r\n     * will result in the recreation of all buffers. The font can even be safely\r\n     * changed while the component is visible. It will be used for the version- and\r\n     * scroll-text.\u003cp /\u003e\r\n     * \u003cp/\u003e\r\n     * If the parameter is \u003ccode\u003enull\u003c/code\u003e then \u003ccode\u003eUIManager.getFont( \"Label.font\" )\u003c/code\u003e\r\n     * will be used.\r\n     *\r\n     * @param newFont The new font value.\r\n     */\r\n    public void setFont(Font newFont) {\r\n        if (newFont \u003d\u003d null) {\r\n            newFont \u003d UIManager.getFont(\"Label.font\");\r\n        }\r\n        if (newFont !\u003d null \u0026\u0026 !newFont.equals(getFont())) {\r\n            super.setFont(newFont);\r\n            fontMetrics \u003d getFontMetrics(newFont);\r\n            flushScrollImage();\r\n        }\r\n    }\r\n\r\n    /*\r\n\tFontRenderContext frc \u003d g2.getFontRenderContext();\r\n        Font f \u003d new Font(\"sansserif\",Font.PLAIN,w/8);\r\n        Font f1 \u003d new Font(\"sansserif\",Font.ITALIC,w/8);\r\n        String s \u003d \"AttributedString\";\r\n        AttributedString as \u003d new AttributedString(s);\r\n\r\n\r\n        // applies the TextAttribute.Font attribute to the AttributedString\r\n        // with the range 0 to 10, which encompasses the letters \u0027A\u0027 through\r\n        // \u0027d\u0027 of the String \"AttributedString\"\r\n        as.addAttribute(TextAttribute.FONT, f, 0, 10 );\r\n\r\n        // applies the TextAttribute.Font attribute to the AttributedString\r\n        // with the range 10 to the length of the String s, which encompasses\r\n        // the letters \u0027S\u0027 through \u0027g\u0027 of String \"AttributedString\"\r\n        as.addAttribute(TextAttribute.FONT, f1, 10, s.length() );\r\n\r\n        AttributedCharacterIterator aci \u003d as.getIterator();\r\n\r\n        // creates a TextLayout from the AttributedCharacterIterator\r\n        TextLayout tl \u003d new TextLayout (aci, frc);\r\n        float sw \u003d (float) tl.getBounds().getWidth();\r\n        float sh \u003d (float) tl.getBounds().getHeight();\r\n\r\n        // creates an outline shape from the TextLayout and centers it\r\n        // with respect to the width of the surface\r\n        Shape sha \u003d tl.getOutline(AffineTransform.getTranslateInstance(w/2-sw/2, h*0.2+sh/2));\r\n        g2.setColor(Color.blue);\r\n        g2.setStroke(new BasicStroke(1.5f));\r\n        g2.draw(sha);\r\n        g2.setColor(Color.magenta);\r\n        g2.fill(sha);\r\n\t*/\r\n    /**\r\n     * Paints this component.\r\n     *\r\n     * @param _g \u003ccode\u003eGraphics\u003c/code\u003e-object\r\n     */\r\n    public void paintComponent(Graphics _g) {\r\n        super.paintComponent(_g);\r\n        processOffscreenImage();\r\n        // we need to create a copy of the given graphics since we\r\n        // change the clip. Otherwise the border wouldn\u0027t be painted\r\n        // propertly (not at all in this case).\r\n        Graphics2D g \u003d (Graphics2D) _g.create();\r\n        g.setClip(paintArea.x, paintArea.y, paintArea.width, paintArea.height);\r\n        g.drawImage(offscreenImage, paintArea.x + offscreenOffset.x, paintArea.y + offscreenOffset.y, this);\r\n        g.dispose();\r\n        //setPainted(true);\r\n    }\r\n\r\n    /**\r\n     * Makes sure that the private attributes size, paintArea, offscreenOffset and\r\n     * translated areas have sane values. It\u0027s called on component-resize.\r\n     */\r\n    private void calculateAttributes() {\r\n        size \u003d getSize(size);\r\n        paintArea.x \u003d insets.left;\r\n        paintArea.y \u003d insets.top;\r\n        paintArea.width \u003d size.width - insets.left - insets.right;\r\n        paintArea.height \u003d size.height - insets.top - insets.bottom;\r\n        int loOffscreenOffsetX \u003d (paintArea.width - preferredSize.width) / 2;\r\n        int loOffscreenOffsetY \u003d (paintArea.height - preferredSize.height) / 2;\r\n        if (loOffscreenOffsetX \u003c 0) {\r\n            loOffscreenOffsetX \u003d 0;\r\n        }\r\n        if (loOffscreenOffsetY \u003c 0) {\r\n            loOffscreenOffsetY \u003d 0;\r\n        }\r\n        offscreenOffset.x \u003d loOffscreenOffsetX;\r\n        offscreenOffset.y \u003d loOffscreenOffsetY;\r\n        translatedScrollArea.x \u003d maxScrollArea.x + offscreenOffset.x;\r\n        translatedScrollArea.y \u003d maxScrollArea.y + offscreenOffset.y;\r\n        translatedScrollArea.width \u003d maxScrollArea.width;\r\n        translatedScrollArea.height \u003d maxScrollArea.height;\r\n        translatedBackgroundImageArea.x \u003d backgroundImageArea.x + offscreenOffset.x;\r\n        translatedBackgroundImageArea.y \u003d backgroundImageArea.y + offscreenOffset.y;\r\n        translatedBackgroundImageArea.width \u003d backgroundImageArea.width;\r\n        translatedBackgroundImageArea.height \u003d backgroundImageArea.height;\r\n        repaint();\r\n    }\r\n\r\n    /**\r\n     * This methods takes the insets (the border) of this component into account\r\n     * when the preferred size is calculated. Any border will work. It is called by\r\n     * the property-change-listener if the border was changed.\r\n     */\r\n    protected void calculatePreferredSize() {\r\n        insets \u003d getInsets(insets);\r\n        preferredSize.width \u003d insets.left + insets.right + backgroundImageArea.width;\r\n        preferredSize.height \u003d insets.top + insets.bottom + backgroundImageArea.height;\r\n        setPreferredSize(preferredSize);\r\n        invalidate();\r\n    }\r\n\r\n    /**\r\n     * This method requests a repaint of the scroll-area. The rest of the component\r\n     * will not be repainted. It is called by \u003ccode\u003esetScrollPosition()\u003c/code\u003e .\r\n     *\r\n     * @see\r\n     */\r\n    private void repaintScrollArea() {\r\n        //setPainted(false);\r\n        repaint(scrollArea.x + offscreenOffset.x, scrollArea.y + offscreenOffset.y, // + 1,\r\n        scrollArea.width, // + 1 );\r\n        scrollArea.height);\r\n    }\r\n\r\n    /**\r\n     * This method calls \u003ccode\u003esuper.addNotify()\u003c/code\u003e and notifies the\r\n     * scroll-thread by calling \u003ccode\u003esetScrolling(true)\u003c/code\u003e. It also\r\n     * (re)initializes the scroll-position to MinimumScrollPosition (this is always\r\n     * the negative height of the scroll-rectangle) and registers tbis component at\r\n     * the \u003ccode\u003eToolTipManager\u003c/code\u003e.\r\n     *\r\n     * @see #setScrolling\r\n     * @see #setScrollPosition\r\n     * @see #getMinimumScrollPosition\r\n     */\r\n    public void addNotify() {\r\n        super.addNotify();\r\n        setScrolling(true);\r\n        ToolTipManager.sharedInstance().registerComponent(this);\r\n    }\r\n\r\n    /**\r\n     * This method calls \u003ccode\u003esuper.removeNotify()\u003c/code\u003e and sends the\r\n     * scroll-thread into a wait-state by calling \u003ccode\u003esetScrolling(false)\u003c/code\u003e\r\n     * . It also unregisters this component from the \u003ccode\u003eToolTipManager\u003c/code\u003e.\r\n     *\r\n     * @see #setScrolling\r\n     */\r\n    public void removeNotify() {\r\n        super.removeNotify();\r\n        setScrolling(false);\r\n        ToolTipManager.sharedInstance().unregisterComponent(this);\r\n        // flush used buffer-images.\r\n        flushOffscreenImage();\r\n        flushScrollImage();\r\n    }\r\n\r\n    /**\r\n     * This method is used to set the scrolling-property of this component. A value\r\n     * of \u003ccode\u003etrue\u003c/code\u003e will notify the scroll-thread that it has to resume\r\n     * work. A value of \u003ccode\u003efalse\u003c/code\u003e will send it into wait-state instead.\r\n     *\r\n     * @param Scrolling The new scrolling value\r\n     */\r\n    public void setScrolling(boolean Scrolling) {\r\n        if (scrolling !\u003d Scrolling) {\r\n            scrolling \u003d Scrolling;\r\n            if (scrolling) {\r\n                timer.start();\r\n                if (logger.isInfoEnabled())\r\n                    logger.info(\"Timer started.\");\r\n            } else {\r\n                timer.stop();\r\n                if (logger.isInfoEnabled())\r\n                    logger.info(\"Timer stopped.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns \u003ccode\u003etrue\u003c/code\u003e if scrolling is currently active. If\r\n     * it returns \u003ccode\u003efalse\u003c/code\u003e then the scroll-thread is waiting.\r\n     *\r\n     * @return The scrolling value\r\n     */\r\n    public boolean isScrolling() {\r\n        return scrolling;\r\n    }\r\n\r\n    /**\r\n     * Description of the Class\r\n     *\r\n     * @author Joern Huxhorn\r\n     */\r\n    class AboutComponentListener extends ComponentAdapter {\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param e Description of the Parameter\r\n         */\r\n        public void componentResized(ComponentEvent e) {\r\n            AboutPanel.this.calculateAttributes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Description of the Class\r\n     *\r\n     * @author Joern Huxhorn\r\n     */\r\n    class AboutPropertyChangeListener implements PropertyChangeListener {\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void propertyChange(PropertyChangeEvent evt) {\r\n            String propertyName \u003d evt.getPropertyName();\r\n            if (propertyName.equals(\"border\")) {\r\n                calculatePreferredSize();\r\n            } else if (propertyName.equals(\"foreground\")) {\r\n                flushScrollImage();\r\n            } else if (propertyName.equals(\"background\")) {\r\n                flushScrollImage();\r\n            }\r\n            //\t\t\telse if ( propertyName.equals( \"locale\" ) )\r\n            //\t\t\t{\r\n            //\t\t\t\tinitResources();\r\n            //\t\t\t}\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This \u003ccode\u003eMouseInputListener\u003c/code\u003e handles the pause/resume on click as\r\n     * well as the dragging inside the scroll-area.\r\n     *\r\n     * @author Joern Huxhorn\r\n     */\r\n    class AboutMouseInputListener extends MouseInputAdapter {\r\n\r\n        Point lastPoint \u003d null;\r\n\r\n        boolean scrollingBeforePress \u003d false;\r\n\r\n        boolean dragged \u003d false;\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void mousePressed(MouseEvent evt) {\r\n            if (handleMouseEvent(evt)) {\r\n                // always stop scrolling if mouse is pressed inside\r\n                // the scroll-area\r\n                lastPoint \u003d evt.getPoint();\r\n                scrollingBeforePress \u003d isScrolling();\r\n                setScrolling(false);\r\n            } else {\r\n                lastPoint \u003d null;\r\n            }\r\n            dragged \u003d false;\r\n        }\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void mouseReleased(MouseEvent evt) {\r\n            if (dragged) {\r\n                // set scrolling-attribute to the value before the user dragged.\r\n                lastPoint \u003d null;\r\n                setScrolling(scrollingBeforePress);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void mouseClicked(MouseEvent evt) {\r\n            // this is only called after mouseReleased if no drag occurred.\r\n            if (handleMouseEvent(evt)) {\r\n                // toggle scrolling.\r\n                setScrolling(!scrollingBeforePress);\r\n            }\r\n            dragged \u003d false;\r\n        }\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void mouseDragged(MouseEvent evt) {\r\n            // only drag if original press was inside scroll-rectangle\r\n            if (lastPoint !\u003d null) {\r\n                dragged \u003d true;\r\n                Point currentPoint \u003d evt.getPoint();\r\n                int yOffset \u003d lastPoint.y - currentPoint.y;\r\n                setScrollPosition(getScrollPosition() + yOffset);\r\n                lastPoint \u003d currentPoint;\r\n            }\r\n        }\r\n    }\r\n\r\n    private class TimerActionListener implements ActionListener {\r\n\r\n        private final Logger logger \u003d LoggerFactory.getLogger(AboutPanel.class);\r\n\r\n        private long lastRepaintStart;\r\n\r\n        private long frequency \u003d 25;\r\n\r\n        public void actionPerformed(ActionEvent e) {\r\n            long currentTime \u003d System.nanoTime() / 1000000;\r\n            long meanTime \u003d currentTime - lastRepaintStart;\r\n            if (meanTime \u003e frequency) {\r\n                if (logger.isDebugEnabled())\r\n                    logger.debug(\"Tick! meanTime\u003d{}\", meanTime);\r\n                increaseScrollPosition();\r\n                lastRepaintStart \u003d currentTime;\r\n            }\r\n        }\r\n    }\r\n    //\tpublic static class Example\r\n    //\t{\r\n    //\t\tprivate JFrame dummyFrame;\r\n    //\t\tprivate JDialog dialog;\r\n    //\r\n    //\t\tprivate AboutPanel theAboutPanel;\r\n    //\t\tprivate static JFileChooser chooser\u003dnew JFileChooser(new File(\".\"));\r\n    //\r\n    //\t\tabstract class SelectionAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tprotected SelectionAction(String name)\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(name);\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic abstract void setImage(URL url);\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\tint returnVal \u003d chooser.showOpenDialog(dialog);\r\n    //\t\t\t\tif(returnVal \u003d\u003d JFileChooser.APPROVE_OPTION)\r\n    //\t\t\t\t{\r\n    //\t\t\t\t\tFile file \u003d chooser.getSelectedFile();\r\n    //\t\t\t\t\tSystem.out.println(\"You chose to open this file: \" + file.getName());\r\n    //\t\t\t\t\ttry\r\n    //\t\t\t\t\t{\r\n    //\t\t\t\t\t\tsetImage(file.toURL());\r\n    //\t\t\t\t\t\tAboutPanel.Example.this.theAboutPanel.setScrollArea(null);\r\n    //\t\t\t\t\t\tdialog.pack();\r\n    //\t\t\t\t\t}\r\n    //\t\t\t\t\tcatch(Exception loEx)\r\n    //\t\t\t\t\t{\r\n    //\t\t\t\t\t\tSystem.out.println(loEx);\r\n    //\t\t\t\t\t}\r\n    //\t\t\t\t}\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ImageSelectionAction extends SelectionAction\r\n    //\t\t{\r\n    //\t\t\tImageSelectionAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Select image\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void setImage(URL url)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setAboutImage(url);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass BackgroundImageSelectionAction extends SelectionAction\r\n    //\t\t{\r\n    //\t\t\tBackgroundImageSelectionAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Select background-image\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void setImage(URL url)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setBackgroundImage(url);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass CloseAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tCloseAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Close\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed( ActionEvent evt )\r\n    //\t\t\t{\r\n    //\t\t\t\tdialog.dispose();\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass FontSizeAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tint fontChange;\r\n    //\r\n    //\r\n    //\t\t\tpublic FontSizeAction( String name, int FontChange )\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(name);\r\n    //\t\t\t\tfontChange \u003d FontChange;\r\n    //\t\t\t}\r\n    //\r\n    //\r\n    //\t\t\tpublic void actionPerformed( java.awt.event.ActionEvent evt )\r\n    //\t\t\t{\r\n    //\t\t\t\tFont loFont \u003d AboutPanel.Example.this.theAboutPanel.getFont();\r\n    //\t\t\t\tfloat loSize \u003d loFont.getSize2D() + fontChange;\r\n    //\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setFont( loFont.deriveFont( loSize ) );\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tabstract class ChooseColorAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tprivate JColorChooser chooser;\r\n    //\t\t\tprivate String chooserTitle;\r\n    //\r\n    //\t\t\tpublic ChooseColorAction( String name)//, String chooserTitle)\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(name);\r\n    //\t\t\t\tchooserTitle\u003dname;\r\n    //\t\t\t\tchooser\u003dnew JColorChooser();\r\n    ////\t\t\tthis.chooserTitle\u003dchooserTitle;\r\n    //\t\t\t}\r\n    //\r\n    //\r\n    //\t\t\tpublic void actionPerformed( java.awt.event.ActionEvent evt )\r\n    //\t\t\t{\r\n    //\t\t\t\tColor c\u003dchooser.showDialog(dialog, chooserTitle, getSelectColor());\r\n    //\t\t\t\tif(c!\u003dnull)\r\n    //\t\t\t\t{\r\n    //\t\t\t\t\tsetSelectColor(c);\r\n    //\t\t\t\t}\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic abstract Color getSelectColor();\r\n    //\t\t\tpublic abstract void setSelectColor(Color c);\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ChooseBackgroundColorAction extends ChooseColorAction\r\n    //\t\t{\r\n    //\t\t\tpublic ChooseBackgroundColorAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Choose background-color\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic Color getSelectColor()\r\n    //\t\t\t{\r\n    //\t\t\t\treturn AboutPanel.Example.this.theAboutPanel.getBackground();\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void setSelectColor(Color c)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setBackground(c);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ChooseTextColorAction extends ChooseColorAction\r\n    //\t\t{\r\n    //\t\t\tpublic ChooseTextColorAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Choose text-color\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic Color getSelectColor()\r\n    //\t\t\t{\r\n    //\t\t\t\treturn AboutPanel.Example.this.theAboutPanel.getForeground();\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void setSelectColor(Color c)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setForeground(c);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ResetAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tpublic ResetAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Reset dialog\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel panel \u003d AboutPanel.Example.this.theAboutPanel;\r\n    ////\t\t\t\tpanel.initResources();\r\n    //\t\t\t\tdialog.pack();\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass PackAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tpublic PackAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Pack dialog\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\tdialog.pack();\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ShowDialogAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tpublic ShowDialogAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Show dialog\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\tdialog.setVisible(true);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ExitMenuAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tpublic ExitMenuAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Exit\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\texit();\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\t// TODO: Select font\r\n    //\t\t// TODO: Select scroll-area\r\n    //\t\t// TODO: Select scroll-text\r\n    //\t\t// TODO: Select version-text/height\r\n    //\r\n    //\t\tpublic Example()\r\n    //\t\t{\r\n    //\t\t\tJMenuBar menuBar\u003dnew JMenuBar();\r\n    //\t\t\tdummyFrame\u003dnew JFrame( \"DummyFrame\" );\r\n    //\t\t\tdummyFrame.setDefaultCloseOperation( javax.swing.JFrame.EXIT_ON_CLOSE );\r\n    //\t\t\tdummyFrame.setJMenuBar(menuBar);\r\n    //\t\t\tJMenu fileMenu\u003dnew JMenu(\"File\");\r\n    //\t\t\tmenuBar.add(fileMenu);\r\n    //\t\t\tfileMenu.add(new JMenuItem(new ShowDialogAction()));\r\n    //\t\t\tfileMenu.addSeparator();\r\n    //\t\t\tfileMenu.add(new JMenuItem(new ExitMenuAction()));\r\n    //\r\n    //\t\t\tdummyFrame.setBounds(10,10,100,100);\r\n    //\t\t\tdialog \u003d new JDialog( dummyFrame, \"About example\", false );\r\n    //\r\n    //\t\t\tJPanel content \u003d new JPanel( new BorderLayout() );\r\n    //\r\n    //\t\t\tdialog.setContentPane( content );\r\n    //\t\t\tcontent.setBorder( new EmptyBorder( 12, 12, 12, 12 ) );\r\n    //\r\n    //\r\n    //\t\t\tAboutPanel aboutPanel \u003d new AboutPanel();\r\n    //\r\n    //\t\t\tcontent.add(BorderLayout.CENTER,aboutPanel);\r\n    //\r\n    //\t\t\ttheAboutPanel\u003daboutPanel;\r\n    //\r\n    //\t\t\tCloseAction closeAction \u003d new CloseAction();\r\n    //\t\t\tJButton closeButton \u003d new JButton( closeAction );\r\n    //\r\n    //\t\t\tdialog.getRootPane().setDefaultButton( closeButton );\r\n    //\t\t\tJPanel buttonPanel \u003d new JPanel();\r\n    //\r\n    //\t\t\tbuttonPanel.setLayout( new BoxLayout( buttonPanel, BoxLayout.X_AXIS ) );\r\n    //\t\t\tbuttonPanel.setBorder( new EmptyBorder( 12, 0, 0, 0 ) );\r\n    //\t\t\tbuttonPanel.add( Box.createGlue() );\r\n    //\t\t\tbuttonPanel.add( closeButton );\r\n    //\t\t\tbuttonPanel.add( Box.createGlue() );\r\n    //\t\t\tcontent.add( BorderLayout.SOUTH, buttonPanel );\r\n    //\r\n    //\t\t\tJMenuBar dialogBar\u003dnew JMenuBar();\r\n    //\t\t\tdialog.setJMenuBar(dialogBar);\r\n    //\t\t\tJMenu optionsMenu\u003dnew JMenu(\"Options\");\r\n    //\t\t\tdialogBar.add(optionsMenu);\r\n    //\r\n    //\t\t\tJMenuItem bgImageItem \u003d new JMenuItem( new BackgroundImageSelectionAction() );\r\n    //\t\t\tJMenuItem imageItem \u003d new JMenuItem( new ImageSelectionAction() );\r\n    //\t\t\tJMenuItem textColorItem \u003d new JMenuItem( new ChooseTextColorAction() );\r\n    //\t\t\tJMenuItem bgColorItem \u003d new JMenuItem( new ChooseBackgroundColorAction() );\r\n    //\t\t\tJMenuItem fontPlusItem \u003d new JMenuItem( new FontSizeAction(\"Increase font-size\", 1));\r\n    //\t\t\tJMenuItem fontMinusItem \u003d new JMenuItem(  new FontSizeAction(\"Decrease font-size\", -1));\r\n    //\t\t\tJMenuItem packItem \u003d new JMenuItem( new PackAction() );\r\n    //\t\t\tJMenuItem resetItem \u003d new JMenuItem( new ResetAction() );\r\n    //\t\t\tJMenuItem closeItem \u003d new JMenuItem( closeAction );\r\n    //\t\t\tJMenuItem exitItem \u003d new JMenuItem( new ExitMenuAction() );\r\n    //\r\n    //\t\t\toptionsMenu.add( bgImageItem );\r\n    //\t\t\toptionsMenu.add( imageItem );\r\n    //\t\t\toptionsMenu.add( textColorItem );\r\n    //\t\t\toptionsMenu.add( bgColorItem );\r\n    //\t\t\toptionsMenu.add( fontPlusItem );\r\n    //\t\t\toptionsMenu.add( fontMinusItem );\r\n    //\t\t\toptionsMenu.addSeparator();\r\n    //\t\t\toptionsMenu.add( packItem );\r\n    //\t\t\toptionsMenu.add( resetItem );\r\n    //\t\t\toptionsMenu.addSeparator();\r\n    //\t\t\toptionsMenu.add( closeItem );\r\n    //\t\t\toptionsMenu.add( exitItem );\r\n    //\r\n    //\t\t\tdialog.pack();\r\n    //\t\t\tdummyFrame.setVisible(true);\r\n    //\t\t}\r\n    //\r\n    //\t\tpublic void showDialog()\r\n    //\t\t{\r\n    //\t\t\tdialog.setVisible(true);\r\n    //\t\t}\r\n    //\r\n    //\t\tpublic void exit()\r\n    //\t\t{\r\n    //\t\t\tSystem.exit(0);\r\n    //\t\t}\r\n    //\r\n    //\t\tpublic static void main(String args[])\r\n    //\t\t{\r\n    //            Example example\u003dnew Example();\r\n    //\t\t\texample.showDialog();\r\n    //\t\t}\r\n    //\t}\r\n}\r\n",
    "package": "de.huxhorn.lilith.swing",
    "classname": "AboutPanel",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/AboutPanel_0Test.java",
    "test_prompt": "// AboutPanel_0Test.java\npackage de.huxhorn.lilith.swing;\n\nimport de.huxhorn.sulky.swing.GraphicsUtilities;\nimport de.huxhorn.sulky.swing.filters.ColorTintFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseEvent;\nimport java.awt.image.BufferedImage;\nimport java.awt.image.BufferedImageOp;\nimport java.awt.image.ConvolveOp;\nimport java.awt.image.Kernel;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport javax.swing.*;\nimport javax.swing.event.MouseInputAdapter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AboutPanel}.\n* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.\n*/\nclass AboutPanel_0Test {",
    "method_signature": "getToolTipText(MouseEvent)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// NDC.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.logback.classic;\r\n\r\nimport de.huxhorn.lilith.data.logging.Message;\r\n\r\npublic class NDC {\r\n\r\n    private static final NDCAdapter ndcAdapter;\r\n\r\n    static {\r\n        // TODO: configuration\r\n        ndcAdapter \u003d new SimpleNDCAdapter();\r\n    }\r\n\r\n    private NDC() {\r\n    }\r\n\r\n    public static void push(String message) {\r\n        ndcAdapter.push(message);\r\n    }\r\n\r\n    public static void push(String messagePattern, Object[] arguments) {\r\n        ndcAdapter.push(messagePattern, arguments);\r\n    }\r\n\r\n    /**\r\n     * Pops the last message from the stack.\r\n     * \u003cp/\u003e\r\n     * This method does not return the popped message to discourage it\u0027s usage in application logic.\r\n     */\r\n    public static void pop() {\r\n        ndcAdapter.pop();\r\n    }\r\n\r\n    public static int getDepth() {\r\n        return ndcAdapter.getDepth();\r\n    }\r\n\r\n    public static void setMaximumDepth(int maximumDepth) {\r\n        ndcAdapter.setMaximumDepth(maximumDepth);\r\n    }\r\n\r\n    public static boolean isEmpty() {\r\n        return ndcAdapter.isEmpty();\r\n    }\r\n\r\n    public static void clear() {\r\n        ndcAdapter.clear();\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing all messages of the stack.\r\n     * \u003cp/\u003e\r\n     * The messages from the NDC stack should not be used in application logic.\r\n     *\r\n     * @return an array containing all messages of the stack.\r\n     */\r\n    public static Message[] getContextStack() {\r\n        return ndcAdapter.getContextStack();\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.logback.classic",
    "classname": "NDC",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/logback/classic/NDC_2Test.java",
    "test_prompt": "// NDC_2Test.java\npackage de.huxhorn.lilith.logback.classic;\n\nimport de.huxhorn.lilith.data.logging.Message;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NDC}.\n* It contains ten unit test cases for the {@link NDC#getContextStack()} method.\n*/\nclass NDC_2Test {",
    "method_signature": "getContextStack()",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// MessageFormatter.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.data.logging;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * \u003cp\u003eReplacement for org.slf4j.helpers.MessageFormatter.\u003c/p\u003e\r\n * \u003cp\u003e\r\n * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message\r\n * is split into three parts:\r\n * \u003c/p\u003e\r\n * \u003col\u003e\r\n * \u003cli\u003eCounting of placeholders in the message pattern (cheap)\u003c/li\u003e\r\n * \u003cli\u003eConversion of argument array into an ArgumentResult, containing the arguments converted to String as well as\r\n * an optional Throwable if available (relatively cheap)\u003c/li\u003e\r\n * \u003cli\u003eReplacement of placeholders in a message pattern with arguments given as String[]. (most expensive)\u003c/li\u003e\r\n * \u003c/ol\u003e\r\n * \u003cp\u003e\r\n * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the\r\n * actual construction of the message, is only done on demand.\r\n * \u003c/p\u003e\r\n */\r\npublic class MessageFormatter {\r\n\r\n    private static final char DELIM_START \u003d \u0027{\u0027;\r\n\r\n    private static final char DELIM_STOP \u003d \u0027}\u0027;\r\n\r\n    private static final char ESCAPE_CHAR \u003d \u0027\\\\\u0027;\r\n\r\n    public static final String RECURSION_PREFIX \u003d \"[...\";\r\n\r\n    public static final String RECURSION_SUFFIX \u003d \"...]\";\r\n\r\n    public static final String ERROR_PREFIX \u003d \"[!!!\";\r\n\r\n    public static final String ERROR_SEPARATOR \u003d \"\u003d\u003e\";\r\n\r\n    public static final String ERROR_MSG_SEPARATOR \u003d \":\";\r\n\r\n    public static final String ERROR_SUFFIX \u003d \"!!!]\";\r\n\r\n    /**\r\n     * Replace placeholders in the given messagePattern with arguments.\r\n     *\r\n     * @param messagePattern the message pattern containing placeholders.\r\n     * @param arguments      the arguments to be used to replace placeholders.\r\n     * @return the formatted message.\r\n     */\r\n    public static String format(String messagePattern, String[] arguments) {\r\n        if (messagePattern \u003d\u003d null || arguments \u003d\u003d null || arguments.length \u003d\u003d 0) {\r\n            return messagePattern;\r\n        }\r\n        StringBuilder result \u003d new StringBuilder();\r\n        int escapeCounter \u003d 0;\r\n        int currentArgument \u003d 0;\r\n        for (int i \u003d 0; i \u003c messagePattern.length(); i++) {\r\n            char curChar \u003d messagePattern.charAt(i);\r\n            if (curChar \u003d\u003d ESCAPE_CHAR) {\r\n                escapeCounter++;\r\n            } else {\r\n                if (curChar \u003d\u003d DELIM_START) {\r\n                    if (i \u003c messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) \u003d\u003d DELIM_STOP) {\r\n                            // write escaped escape chars\r\n                            int escapedEscapes \u003d escapeCounter / 2;\r\n                            for (int j \u003d 0; j \u003c escapedEscapes; j++) {\r\n                                result.append(ESCAPE_CHAR);\r\n                            }\r\n                            if (escapeCounter % 2 \u003d\u003d 1) {\r\n                                // i.e. escaped\r\n                                // write escaped escape chars\r\n                                result.append(DELIM_START);\r\n                                result.append(DELIM_STOP);\r\n                            } else {\r\n                                // unescaped\r\n                                if (currentArgument \u003c arguments.length) {\r\n                                    result.append(arguments[currentArgument]);\r\n                                } else {\r\n                                    result.append(DELIM_START).append(DELIM_STOP);\r\n                                }\r\n                                currentArgument++;\r\n                            }\r\n                            i++;\r\n                            escapeCounter \u003d 0;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                // any other char beside ESCAPE or DELIM_START/STOP-combo\r\n                // write unescaped escape chars\r\n                if (escapeCounter \u003e 0) {\r\n                    for (int j \u003d 0; j \u003c escapeCounter; j++) {\r\n                        result.append(ESCAPE_CHAR);\r\n                    }\r\n                    escapeCounter \u003d 0;\r\n                }\r\n                result.append(curChar);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Counts the number of unescaped placeholders in the given messagePattern.\r\n     *\r\n     * @param messagePattern the message pattern to be analyzed.\r\n     * @return the number of unescaped placeholders.\r\n     */\r\n    public static int countArgumentPlaceholders(String messagePattern) {\r\n        if (messagePattern \u003d\u003d null) {\r\n            return 0;\r\n        }\r\n        int delim \u003d messagePattern.indexOf(DELIM_START);\r\n        if (delim \u003d\u003d -1) {\r\n            // special case, no placeholders at all.\r\n            return 0;\r\n        }\r\n        int result \u003d 0;\r\n        boolean isEscaped \u003d false;\r\n        for (int i \u003d 0; i \u003c messagePattern.length(); i++) {\r\n            char curChar \u003d messagePattern.charAt(i);\r\n            if (curChar \u003d\u003d ESCAPE_CHAR) {\r\n                isEscaped \u003d !isEscaped;\r\n            } else if (curChar \u003d\u003d DELIM_START) {\r\n                if (!isEscaped) {\r\n                    if (i \u003c messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) \u003d\u003d DELIM_STOP) {\r\n                            result++;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                isEscaped \u003d false;\r\n            } else {\r\n                isEscaped \u003d false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * \u003cp\u003eThis method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String\r\n     * as well as an optional Throwable.\u003c/p\u003e\r\n     * \u003cp/\u003e\r\n     * \u003cp\u003eIf the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned\r\n     * in MessageFormatter.ArgumentResult.getThrowable() and won\u0027t be contained in the created String[].\u003cbr/\u003e\r\n     * If it is used up getThrowable will return null even if the last argument was a Throwable!\u003c/p\u003e\r\n     *\r\n     * @param messagePattern the message pattern that to be checked for placeholders.\r\n     * @param arguments      the argument array to be converted.\r\n     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.\r\n     */\r\n    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {\r\n        if (arguments \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        int argsCount \u003d countArgumentPlaceholders(messagePattern);\r\n        int resultArgCount \u003d arguments.length;\r\n        Throwable throwable \u003d null;\r\n        if (argsCount \u003c arguments.length) {\r\n            if (arguments[arguments.length - 1] instanceof Throwable) {\r\n                throwable \u003d (Throwable) arguments[arguments.length - 1];\r\n                resultArgCount--;\r\n            }\r\n        }\r\n        String[] stringArgs;\r\n        if (argsCount \u003d\u003d 1 \u0026\u0026 throwable \u003d\u003d null \u0026\u0026 arguments.length \u003e 1) {\r\n            // special case\r\n            stringArgs \u003d new String[1];\r\n            stringArgs[0] \u003d deepToString(arguments);\r\n        } else {\r\n            stringArgs \u003d new String[resultArgCount];\r\n            for (int i \u003d 0; i \u003c stringArgs.length; i++) {\r\n                stringArgs[i] \u003d deepToString(arguments[i]);\r\n            }\r\n        }\r\n        return new ArgumentResult(stringArgs, throwable);\r\n    }\r\n\r\n    public static String deepToString(Object o) {\r\n        if (o \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        if (o instanceof String) {\r\n            return (String) o;\r\n        }\r\n        StringBuilder str \u003d new StringBuilder();\r\n        // that\u0027s actually a neat name ;)\r\n        Set\u003cString\u003e dejaVu \u003d new HashSet\u003cString\u003e();\r\n        recursiveDeepToString(o, str, dejaVu);\r\n        return str.toString();\r\n    }\r\n\r\n    /**\r\n     * This method performs a deep toString of the given Object.\r\n     * Primitive arrays are converted using their respective Arrays.toString methods while\r\n     * special handling is implemented for \"container types\", i.e. Object[], Map and Collection because those could\r\n     * contain themselves.\r\n     * \u003cp/\u003e\r\n     * dejaVu is used in case of those container types to prevent an endless recursion.\r\n     * \u003cp/\u003e\r\n     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.\r\n     * They only check if the container is directly contained in itself, but not if a contained container contains the\r\n     * original one. Because of that, Arrays.toString(Object[]) isn\u0027t safe either.\r\n     * Confusing? Just read the last paragraph again and check the respective toString() implementation.\r\n     * \u003cp/\u003e\r\n     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)\r\n     * would produce a relatively hard-to-debug StackOverflowError.\r\n     *\r\n     * @param o      the Object to convert into a String\r\n     * @param str    the StringBuilder that o will be appended to\r\n     * @param dejaVu a list of container identities that were already used.\r\n     */\r\n    private static void recursiveDeepToString(Object o, StringBuilder str, Set\u003cString\u003e dejaVu) {\r\n        if (o \u003d\u003d null) {\r\n            str.append(\"null\");\r\n            return;\r\n        }\r\n        if (o instanceof String) {\r\n            str.append(o);\r\n            return;\r\n        }\r\n        Class oClass \u003d o.getClass();\r\n        if (oClass.isArray()) {\r\n            if (oClass \u003d\u003d byte[].class) {\r\n                str.append(Arrays.toString((byte[]) o));\r\n            } else if (oClass \u003d\u003d short[].class) {\r\n                str.append(Arrays.toString((short[]) o));\r\n            } else if (oClass \u003d\u003d int[].class) {\r\n                str.append(Arrays.toString((int[]) o));\r\n            } else if (oClass \u003d\u003d long[].class) {\r\n                str.append(Arrays.toString((long[]) o));\r\n            } else if (oClass \u003d\u003d float[].class) {\r\n                str.append(Arrays.toString((float[]) o));\r\n            } else if (oClass \u003d\u003d double[].class) {\r\n                str.append(Arrays.toString((double[]) o));\r\n            } else if (oClass \u003d\u003d boolean[].class) {\r\n                str.append(Arrays.toString((boolean[]) o));\r\n            } else if (oClass \u003d\u003d char[].class) {\r\n                str.append(Arrays.toString((char[]) o));\r\n            } else {\r\n                // special handling of container Object[]\r\n                String id \u003d identityToString(o);\r\n                if (dejaVu.contains(id)) {\r\n                    str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n                } else {\r\n                    dejaVu.add(id);\r\n                    Object[] oArray \u003d (Object[]) o;\r\n                    str.append(\"[\");\r\n                    boolean first \u003d true;\r\n                    for (Object current : oArray) {\r\n                        if (first) {\r\n                            first \u003d false;\r\n                        } else {\r\n                            str.append(\", \");\r\n                        }\r\n                        recursiveDeepToString(current, str, new HashSet\u003cString\u003e(dejaVu));\r\n                    }\r\n                    str.append(\"]\");\r\n                }\r\n                //str.append(Arrays.deepToString((Object[]) o));\r\n            }\r\n        } else if (o instanceof Map) {\r\n            // special handling of container Map\r\n            String id \u003d identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Map\u003c?, ?\u003e oMap \u003d (Map\u003c?, ?\u003e) o;\r\n                str.append(\"{\");\r\n                boolean isFirst \u003d true;\r\n                for (Map.Entry\u003c?, ?\u003e current : oMap.entrySet()) {\r\n                    if (isFirst) {\r\n                        isFirst \u003d false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    Object key \u003d current.getKey();\r\n                    Object value \u003d current.getValue();\r\n                    recursiveDeepToString(key, str, new HashSet\u003cString\u003e(dejaVu));\r\n                    str.append(\"\u003d\");\r\n                    recursiveDeepToString(value, str, new HashSet\u003cString\u003e(dejaVu));\r\n                }\r\n                str.append(\"}\");\r\n            }\r\n        } else if (o instanceof Collection) {\r\n            // special handling of container Collection\r\n            String id \u003d identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Collection\u003c?\u003e oCol \u003d (Collection\u003c?\u003e) o;\r\n                str.append(\"[\");\r\n                boolean isFirst \u003d true;\r\n                for (Object current : oCol) {\r\n                    if (isFirst) {\r\n                        isFirst \u003d false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    recursiveDeepToString(current, str, new HashSet\u003cString\u003e(dejaVu));\r\n                }\r\n                str.append(\"]\");\r\n            }\r\n        } else if (o instanceof Date) {\r\n            Date date \u003d (Date) o;\r\n            SimpleDateFormat format \u003d new SimpleDateFormat(\"yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSSZ\");\r\n            // I\u0027ll leave it like this for the moment... this could probably be optimized using ThreadLocal...\r\n            str.append(format.format(date));\r\n        } else {\r\n            // it\u0027s just some other Object, we can only use toString().\r\n            try {\r\n                str.append(o.toString());\r\n            } catch (Throwable t) {\r\n                str.append(ERROR_PREFIX);\r\n                str.append(identityToString(o));\r\n                str.append(ERROR_SEPARATOR);\r\n                String msg \u003d t.getMessage();\r\n                String className \u003d t.getClass().getName();\r\n                str.append(className);\r\n                if (!className.equals(msg)) {\r\n                    str.append(ERROR_MSG_SEPARATOR);\r\n                    str.append(msg);\r\n                }\r\n                str.append(ERROR_SUFFIX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns the same as if Object.toString() would not have been\r\n     * overridden in obj.\r\n     * \u003cp/\u003e\r\n     * Note that this isn\u0027t 100% secure as collisions can always happen with hash codes.\r\n     * \u003cp/\u003e\r\n     * Copied from Object.hashCode():\r\n     * As much as is reasonably practical, the hashCode method defined by\r\n     * class \u003ctt\u003eObject\u003c/tt\u003e does return distinct integers for distinct\r\n     * objects. (This is typically implemented by converting the internal\r\n     * address of the object into an integer, but this implementation\r\n     * technique is not required by the\r\n     * Java\u003cfont size\u003d\"-2\"\u003e\u003csup\u003eTM\u003c/sup\u003e\u003c/font\u003e programming language.)\r\n     *\r\n     * @param obj the Object that is to be converted into an identity string.\r\n     * @return the identity string as also defined in Object.toString()\r\n     */\r\n    public static String identityToString(Object obj) {\r\n        if (obj \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        return obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\r\n    }\r\n\r\n    /**\r\n     * \u003cp\u003eThis is just a simple class containing the result of an evaluateArgument call. It\u0027s necessary because we need to\r\n     * return two results, i.e. the resulting String[] and the optional Throwable.\u003c/p\u003e\r\n     * \u003cp/\u003e\r\n     * \u003cp\u003eThis class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed\r\n     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not\r\n     * available/different in the deserializing VM.\u003c/p\u003e\r\n     */\r\n    public static class ArgumentResult {\r\n\r\n        private Throwable throwable;\r\n\r\n        private String[] arguments;\r\n\r\n        public ArgumentResult(String[] arguments, Throwable throwable) {\r\n            this.throwable \u003d throwable;\r\n            this.arguments \u003d arguments;\r\n        }\r\n\r\n        public Throwable getThrowable() {\r\n            return throwable;\r\n        }\r\n\r\n        public String[] getArguments() {\r\n            return arguments;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder result \u003d new StringBuilder();\r\n            result.append(\"ArgumentResult[throwable\u003d\").append(throwable);\r\n            result.append(\", arguments\u003d\");\r\n            if (arguments !\u003d null) {\r\n                result.append(\"[\");\r\n                boolean isFirst \u003d true;\r\n                for (String current : arguments) {\r\n                    if (!isFirst) {\r\n                        result.append(\", \");\r\n                    } else {\r\n                        isFirst \u003d false;\r\n                    }\r\n                    if (current !\u003d null) {\r\n                        result.append(\"\u0027\").append(current).append(\"\u0027\");\r\n                    } else {\r\n                        result.append(\"null\");\r\n                    }\r\n                }\r\n                result.append(\"]\");\r\n            }\r\n            return result.toString();\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if (this \u003d\u003d o)\r\n                return true;\r\n            if (o \u003d\u003d null || getClass() !\u003d o.getClass())\r\n                return false;\r\n            ArgumentResult result \u003d (ArgumentResult) o;\r\n            if (!Arrays.equals(arguments, result.arguments))\r\n                return false;\r\n            if (throwable !\u003d null ? !throwable.equals(result.throwable) : result.throwable !\u003d null)\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        public int hashCode() {\r\n            int result;\r\n            result \u003d (throwable !\u003d null ? throwable.hashCode() : 0);\r\n            result \u003d 31 * result + (arguments !\u003d null ? Arrays.hashCode(arguments) : 0);\r\n            return result;\r\n        }\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.data.logging",
    "classname": "MessageFormatter",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_0Test.java",
    "test_prompt": "// MessageFormatter_0Test.java\npackage de.huxhorn.lilith.data.logging;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFormatter}.\n* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.\n*/\nclass MessageFormatter_0Test {",
    "method_signature": "format(String, String[])",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// MessageFormatter.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.data.logging;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * \u003cp\u003eReplacement for org.slf4j.helpers.MessageFormatter.\u003c/p\u003e\r\n * \u003cp\u003e\r\n * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message\r\n * is split into three parts:\r\n * \u003c/p\u003e\r\n * \u003col\u003e\r\n * \u003cli\u003eCounting of placeholders in the message pattern (cheap)\u003c/li\u003e\r\n * \u003cli\u003eConversion of argument array into an ArgumentResult, containing the arguments converted to String as well as\r\n * an optional Throwable if available (relatively cheap)\u003c/li\u003e\r\n * \u003cli\u003eReplacement of placeholders in a message pattern with arguments given as String[]. (most expensive)\u003c/li\u003e\r\n * \u003c/ol\u003e\r\n * \u003cp\u003e\r\n * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the\r\n * actual construction of the message, is only done on demand.\r\n * \u003c/p\u003e\r\n */\r\npublic class MessageFormatter {\r\n\r\n    private static final char DELIM_START \u003d \u0027{\u0027;\r\n\r\n    private static final char DELIM_STOP \u003d \u0027}\u0027;\r\n\r\n    private static final char ESCAPE_CHAR \u003d \u0027\\\\\u0027;\r\n\r\n    public static final String RECURSION_PREFIX \u003d \"[...\";\r\n\r\n    public static final String RECURSION_SUFFIX \u003d \"...]\";\r\n\r\n    public static final String ERROR_PREFIX \u003d \"[!!!\";\r\n\r\n    public static final String ERROR_SEPARATOR \u003d \"\u003d\u003e\";\r\n\r\n    public static final String ERROR_MSG_SEPARATOR \u003d \":\";\r\n\r\n    public static final String ERROR_SUFFIX \u003d \"!!!]\";\r\n\r\n    /**\r\n     * Replace placeholders in the given messagePattern with arguments.\r\n     *\r\n     * @param messagePattern the message pattern containing placeholders.\r\n     * @param arguments      the arguments to be used to replace placeholders.\r\n     * @return the formatted message.\r\n     */\r\n    public static String format(String messagePattern, String[] arguments) {\r\n        if (messagePattern \u003d\u003d null || arguments \u003d\u003d null || arguments.length \u003d\u003d 0) {\r\n            return messagePattern;\r\n        }\r\n        StringBuilder result \u003d new StringBuilder();\r\n        int escapeCounter \u003d 0;\r\n        int currentArgument \u003d 0;\r\n        for (int i \u003d 0; i \u003c messagePattern.length(); i++) {\r\n            char curChar \u003d messagePattern.charAt(i);\r\n            if (curChar \u003d\u003d ESCAPE_CHAR) {\r\n                escapeCounter++;\r\n            } else {\r\n                if (curChar \u003d\u003d DELIM_START) {\r\n                    if (i \u003c messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) \u003d\u003d DELIM_STOP) {\r\n                            // write escaped escape chars\r\n                            int escapedEscapes \u003d escapeCounter / 2;\r\n                            for (int j \u003d 0; j \u003c escapedEscapes; j++) {\r\n                                result.append(ESCAPE_CHAR);\r\n                            }\r\n                            if (escapeCounter % 2 \u003d\u003d 1) {\r\n                                // i.e. escaped\r\n                                // write escaped escape chars\r\n                                result.append(DELIM_START);\r\n                                result.append(DELIM_STOP);\r\n                            } else {\r\n                                // unescaped\r\n                                if (currentArgument \u003c arguments.length) {\r\n                                    result.append(arguments[currentArgument]);\r\n                                } else {\r\n                                    result.append(DELIM_START).append(DELIM_STOP);\r\n                                }\r\n                                currentArgument++;\r\n                            }\r\n                            i++;\r\n                            escapeCounter \u003d 0;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                // any other char beside ESCAPE or DELIM_START/STOP-combo\r\n                // write unescaped escape chars\r\n                if (escapeCounter \u003e 0) {\r\n                    for (int j \u003d 0; j \u003c escapeCounter; j++) {\r\n                        result.append(ESCAPE_CHAR);\r\n                    }\r\n                    escapeCounter \u003d 0;\r\n                }\r\n                result.append(curChar);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Counts the number of unescaped placeholders in the given messagePattern.\r\n     *\r\n     * @param messagePattern the message pattern to be analyzed.\r\n     * @return the number of unescaped placeholders.\r\n     */\r\n    public static int countArgumentPlaceholders(String messagePattern) {\r\n        if (messagePattern \u003d\u003d null) {\r\n            return 0;\r\n        }\r\n        int delim \u003d messagePattern.indexOf(DELIM_START);\r\n        if (delim \u003d\u003d -1) {\r\n            // special case, no placeholders at all.\r\n            return 0;\r\n        }\r\n        int result \u003d 0;\r\n        boolean isEscaped \u003d false;\r\n        for (int i \u003d 0; i \u003c messagePattern.length(); i++) {\r\n            char curChar \u003d messagePattern.charAt(i);\r\n            if (curChar \u003d\u003d ESCAPE_CHAR) {\r\n                isEscaped \u003d !isEscaped;\r\n            } else if (curChar \u003d\u003d DELIM_START) {\r\n                if (!isEscaped) {\r\n                    if (i \u003c messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) \u003d\u003d DELIM_STOP) {\r\n                            result++;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                isEscaped \u003d false;\r\n            } else {\r\n                isEscaped \u003d false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * \u003cp\u003eThis method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String\r\n     * as well as an optional Throwable.\u003c/p\u003e\r\n     * \u003cp/\u003e\r\n     * \u003cp\u003eIf the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned\r\n     * in MessageFormatter.ArgumentResult.getThrowable() and won\u0027t be contained in the created String[].\u003cbr/\u003e\r\n     * If it is used up getThrowable will return null even if the last argument was a Throwable!\u003c/p\u003e\r\n     *\r\n     * @param messagePattern the message pattern that to be checked for placeholders.\r\n     * @param arguments      the argument array to be converted.\r\n     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.\r\n     */\r\n    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {\r\n        if (arguments \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        int argsCount \u003d countArgumentPlaceholders(messagePattern);\r\n        int resultArgCount \u003d arguments.length;\r\n        Throwable throwable \u003d null;\r\n        if (argsCount \u003c arguments.length) {\r\n            if (arguments[arguments.length - 1] instanceof Throwable) {\r\n                throwable \u003d (Throwable) arguments[arguments.length - 1];\r\n                resultArgCount--;\r\n            }\r\n        }\r\n        String[] stringArgs;\r\n        if (argsCount \u003d\u003d 1 \u0026\u0026 throwable \u003d\u003d null \u0026\u0026 arguments.length \u003e 1) {\r\n            // special case\r\n            stringArgs \u003d new String[1];\r\n            stringArgs[0] \u003d deepToString(arguments);\r\n        } else {\r\n            stringArgs \u003d new String[resultArgCount];\r\n            for (int i \u003d 0; i \u003c stringArgs.length; i++) {\r\n                stringArgs[i] \u003d deepToString(arguments[i]);\r\n            }\r\n        }\r\n        return new ArgumentResult(stringArgs, throwable);\r\n    }\r\n\r\n    public static String deepToString(Object o) {\r\n        if (o \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        if (o instanceof String) {\r\n            return (String) o;\r\n        }\r\n        StringBuilder str \u003d new StringBuilder();\r\n        // that\u0027s actually a neat name ;)\r\n        Set\u003cString\u003e dejaVu \u003d new HashSet\u003cString\u003e();\r\n        recursiveDeepToString(o, str, dejaVu);\r\n        return str.toString();\r\n    }\r\n\r\n    /**\r\n     * This method performs a deep toString of the given Object.\r\n     * Primitive arrays are converted using their respective Arrays.toString methods while\r\n     * special handling is implemented for \"container types\", i.e. Object[], Map and Collection because those could\r\n     * contain themselves.\r\n     * \u003cp/\u003e\r\n     * dejaVu is used in case of those container types to prevent an endless recursion.\r\n     * \u003cp/\u003e\r\n     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.\r\n     * They only check if the container is directly contained in itself, but not if a contained container contains the\r\n     * original one. Because of that, Arrays.toString(Object[]) isn\u0027t safe either.\r\n     * Confusing? Just read the last paragraph again and check the respective toString() implementation.\r\n     * \u003cp/\u003e\r\n     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)\r\n     * would produce a relatively hard-to-debug StackOverflowError.\r\n     *\r\n     * @param o      the Object to convert into a String\r\n     * @param str    the StringBuilder that o will be appended to\r\n     * @param dejaVu a list of container identities that were already used.\r\n     */\r\n    private static void recursiveDeepToString(Object o, StringBuilder str, Set\u003cString\u003e dejaVu) {\r\n        if (o \u003d\u003d null) {\r\n            str.append(\"null\");\r\n            return;\r\n        }\r\n        if (o instanceof String) {\r\n            str.append(o);\r\n            return;\r\n        }\r\n        Class oClass \u003d o.getClass();\r\n        if (oClass.isArray()) {\r\n            if (oClass \u003d\u003d byte[].class) {\r\n                str.append(Arrays.toString((byte[]) o));\r\n            } else if (oClass \u003d\u003d short[].class) {\r\n                str.append(Arrays.toString((short[]) o));\r\n            } else if (oClass \u003d\u003d int[].class) {\r\n                str.append(Arrays.toString((int[]) o));\r\n            } else if (oClass \u003d\u003d long[].class) {\r\n                str.append(Arrays.toString((long[]) o));\r\n            } else if (oClass \u003d\u003d float[].class) {\r\n                str.append(Arrays.toString((float[]) o));\r\n            } else if (oClass \u003d\u003d double[].class) {\r\n                str.append(Arrays.toString((double[]) o));\r\n            } else if (oClass \u003d\u003d boolean[].class) {\r\n                str.append(Arrays.toString((boolean[]) o));\r\n            } else if (oClass \u003d\u003d char[].class) {\r\n                str.append(Arrays.toString((char[]) o));\r\n            } else {\r\n                // special handling of container Object[]\r\n                String id \u003d identityToString(o);\r\n                if (dejaVu.contains(id)) {\r\n                    str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n                } else {\r\n                    dejaVu.add(id);\r\n                    Object[] oArray \u003d (Object[]) o;\r\n                    str.append(\"[\");\r\n                    boolean first \u003d true;\r\n                    for (Object current : oArray) {\r\n                        if (first) {\r\n                            first \u003d false;\r\n                        } else {\r\n                            str.append(\", \");\r\n                        }\r\n                        recursiveDeepToString(current, str, new HashSet\u003cString\u003e(dejaVu));\r\n                    }\r\n                    str.append(\"]\");\r\n                }\r\n                //str.append(Arrays.deepToString((Object[]) o));\r\n            }\r\n        } else if (o instanceof Map) {\r\n            // special handling of container Map\r\n            String id \u003d identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Map\u003c?, ?\u003e oMap \u003d (Map\u003c?, ?\u003e) o;\r\n                str.append(\"{\");\r\n                boolean isFirst \u003d true;\r\n                for (Map.Entry\u003c?, ?\u003e current : oMap.entrySet()) {\r\n                    if (isFirst) {\r\n                        isFirst \u003d false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    Object key \u003d current.getKey();\r\n                    Object value \u003d current.getValue();\r\n                    recursiveDeepToString(key, str, new HashSet\u003cString\u003e(dejaVu));\r\n                    str.append(\"\u003d\");\r\n                    recursiveDeepToString(value, str, new HashSet\u003cString\u003e(dejaVu));\r\n                }\r\n                str.append(\"}\");\r\n            }\r\n        } else if (o instanceof Collection) {\r\n            // special handling of container Collection\r\n            String id \u003d identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Collection\u003c?\u003e oCol \u003d (Collection\u003c?\u003e) o;\r\n                str.append(\"[\");\r\n                boolean isFirst \u003d true;\r\n                for (Object current : oCol) {\r\n                    if (isFirst) {\r\n                        isFirst \u003d false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    recursiveDeepToString(current, str, new HashSet\u003cString\u003e(dejaVu));\r\n                }\r\n                str.append(\"]\");\r\n            }\r\n        } else if (o instanceof Date) {\r\n            Date date \u003d (Date) o;\r\n            SimpleDateFormat format \u003d new SimpleDateFormat(\"yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSSZ\");\r\n            // I\u0027ll leave it like this for the moment... this could probably be optimized using ThreadLocal...\r\n            str.append(format.format(date));\r\n        } else {\r\n            // it\u0027s just some other Object, we can only use toString().\r\n            try {\r\n                str.append(o.toString());\r\n            } catch (Throwable t) {\r\n                str.append(ERROR_PREFIX);\r\n                str.append(identityToString(o));\r\n                str.append(ERROR_SEPARATOR);\r\n                String msg \u003d t.getMessage();\r\n                String className \u003d t.getClass().getName();\r\n                str.append(className);\r\n                if (!className.equals(msg)) {\r\n                    str.append(ERROR_MSG_SEPARATOR);\r\n                    str.append(msg);\r\n                }\r\n                str.append(ERROR_SUFFIX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns the same as if Object.toString() would not have been\r\n     * overridden in obj.\r\n     * \u003cp/\u003e\r\n     * Note that this isn\u0027t 100% secure as collisions can always happen with hash codes.\r\n     * \u003cp/\u003e\r\n     * Copied from Object.hashCode():\r\n     * As much as is reasonably practical, the hashCode method defined by\r\n     * class \u003ctt\u003eObject\u003c/tt\u003e does return distinct integers for distinct\r\n     * objects. (This is typically implemented by converting the internal\r\n     * address of the object into an integer, but this implementation\r\n     * technique is not required by the\r\n     * Java\u003cfont size\u003d\"-2\"\u003e\u003csup\u003eTM\u003c/sup\u003e\u003c/font\u003e programming language.)\r\n     *\r\n     * @param obj the Object that is to be converted into an identity string.\r\n     * @return the identity string as also defined in Object.toString()\r\n     */\r\n    public static String identityToString(Object obj) {\r\n        if (obj \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        return obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\r\n    }\r\n\r\n    /**\r\n     * \u003cp\u003eThis is just a simple class containing the result of an evaluateArgument call. It\u0027s necessary because we need to\r\n     * return two results, i.e. the resulting String[] and the optional Throwable.\u003c/p\u003e\r\n     * \u003cp/\u003e\r\n     * \u003cp\u003eThis class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed\r\n     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not\r\n     * available/different in the deserializing VM.\u003c/p\u003e\r\n     */\r\n    public static class ArgumentResult {\r\n\r\n        private Throwable throwable;\r\n\r\n        private String[] arguments;\r\n\r\n        public ArgumentResult(String[] arguments, Throwable throwable) {\r\n            this.throwable \u003d throwable;\r\n            this.arguments \u003d arguments;\r\n        }\r\n\r\n        public Throwable getThrowable() {\r\n            return throwable;\r\n        }\r\n\r\n        public String[] getArguments() {\r\n            return arguments;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder result \u003d new StringBuilder();\r\n            result.append(\"ArgumentResult[throwable\u003d\").append(throwable);\r\n            result.append(\", arguments\u003d\");\r\n            if (arguments !\u003d null) {\r\n                result.append(\"[\");\r\n                boolean isFirst \u003d true;\r\n                for (String current : arguments) {\r\n                    if (!isFirst) {\r\n                        result.append(\", \");\r\n                    } else {\r\n                        isFirst \u003d false;\r\n                    }\r\n                    if (current !\u003d null) {\r\n                        result.append(\"\u0027\").append(current).append(\"\u0027\");\r\n                    } else {\r\n                        result.append(\"null\");\r\n                    }\r\n                }\r\n                result.append(\"]\");\r\n            }\r\n            return result.toString();\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if (this \u003d\u003d o)\r\n                return true;\r\n            if (o \u003d\u003d null || getClass() !\u003d o.getClass())\r\n                return false;\r\n            ArgumentResult result \u003d (ArgumentResult) o;\r\n            if (!Arrays.equals(arguments, result.arguments))\r\n                return false;\r\n            if (throwable !\u003d null ? !throwable.equals(result.throwable) : result.throwable !\u003d null)\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        public int hashCode() {\r\n            int result;\r\n            result \u003d (throwable !\u003d null ? throwable.hashCode() : 0);\r\n            result \u003d 31 * result + (arguments !\u003d null ? Arrays.hashCode(arguments) : 0);\r\n            return result;\r\n        }\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.data.logging",
    "classname": "MessageFormatter",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_1Test.java",
    "test_prompt": "// MessageFormatter_1Test.java\npackage de.huxhorn.lilith.data.logging;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFormatter}.\n* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.\n*/\nclass MessageFormatter_1Test {",
    "method_signature": "countArgumentPlaceholders(String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// MessageFormatter.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.data.logging;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * \u003cp\u003eReplacement for org.slf4j.helpers.MessageFormatter.\u003c/p\u003e\r\n * \u003cp\u003e\r\n * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message\r\n * is split into three parts:\r\n * \u003c/p\u003e\r\n * \u003col\u003e\r\n * \u003cli\u003eCounting of placeholders in the message pattern (cheap)\u003c/li\u003e\r\n * \u003cli\u003eConversion of argument array into an ArgumentResult, containing the arguments converted to String as well as\r\n * an optional Throwable if available (relatively cheap)\u003c/li\u003e\r\n * \u003cli\u003eReplacement of placeholders in a message pattern with arguments given as String[]. (most expensive)\u003c/li\u003e\r\n * \u003c/ol\u003e\r\n * \u003cp\u003e\r\n * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the\r\n * actual construction of the message, is only done on demand.\r\n * \u003c/p\u003e\r\n */\r\npublic class MessageFormatter {\r\n\r\n    private static final char DELIM_START \u003d \u0027{\u0027;\r\n\r\n    private static final char DELIM_STOP \u003d \u0027}\u0027;\r\n\r\n    private static final char ESCAPE_CHAR \u003d \u0027\\\\\u0027;\r\n\r\n    public static final String RECURSION_PREFIX \u003d \"[...\";\r\n\r\n    public static final String RECURSION_SUFFIX \u003d \"...]\";\r\n\r\n    public static final String ERROR_PREFIX \u003d \"[!!!\";\r\n\r\n    public static final String ERROR_SEPARATOR \u003d \"\u003d\u003e\";\r\n\r\n    public static final String ERROR_MSG_SEPARATOR \u003d \":\";\r\n\r\n    public static final String ERROR_SUFFIX \u003d \"!!!]\";\r\n\r\n    /**\r\n     * Replace placeholders in the given messagePattern with arguments.\r\n     *\r\n     * @param messagePattern the message pattern containing placeholders.\r\n     * @param arguments      the arguments to be used to replace placeholders.\r\n     * @return the formatted message.\r\n     */\r\n    public static String format(String messagePattern, String[] arguments) {\r\n        if (messagePattern \u003d\u003d null || arguments \u003d\u003d null || arguments.length \u003d\u003d 0) {\r\n            return messagePattern;\r\n        }\r\n        StringBuilder result \u003d new StringBuilder();\r\n        int escapeCounter \u003d 0;\r\n        int currentArgument \u003d 0;\r\n        for (int i \u003d 0; i \u003c messagePattern.length(); i++) {\r\n            char curChar \u003d messagePattern.charAt(i);\r\n            if (curChar \u003d\u003d ESCAPE_CHAR) {\r\n                escapeCounter++;\r\n            } else {\r\n                if (curChar \u003d\u003d DELIM_START) {\r\n                    if (i \u003c messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) \u003d\u003d DELIM_STOP) {\r\n                            // write escaped escape chars\r\n                            int escapedEscapes \u003d escapeCounter / 2;\r\n                            for (int j \u003d 0; j \u003c escapedEscapes; j++) {\r\n                                result.append(ESCAPE_CHAR);\r\n                            }\r\n                            if (escapeCounter % 2 \u003d\u003d 1) {\r\n                                // i.e. escaped\r\n                                // write escaped escape chars\r\n                                result.append(DELIM_START);\r\n                                result.append(DELIM_STOP);\r\n                            } else {\r\n                                // unescaped\r\n                                if (currentArgument \u003c arguments.length) {\r\n                                    result.append(arguments[currentArgument]);\r\n                                } else {\r\n                                    result.append(DELIM_START).append(DELIM_STOP);\r\n                                }\r\n                                currentArgument++;\r\n                            }\r\n                            i++;\r\n                            escapeCounter \u003d 0;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                // any other char beside ESCAPE or DELIM_START/STOP-combo\r\n                // write unescaped escape chars\r\n                if (escapeCounter \u003e 0) {\r\n                    for (int j \u003d 0; j \u003c escapeCounter; j++) {\r\n                        result.append(ESCAPE_CHAR);\r\n                    }\r\n                    escapeCounter \u003d 0;\r\n                }\r\n                result.append(curChar);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Counts the number of unescaped placeholders in the given messagePattern.\r\n     *\r\n     * @param messagePattern the message pattern to be analyzed.\r\n     * @return the number of unescaped placeholders.\r\n     */\r\n    public static int countArgumentPlaceholders(String messagePattern) {\r\n        if (messagePattern \u003d\u003d null) {\r\n            return 0;\r\n        }\r\n        int delim \u003d messagePattern.indexOf(DELIM_START);\r\n        if (delim \u003d\u003d -1) {\r\n            // special case, no placeholders at all.\r\n            return 0;\r\n        }\r\n        int result \u003d 0;\r\n        boolean isEscaped \u003d false;\r\n        for (int i \u003d 0; i \u003c messagePattern.length(); i++) {\r\n            char curChar \u003d messagePattern.charAt(i);\r\n            if (curChar \u003d\u003d ESCAPE_CHAR) {\r\n                isEscaped \u003d !isEscaped;\r\n            } else if (curChar \u003d\u003d DELIM_START) {\r\n                if (!isEscaped) {\r\n                    if (i \u003c messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) \u003d\u003d DELIM_STOP) {\r\n                            result++;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                isEscaped \u003d false;\r\n            } else {\r\n                isEscaped \u003d false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * \u003cp\u003eThis method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String\r\n     * as well as an optional Throwable.\u003c/p\u003e\r\n     * \u003cp/\u003e\r\n     * \u003cp\u003eIf the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned\r\n     * in MessageFormatter.ArgumentResult.getThrowable() and won\u0027t be contained in the created String[].\u003cbr/\u003e\r\n     * If it is used up getThrowable will return null even if the last argument was a Throwable!\u003c/p\u003e\r\n     *\r\n     * @param messagePattern the message pattern that to be checked for placeholders.\r\n     * @param arguments      the argument array to be converted.\r\n     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.\r\n     */\r\n    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {\r\n        if (arguments \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        int argsCount \u003d countArgumentPlaceholders(messagePattern);\r\n        int resultArgCount \u003d arguments.length;\r\n        Throwable throwable \u003d null;\r\n        if (argsCount \u003c arguments.length) {\r\n            if (arguments[arguments.length - 1] instanceof Throwable) {\r\n                throwable \u003d (Throwable) arguments[arguments.length - 1];\r\n                resultArgCount--;\r\n            }\r\n        }\r\n        String[] stringArgs;\r\n        if (argsCount \u003d\u003d 1 \u0026\u0026 throwable \u003d\u003d null \u0026\u0026 arguments.length \u003e 1) {\r\n            // special case\r\n            stringArgs \u003d new String[1];\r\n            stringArgs[0] \u003d deepToString(arguments);\r\n        } else {\r\n            stringArgs \u003d new String[resultArgCount];\r\n            for (int i \u003d 0; i \u003c stringArgs.length; i++) {\r\n                stringArgs[i] \u003d deepToString(arguments[i]);\r\n            }\r\n        }\r\n        return new ArgumentResult(stringArgs, throwable);\r\n    }\r\n\r\n    public static String deepToString(Object o) {\r\n        if (o \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        if (o instanceof String) {\r\n            return (String) o;\r\n        }\r\n        StringBuilder str \u003d new StringBuilder();\r\n        // that\u0027s actually a neat name ;)\r\n        Set\u003cString\u003e dejaVu \u003d new HashSet\u003cString\u003e();\r\n        recursiveDeepToString(o, str, dejaVu);\r\n        return str.toString();\r\n    }\r\n\r\n    /**\r\n     * This method performs a deep toString of the given Object.\r\n     * Primitive arrays are converted using their respective Arrays.toString methods while\r\n     * special handling is implemented for \"container types\", i.e. Object[], Map and Collection because those could\r\n     * contain themselves.\r\n     * \u003cp/\u003e\r\n     * dejaVu is used in case of those container types to prevent an endless recursion.\r\n     * \u003cp/\u003e\r\n     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.\r\n     * They only check if the container is directly contained in itself, but not if a contained container contains the\r\n     * original one. Because of that, Arrays.toString(Object[]) isn\u0027t safe either.\r\n     * Confusing? Just read the last paragraph again and check the respective toString() implementation.\r\n     * \u003cp/\u003e\r\n     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)\r\n     * would produce a relatively hard-to-debug StackOverflowError.\r\n     *\r\n     * @param o      the Object to convert into a String\r\n     * @param str    the StringBuilder that o will be appended to\r\n     * @param dejaVu a list of container identities that were already used.\r\n     */\r\n    private static void recursiveDeepToString(Object o, StringBuilder str, Set\u003cString\u003e dejaVu) {\r\n        if (o \u003d\u003d null) {\r\n            str.append(\"null\");\r\n            return;\r\n        }\r\n        if (o instanceof String) {\r\n            str.append(o);\r\n            return;\r\n        }\r\n        Class oClass \u003d o.getClass();\r\n        if (oClass.isArray()) {\r\n            if (oClass \u003d\u003d byte[].class) {\r\n                str.append(Arrays.toString((byte[]) o));\r\n            } else if (oClass \u003d\u003d short[].class) {\r\n                str.append(Arrays.toString((short[]) o));\r\n            } else if (oClass \u003d\u003d int[].class) {\r\n                str.append(Arrays.toString((int[]) o));\r\n            } else if (oClass \u003d\u003d long[].class) {\r\n                str.append(Arrays.toString((long[]) o));\r\n            } else if (oClass \u003d\u003d float[].class) {\r\n                str.append(Arrays.toString((float[]) o));\r\n            } else if (oClass \u003d\u003d double[].class) {\r\n                str.append(Arrays.toString((double[]) o));\r\n            } else if (oClass \u003d\u003d boolean[].class) {\r\n                str.append(Arrays.toString((boolean[]) o));\r\n            } else if (oClass \u003d\u003d char[].class) {\r\n                str.append(Arrays.toString((char[]) o));\r\n            } else {\r\n                // special handling of container Object[]\r\n                String id \u003d identityToString(o);\r\n                if (dejaVu.contains(id)) {\r\n                    str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n                } else {\r\n                    dejaVu.add(id);\r\n                    Object[] oArray \u003d (Object[]) o;\r\n                    str.append(\"[\");\r\n                    boolean first \u003d true;\r\n                    for (Object current : oArray) {\r\n                        if (first) {\r\n                            first \u003d false;\r\n                        } else {\r\n                            str.append(\", \");\r\n                        }\r\n                        recursiveDeepToString(current, str, new HashSet\u003cString\u003e(dejaVu));\r\n                    }\r\n                    str.append(\"]\");\r\n                }\r\n                //str.append(Arrays.deepToString((Object[]) o));\r\n            }\r\n        } else if (o instanceof Map) {\r\n            // special handling of container Map\r\n            String id \u003d identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Map\u003c?, ?\u003e oMap \u003d (Map\u003c?, ?\u003e) o;\r\n                str.append(\"{\");\r\n                boolean isFirst \u003d true;\r\n                for (Map.Entry\u003c?, ?\u003e current : oMap.entrySet()) {\r\n                    if (isFirst) {\r\n                        isFirst \u003d false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    Object key \u003d current.getKey();\r\n                    Object value \u003d current.getValue();\r\n                    recursiveDeepToString(key, str, new HashSet\u003cString\u003e(dejaVu));\r\n                    str.append(\"\u003d\");\r\n                    recursiveDeepToString(value, str, new HashSet\u003cString\u003e(dejaVu));\r\n                }\r\n                str.append(\"}\");\r\n            }\r\n        } else if (o instanceof Collection) {\r\n            // special handling of container Collection\r\n            String id \u003d identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Collection\u003c?\u003e oCol \u003d (Collection\u003c?\u003e) o;\r\n                str.append(\"[\");\r\n                boolean isFirst \u003d true;\r\n                for (Object current : oCol) {\r\n                    if (isFirst) {\r\n                        isFirst \u003d false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    recursiveDeepToString(current, str, new HashSet\u003cString\u003e(dejaVu));\r\n                }\r\n                str.append(\"]\");\r\n            }\r\n        } else if (o instanceof Date) {\r\n            Date date \u003d (Date) o;\r\n            SimpleDateFormat format \u003d new SimpleDateFormat(\"yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSSZ\");\r\n            // I\u0027ll leave it like this for the moment... this could probably be optimized using ThreadLocal...\r\n            str.append(format.format(date));\r\n        } else {\r\n            // it\u0027s just some other Object, we can only use toString().\r\n            try {\r\n                str.append(o.toString());\r\n            } catch (Throwable t) {\r\n                str.append(ERROR_PREFIX);\r\n                str.append(identityToString(o));\r\n                str.append(ERROR_SEPARATOR);\r\n                String msg \u003d t.getMessage();\r\n                String className \u003d t.getClass().getName();\r\n                str.append(className);\r\n                if (!className.equals(msg)) {\r\n                    str.append(ERROR_MSG_SEPARATOR);\r\n                    str.append(msg);\r\n                }\r\n                str.append(ERROR_SUFFIX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns the same as if Object.toString() would not have been\r\n     * overridden in obj.\r\n     * \u003cp/\u003e\r\n     * Note that this isn\u0027t 100% secure as collisions can always happen with hash codes.\r\n     * \u003cp/\u003e\r\n     * Copied from Object.hashCode():\r\n     * As much as is reasonably practical, the hashCode method defined by\r\n     * class \u003ctt\u003eObject\u003c/tt\u003e does return distinct integers for distinct\r\n     * objects. (This is typically implemented by converting the internal\r\n     * address of the object into an integer, but this implementation\r\n     * technique is not required by the\r\n     * Java\u003cfont size\u003d\"-2\"\u003e\u003csup\u003eTM\u003c/sup\u003e\u003c/font\u003e programming language.)\r\n     *\r\n     * @param obj the Object that is to be converted into an identity string.\r\n     * @return the identity string as also defined in Object.toString()\r\n     */\r\n    public static String identityToString(Object obj) {\r\n        if (obj \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        return obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\r\n    }\r\n\r\n    /**\r\n     * \u003cp\u003eThis is just a simple class containing the result of an evaluateArgument call. It\u0027s necessary because we need to\r\n     * return two results, i.e. the resulting String[] and the optional Throwable.\u003c/p\u003e\r\n     * \u003cp/\u003e\r\n     * \u003cp\u003eThis class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed\r\n     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not\r\n     * available/different in the deserializing VM.\u003c/p\u003e\r\n     */\r\n    public static class ArgumentResult {\r\n\r\n        private Throwable throwable;\r\n\r\n        private String[] arguments;\r\n\r\n        public ArgumentResult(String[] arguments, Throwable throwable) {\r\n            this.throwable \u003d throwable;\r\n            this.arguments \u003d arguments;\r\n        }\r\n\r\n        public Throwable getThrowable() {\r\n            return throwable;\r\n        }\r\n\r\n        public String[] getArguments() {\r\n            return arguments;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder result \u003d new StringBuilder();\r\n            result.append(\"ArgumentResult[throwable\u003d\").append(throwable);\r\n            result.append(\", arguments\u003d\");\r\n            if (arguments !\u003d null) {\r\n                result.append(\"[\");\r\n                boolean isFirst \u003d true;\r\n                for (String current : arguments) {\r\n                    if (!isFirst) {\r\n                        result.append(\", \");\r\n                    } else {\r\n                        isFirst \u003d false;\r\n                    }\r\n                    if (current !\u003d null) {\r\n                        result.append(\"\u0027\").append(current).append(\"\u0027\");\r\n                    } else {\r\n                        result.append(\"null\");\r\n                    }\r\n                }\r\n                result.append(\"]\");\r\n            }\r\n            return result.toString();\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if (this \u003d\u003d o)\r\n                return true;\r\n            if (o \u003d\u003d null || getClass() !\u003d o.getClass())\r\n                return false;\r\n            ArgumentResult result \u003d (ArgumentResult) o;\r\n            if (!Arrays.equals(arguments, result.arguments))\r\n                return false;\r\n            if (throwable !\u003d null ? !throwable.equals(result.throwable) : result.throwable !\u003d null)\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        public int hashCode() {\r\n            int result;\r\n            result \u003d (throwable !\u003d null ? throwable.hashCode() : 0);\r\n            result \u003d 31 * result + (arguments !\u003d null ? Arrays.hashCode(arguments) : 0);\r\n            return result;\r\n        }\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.data.logging",
    "classname": "MessageFormatter",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_2Test.java",
    "test_prompt": "// MessageFormatter_2Test.java\npackage de.huxhorn.lilith.data.logging;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFormatter}.\n* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.\n*/\nclass MessageFormatter_2Test {",
    "method_signature": "evaluateArguments(String, Object[])",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// MessageFormatter.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n */\r\npackage de.huxhorn.lilith.data.logging;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * \u003cp\u003eReplacement for org.slf4j.helpers.MessageFormatter.\u003c/p\u003e\r\n * \u003cp\u003e\r\n * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message\r\n * is split into three parts:\r\n * \u003c/p\u003e\r\n * \u003col\u003e\r\n * \u003cli\u003eCounting of placeholders in the message pattern (cheap)\u003c/li\u003e\r\n * \u003cli\u003eConversion of argument array into an ArgumentResult, containing the arguments converted to String as well as\r\n * an optional Throwable if available (relatively cheap)\u003c/li\u003e\r\n * \u003cli\u003eReplacement of placeholders in a message pattern with arguments given as String[]. (most expensive)\u003c/li\u003e\r\n * \u003c/ol\u003e\r\n * \u003cp\u003e\r\n * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the\r\n * actual construction of the message, is only done on demand.\r\n * \u003c/p\u003e\r\n */\r\npublic class MessageFormatter {\r\n\r\n    private static final char DELIM_START \u003d \u0027{\u0027;\r\n\r\n    private static final char DELIM_STOP \u003d \u0027}\u0027;\r\n\r\n    private static final char ESCAPE_CHAR \u003d \u0027\\\\\u0027;\r\n\r\n    public static final String RECURSION_PREFIX \u003d \"[...\";\r\n\r\n    public static final String RECURSION_SUFFIX \u003d \"...]\";\r\n\r\n    public static final String ERROR_PREFIX \u003d \"[!!!\";\r\n\r\n    public static final String ERROR_SEPARATOR \u003d \"\u003d\u003e\";\r\n\r\n    public static final String ERROR_MSG_SEPARATOR \u003d \":\";\r\n\r\n    public static final String ERROR_SUFFIX \u003d \"!!!]\";\r\n\r\n    /**\r\n     * Replace placeholders in the given messagePattern with arguments.\r\n     *\r\n     * @param messagePattern the message pattern containing placeholders.\r\n     * @param arguments      the arguments to be used to replace placeholders.\r\n     * @return the formatted message.\r\n     */\r\n    public static String format(String messagePattern, String[] arguments) {\r\n        if (messagePattern \u003d\u003d null || arguments \u003d\u003d null || arguments.length \u003d\u003d 0) {\r\n            return messagePattern;\r\n        }\r\n        StringBuilder result \u003d new StringBuilder();\r\n        int escapeCounter \u003d 0;\r\n        int currentArgument \u003d 0;\r\n        for (int i \u003d 0; i \u003c messagePattern.length(); i++) {\r\n            char curChar \u003d messagePattern.charAt(i);\r\n            if (curChar \u003d\u003d ESCAPE_CHAR) {\r\n                escapeCounter++;\r\n            } else {\r\n                if (curChar \u003d\u003d DELIM_START) {\r\n                    if (i \u003c messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) \u003d\u003d DELIM_STOP) {\r\n                            // write escaped escape chars\r\n                            int escapedEscapes \u003d escapeCounter / 2;\r\n                            for (int j \u003d 0; j \u003c escapedEscapes; j++) {\r\n                                result.append(ESCAPE_CHAR);\r\n                            }\r\n                            if (escapeCounter % 2 \u003d\u003d 1) {\r\n                                // i.e. escaped\r\n                                // write escaped escape chars\r\n                                result.append(DELIM_START);\r\n                                result.append(DELIM_STOP);\r\n                            } else {\r\n                                // unescaped\r\n                                if (currentArgument \u003c arguments.length) {\r\n                                    result.append(arguments[currentArgument]);\r\n                                } else {\r\n                                    result.append(DELIM_START).append(DELIM_STOP);\r\n                                }\r\n                                currentArgument++;\r\n                            }\r\n                            i++;\r\n                            escapeCounter \u003d 0;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                // any other char beside ESCAPE or DELIM_START/STOP-combo\r\n                // write unescaped escape chars\r\n                if (escapeCounter \u003e 0) {\r\n                    for (int j \u003d 0; j \u003c escapeCounter; j++) {\r\n                        result.append(ESCAPE_CHAR);\r\n                    }\r\n                    escapeCounter \u003d 0;\r\n                }\r\n                result.append(curChar);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Counts the number of unescaped placeholders in the given messagePattern.\r\n     *\r\n     * @param messagePattern the message pattern to be analyzed.\r\n     * @return the number of unescaped placeholders.\r\n     */\r\n    public static int countArgumentPlaceholders(String messagePattern) {\r\n        if (messagePattern \u003d\u003d null) {\r\n            return 0;\r\n        }\r\n        int delim \u003d messagePattern.indexOf(DELIM_START);\r\n        if (delim \u003d\u003d -1) {\r\n            // special case, no placeholders at all.\r\n            return 0;\r\n        }\r\n        int result \u003d 0;\r\n        boolean isEscaped \u003d false;\r\n        for (int i \u003d 0; i \u003c messagePattern.length(); i++) {\r\n            char curChar \u003d messagePattern.charAt(i);\r\n            if (curChar \u003d\u003d ESCAPE_CHAR) {\r\n                isEscaped \u003d !isEscaped;\r\n            } else if (curChar \u003d\u003d DELIM_START) {\r\n                if (!isEscaped) {\r\n                    if (i \u003c messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) \u003d\u003d DELIM_STOP) {\r\n                            result++;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                isEscaped \u003d false;\r\n            } else {\r\n                isEscaped \u003d false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * \u003cp\u003eThis method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String\r\n     * as well as an optional Throwable.\u003c/p\u003e\r\n     * \u003cp/\u003e\r\n     * \u003cp\u003eIf the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned\r\n     * in MessageFormatter.ArgumentResult.getThrowable() and won\u0027t be contained in the created String[].\u003cbr/\u003e\r\n     * If it is used up getThrowable will return null even if the last argument was a Throwable!\u003c/p\u003e\r\n     *\r\n     * @param messagePattern the message pattern that to be checked for placeholders.\r\n     * @param arguments      the argument array to be converted.\r\n     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.\r\n     */\r\n    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {\r\n        if (arguments \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        int argsCount \u003d countArgumentPlaceholders(messagePattern);\r\n        int resultArgCount \u003d arguments.length;\r\n        Throwable throwable \u003d null;\r\n        if (argsCount \u003c arguments.length) {\r\n            if (arguments[arguments.length - 1] instanceof Throwable) {\r\n                throwable \u003d (Throwable) arguments[arguments.length - 1];\r\n                resultArgCount--;\r\n            }\r\n        }\r\n        String[] stringArgs;\r\n        if (argsCount \u003d\u003d 1 \u0026\u0026 throwable \u003d\u003d null \u0026\u0026 arguments.length \u003e 1) {\r\n            // special case\r\n            stringArgs \u003d new String[1];\r\n            stringArgs[0] \u003d deepToString(arguments);\r\n        } else {\r\n            stringArgs \u003d new String[resultArgCount];\r\n            for (int i \u003d 0; i \u003c stringArgs.length; i++) {\r\n                stringArgs[i] \u003d deepToString(arguments[i]);\r\n            }\r\n        }\r\n        return new ArgumentResult(stringArgs, throwable);\r\n    }\r\n\r\n    public static String deepToString(Object o) {\r\n        if (o \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        if (o instanceof String) {\r\n            return (String) o;\r\n        }\r\n        StringBuilder str \u003d new StringBuilder();\r\n        // that\u0027s actually a neat name ;)\r\n        Set\u003cString\u003e dejaVu \u003d new HashSet\u003cString\u003e();\r\n        recursiveDeepToString(o, str, dejaVu);\r\n        return str.toString();\r\n    }\r\n\r\n    /**\r\n     * This method performs a deep toString of the given Object.\r\n     * Primitive arrays are converted using their respective Arrays.toString methods while\r\n     * special handling is implemented for \"container types\", i.e. Object[], Map and Collection because those could\r\n     * contain themselves.\r\n     * \u003cp/\u003e\r\n     * dejaVu is used in case of those container types to prevent an endless recursion.\r\n     * \u003cp/\u003e\r\n     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.\r\n     * They only check if the container is directly contained in itself, but not if a contained container contains the\r\n     * original one. Because of that, Arrays.toString(Object[]) isn\u0027t safe either.\r\n     * Confusing? Just read the last paragraph again and check the respective toString() implementation.\r\n     * \u003cp/\u003e\r\n     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)\r\n     * would produce a relatively hard-to-debug StackOverflowError.\r\n     *\r\n     * @param o      the Object to convert into a String\r\n     * @param str    the StringBuilder that o will be appended to\r\n     * @param dejaVu a list of container identities that were already used.\r\n     */\r\n    private static void recursiveDeepToString(Object o, StringBuilder str, Set\u003cString\u003e dejaVu) {\r\n        if (o \u003d\u003d null) {\r\n            str.append(\"null\");\r\n            return;\r\n        }\r\n        if (o instanceof String) {\r\n            str.append(o);\r\n            return;\r\n        }\r\n        Class oClass \u003d o.getClass();\r\n        if (oClass.isArray()) {\r\n            if (oClass \u003d\u003d byte[].class) {\r\n                str.append(Arrays.toString((byte[]) o));\r\n            } else if (oClass \u003d\u003d short[].class) {\r\n                str.append(Arrays.toString((short[]) o));\r\n            } else if (oClass \u003d\u003d int[].class) {\r\n                str.append(Arrays.toString((int[]) o));\r\n            } else if (oClass \u003d\u003d long[].class) {\r\n                str.append(Arrays.toString((long[]) o));\r\n            } else if (oClass \u003d\u003d float[].class) {\r\n                str.append(Arrays.toString((float[]) o));\r\n            } else if (oClass \u003d\u003d double[].class) {\r\n                str.append(Arrays.toString((double[]) o));\r\n            } else if (oClass \u003d\u003d boolean[].class) {\r\n                str.append(Arrays.toString((boolean[]) o));\r\n            } else if (oClass \u003d\u003d char[].class) {\r\n                str.append(Arrays.toString((char[]) o));\r\n            } else {\r\n                // special handling of container Object[]\r\n                String id \u003d identityToString(o);\r\n                if (dejaVu.contains(id)) {\r\n                    str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n                } else {\r\n                    dejaVu.add(id);\r\n                    Object[] oArray \u003d (Object[]) o;\r\n                    str.append(\"[\");\r\n                    boolean first \u003d true;\r\n                    for (Object current : oArray) {\r\n                        if (first) {\r\n                            first \u003d false;\r\n                        } else {\r\n                            str.append(\", \");\r\n                        }\r\n                        recursiveDeepToString(current, str, new HashSet\u003cString\u003e(dejaVu));\r\n                    }\r\n                    str.append(\"]\");\r\n                }\r\n                //str.append(Arrays.deepToString((Object[]) o));\r\n            }\r\n        } else if (o instanceof Map) {\r\n            // special handling of container Map\r\n            String id \u003d identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Map\u003c?, ?\u003e oMap \u003d (Map\u003c?, ?\u003e) o;\r\n                str.append(\"{\");\r\n                boolean isFirst \u003d true;\r\n                for (Map.Entry\u003c?, ?\u003e current : oMap.entrySet()) {\r\n                    if (isFirst) {\r\n                        isFirst \u003d false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    Object key \u003d current.getKey();\r\n                    Object value \u003d current.getValue();\r\n                    recursiveDeepToString(key, str, new HashSet\u003cString\u003e(dejaVu));\r\n                    str.append(\"\u003d\");\r\n                    recursiveDeepToString(value, str, new HashSet\u003cString\u003e(dejaVu));\r\n                }\r\n                str.append(\"}\");\r\n            }\r\n        } else if (o instanceof Collection) {\r\n            // special handling of container Collection\r\n            String id \u003d identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Collection\u003c?\u003e oCol \u003d (Collection\u003c?\u003e) o;\r\n                str.append(\"[\");\r\n                boolean isFirst \u003d true;\r\n                for (Object current : oCol) {\r\n                    if (isFirst) {\r\n                        isFirst \u003d false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    recursiveDeepToString(current, str, new HashSet\u003cString\u003e(dejaVu));\r\n                }\r\n                str.append(\"]\");\r\n            }\r\n        } else if (o instanceof Date) {\r\n            Date date \u003d (Date) o;\r\n            SimpleDateFormat format \u003d new SimpleDateFormat(\"yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSSZ\");\r\n            // I\u0027ll leave it like this for the moment... this could probably be optimized using ThreadLocal...\r\n            str.append(format.format(date));\r\n        } else {\r\n            // it\u0027s just some other Object, we can only use toString().\r\n            try {\r\n                str.append(o.toString());\r\n            } catch (Throwable t) {\r\n                str.append(ERROR_PREFIX);\r\n                str.append(identityToString(o));\r\n                str.append(ERROR_SEPARATOR);\r\n                String msg \u003d t.getMessage();\r\n                String className \u003d t.getClass().getName();\r\n                str.append(className);\r\n                if (!className.equals(msg)) {\r\n                    str.append(ERROR_MSG_SEPARATOR);\r\n                    str.append(msg);\r\n                }\r\n                str.append(ERROR_SUFFIX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns the same as if Object.toString() would not have been\r\n     * overridden in obj.\r\n     * \u003cp/\u003e\r\n     * Note that this isn\u0027t 100% secure as collisions can always happen with hash codes.\r\n     * \u003cp/\u003e\r\n     * Copied from Object.hashCode():\r\n     * As much as is reasonably practical, the hashCode method defined by\r\n     * class \u003ctt\u003eObject\u003c/tt\u003e does return distinct integers for distinct\r\n     * objects. (This is typically implemented by converting the internal\r\n     * address of the object into an integer, but this implementation\r\n     * technique is not required by the\r\n     * Java\u003cfont size\u003d\"-2\"\u003e\u003csup\u003eTM\u003c/sup\u003e\u003c/font\u003e programming language.)\r\n     *\r\n     * @param obj the Object that is to be converted into an identity string.\r\n     * @return the identity string as also defined in Object.toString()\r\n     */\r\n    public static String identityToString(Object obj) {\r\n        if (obj \u003d\u003d null) {\r\n            return null;\r\n        }\r\n        return obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\r\n    }\r\n\r\n    /**\r\n     * \u003cp\u003eThis is just a simple class containing the result of an evaluateArgument call. It\u0027s necessary because we need to\r\n     * return two results, i.e. the resulting String[] and the optional Throwable.\u003c/p\u003e\r\n     * \u003cp/\u003e\r\n     * \u003cp\u003eThis class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed\r\n     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not\r\n     * available/different in the deserializing VM.\u003c/p\u003e\r\n     */\r\n    public static class ArgumentResult {\r\n\r\n        private Throwable throwable;\r\n\r\n        private String[] arguments;\r\n\r\n        public ArgumentResult(String[] arguments, Throwable throwable) {\r\n            this.throwable \u003d throwable;\r\n            this.arguments \u003d arguments;\r\n        }\r\n\r\n        public Throwable getThrowable() {\r\n            return throwable;\r\n        }\r\n\r\n        public String[] getArguments() {\r\n            return arguments;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder result \u003d new StringBuilder();\r\n            result.append(\"ArgumentResult[throwable\u003d\").append(throwable);\r\n            result.append(\", arguments\u003d\");\r\n            if (arguments !\u003d null) {\r\n                result.append(\"[\");\r\n                boolean isFirst \u003d true;\r\n                for (String current : arguments) {\r\n                    if (!isFirst) {\r\n                        result.append(\", \");\r\n                    } else {\r\n                        isFirst \u003d false;\r\n                    }\r\n                    if (current !\u003d null) {\r\n                        result.append(\"\u0027\").append(current).append(\"\u0027\");\r\n                    } else {\r\n                        result.append(\"null\");\r\n                    }\r\n                }\r\n                result.append(\"]\");\r\n            }\r\n            return result.toString();\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if (this \u003d\u003d o)\r\n                return true;\r\n            if (o \u003d\u003d null || getClass() !\u003d o.getClass())\r\n                return false;\r\n            ArgumentResult result \u003d (ArgumentResult) o;\r\n            if (!Arrays.equals(arguments, result.arguments))\r\n                return false;\r\n            if (throwable !\u003d null ? !throwable.equals(result.throwable) : result.throwable !\u003d null)\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        public int hashCode() {\r\n            int result;\r\n            result \u003d (throwable !\u003d null ? throwable.hashCode() : 0);\r\n            result \u003d 31 * result + (arguments !\u003d null ? Arrays.hashCode(arguments) : 0);\r\n            return result;\r\n        }\r\n    }\r\n}\r\n",
    "package": "de.huxhorn.lilith.data.logging",
    "classname": "MessageFormatter",
    "id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_4Test.java",
    "test_prompt": "// MessageFormatter_4Test.java\npackage de.huxhorn.lilith.data.logging;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFormatter}.\n* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.\n*/\nclass MessageFormatter_4Test {",
    "method_signature": "identityToString(Object)",
    "suffix": "4"
  }
]