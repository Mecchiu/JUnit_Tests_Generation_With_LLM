ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
chatcmpl-A5TiWkdVj5DWhNLxEEobl4tbyNorj,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_0Test.java,9.044358015060425,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_0Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#capacity()} method.
*/
class DefaultNoteListModel_0Test {","```java
class DefaultNoteListModel_0Test {

    @Test
    void testCapacityWhenListIsEmpty() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        assertEquals(10, model.capacity());
    }

    @Test
    void testCapacityAfterAddingElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(new AbstractNote());
        assertEquals(10, model.capacity());
    }

    @Test
    void testCapacityAfterRemovingElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        model.removeElement(note);
        assertEquals(10, model.capacity());
    }

    @Test
    void testCapacityAfterInsertingElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.insertElementAt(new AbstractNote(), 0);
        assertEquals(10, model.capacity());
    }

    @Test
    void testCapacityAfterSettingElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.setElementAt(new AbstractNote(), 0);
        assertEquals(10, model.capacity());
    }

    @Test
    void testCapacityAfterAddingMultipleElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        for (int i = 0; i < 15; i++) {
            model.addElement(new AbstractNote());
        }
        assertEquals(20, model.capacity());
    }

    @Test
    void testCapacityAfterRemovingMultipleElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        List<AbstractNote> notes = new ArrayList<>();
        for (int i = 0; i < 15; i++) {
            AbstractNote note = new AbstractNote();
            model.addElement(note);
            notes.add(note);
        }
        for (AbstractNote note : notes) {
            model.removeElement(note);
        }
        assertEquals(20, model.capacity());
    }

    @Test
    void testCapacityAfterInsertingMultipleElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        for (int i = 0; i < 15; i++) {
            model.insertElementAt(new AbstractNote(), 0);
        }
        assertEquals(20, model.capacity());
    }

    @Test
    void testCapacityAfterSettingMultipleElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        for (int i = 0; i < 15; i++) {
            model.setElementAt(new AbstractNote(), i);
        }
        assertEquals(20, model.capacity());
    }
}
```
```"
chatcmpl-A5TjZGfKM8qJKvkZzEU7EX7iifMQB,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_1Test.java,6.135591983795166,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_1Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#size()} method.
*/
class DefaultNoteListModel_1Test {","```java
class DefaultNoteListModel_1Test {

    @Test
    void testSizeEmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        assertEquals(0, model.size());
    }

    @Test
    void testSizeNonEmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(new AbstractNote());
        assertEquals(1, model.size());
    }

    @Test
    void testSizeMultipleElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(new AbstractNote());
        model.addElement(new AbstractNote());
        model.addElement(new AbstractNote());
        assertEquals(3, model.size());
    }

    @Test
    void testSizeAfterRemove() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        model.addElement(new AbstractNote());
        model.removeElement(note);
        assertEquals(1, model.size());
    }

    @Test
    void testSizeAfterInsert() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(new AbstractNote());
        model.insertElementAt(new AbstractNote(), 0);
        assertEquals(2, model.size());
    }

    @Test
    void testSizeAfterSet() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(new AbstractNote());
        model.setElementAt(new AbstractNote(), 0);
        assertEquals(1, model.size());
    }

    @Test
    void testSizeAfterAdd() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.add(0, new AbstractNote());
        assertEquals(1, model.size());
    }

    @Test
    void testSizeAfterRemoveAt() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(new AbstractNote());
        model.removeElementAt(0);
        assertEquals(0, model.size());
    }

    @Test
    void testSizeAfterClear() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(new AbstractNote());
        model.addElement(new AbstractNote());
        model.addElement(new AbstractNote());
        model.removeAllElements();
        assertEquals(0, model.size());
    }
}
```
```"
chatcmpl-A5Tkcv6wqxxamVOnylf3RYrHDnoQh,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_2Test.java,13.661648988723755,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_2Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#elements()} method.
*/
class DefaultNoteListModel_2Test {","```java
class DefaultNoteListModel_2Test {

    @Test
    void testElements_ReturnsEnumerationOfComponents() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        Enumeration<AbstractNote> elements = model.elements();

        List<AbstractNote> actualElements = new ArrayList<>();
        while (elements.hasMoreElements()) {
            actualElements.add(elements.nextElement());
        }

        List<AbstractNote> expectedElements = Arrays.asList(note1, note2);
        assertEquals(expectedElements, actualElements);
    }

    @Test
    void testElements_ReturnsEmptyEnumeration_WhenNoComponents() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        Enumeration<AbstractNote> elements = model.elements();

        assertFalse(elements.hasMoreElements());
    }

    @Test
    void testElements_ReturnsEnumerationOfComponentsInCorrectOrder() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        Enumeration<AbstractNote> elements = model.elements();

        List<AbstractNote> actualElements = new ArrayList<>();
        while (elements.hasMoreElements()) {
            actualElements.add(elements.nextElement());
        }

        List<AbstractNote> expectedElements = Arrays.asList(note1, note2);
        assertEquals(expectedElements, actualElements);
    }

    @Test
    void testElements_ReturnsEnumerationOfComponents_WhenMultipleComponents() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        AbstractNote note3 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.addElement(note3);

        Enumeration<AbstractNote> elements = model.elements();

        List<AbstractNote> actualElements = new ArrayList<>();
        while (elements.hasMoreElements()) {
            actualElements.add(elements.nextElement());
        }

        List<AbstractNote> expectedElements = Arrays.asList(note1, note2, note3);
        assertEquals(expectedElements, actualElements);
    }

    @Test
    void testElements_ReturnsEnumerationOfComponents_WhenDuplicateComponents() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note1);

        Enumeration<AbstractNote> elements = model.elements();

        List<AbstractNote> actualElements = new ArrayList<>();
        while (elements.hasMoreElements()) {
            actualElements.add(elements.nextElement());
        }

        List<AbstractNote> expectedElements = Arrays.asList(note1, note1);
        assertEquals(expectedElements, actualElements);
    }

    @Test
    void testElements_ReturnsEnumerationOfComponents_WhenEmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        Enumeration<AbstractNote> elements = model.elements();

        List<AbstractNote> actualElements = new ArrayList<>();
        while (elements.hasMoreElements()) {
            actualElements.add(elements.nextElement());
        }

        assertTrue(actualElements.isEmpty());
    }

    @Test
    void testElements_ReturnsEnumerationOfComponents_WhenNullComponents() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(null);

        Enumeration<AbstractNote> elements = model.elements();

        List<AbstractNote> actualElements = new ArrayList<>();
        while (elements.hasMoreElements()) {
            actualElements.add(elements.nextElement());
        }

        List<AbstractNote> expectedElements = Collections.singletonList(null);
        assertEquals(expectedElements, actualElements);
    }

    @Test
    void testElements_ReturnsEnumerationOfComponents_WhenLargeNumberOfComponents() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        for (int i = 0; i < 1000; i++) {
            model.addElement(new AbstractNote());
        }

        Enumeration<AbstractNote> elements = model.elements();

        List<AbstractNote> actualElements = new ArrayList<>();
        while (elements.hasMoreElements()) {
            actualElements.add(elements.nextElement());
        }

        assertEquals(1000, actualElements.size());
    }

    @Test
    void testElements_ReturnsEnumerationOfComponents_WhenComponentsWithDifferentProperties() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        note1.setTitle(""Note 1"");
        AbstractNote note2 = new AbstractNote();
        note2.setTitle(""Note 2"");
        model.addElement(note1);
        model.addElement(note2);

        Enumeration<AbstractNote> elements = model.elements();

        List<AbstractNote> actualElements = new ArrayList<>();
        while (elements.hasMoreElements()) {
            actualElements.add(elements.nextElement());
        }

        List<AbstractNote> expectedElements = Arrays.asList(note1, note2);
        assertEquals(expectedElements, actualElements);
    }
}
```
```"
chatcmpl-A5TlfSvma91SpvNUsdFxu8xGnNGQh,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_3Test.java,7.697633504867554,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_3Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#contains(AbstractNote)} method.
*/
class DefaultNoteListModel_3Test {","```java
class DefaultNoteListModel_3Test {

    @Test
    void testContains_EmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        assertFalse(model.contains(note));
    }

    @Test
    void testContains_SingleElementList_Contains() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        assertTrue(model.contains(note));
    }

    @Test
    void testContains_SingleElementList_NotContains() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        assertFalse(model.contains(note2));
    }

    @Test
    void testContains_MultipleElementList_Contains() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        assertTrue(model.contains(note2));
    }

    @Test
    void testContains_MultipleElementList_NotContains() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        assertFalse(model.contains(note2));
    }

    @Test
    void testContains_NullElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        assertFalse(model.contains(null));
    }

    @Test
    void testContains_EmptyList_NullElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        assertFalse(model.contains(null));
    }

    @Test
    void testContains_SingleElementList_NullElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        assertFalse(model.contains(null));
    }

    @Test
    void testContains_MultipleElementList_NullElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        assertFalse(model.contains(null));
    }
}
```
```"
chatcmpl-A5Tmi2ovSnfaUlVNWThMJ4ud67HGp,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_4Test.java,8.975398540496826,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_4Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#indexOf(AbstractNote)} method.
*/
class DefaultNoteListModel_4Test {","```java
class DefaultNoteListModel_4Test {

    @Test
    void testIndexOf_EmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        int index = model.indexOf(note);
        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_NoteInList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        int index = model.indexOf(note2);
        assertEquals(1, index);
    }

    @Test
    void testIndexOf_NoteNotInList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        int index = model.indexOf(note2);
        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_NullNote() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = null;
        model.addElement(new AbstractNote());
        int index = model.indexOf(note);
        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_FirstOccurrence() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        model.addElement(note);
        int index = model.indexOf(note);
        assertEquals(0, index);
    }

    @Test
    void testIndexOf_StartIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(new AbstractNote());
        model.addElement(note);
        int index = model.indexOf(note, 1);
        assertEquals(1, index);
    }

    @Test
    void testIndexOf_StartIndex_NotFound() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(new AbstractNote());
        int index = model.indexOf(note, 1);
        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_LastOccurrence() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        model.addElement(note);
        int index = model.lastIndexOf(note);
        assertEquals(1, index);
    }

    @Test
    void testIndexOf_LastOccurrence_Index() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        model.addElement(new AbstractNote());
        int index = model.lastIndexOf(note, 0);
        assertEquals(0, index);
    }

    @Test
    void testIndexOf_LastOccurrence_Index_NotFound() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(new AbstractNote());
        int index = model.lastIndexOf(note, 0);
        assertEquals(-1, index);
    }
}
```
```"
chatcmpl-A5TnlwWjvNEtJOPejtvY5oEXsaRbM,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_5Test.java,8.511004447937012,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_5Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#indexOf(AbstractNote, int)} method.
*/
class DefaultNoteListModel_5Test {","```java
class DefaultNoteListModel_5Test {

    @Test
    void testIndexOf_withExistingElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        int index = model.indexOf(note2, 0);

        assertEquals(1, index);
    }

    @Test
    void testIndexOf_withNonExistingElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);

        int index = model.indexOf(note2, 0);

        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_withExistingElementStartingFromIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        int index = model.indexOf(note1, 1);

        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_withNonExistingElementStartingFromIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);

        int index = model.indexOf(note2, 1);

        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_withExistingElementAtLastIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        int index = model.indexOf(note2, 1);

        assertEquals(1, index);
    }

    @Test
    void testIndexOf_withNonExistingElementAtLastIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);

        int index = model.indexOf(note2, 1);

        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_withEmptyModel() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();

        int index = model.indexOf(note, 0);

        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_withNullElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = null;

        int index = model.indexOf(note, 0);

        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_withNegativeIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();

        int index = model.indexOf(note, -1);

        assertEquals(-1, index);
    }

    @Test
    void testIndexOf_withIndexGreaterThanSize() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();

        int index = model.indexOf(note, 1);

        assertEquals(-1, index);
    }
}
```
```"
chatcmpl-A5Toopkse2mhv9KemIyeMiQdIEP3A,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_6Test.java,10.504802942276001,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_6Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#lastIndexOf(AbstractNote)} method.
*/
class DefaultNoteListModel_6Test {","```java
class DefaultNoteListModel_6Test {

    @Test
    void testLastIndexOf_whenElementExistsAtEnd_shouldReturnCorrectIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        int index = model.lastIndexOf(note2);

        assertEquals(1, index);
    }

    @Test
    void testLastIndexOf_whenElementExistsMultipleTimes_shouldReturnLastIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note1);
        model.addElement(note1);

        int index = model.lastIndexOf(note1);

        assertEquals(2, index);
    }

    @Test
    void testLastIndexOf_whenElementDoesNotExist_shouldReturnNegativeOne() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);

        int index = model.lastIndexOf(note2);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_whenEmptyList_shouldReturnNegativeOne() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        int index = model.lastIndexOf(new AbstractNote());

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_whenNullElement_shouldReturnNegativeOne() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(new AbstractNote());

        int index = model.lastIndexOf(null);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_whenElementExistsAtSpecifiedIndex_shouldReturnCorrectIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.addElement(note1);

        int index = model.lastIndexOf(note1, 1);

        assertEquals(0, index);
    }

    @Test
    void testLastIndexOf_whenElementExistsAtSpecifiedIndexMultipleTimes_shouldReturnLastIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note1);
        model.addElement(note1);

        int index = model.lastIndexOf(note1, 1);

        assertEquals(0, index);
    }

    @Test
    void testLastIndexOf_whenElementDoesNotExistAtSpecifiedIndex_shouldReturnNegativeOne() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);

        int index = model.lastIndexOf(note2, 0);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_whenEmptyListAtSpecifiedIndex_shouldReturnNegativeOne() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        int index = model.lastIndexOf(new AbstractNote(), 0);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_whenNullElementAtSpecifiedIndex_shouldReturnNegativeOne() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(new AbstractNote());

        int index = model.lastIndexOf(null, 0);

        assertEquals(-1, index);
    }
}
```
```"
chatcmpl-A5TprbCs79FWkzDWHxhyImYokxRNu,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_7Test.java,8.284676313400269,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_7Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#lastIndexOf(AbstractNote, int)} method.
*/
class DefaultNoteListModel_7Test {","```java
class DefaultNoteListModel_7Test {

    @Test
    void testLastIndexOf_withExistingElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        int index = model.lastIndexOf(note1, 1);

        assertEquals(0, index);
    }

    @Test
    void testLastIndexOf_withNonExistingElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);

        int index = model.lastIndexOf(note2, 1);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_withEmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();

        int index = model.lastIndexOf(note, 0);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_withNegativeIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);

        int index = model.lastIndexOf(note, -1);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_withIndexOutOfBounds() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);

        int index = model.lastIndexOf(note, 2);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_withNullElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);

        int index = model.lastIndexOf(null, 0);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_withNullElementAndNonEmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);

        int index = model.lastIndexOf(null, 1);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_withNullElementAndEmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        int index = model.lastIndexOf(null, 0);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_withNullElementAndNegativeIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        int index = model.lastIndexOf(null, -1);

        assertEquals(-1, index);
    }

    @Test
    void testLastIndexOf_withNullElementAndIndexOutOfBounds() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        int index = model.lastIndexOf(null, 2);

        assertEquals(-1, index);
    }
}
```
```"
chatcmpl-A5TquDYj1NhR9tLAEiPeMpK7mODY8,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_8Test.java,6.7327210903167725,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_8Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#elementAt(int)} method.
*/
class DefaultNoteListModel_8Test {","```java
class DefaultNoteListModel_8Test {

    @Test
    void testElementAt_withValidIndex_returnsElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);

        AbstractNote result = model.elementAt(0);

        assertEquals(note, result);
    }

    @Test
    void testElementAt_withNegativeIndex_throwsException() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            model.elementAt(-1);
        });
    }

    @Test
    void testElementAt_withIndexOutOfRange_throwsException() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);

        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            model.elementAt(1);
        });
    }

    @Test
    void testElementAt_withEmptyList_throwsException() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            model.elementAt(0);
        });
    }

    @Test
    void testElementAt_withValidIndex_returnsDifferentElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        AbstractNote result = model.elementAt(1);

        assertEquals(note2, result);
    }

    @Test
    void testElementAt_withValidIndex_returnsLastElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        AbstractNote result = model.elementAt(1);

        assertEquals(note2, result);
    }

    @Test
    void testElementAt_withValidIndex_returnsFirstElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        AbstractNote result = model.elementAt(0);

        assertEquals(note1, result);
    }

    @Test
    void testElementAt_withValidIndex_returnsNull() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(null);

        AbstractNote result = model.elementAt(0);

        assertNull(result);
    }

    @Test
    void testElementAt_withValidIndex_returnsDifferentNull() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        model.addElement(null);
        model.addElement(new AbstractNote());

        AbstractNote result = model.elementAt(0);

        assertNull(result);
    }
}
```
```"
chatcmpl-A5TrxeAhmJRZ2CjOSnNlfxX5rfQHJ,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_9Test.java,7.515502452850342,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_9Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#firstElement()} method.
*/
class DefaultNoteListModel_9Test {","```java
class DefaultNoteListModel_9Test {

    @Test
    void testFirstElement_EmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        assertThrows(NoSuchElementException.class, model::firstElement);
    }

    @Test
    void testFirstElement_NonEmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        assertEquals(note, model.firstElement());
    }

    @Test
    void testFirstElement_MultipleElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        assertEquals(note1, model.firstElement());
    }

    @Test
    void testFirstElement_RemoveElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.removeElement(note1);
        assertEquals(note2, model.firstElement());
    }

    @Test
    void testFirstElement_AddAtIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.insertElementAt(note1, 0);
        model.insertElementAt(note2, 0);
        assertEquals(note2, model.firstElement());
    }

    @Test
    void testFirstElement_SetElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.setElementAt(note2, 0);
        assertEquals(note2, model.firstElement());
    }

    @Test
    void testFirstElement_RemoveAtIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.insertElementAt(note1, 0);
        model.insertElementAt(note2, 1);
        model.removeElementAt(0);
        assertEquals(note2, model.firstElement());
    }

    @Test
    void testFirstElement_LastElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.removeElementAt(0);
        assertEquals(note2, model.firstElement());
    }

    @Test
    void testFirstElement_SingleElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        assertEquals(note, model.firstElement());
    }

    @Test
    void testFirstElement_MultipleCalls() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        model.firstElement();
        assertEquals(note, model.firstElement());
    }
}
```
```"
chatcmpl-A5Tt0g65zDBlgPyR1lnnPUGCqFF0z,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_10Test.java,8.865326166152954,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_10Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#lastElement()} method.
*/
class DefaultNoteListModel_10Test {","```java
class DefaultNoteListModel_10Test {

    @Test
    void testLastElement_EmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        assertThrows(NoSuchElementException.class, model::lastElement);
    }

    @Test
    void testLastElement_SingleElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        assertEquals(note, model.lastElement());
    }

    @Test
    void testLastElement_MultipleElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        assertEquals(note2, model.lastElement());
    }

    @Test
    void testLastElement_RemoveLastElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.removeElement(note2);
        assertEquals(note1, model.lastElement());
    }

    @Test
    void testLastElement_RemoveAllElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.removeElement(note1);
        model.removeElement(note2);
        assertThrows(NoSuchElementException.class, model::lastElement);
    }

    @Test
    void testLastElement_AddThenRemoveAllElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.removeElement(note1);
        model.removeElement(note2);
        assertThrows(NoSuchElementException.class, model::lastElement);
    }

    @Test
    void testLastElement_AddThenRemoveLastElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.removeElement(note2);
        assertEquals(note1, model.lastElement());
    }

    @Test
    void testLastElement_AddThenRemoveFirstElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.removeElement(note1);
        assertEquals(note2, model.lastElement());
    }

    @Test
    void testLastElement_AddThenRemoveMiddleElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        AbstractNote note3 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.addElement(note3);
        model.removeElement(note2);
        assertEquals(note3, model.lastElement());
    }

    @Test
    void testLastElement_AddThenRemoveAllButOneElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        AbstractNote note3 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.addElement(note3);
        model.removeElement(note1);
        model.removeElement(note3);
        assertEquals(note2, model.lastElement());
    }
}
```
```"
chatcmpl-A5Tu3gHGs7ggxNsdVkCmfZebqrfhI,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_11Test.java,5.069279670715332,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_11Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#removeElement(AbstractNote)} method.
*/
class DefaultNoteListModel_11Test {","```java
public class DefaultNoteListModel_11Test {

    @Test
    void testRemoveElement_Success() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        assertTrue(model.removeElement(note1));
        assertEquals(1, model.size());
    }

    @Test
    void testRemoveElement_NotFound() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);

        assertFalse(model.removeElement(note2));
        assertEquals(1, model.size());
    }

    @Test
    void testRemoveElement_FireItemRemoved() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        model.addElement(note1);

        NoteListDataListenerMock listener = new NoteListDataListenerMock();
        model.addNoteListDataListener(listener);

        model.removeElement(note1);

        assertTrue(listener.itemRemovedCalled);
        assertEquals(0, listener.removedIndex);
    }

    static class NoteListDataListenerMock implements NoteListDataListener {
        boolean itemRemovedCalled = false;
        int removedIndex = -1;

        @Override
        public void contentChanged(NoteListDataEvent event) {
        }

        @Override
        public void itemAdded(NoteListDataEvent event) {
        }

        @Override
        public void itemRemoved(NoteListDataEvent event) {
            itemRemovedCalled = true;
            removedIndex = event.getIndex();
        }
    }
}
```
```"
chatcmpl-A5Tv6dbL5QeVaDJgK5hQfzMHT2Qe8,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_12Test.java,10.706466674804688,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_12Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#toArray()} method.
*/
class DefaultNoteListModel_12Test {","```java
class DefaultNoteListModel_12Test {

    @Test
    void testToArray_emptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote[] expected = new AbstractNote[0];
        assertArrayEquals(expected, model.toArray());
    }

    @Test
    void testToArray_singleElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        AbstractNote[] expected = {note};
        assertArrayEquals(expected, model.toArray());
    }

    @Test
    void testToArray_multipleElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        AbstractNote[] expected = {note1, note2};
        assertArrayEquals(expected, model.toArray());
    }

    @Test
    void testToArray_nullElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = null;
        model.addElement(note);
        AbstractNote[] expected = {null};
        assertArrayEquals(expected, model.toArray());
    }

    @Test
    void testToArray_mixedElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = null;
        model.addElement(note1);
        model.addElement(note2);
        AbstractNote[] expected = {note1, null};
        assertArrayEquals(expected, model.toArray());
    }

    @Test
    void testToArray_largeList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote[] expected = new AbstractNote[1000];
        for (int i = 0; i < 1000; i++) {
            AbstractNote note = new AbstractNote();
            model.addElement(note);
            expected[i] = note;
        }
        assertArrayEquals(expected, model.toArray());
    }

    @Test
    void testToArray_sameElementRepeated() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        for (int i = 0; i < 10; i++) {
            model.addElement(note);
        }
        AbstractNote[] expected = new AbstractNote[10];
        Arrays.fill(expected, note);
        assertArrayEquals(expected, model.toArray());
    }

    @Test
    void testToArray_removeElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.removeElement(note1);
        AbstractNote[] expected = {note2};
        assertArrayEquals(expected, model.toArray());
    }

    @Test
    void testToArray_insertElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.insertElementAt(note2, 0);
        AbstractNote[] expected = {note2, note1};
        assertArrayEquals(expected, model.toArray());
    }

    @Test
    void testToArray_setElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.setElementAt(note2, 0);
        AbstractNote[] expected = {note2};
        assertArrayEquals(expected, model.toArray());
    }
}
```
```"
chatcmpl-A5Tw9kZNovvxn6LXyompU7j8jVklU,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_13Test.java,9.283203840255737,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_13Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#get(int)} method.
*/
class DefaultNoteListModel_13Test {","```java
class DefaultNoteListModel_13Test {

    @Test
    void testGetAtIndexZero() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note = new AbstractNote();
        model.addElement(note);
        assertEquals(note, model.get(0));
    }

    @Test
    void testGetAtIndexOutOfBounds() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            model.get(1);
        });
    }

    @Test
    void testGetAtIndexNegative() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            model.get(-1);
        });
    }

    @Test
    void testGetAtIndexMiddle() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        assertEquals(note2, model.get(1));
    }

    @Test
    void testGetEmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            model.get(0);
        });
    }

    @Test
    void testGetMultipleElements() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        assertEquals(note1, model.get(0));
        assertEquals(note2, model.get(1));
    }

    @Test
    void testGetLastElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        assertEquals(note2, model.get(model.size() - 1));
    }

    @Test
    void testGetFirstElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        assertEquals(note1, model.get(0));
    }

    @Test
    void testGetWithSetElement() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.setElementAt(note2, 0);
        assertEquals(note2, model.get(0));
    }
}
```
```"
chatcmpl-A5TxCJJNkYtfFPtFRnYnyIxFvoHSf,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/ui/DefaultNoteListModel_14Test.java,12.34663701057434,stop,"// DefaultNoteListModel.java
/*
 * @(#)DefaultNoteListModel.java
 * Created on 2005-8-4
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;

/**
 * Default implementation of <code>NoteListModel</code>
 *
 * @author Allen Chue
 */
public class DefaultNoteListModel implements NoteListModel {

    private Vector<AbstractNote> delegate = new Vector<AbstractNote>();

    // Uni-listener temporary
    private NoteListDataListener dataListener;

    /**
     * Returns the current capacity of this list.
     *
     * @return the current capacity
     * @see Vector#capacity()
     */
    public int capacity() {
        return delegate.capacity();
    }

    /**
     * Returns the number of components in this list.
     *
     * @return the number of components in this list
     * @see Vector#size()
     */
    public int size() {
        return delegate.size();
    }

    /**
     * Tests whether this list has any components.
     *
     * @return <code>true</code> if and only if this list has no components,
     *         that is, its size is zero; <code>false</code> otherwise
     * @see Vector#isEmpty()
     */
    public boolean isEmpty() {
        return delegate.isEmpty();
    }

    /**
     * Returns an enumeration of the components of this list.
     *
     * @return an enumeration of the components of this list
     * @see Vector#elements()
     */
    public Enumeration<AbstractNote> elements() {
        return delegate.elements();
    }

    /**
     * Tests whether the specified object is a component in this list.
     *
     * @param elem
     *            an object
     * @return <code>true</code> if the specified object is the same as a
     *         component in this list
     * @see Vector#contains(Object)
     */
    public boolean contains(AbstractNote elem) {
        return delegate.contains(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>.
     *
     * @param elem
     *            an object
     * @return the index of the first occurrence of the argument in this list;
     *         returns <code>-1</code> if the object is not found
     * @see Vector#indexOf(Object)
     */
    public int indexOf(AbstractNote elem) {
        return delegate.indexOf(elem);
    }

    /**
     * Searches for the first occurrence of <code>elem</code>, beginning the
     * search at <code>index</code>.
     *
     * @param elem
     *            an desired component
     * @param index
     *            the index from which to begin searching
     * @return the index where the first occurrence of <code>elem</code> is
     *         found after <code>index</code>; returns <code>-1</code> if
     *         the <code>elem</code> is not found in the list
     * @see Vector#indexOf(Object,int)
     */
    public int indexOf(AbstractNote elem, int index) {
        return delegate.indexOf(elem, index);
    }

    /**
     * Returns the index of the last occurrence of <code>elem</code>.
     *
     * @param elem
     *            the desired component
     * @return the index of the last occurrence of <code>elem</code> in the
     *         list; returns <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object)
     */
    public int lastIndexOf(AbstractNote elem) {
        return delegate.lastIndexOf(elem);
    }

    /**
     * Searches backwards for <code>elem</code>, starting from the specified
     * index, and returns an index to it.
     *
     * @param elem
     *            the desired component
     * @param index
     *            the index to start searching from
     * @return the index of the last occurrence of the <code>elem</code> in
     *         this list at position less than <code>index</code>; returns
     *         <code>-1</code> if the object is not found
     * @see Vector#lastIndexOf(Object,int)
     */
    public int lastIndexOf(AbstractNote elem, int index) {
        return delegate.lastIndexOf(elem, index);
    }

    /**
     * Returns the component at the specified index. Throws an
     * <code>ArrayIndexOutOfBoundsException</code> if the index is negative or
     * not less than the size of the list. <blockquote> <b>Note:</b> Although
     * this method is not deprecated, the preferred method to use is
     * <code>get(int)</code>, which implements the <code>List</code>
     * interface defined in the 1.2 Collections framework. </blockquote>
     *
     * @param index
     *            an index into this list
     * @return the component at the specified index
     * @see #get(int)
     * @see Vector#elementAt(int)
     */
    public AbstractNote elementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Returns the first component of this list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the first component of this list
     * @see java.util.Vector#firstElement()
     */
    public AbstractNote firstElement() {
        return delegate.firstElement();
    }

    /**
     * Returns the last component of the list. Throws a
     * <code>NoSuchElementException</code> if this vector has no components.
     *
     * @return the last component of the list
     * @see Vector#lastElement()
     */
    public AbstractNote lastElement() {
        return delegate.lastElement();
    }

    /**
     * Return the number of components in the list.
     *
     * @return the number of components in the list
     * @see NoteListModel#getSize()
     */
    public int getSize() {
        return delegate.size();
    }

    /**
     * Sets the component at the specified <code>index</code> of this list to
     * be the specified object. The previous component at that position is
     * discarded.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>set(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            what the component is to be set to
     * @param index
     *            the specified index
     * @see #set(int,Object)
     * @see Vector#setElementAt(Object,int)
     */
    public void setElementAt(AbstractNote obj, int index) {
        delegate.setElementAt(obj, index);
        fireContentChanged(this, index);
    }

    /**
     * Deletes the component at the specified index.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>remove(int)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param index
     *            the index of the object to remove
     * @see #remove(int)
     * @see Vector#removeElementAt(int)
     */
    public void removeElementAt(int index) {
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
    }

    /**
     * Inserts the specified object as a component in this list at the specified
     * <code>index</code>.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * invalid. <blockquote> <b>Note:</b> Although this method is not
     * deprecated, the preferred method to use is <code>add(int,Object)</code>,
     * which implements the <code>List</code> interface defined in the 1.2
     * Collections framework. </blockquote>
     *
     * @param obj
     *            the component to insert
     * @param index
     *            where to insert the new component
     * @exception ArrayIndexOutOfBoundsException
     *                if the index was invalid
     * @see #add(int,Object)
     * @see Vector#insertElementAt(Object,int)
     */
    public void insertElementAt(AbstractNote obj, int index) {
        delegate.insertElementAt(obj, index);
        fireItemAdded(this, index);
    }

    /**
     * Adds the specified component to the end of this list.
     *
     * @param obj
     *            the component to be added
     * @see Vector#addElement(Object)
     */
    public void addElement(AbstractNote obj) {
        int index = delegate.size();
        delegate.addElement(obj);
        fireItemAdded(this, index);
    }

    /**
     * Removes the first (lowest-indexed) occurrence of the argument from this
     * list.
     *
     * @param obj
     *            the component to be removed
     * @return <code>true</code> if the argument was a component of this list;
     *         <code>false</code> otherwise
     * @see Vector#removeElement(Object)
     */
    public boolean removeElement(AbstractNote obj) {
        int index = indexOf(obj);
        boolean an = delegate.removeElement(obj);
        if (index >= 0) {
            fireItemRemoved(this, index);
        }
        return an;
    }

    /**
     * Returns a string that displays and identifies this object's properties.
     *
     * @return a String representation of this object
     */
    @Override
    public String toString() {
        return delegate.toString();
    }

    /*
     * The remaining methods are included for compatibility with the Java 2
     * platform Vector class.
     */
    /**
     * Returns an array containing all of the elements in this list in the
     * correct order.
     *
     * @return an array containing the elements of the list
     * @see Vector#toArray()
     */
    public AbstractNote[] toArray() {
        AbstractNote[] an = new AbstractNote[delegate.size()];
        delegate.copyInto(an);
        return an;
    }

    /**
     * Returns the element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to return
     */
    public AbstractNote get(int index) {
        return delegate.elementAt(index);
    }

    /**
     * Replaces the element at the specified position in this list with the
     * specified element.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            index of element to replace
     * @param element
     *            element to be stored at the specified position
     * @return the element previously at the specified position
     */
    public AbstractNote set(int index, AbstractNote element) {
        AbstractNote an = delegate.elementAt(index);
        delegate.setElementAt(element, index);
        fireContentChanged(this, index);
        return an;
    }

    /**
     * Inserts the specified element at the specified position in this list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt; size()</code>).
     *
     * @param index
     *            index at which the specified element is to be inserted
     * @param element
     *            element to be inserted
     */
    public void add(int index, AbstractNote element) {
        delegate.insertElementAt(element, index);
        fireItemAdded(this, index);
    }

    /**
     * Removes the element at the specified position in this list. Returns the
     * element that was removed from the list.
     * <p>
     * Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is
     * out of range (<code>index &lt; 0 || index &gt;= size()</code>).
     *
     * @param index
     *            the index of the element to removed
     */
    public AbstractNote remove(int index) {
        AbstractNote an = delegate.elementAt(index);
        delegate.removeElementAt(index);
        fireItemRemoved(this, index);
        return an;
    }

    /**
     * Returns the value at position <code>index</code>
     *
     * @return the value at position <code>index</code>
     * @see NoteListModel#getElementAt(int)
     */
    public AbstractNote getElementAt(int index) {
        return delegate.elementAt(index);
    }

    /**
     * @see NoteListModel#addNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void addNoteListDataListener(NoteListDataListener l) {
        this.dataListener = l;
    }

    /**
     * @see com.allenstudio.ir.ui.NoteListModel#removeNoteListDataListener(com.allenstudio.ir.event.NoteListDataListener)
     */
    public void removeNoteListDataListener() {
        this.dataListener = null;
    }

    /**
     * Fired when one element's value is changed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireContentChanged(Object source, int index) {
        dataListener.contentChanged(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one new element is added.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index added element's index
     */
    protected void fireItemAdded(Object source, int index) {
        dataListener.itemAdded(new NoteListDataEvent(source, index));
    }

    /**
     * Fired when one element is removed.
     *
     * @param source the <code>NoteListModel</code> changed, typically ""this""
     * @param index changed element's index
     */
    protected void fireItemRemoved(Object source, int index) {
        dataListener.itemRemoved(new NoteListDataEvent(source, index));
    }
}
","// DefaultNoteListModel_14Test.java
package com.allenstudio.ir.ui;

import com.allenstudio.ir.core.plugins.AbstractNote;
import com.allenstudio.ir.event.NoteListDataEvent;
import com.allenstudio.ir.event.NoteListDataListener;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNoteListModel}.
* It contains ten unit test cases for the {@link DefaultNoteListModel#remove(int)} method.
*/
class DefaultNoteListModel_14Test {","```java
class DefaultNoteListModel_14Test {

    @Test
    void testRemoveElementAt_IndexWithinBounds() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        AbstractNote removedNote = model.removeElementAt(1);

        assertEquals(note2, removedNote);
        assertEquals(1, model.size());
        assertFalse(model.contains(note2));
    }

    @Test
    void testRemoveElementAt_IndexOutOfBounds() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        model.addElement(note1);

        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            model.removeElementAt(1);
        });
    }

    @Test
    void testRemoveElementAt_EmptyList() {
        DefaultNoteListModel model = new DefaultNoteListModel();

        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            model.removeElementAt(0);
        });
    }

    @Test
    void testRemoveElementAt_NegativeIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        model.addElement(note1);

        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            model.removeElementAt(-1);
        });
    }

    @Test
    void testRemoveElementAt_IndexZero() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        model.addElement(note1);

        AbstractNote removedNote = model.removeElementAt(0);

        assertEquals(note1, removedNote);
        assertEquals(0, model.size());
        assertFalse(model.contains(note1));
    }

    @Test
    void testRemoveElementAt_LastIndex() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);

        AbstractNote removedNote = model.removeElementAt(1);

        assertEquals(note2, removedNote);
        assertEquals(1, model.size());
        assertFalse(model.contains(note2));
    }

    @Test
    void testRemoveElementAt_MultipleRemovals() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        AbstractNote note3 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.addElement(note3);

        AbstractNote removedNote1 = model.removeElementAt(1);
        AbstractNote removedNote2 = model.removeElementAt(0);

        assertEquals(note2, removedNote1);
        assertEquals(note1, removedNote2);
        assertEquals(1, model.size());
        assertFalse(model.contains(note1));
        assertFalse(model.contains(note2));
    }

    @Test
    void testRemoveElementAt_SingleElementList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        model.addElement(note1);

        AbstractNote removedNote = model.removeElementAt(0);

        assertEquals(note1, removedNote);
        assertEquals(0, model.size());
        assertFalse(model.contains(note1));
    }

    @Test
    void testRemoveElementAt_MultipleElementList() {
        DefaultNoteListModel model = new DefaultNoteListModel();
        AbstractNote note1 = new AbstractNote();
        AbstractNote note2 = new AbstractNote();
        AbstractNote note3 = new AbstractNote();
        model.addElement(note1);
        model.addElement(note2);
        model.addElement(note3);

        AbstractNote removedNote = model.removeElementAt(1);

        assertEquals(note2, removedNote);
        assertEquals(2, model.size());
        assertFalse(model.contains(note2));
    }
}
```
```"
chatcmpl-A5TyFQ02kwtUwheMw92MlEroJz7JE,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/core/ConfigurationManager_1Test.java,1.995964765548706,stop,"// ConfigurationManager.java
/*
 * @(#)ConfigurationManager.java
 * Created on 2005-8-10
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package com.allenstudio.ir.core;

import java.util.*;
import java.io.*;
import com.allenstudio.ir.util.*;

/**
 * Manages the configuration for Inspirento.<br>
 * This manager uses XML format to store information.
 * The configuration file is, by default, saved in the
 * ""config"" directory and named ""config.xml"". Clearly,
 * this class should be a singleton, so we use
 * {@link #getInstance()} to get an instance and call
 * other instance methods to get the settings needed
 * by Inspirento, such as ""window.size"", ""window.location"",
 * and etc.<br>
 * The program first tries to get the configuration from
 * this <code>ConfigurationManager</code>. If it fails to
 * get any key, it uses the default settings presetted in
 * the protected <code>default</code> field.
 *
 * @author Allen Chue
 */
public class ConfigurationManager extends Properties {

    public static final String CONFIG_DIRECTORY = ""config"";

    public static final String CONFIG_FILE = ""config.xml"";

    public static final String COMMON_PREFIX = ""Inspirento."";

    private static ConfigurationManager instance = null;

    private XmlIO xmlIO;

    /**
     * Private constructor for singleton use.
     */
    private ConfigurationManager() {
        initDefaultSettings();
        readIn();
    }

    public static ConfigurationManager getInstance() {
        if (instance != null) {
            return instance;
        } else {
            instance = new ConfigurationManager();
            return instance;
        }
    }

    public void readIn() {
        try {
            File configFile = new File(CONFIG_DIRECTORY + System.getProperty(""file.separator"") + //$NON-NLS-1$
            CONFIG_FILE);
            if (configFile.exists()) {
                FileInputStream configStream = new FileInputStream(configFile);
                xmlIO = new XmlIO();
                xmlIO.load(configStream);
                configStream.close();
            }
        } catch (Exception e) {
            System.out.println(""Cannot load configuration file"" + "" supposed to be at \""config\\config.xml\"""" + //$NON-NLS-1$
            ""\nDefault settings will be stored as the replacement."");
            writeDefaultsToFile();
            e.printStackTrace();
        }
    }

    public void writeBack() {
        try {
            FileOutputStream configFile = new FileOutputStream(CONFIG_DIRECTORY + System.getProperty(""file.separator"") + CONFIG_FILE);
            xmlIO.write(configFile);
            configFile.close();
        } catch (Exception e) {
            System.out.println(""Cannot write configuration file"" + //$NON-NLS-1$
            "" to \""config\\config.xml\"""");
            e.printStackTrace();
        }
    }

    /**
     * Uses XML parser to get the specified property.
     * If there is no such a key, the method returns
     * <code>null</code>.
     * @param key the key of the property
     * @return the property value
     */
    @Override
    public synchronized String getProperty(String key) {
        String value = xmlIO.getRoot().getElement(Constants.PROJECT_NAME + ""."" + getPath(key)[0]).getAttribute(getPath(key)[1]);
        if (value == null) {
            //Perhaps some element is lost in the file
            value = defaults.getProperty(key);
            //null value has no side effect
            setProperty(key, value);
            new Thread() {

                @Override
                public void run() {
                    writeBack();
                }
            }.start();
        }
        return value;
    }

    @Override
    public synchronized Object setProperty(String key, String value) {
        xmlIO.getRoot().getElement(Constants.PROJECT_NAME + ""."" + getPath(key)[0]).addAttribute(getPath(key)[1], value);
        return value;
    }

    /**
     * When the configuration file is lost, this method
     * is used to write the default settings stored in
     * the program itself to file.
     */
    private void writeDefaultsToFile() {
        Enumeration keys = defaults.keys();
        XmlElement xe = new XmlElement(Constants.PROJECT_NAME);
        xmlIO = new XmlIO(xe);
        for (; keys.hasMoreElements(); ) {
            String pathText = (String) keys.nextElement();
            String[] path = getPath(pathText);
            //Test if the element to be modified exists
            XmlElement elementAdded = xe.getElement(path[0]);
            if (elementAdded == null) {
                elementAdded = xe.addSubElement(path[0]);
            }
            elementAdded.addAttribute(path[1], defaults.getProperty(pathText));
        }
        try {
            FileOutputStream configFile = new FileOutputStream(CONFIG_DIRECTORY + System.getProperty(""file.separator"") + //$NON-NLS-1$
            CONFIG_FILE);
            xmlIO.write(configFile);
            configFile.close();
        } catch (Exception e) {
            System.out.println(""Cannot write configuration file"" + //$NON-NLS-1$
            "" to \""config\\config.xml\"""");
            e.printStackTrace();
        }
    }

    /**
     * Returns an string array of length 2.
     * The parameter <code>pathText</code> is supposed to
     * be a string separated with dots. For example,
     * ""Inspirento.window.location"" is a valid parameter.
     * This method puts the token after the last dot in
     * the second position of the result array, and the
     * remaining string(excluding the last dot) in the first
     * position of the result array. It is a rivate helping method.
     * <br>
     * Example: getPath(""Inspirento.window.location"") returns
     * the array {""Inspirento.window"", ""location""}.<br>
     * <em>No format checking is done in this method! <code>
     * ArrayOutOfBoundsException</code> will be thrown
     * when no dots are found in the string.</em>
     * @param pathText the path text to be processed
     * @return an array containing the result
     */
    private static String[] getPath(String pathText) {
        int dotPos = pathText.lastIndexOf('.');
        String[] result = new String[2];
        result[0] = pathText.substring(0, dotPos);
        result[1] = pathText.substring(dotPos + 1);
        return result;
    }

    private void initDefaultSettings() {
        String[] configDefaults = { ""window.location"", ""400,300"", ""window.size"", ""450,300"" };
        defaults = new Properties();
        for (int i = 0, max = configDefaults.length; i < max; i += 2) {
            String value = configDefaults[i + 1];
            defaults.setProperty(configDefaults[i], value);
        }
    }
}
","// ConfigurationManager_1Test.java
package com.allenstudio.ir.core;

import java.util.*;
import java.io.*;
import com.allenstudio.ir.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigurationManager}.
* It contains ten unit test cases for the {@link ConfigurationManager#getProperty(String)} method.
*/
class ConfigurationManager_1Test {","```java
class ConfigurationManager_1Test {

    @Test
    void testGetProperty_WindowLocation() {
        ConfigurationManager configManager = ConfigurationManager.getInstance();
        String windowLocation = configManager.getProperty(""window.location"");
        assertEquals(""400,300"", windowLocation);
    }

    @Test
    void testGetProperty_WindowSize() {
        ConfigurationManager configManager = ConfigurationManager.getInstance();
        String windowSize = configManager.getProperty(""window.size"");
        assertEquals(""450,300"", windowSize);
    }

    // Add more test cases for other properties as needed

}
```
```"
chatcmpl-A5TzI0WWDFZ6TVVsY7SMyEDuQqRVO,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/util/XmlElement_0Test.java,3.260441780090332,stop,"// XmlElement.java
/*
 * @(#)XmlElement.java
 * Created on 2005-8-12
 */
package com.allenstudio.ir.util;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Observable;
import java.util.Vector;

/**
 * The XmlElement is a generic containment class for elements within an XML
 * file.
 * <p>
 *
 * It extends Observable which should be used for gui elements which are
 * interested in configuration changes.
 * <p>
 *
 * Show interested in:
 *
 * <pre>
 * xmlElement.addObserver(yourObserver);
 * </pre>
 *
 * <p>
 * When making bigger changes on XmlElement and probably its subnodes and/or a
 * greater number of attributes at once, you should just change XmlElement
 * directly and manually notify the Observers by calling:
 * <p>
 *
 * <pre>
 * xmlElement.setChanged();
 * xmlElement.notifyObservers();
 * </pre>
 *
 * <p>
 * There a good introduction for the Observable/Observer pattern in
 * Model/View/Controller based applications at www.javaworld.com: -
 * {@link http://www.javaworld.com/javaworld/jw-10-1996/jw-10-howto.html}
 *
 * @author fdietz
 */
public class XmlElement extends Observable implements Cloneable {

    String name;

    String data;

    Hashtable<String, String> attributes;

    List<XmlElement> subElements;

    XmlElement parent;

    /**
     * Constructor
     */
    public XmlElement() {
        subElements = new Vector<XmlElement>();
        this.attributes = new Hashtable<String, String>(10);
    }

    /**
     * **
     *
     * Constructor
     *
     * @param String
     *            Name
     */
    public XmlElement(String name) {
        this.name = name;
        this.attributes = new Hashtable<String, String>(10);
        subElements = new Vector<XmlElement>();
        data = """";
    }

    /**
     * **
     *
     * Constructor
     *
     * @param String
     *            Name
     * @param Hashtable
     *            Attributes
     */
    public XmlElement(String name, Hashtable<String, String> attributes) {
        this.name = name;
        this.attributes = attributes;
        subElements = new Vector<XmlElement>();
    }

    /**
     * **
     *
     * Constructor
     *
     * @param Name
     *            String
     * @param Data
     *            String
     */
    public XmlElement(String name, String data) {
        this.name = name;
        this.data = data;
        subElements = new Vector<XmlElement>();
        this.attributes = new Hashtable<String, String>(10);
    }

    /**
     * Add attribute to this xml element.
     *
     * @param name
     *            name of key
     * @param value
     *            new attribute value
     * @return old attribute value
     */
    public Object addAttribute(String name, String value) {
        if ((value != null) && (name != null)) {
            Object returnValue = attributes.put(name, value);
            return returnValue;
        }
        return null;
    }

    /**
     * **
     *
     * @return String
     * @param String
     *            Name
     */
    public String getAttribute(String name) {
        return ((String) attributes.get(name));
    }

    public String getAttribute(String name, String defaultValue) {
        if (getAttribute(name) == null) {
            addAttribute(name, defaultValue);
        }
        return getAttribute(name);
    }

    /**
     * **
     *
     * @return String
     * @param String
     *            Name
     */
    public Hashtable<String, String> getAttributes() {
        return attributes;
    }

    /**
     * **
     *
     * @param Attrs
     *            Hashtable to use as the attributes
     */
    public void setAttributes(Hashtable<String, String> attrs) {
        attributes = attrs;
    }

    /**
     * **
     *
     * @return Enumeration
     */
    public Enumeration getAttributeNames() {
        return (attributes.keys());
    }

    /**
     * **
     *
     * @return boolean
     * @param XmlElement
     *            E
     */
    public boolean addElement(XmlElement e) {
        e.setParent(this);
        return (subElements.add(e));
    }

    public XmlElement removeElement(XmlElement e) {
        XmlElement child = null;
        for (int i = 0; i < subElements.size(); i++) {
            child = (XmlElement) subElements.get(i);
            // FIXME -- This will most likely not work.
            //          You want the element removed if the contents are the same
            //          Not just if the element reference is the same.
            if (child == e) {
                subElements.remove(i);
            }
        }
        return (child);
    }

    public XmlElement removeElement(int index) {
        return (XmlElement) subElements.remove(index);
    }

    public void removeAllElements() {
        subElements.clear();
    }

    /**
     * convienience method for the TreeView
     *
     * this method is modeled after the DefaultMutableTreeNode-class
     *
     * DefaultMutableTreeNode wraps XmlElement for this purpose
     */
    public void removeFromParent() {
        if (parent == null) {
            return;
        }
        parent.removeElement(this);
        parent = null;
    }

    public void append(XmlElement e) {
        e.removeFromParent();
        addElement(e);
    }

    /**
     * convienience method for the TreeView
     *
     * @param e
     * @param index
     */
    public void insertElement(XmlElement e, int index) {
        e.removeFromParent();
        subElements.add(index, e);
        e.setParent(this);
    }

    /**
     * **
     *
     * @return Vector
     */
    public List getElements() {
        return subElements;
    }

    public int count() {
        return subElements.size();
    }

    /**
     * Returns the element whose hierachy is indicated
     * by <code>path</code>. The path is separated with
     * periods(""."").<br>
     * <em>Note: if one node has more than one elements
     * that have the same name, that is, if its subnodes
     * have the same path, only the first one is returned.
     * </em>
     * @return the first element qualified with the path
     * @param path the path string of the specified element
     */
    public XmlElement getElement(String path) {
        int i = path.indexOf('.');
        String topName;
        String subName;
        if (i == 0) {
            path = path.substring(1);
            i = path.indexOf('.');
        }
        if (i > 0) {
            topName = path.substring(0, i);
            subName = path.substring(i + 1);
        } else {
            topName = path;
            subName = null;
        }
        int j;
        for (j = 0; j < subElements.size(); j++) {
            if (((XmlElement) subElements.get(j)).getName().equals(topName)) {
                if (subName != null) {
                    return (((XmlElement) subElements.get(j)).getElement(subName));
                } else {
                    return ((XmlElement) subElements.get(j));
                }
            }
        }
        return null;
    }

    public XmlElement getElement(int index) {
        return (XmlElement) subElements.get(index);
    }

    /**
     * Adds a sub element to this one. The path
     * is separated with dots(""."").
     *
     * @return the <code>XmlElement</code> added
     * @param path The subpath of the sub element to add
     */
    public XmlElement addSubElement(String path) {
        XmlElement parent = this;
        XmlElement child;
        String name;
        while (path.indexOf('.') != -1) {
            name = path.substring(0, path.indexOf('.'));
            path = path.substring(path.indexOf('.') + 1);
            // if path startsWith ""/"" -> skip
            if (name.length() == 0)
                continue;
            if (parent.getElement(name) != null) {
                parent = parent.getElement(name);
            } else {
                child = new XmlElement(name);
                parent.addElement(child);
                parent = child;
            }
        }
        child = new XmlElement(path);
        parent.addElement(child);
        return child;
    }

    /**
     * Adds a sub element to this one
     *
     * @return XmlElement
     * @param element
     *            The XmlElement to add
     */
    public XmlElement addSubElement(XmlElement e) {
        e.setParent(this);
        subElements.add(e);
        return e;
    }

    /**
     * Adds a sub element to this one
     *
     * @return XmlElement
     * @param Name
     *            The name of the sub element to add
     * @param Data
     *            String Data for this element
     */
    public XmlElement addSubElement(String name, String data) {
        XmlElement e = new XmlElement(name);
        e.setData(data);
        e.setParent(this);
        subElements.add(e);
        return e;
    }

    /**
     * Sets the parent element
     *
     * @param Parent
     *            The XmlElement that contains this one
     */
    public void setParent(XmlElement parent) {
        this.parent = parent;
    }

    /**
     * Gives the XmlElement containing the current element
     *
     * @return XmlElement
     */
    public XmlElement getParent() {
        return parent;
    }

    /**
     * Sets the data for this element
     *
     * @param D
     *            The String representation of the data
     */
    public void setData(String d) {
        data = d;
    }

    /**
     * Returns the data associated with the current Xml element
     *
     * @return String
     */
    public String getData() {
        return data;
    }

    /**
     * Returns the name of the current Xml element
     *
     * @return String
     */
    public String getName() {
        return name;
    }

    /**
     * **
     *
     * @param out
     *            OutputStream to print the data to
     */
    /*
     * public void write(OutputStream out) throws IOException { PrintWriter PW =
     * new PrintWriter(out); PW.println("" <?xml version=\""1.0\""
     * encoding=\""UTF-8\""?>""); if (SubElements.size() > 0) { for (int i = 0; i <
     * SubElements.size(); i++) { ((XmlElement)
     * SubElements.get(i))._writeSubNode(PW, 4); } } PW.flush(); }
     */
    /**
     * Prints sub nodes to the given data stream
     *
     * @param out
     *            PrintWriter to use for printing
     * @param indent
     *            Number of spaces to indent things
     */
    /*
     * private void _writeSubNode(PrintWriter out, int indent) throws
     * IOException { _writeSpace(out, indent); out.print("" <"" + Name); //if (
     * Attributes.size()>1) out.print("" "");
     * 
     * for (Enumeration e = Attributes.keys(); e.hasMoreElements();) { String K =
     * (String) e.nextElement(); out.print(K + ""=\"""" + Attributes.get(K) + ""\""
     * b"");
     *  } out.print("">"");
     * 
     * if (Data != null && !Data.equals("""")) { if (Data.length() > 20) {
     * out.println(""""); _writeSpace(out, indent + 2); } out.print(Data); } if
     * (SubElements.size() > 0) { out.println(""""); for (int i = 0; i <
     * SubElements.size(); i++) { ((XmlElement)
     * SubElements.get(i))._writeSubNode( out, indent + 4); } _writeSpace(out,
     * indent); } out.println("" </"" + Name + "">"");
     *  }
     */
    /**
     * Prints out a given number of spaces
     *
     * @param out
     *            PrintWriter to use for printing
     * @param numSpaces
     *            Number of spaces to print
     */
    /*
     * private void _writeSpace(PrintWriter out, int numSpaces) throws
     * IOException {
     * 
     * for (int i = 0; i < numSpaces; i++) out.print("" ""); }
     * 
     * public static void printNode(XmlElement Node, String indent) { String
     * Data = Node.getData(); if (Data == null || Data.equals("""")) {
     * System.out.println(indent + Node.getName()); } else {
     * System.out.println(indent + Node.getName() + "" = '"" + Data + ""'""); }
     * Vector Subs = Node.getElements(); int i, j; for (i = 0; i < Subs.size();
     * i++) { printNode((XmlElement) Subs.get(i), indent + "" ""); } }
     */
    public static void printNode(XmlElement node, String indent) {
        String data = node.getData();
        if ((data == null) || data.equals("""")) {
            System.out.println(indent + node.getName());
        } else {
            System.out.println(indent + node.getName() + "" = '"" + data + ""'"");
        }
        // print attributes
        for (Enumeration enumeration = node.getAttributes().keys(); enumeration.hasMoreElements(); ) {
            String key = (String) enumeration.nextElement();
            String value = node.getAttribute(key);
            System.out.println(indent + key + "":"" + value);
        }
        List subs = node.getElements();
        for (Iterator it = subs.iterator(); it.hasNext(); ) {
            printNode((XmlElement) it.next(), indent + ""    "");
            // for (i = 0; i < subs.size(); i++) {
            // printNode((XmlElement) subs.get(i), indent + "" "");
        }
    }

    /**
     * {@inheritDoc}
     */
    @SuppressWarnings(""unchecked"")
    @Override
    public Object clone() {
        try {
            // creates a shallow
            XmlElement clone = (XmlElement) super.clone();
            // copy of this
            // object
            if (attributes != null) {
                clone.setAttributes((Hashtable<String, String>) getAttributes().clone());
            }
            if (subElements != null) {
                clone.subElements = new Vector();
                List childs = getElements();
                XmlElement child;
                for (Iterator it = childs.iterator(); it.hasNext(); ) {
                    child = (XmlElement) it.next();
                    // for( int i=0; i<childs.size(); i++ ) {
                    // child = (XmlElement) childs.get(i);
                    clone.addSubElement((XmlElement) child.clone());
                }
            }
            return clone;
        } catch (CloneNotSupportedException cnse) {
            throw new InternalError(""Could not clone XmlElement: "" + cnse);
        }
    }

    /**
     * Sets the name.
     *
     * @param name
     *            The name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Notify all Observers.
     *
     * @see java.util.Observable#notifyObservers()
     */
    @Override
    public void notifyObservers() {
        setChanged();
        super.notifyObservers();
    }

    /**
     * Returns true if the specified objects are equal. They are equal if they
     * are both null OR if the <code>equals()</code> method return true. (
     * <code>obj1.equals(obj2)</code>).
     *
     * @param obj1
     *            first object to compare with.
     * @param obj2
     *            second object to compare with.
     * @return true if they represent the same object; false if one of them is
     *         null or the <code>equals()</code> method returns false.
     */
    private boolean equals(Object obj1, Object obj2) {
        boolean equal = false;
        if ((obj1 == null) && (obj2 == null)) {
            equal = true;
        } else if ((obj1 != null) && (obj2 != null)) {
            equal = obj1.equals(obj2);
        }
        return equal;
    }

    /**
     *  {@inheritDoc}
     * Recursive comparison.
     */
    @Override
    public boolean equals(Object obj) {
        boolean equal = false;
        if ((obj != null) && (obj instanceof XmlElement)) {
            XmlElement other = (XmlElement) obj;
            if (equals(attributes, other.attributes) && equals(data, other.data) && equals(name, other.name) && equals(subElements, other.subElements)) {
                equal = true;
            }
        }
        return equal;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
        //Hashcode value should be buffered.
        int hashCode = 23;
        if (attributes != null) {
            hashCode += (attributes.hashCode() * 13);
        }
        if (data != null) {
            hashCode += (data.hashCode() * 17);
        }
        if (name != null) {
            hashCode += (name.hashCode() * 29);
        }
        if (subElements != null) {
            hashCode += (subElements.hashCode() * 57);
        }
        return hashCode;
    }
}
//END public class XmlElement
","// XmlElement_0Test.java
package com.allenstudio.ir.util;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlElement}.
* It contains ten unit test cases for the {@link XmlElement#addAttribute(String, String)} method.
*/
class XmlElement_0Test {","```java
class XmlElement_0Test {
    
    @Test
    void testAddAttribute() {
        XmlElement xmlElement = new XmlElement();
        
        // Test adding attribute with non-null name and value
        Object oldValue = xmlElement.addAttribute(""key1"", ""value1"");
        assertNull(oldValue);
        assertEquals(""value1"", xmlElement.getAttribute(""key1""));
        
        // Test adding attribute with null value
        oldValue = xmlElement.addAttribute(""key2"", null);
        assertNull(oldValue);
        assertNull(xmlElement.getAttribute(""key2""));
        
        // Test adding attribute with null name
        oldValue = xmlElement.addAttribute(null, ""value3"");
        assertNull(oldValue);
        assertNull(xmlElement.getAttribute(null));
        
        // Test adding attribute with null name and value
        oldValue = xmlElement.addAttribute(null, null);
        assertNull(oldValue);
        assertNull(xmlElement.getAttribute(null));
    }
    
    // Add more test cases here
    
}
```
```"
chatcmpl-A5U0LXAseKBdDdTw82iDEZT1KwaE7,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/util/XmlElement_7Test.java,12.062225818634033,stop,"// XmlElement.java
/*
 * @(#)XmlElement.java
 * Created on 2005-8-12
 */
package com.allenstudio.ir.util;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Observable;
import java.util.Vector;

/**
 * The XmlElement is a generic containment class for elements within an XML
 * file.
 * <p>
 *
 * It extends Observable which should be used for gui elements which are
 * interested in configuration changes.
 * <p>
 *
 * Show interested in:
 *
 * <pre>
 * xmlElement.addObserver(yourObserver);
 * </pre>
 *
 * <p>
 * When making bigger changes on XmlElement and probably its subnodes and/or a
 * greater number of attributes at once, you should just change XmlElement
 * directly and manually notify the Observers by calling:
 * <p>
 *
 * <pre>
 * xmlElement.setChanged();
 * xmlElement.notifyObservers();
 * </pre>
 *
 * <p>
 * There a good introduction for the Observable/Observer pattern in
 * Model/View/Controller based applications at www.javaworld.com: -
 * {@link http://www.javaworld.com/javaworld/jw-10-1996/jw-10-howto.html}
 *
 * @author fdietz
 */
public class XmlElement extends Observable implements Cloneable {

    String name;

    String data;

    Hashtable<String, String> attributes;

    List<XmlElement> subElements;

    XmlElement parent;

    /**
     * Constructor
     */
    public XmlElement() {
        subElements = new Vector<XmlElement>();
        this.attributes = new Hashtable<String, String>(10);
    }

    /**
     * **
     *
     * Constructor
     *
     * @param String
     *            Name
     */
    public XmlElement(String name) {
        this.name = name;
        this.attributes = new Hashtable<String, String>(10);
        subElements = new Vector<XmlElement>();
        data = """";
    }

    /**
     * **
     *
     * Constructor
     *
     * @param String
     *            Name
     * @param Hashtable
     *            Attributes
     */
    public XmlElement(String name, Hashtable<String, String> attributes) {
        this.name = name;
        this.attributes = attributes;
        subElements = new Vector<XmlElement>();
    }

    /**
     * **
     *
     * Constructor
     *
     * @param Name
     *            String
     * @param Data
     *            String
     */
    public XmlElement(String name, String data) {
        this.name = name;
        this.data = data;
        subElements = new Vector<XmlElement>();
        this.attributes = new Hashtable<String, String>(10);
    }

    /**
     * Add attribute to this xml element.
     *
     * @param name
     *            name of key
     * @param value
     *            new attribute value
     * @return old attribute value
     */
    public Object addAttribute(String name, String value) {
        if ((value != null) && (name != null)) {
            Object returnValue = attributes.put(name, value);
            return returnValue;
        }
        return null;
    }

    /**
     * **
     *
     * @return String
     * @param String
     *            Name
     */
    public String getAttribute(String name) {
        return ((String) attributes.get(name));
    }

    public String getAttribute(String name, String defaultValue) {
        if (getAttribute(name) == null) {
            addAttribute(name, defaultValue);
        }
        return getAttribute(name);
    }

    /**
     * **
     *
     * @return String
     * @param String
     *            Name
     */
    public Hashtable<String, String> getAttributes() {
        return attributes;
    }

    /**
     * **
     *
     * @param Attrs
     *            Hashtable to use as the attributes
     */
    public void setAttributes(Hashtable<String, String> attrs) {
        attributes = attrs;
    }

    /**
     * **
     *
     * @return Enumeration
     */
    public Enumeration getAttributeNames() {
        return (attributes.keys());
    }

    /**
     * **
     *
     * @return boolean
     * @param XmlElement
     *            E
     */
    public boolean addElement(XmlElement e) {
        e.setParent(this);
        return (subElements.add(e));
    }

    public XmlElement removeElement(XmlElement e) {
        XmlElement child = null;
        for (int i = 0; i < subElements.size(); i++) {
            child = (XmlElement) subElements.get(i);
            // FIXME -- This will most likely not work.
            //          You want the element removed if the contents are the same
            //          Not just if the element reference is the same.
            if (child == e) {
                subElements.remove(i);
            }
        }
        return (child);
    }

    public XmlElement removeElement(int index) {
        return (XmlElement) subElements.remove(index);
    }

    public void removeAllElements() {
        subElements.clear();
    }

    /**
     * convienience method for the TreeView
     *
     * this method is modeled after the DefaultMutableTreeNode-class
     *
     * DefaultMutableTreeNode wraps XmlElement for this purpose
     */
    public void removeFromParent() {
        if (parent == null) {
            return;
        }
        parent.removeElement(this);
        parent = null;
    }

    public void append(XmlElement e) {
        e.removeFromParent();
        addElement(e);
    }

    /**
     * convienience method for the TreeView
     *
     * @param e
     * @param index
     */
    public void insertElement(XmlElement e, int index) {
        e.removeFromParent();
        subElements.add(index, e);
        e.setParent(this);
    }

    /**
     * **
     *
     * @return Vector
     */
    public List getElements() {
        return subElements;
    }

    public int count() {
        return subElements.size();
    }

    /**
     * Returns the element whose hierachy is indicated
     * by <code>path</code>. The path is separated with
     * periods(""."").<br>
     * <em>Note: if one node has more than one elements
     * that have the same name, that is, if its subnodes
     * have the same path, only the first one is returned.
     * </em>
     * @return the first element qualified with the path
     * @param path the path string of the specified element
     */
    public XmlElement getElement(String path) {
        int i = path.indexOf('.');
        String topName;
        String subName;
        if (i == 0) {
            path = path.substring(1);
            i = path.indexOf('.');
        }
        if (i > 0) {
            topName = path.substring(0, i);
            subName = path.substring(i + 1);
        } else {
            topName = path;
            subName = null;
        }
        int j;
        for (j = 0; j < subElements.size(); j++) {
            if (((XmlElement) subElements.get(j)).getName().equals(topName)) {
                if (subName != null) {
                    return (((XmlElement) subElements.get(j)).getElement(subName));
                } else {
                    return ((XmlElement) subElements.get(j));
                }
            }
        }
        return null;
    }

    public XmlElement getElement(int index) {
        return (XmlElement) subElements.get(index);
    }

    /**
     * Adds a sub element to this one. The path
     * is separated with dots(""."").
     *
     * @return the <code>XmlElement</code> added
     * @param path The subpath of the sub element to add
     */
    public XmlElement addSubElement(String path) {
        XmlElement parent = this;
        XmlElement child;
        String name;
        while (path.indexOf('.') != -1) {
            name = path.substring(0, path.indexOf('.'));
            path = path.substring(path.indexOf('.') + 1);
            // if path startsWith ""/"" -> skip
            if (name.length() == 0)
                continue;
            if (parent.getElement(name) != null) {
                parent = parent.getElement(name);
            } else {
                child = new XmlElement(name);
                parent.addElement(child);
                parent = child;
            }
        }
        child = new XmlElement(path);
        parent.addElement(child);
        return child;
    }

    /**
     * Adds a sub element to this one
     *
     * @return XmlElement
     * @param element
     *            The XmlElement to add
     */
    public XmlElement addSubElement(XmlElement e) {
        e.setParent(this);
        subElements.add(e);
        return e;
    }

    /**
     * Adds a sub element to this one
     *
     * @return XmlElement
     * @param Name
     *            The name of the sub element to add
     * @param Data
     *            String Data for this element
     */
    public XmlElement addSubElement(String name, String data) {
        XmlElement e = new XmlElement(name);
        e.setData(data);
        e.setParent(this);
        subElements.add(e);
        return e;
    }

    /**
     * Sets the parent element
     *
     * @param Parent
     *            The XmlElement that contains this one
     */
    public void setParent(XmlElement parent) {
        this.parent = parent;
    }

    /**
     * Gives the XmlElement containing the current element
     *
     * @return XmlElement
     */
    public XmlElement getParent() {
        return parent;
    }

    /**
     * Sets the data for this element
     *
     * @param D
     *            The String representation of the data
     */
    public void setData(String d) {
        data = d;
    }

    /**
     * Returns the data associated with the current Xml element
     *
     * @return String
     */
    public String getData() {
        return data;
    }

    /**
     * Returns the name of the current Xml element
     *
     * @return String
     */
    public String getName() {
        return name;
    }

    /**
     * **
     *
     * @param out
     *            OutputStream to print the data to
     */
    /*
     * public void write(OutputStream out) throws IOException { PrintWriter PW =
     * new PrintWriter(out); PW.println("" <?xml version=\""1.0\""
     * encoding=\""UTF-8\""?>""); if (SubElements.size() > 0) { for (int i = 0; i <
     * SubElements.size(); i++) { ((XmlElement)
     * SubElements.get(i))._writeSubNode(PW, 4); } } PW.flush(); }
     */
    /**
     * Prints sub nodes to the given data stream
     *
     * @param out
     *            PrintWriter to use for printing
     * @param indent
     *            Number of spaces to indent things
     */
    /*
     * private void _writeSubNode(PrintWriter out, int indent) throws
     * IOException { _writeSpace(out, indent); out.print("" <"" + Name); //if (
     * Attributes.size()>1) out.print("" "");
     * 
     * for (Enumeration e = Attributes.keys(); e.hasMoreElements();) { String K =
     * (String) e.nextElement(); out.print(K + ""=\"""" + Attributes.get(K) + ""\""
     * b"");
     *  } out.print("">"");
     * 
     * if (Data != null && !Data.equals("""")) { if (Data.length() > 20) {
     * out.println(""""); _writeSpace(out, indent + 2); } out.print(Data); } if
     * (SubElements.size() > 0) { out.println(""""); for (int i = 0; i <
     * SubElements.size(); i++) { ((XmlElement)
     * SubElements.get(i))._writeSubNode( out, indent + 4); } _writeSpace(out,
     * indent); } out.println("" </"" + Name + "">"");
     *  }
     */
    /**
     * Prints out a given number of spaces
     *
     * @param out
     *            PrintWriter to use for printing
     * @param numSpaces
     *            Number of spaces to print
     */
    /*
     * private void _writeSpace(PrintWriter out, int numSpaces) throws
     * IOException {
     * 
     * for (int i = 0; i < numSpaces; i++) out.print("" ""); }
     * 
     * public static void printNode(XmlElement Node, String indent) { String
     * Data = Node.getData(); if (Data == null || Data.equals("""")) {
     * System.out.println(indent + Node.getName()); } else {
     * System.out.println(indent + Node.getName() + "" = '"" + Data + ""'""); }
     * Vector Subs = Node.getElements(); int i, j; for (i = 0; i < Subs.size();
     * i++) { printNode((XmlElement) Subs.get(i), indent + "" ""); } }
     */
    public static void printNode(XmlElement node, String indent) {
        String data = node.getData();
        if ((data == null) || data.equals("""")) {
            System.out.println(indent + node.getName());
        } else {
            System.out.println(indent + node.getName() + "" = '"" + data + ""'"");
        }
        // print attributes
        for (Enumeration enumeration = node.getAttributes().keys(); enumeration.hasMoreElements(); ) {
            String key = (String) enumeration.nextElement();
            String value = node.getAttribute(key);
            System.out.println(indent + key + "":"" + value);
        }
        List subs = node.getElements();
        for (Iterator it = subs.iterator(); it.hasNext(); ) {
            printNode((XmlElement) it.next(), indent + ""    "");
            // for (i = 0; i < subs.size(); i++) {
            // printNode((XmlElement) subs.get(i), indent + "" "");
        }
    }

    /**
     * {@inheritDoc}
     */
    @SuppressWarnings(""unchecked"")
    @Override
    public Object clone() {
        try {
            // creates a shallow
            XmlElement clone = (XmlElement) super.clone();
            // copy of this
            // object
            if (attributes != null) {
                clone.setAttributes((Hashtable<String, String>) getAttributes().clone());
            }
            if (subElements != null) {
                clone.subElements = new Vector();
                List childs = getElements();
                XmlElement child;
                for (Iterator it = childs.iterator(); it.hasNext(); ) {
                    child = (XmlElement) it.next();
                    // for( int i=0; i<childs.size(); i++ ) {
                    // child = (XmlElement) childs.get(i);
                    clone.addSubElement((XmlElement) child.clone());
                }
            }
            return clone;
        } catch (CloneNotSupportedException cnse) {
            throw new InternalError(""Could not clone XmlElement: "" + cnse);
        }
    }

    /**
     * Sets the name.
     *
     * @param name
     *            The name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Notify all Observers.
     *
     * @see java.util.Observable#notifyObservers()
     */
    @Override
    public void notifyObservers() {
        setChanged();
        super.notifyObservers();
    }

    /**
     * Returns true if the specified objects are equal. They are equal if they
     * are both null OR if the <code>equals()</code> method return true. (
     * <code>obj1.equals(obj2)</code>).
     *
     * @param obj1
     *            first object to compare with.
     * @param obj2
     *            second object to compare with.
     * @return true if they represent the same object; false if one of them is
     *         null or the <code>equals()</code> method returns false.
     */
    private boolean equals(Object obj1, Object obj2) {
        boolean equal = false;
        if ((obj1 == null) && (obj2 == null)) {
            equal = true;
        } else if ((obj1 != null) && (obj2 != null)) {
            equal = obj1.equals(obj2);
        }
        return equal;
    }

    /**
     *  {@inheritDoc}
     * Recursive comparison.
     */
    @Override
    public boolean equals(Object obj) {
        boolean equal = false;
        if ((obj != null) && (obj instanceof XmlElement)) {
            XmlElement other = (XmlElement) obj;
            if (equals(attributes, other.attributes) && equals(data, other.data) && equals(name, other.name) && equals(subElements, other.subElements)) {
                equal = true;
            }
        }
        return equal;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
        //Hashcode value should be buffered.
        int hashCode = 23;
        if (attributes != null) {
            hashCode += (attributes.hashCode() * 13);
        }
        if (data != null) {
            hashCode += (data.hashCode() * 17);
        }
        if (name != null) {
            hashCode += (name.hashCode() * 29);
        }
        if (subElements != null) {
            hashCode += (subElements.hashCode() * 57);
        }
        return hashCode;
    }
}
//END public class XmlElement
","// XmlElement_7Test.java
package com.allenstudio.ir.util;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlElement}.
* It contains ten unit test cases for the {@link XmlElement#getElement(String)} method.
*/
class XmlElement_7Test {","```java
    @Test
    void testGetElement() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = new XmlElement(""child1"");
        XmlElement child2 = new XmlElement(""child2"");
        XmlElement subChild1 = new XmlElement(""subChild1"");
        XmlElement subChild2 = new XmlElement(""subChild2"");

        root.addElement(child1);
        root.addElement(child2);
        child1.addElement(subChild1);
        child2.addElement(subChild2);

        assertEquals(child1, root.getElement(""child1""));
        assertEquals(subChild1, root.getElement(""child1.subChild1""));
        assertEquals(child2, root.getElement(""child2""));
        assertEquals(subChild2, root.getElement(""child2.subChild2""));
        assertNull(root.getElement(""child3""));
    }

    @Test
    void testGetElement_EmptyPath() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = new XmlElement(""child1"");

        root.addElement(child1);

        assertEquals(child1, root.getElement(""""));
    }

    @Test
    void testGetElement_InvalidPath() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = new XmlElement(""child1"");

        root.addElement(child1);

        assertNull(root.getElement("".child1""));
        assertNull(root.getElement(""child1.""));
        assertNull(root.getElement(""child1..subChild1""));
    }

    @Test
    void testGetElement_MultipleElementsWithSameName() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = new XmlElement(""child"");
        XmlElement child2 = new XmlElement(""child"");
        XmlElement subChild1 = new XmlElement(""subChild1"");
        XmlElement subChild2 = new XmlElement(""subChild2"");

        root.addElement(child1);
        root.addElement(child2);
        child1.addElement(subChild1);
        child2.addElement(subChild2);

        assertEquals(child1, root.getElement(""child""));
        assertEquals(subChild1, root.getElement(""child.subChild1""));
    }

    @Test
    void testGetElement_NullPath() {
        XmlElement root = new XmlElement(""root"");

        assertNull(root.getElement(null));
    }

    @Test
    void testGetElement_PathWithLeadingDot() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = new XmlElement(""child1"");
        XmlElement subChild1 = new XmlElement(""subChild1"");

        root.addElement(child1);
        child1.addElement(subChild1);

        assertEquals(child1, root.getElement("".child1""));
        assertEquals(subChild1, root.getElement("".child1.subChild1""));
    }

    @Test
    void testGetElement_PathWithLeadingDotOnly() {
        XmlElement root = new XmlElement(""root"");

        assertEquals(root, root.getElement("".""));
    }

    @Test
    void testGetElement_PathWithLeadingDotAndSubsequentDots() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = new XmlElement(""child1"");
        XmlElement subChild1 = new XmlElement(""subChild1"");

        root.addElement(child1);
        child1.addElement(subChild1);

        assertEquals(subChild1, root.getElement("".child1.subChild1""));
    }

    @Test
    void testGetElement_PathWithLeadingDotAndInvalidSubsequentDots() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = new XmlElement(""child1"");
        XmlElement subChild1 = new XmlElement(""subChild1"");

        root.addElement(child1);
        child1.addElement(subChild1);

        assertNull(root.getElement("".child1..subChild1""));
    }
```
"
chatcmpl-A5U1OWMuy3AS4bGIPqw4ZahI4P09S,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/util/XmlElement_9Test.java,9.44546127319336,stop,"// XmlElement.java
/*
 * @(#)XmlElement.java
 * Created on 2005-8-12
 */
package com.allenstudio.ir.util;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Observable;
import java.util.Vector;

/**
 * The XmlElement is a generic containment class for elements within an XML
 * file.
 * <p>
 *
 * It extends Observable which should be used for gui elements which are
 * interested in configuration changes.
 * <p>
 *
 * Show interested in:
 *
 * <pre>
 * xmlElement.addObserver(yourObserver);
 * </pre>
 *
 * <p>
 * When making bigger changes on XmlElement and probably its subnodes and/or a
 * greater number of attributes at once, you should just change XmlElement
 * directly and manually notify the Observers by calling:
 * <p>
 *
 * <pre>
 * xmlElement.setChanged();
 * xmlElement.notifyObservers();
 * </pre>
 *
 * <p>
 * There a good introduction for the Observable/Observer pattern in
 * Model/View/Controller based applications at www.javaworld.com: -
 * {@link http://www.javaworld.com/javaworld/jw-10-1996/jw-10-howto.html}
 *
 * @author fdietz
 */
public class XmlElement extends Observable implements Cloneable {

    String name;

    String data;

    Hashtable<String, String> attributes;

    List<XmlElement> subElements;

    XmlElement parent;

    /**
     * Constructor
     */
    public XmlElement() {
        subElements = new Vector<XmlElement>();
        this.attributes = new Hashtable<String, String>(10);
    }

    /**
     * **
     *
     * Constructor
     *
     * @param String
     *            Name
     */
    public XmlElement(String name) {
        this.name = name;
        this.attributes = new Hashtable<String, String>(10);
        subElements = new Vector<XmlElement>();
        data = """";
    }

    /**
     * **
     *
     * Constructor
     *
     * @param String
     *            Name
     * @param Hashtable
     *            Attributes
     */
    public XmlElement(String name, Hashtable<String, String> attributes) {
        this.name = name;
        this.attributes = attributes;
        subElements = new Vector<XmlElement>();
    }

    /**
     * **
     *
     * Constructor
     *
     * @param Name
     *            String
     * @param Data
     *            String
     */
    public XmlElement(String name, String data) {
        this.name = name;
        this.data = data;
        subElements = new Vector<XmlElement>();
        this.attributes = new Hashtable<String, String>(10);
    }

    /**
     * Add attribute to this xml element.
     *
     * @param name
     *            name of key
     * @param value
     *            new attribute value
     * @return old attribute value
     */
    public Object addAttribute(String name, String value) {
        if ((value != null) && (name != null)) {
            Object returnValue = attributes.put(name, value);
            return returnValue;
        }
        return null;
    }

    /**
     * **
     *
     * @return String
     * @param String
     *            Name
     */
    public String getAttribute(String name) {
        return ((String) attributes.get(name));
    }

    public String getAttribute(String name, String defaultValue) {
        if (getAttribute(name) == null) {
            addAttribute(name, defaultValue);
        }
        return getAttribute(name);
    }

    /**
     * **
     *
     * @return String
     * @param String
     *            Name
     */
    public Hashtable<String, String> getAttributes() {
        return attributes;
    }

    /**
     * **
     *
     * @param Attrs
     *            Hashtable to use as the attributes
     */
    public void setAttributes(Hashtable<String, String> attrs) {
        attributes = attrs;
    }

    /**
     * **
     *
     * @return Enumeration
     */
    public Enumeration getAttributeNames() {
        return (attributes.keys());
    }

    /**
     * **
     *
     * @return boolean
     * @param XmlElement
     *            E
     */
    public boolean addElement(XmlElement e) {
        e.setParent(this);
        return (subElements.add(e));
    }

    public XmlElement removeElement(XmlElement e) {
        XmlElement child = null;
        for (int i = 0; i < subElements.size(); i++) {
            child = (XmlElement) subElements.get(i);
            // FIXME -- This will most likely not work.
            //          You want the element removed if the contents are the same
            //          Not just if the element reference is the same.
            if (child == e) {
                subElements.remove(i);
            }
        }
        return (child);
    }

    public XmlElement removeElement(int index) {
        return (XmlElement) subElements.remove(index);
    }

    public void removeAllElements() {
        subElements.clear();
    }

    /**
     * convienience method for the TreeView
     *
     * this method is modeled after the DefaultMutableTreeNode-class
     *
     * DefaultMutableTreeNode wraps XmlElement for this purpose
     */
    public void removeFromParent() {
        if (parent == null) {
            return;
        }
        parent.removeElement(this);
        parent = null;
    }

    public void append(XmlElement e) {
        e.removeFromParent();
        addElement(e);
    }

    /**
     * convienience method for the TreeView
     *
     * @param e
     * @param index
     */
    public void insertElement(XmlElement e, int index) {
        e.removeFromParent();
        subElements.add(index, e);
        e.setParent(this);
    }

    /**
     * **
     *
     * @return Vector
     */
    public List getElements() {
        return subElements;
    }

    public int count() {
        return subElements.size();
    }

    /**
     * Returns the element whose hierachy is indicated
     * by <code>path</code>. The path is separated with
     * periods(""."").<br>
     * <em>Note: if one node has more than one elements
     * that have the same name, that is, if its subnodes
     * have the same path, only the first one is returned.
     * </em>
     * @return the first element qualified with the path
     * @param path the path string of the specified element
     */
    public XmlElement getElement(String path) {
        int i = path.indexOf('.');
        String topName;
        String subName;
        if (i == 0) {
            path = path.substring(1);
            i = path.indexOf('.');
        }
        if (i > 0) {
            topName = path.substring(0, i);
            subName = path.substring(i + 1);
        } else {
            topName = path;
            subName = null;
        }
        int j;
        for (j = 0; j < subElements.size(); j++) {
            if (((XmlElement) subElements.get(j)).getName().equals(topName)) {
                if (subName != null) {
                    return (((XmlElement) subElements.get(j)).getElement(subName));
                } else {
                    return ((XmlElement) subElements.get(j));
                }
            }
        }
        return null;
    }

    public XmlElement getElement(int index) {
        return (XmlElement) subElements.get(index);
    }

    /**
     * Adds a sub element to this one. The path
     * is separated with dots(""."").
     *
     * @return the <code>XmlElement</code> added
     * @param path The subpath of the sub element to add
     */
    public XmlElement addSubElement(String path) {
        XmlElement parent = this;
        XmlElement child;
        String name;
        while (path.indexOf('.') != -1) {
            name = path.substring(0, path.indexOf('.'));
            path = path.substring(path.indexOf('.') + 1);
            // if path startsWith ""/"" -> skip
            if (name.length() == 0)
                continue;
            if (parent.getElement(name) != null) {
                parent = parent.getElement(name);
            } else {
                child = new XmlElement(name);
                parent.addElement(child);
                parent = child;
            }
        }
        child = new XmlElement(path);
        parent.addElement(child);
        return child;
    }

    /**
     * Adds a sub element to this one
     *
     * @return XmlElement
     * @param element
     *            The XmlElement to add
     */
    public XmlElement addSubElement(XmlElement e) {
        e.setParent(this);
        subElements.add(e);
        return e;
    }

    /**
     * Adds a sub element to this one
     *
     * @return XmlElement
     * @param Name
     *            The name of the sub element to add
     * @param Data
     *            String Data for this element
     */
    public XmlElement addSubElement(String name, String data) {
        XmlElement e = new XmlElement(name);
        e.setData(data);
        e.setParent(this);
        subElements.add(e);
        return e;
    }

    /**
     * Sets the parent element
     *
     * @param Parent
     *            The XmlElement that contains this one
     */
    public void setParent(XmlElement parent) {
        this.parent = parent;
    }

    /**
     * Gives the XmlElement containing the current element
     *
     * @return XmlElement
     */
    public XmlElement getParent() {
        return parent;
    }

    /**
     * Sets the data for this element
     *
     * @param D
     *            The String representation of the data
     */
    public void setData(String d) {
        data = d;
    }

    /**
     * Returns the data associated with the current Xml element
     *
     * @return String
     */
    public String getData() {
        return data;
    }

    /**
     * Returns the name of the current Xml element
     *
     * @return String
     */
    public String getName() {
        return name;
    }

    /**
     * **
     *
     * @param out
     *            OutputStream to print the data to
     */
    /*
     * public void write(OutputStream out) throws IOException { PrintWriter PW =
     * new PrintWriter(out); PW.println("" <?xml version=\""1.0\""
     * encoding=\""UTF-8\""?>""); if (SubElements.size() > 0) { for (int i = 0; i <
     * SubElements.size(); i++) { ((XmlElement)
     * SubElements.get(i))._writeSubNode(PW, 4); } } PW.flush(); }
     */
    /**
     * Prints sub nodes to the given data stream
     *
     * @param out
     *            PrintWriter to use for printing
     * @param indent
     *            Number of spaces to indent things
     */
    /*
     * private void _writeSubNode(PrintWriter out, int indent) throws
     * IOException { _writeSpace(out, indent); out.print("" <"" + Name); //if (
     * Attributes.size()>1) out.print("" "");
     * 
     * for (Enumeration e = Attributes.keys(); e.hasMoreElements();) { String K =
     * (String) e.nextElement(); out.print(K + ""=\"""" + Attributes.get(K) + ""\""
     * b"");
     *  } out.print("">"");
     * 
     * if (Data != null && !Data.equals("""")) { if (Data.length() > 20) {
     * out.println(""""); _writeSpace(out, indent + 2); } out.print(Data); } if
     * (SubElements.size() > 0) { out.println(""""); for (int i = 0; i <
     * SubElements.size(); i++) { ((XmlElement)
     * SubElements.get(i))._writeSubNode( out, indent + 4); } _writeSpace(out,
     * indent); } out.println("" </"" + Name + "">"");
     *  }
     */
    /**
     * Prints out a given number of spaces
     *
     * @param out
     *            PrintWriter to use for printing
     * @param numSpaces
     *            Number of spaces to print
     */
    /*
     * private void _writeSpace(PrintWriter out, int numSpaces) throws
     * IOException {
     * 
     * for (int i = 0; i < numSpaces; i++) out.print("" ""); }
     * 
     * public static void printNode(XmlElement Node, String indent) { String
     * Data = Node.getData(); if (Data == null || Data.equals("""")) {
     * System.out.println(indent + Node.getName()); } else {
     * System.out.println(indent + Node.getName() + "" = '"" + Data + ""'""); }
     * Vector Subs = Node.getElements(); int i, j; for (i = 0; i < Subs.size();
     * i++) { printNode((XmlElement) Subs.get(i), indent + "" ""); } }
     */
    public static void printNode(XmlElement node, String indent) {
        String data = node.getData();
        if ((data == null) || data.equals("""")) {
            System.out.println(indent + node.getName());
        } else {
            System.out.println(indent + node.getName() + "" = '"" + data + ""'"");
        }
        // print attributes
        for (Enumeration enumeration = node.getAttributes().keys(); enumeration.hasMoreElements(); ) {
            String key = (String) enumeration.nextElement();
            String value = node.getAttribute(key);
            System.out.println(indent + key + "":"" + value);
        }
        List subs = node.getElements();
        for (Iterator it = subs.iterator(); it.hasNext(); ) {
            printNode((XmlElement) it.next(), indent + ""    "");
            // for (i = 0; i < subs.size(); i++) {
            // printNode((XmlElement) subs.get(i), indent + "" "");
        }
    }

    /**
     * {@inheritDoc}
     */
    @SuppressWarnings(""unchecked"")
    @Override
    public Object clone() {
        try {
            // creates a shallow
            XmlElement clone = (XmlElement) super.clone();
            // copy of this
            // object
            if (attributes != null) {
                clone.setAttributes((Hashtable<String, String>) getAttributes().clone());
            }
            if (subElements != null) {
                clone.subElements = new Vector();
                List childs = getElements();
                XmlElement child;
                for (Iterator it = childs.iterator(); it.hasNext(); ) {
                    child = (XmlElement) it.next();
                    // for( int i=0; i<childs.size(); i++ ) {
                    // child = (XmlElement) childs.get(i);
                    clone.addSubElement((XmlElement) child.clone());
                }
            }
            return clone;
        } catch (CloneNotSupportedException cnse) {
            throw new InternalError(""Could not clone XmlElement: "" + cnse);
        }
    }

    /**
     * Sets the name.
     *
     * @param name
     *            The name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Notify all Observers.
     *
     * @see java.util.Observable#notifyObservers()
     */
    @Override
    public void notifyObservers() {
        setChanged();
        super.notifyObservers();
    }

    /**
     * Returns true if the specified objects are equal. They are equal if they
     * are both null OR if the <code>equals()</code> method return true. (
     * <code>obj1.equals(obj2)</code>).
     *
     * @param obj1
     *            first object to compare with.
     * @param obj2
     *            second object to compare with.
     * @return true if they represent the same object; false if one of them is
     *         null or the <code>equals()</code> method returns false.
     */
    private boolean equals(Object obj1, Object obj2) {
        boolean equal = false;
        if ((obj1 == null) && (obj2 == null)) {
            equal = true;
        } else if ((obj1 != null) && (obj2 != null)) {
            equal = obj1.equals(obj2);
        }
        return equal;
    }

    /**
     *  {@inheritDoc}
     * Recursive comparison.
     */
    @Override
    public boolean equals(Object obj) {
        boolean equal = false;
        if ((obj != null) && (obj instanceof XmlElement)) {
            XmlElement other = (XmlElement) obj;
            if (equals(attributes, other.attributes) && equals(data, other.data) && equals(name, other.name) && equals(subElements, other.subElements)) {
                equal = true;
            }
        }
        return equal;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
        //Hashcode value should be buffered.
        int hashCode = 23;
        if (attributes != null) {
            hashCode += (attributes.hashCode() * 13);
        }
        if (data != null) {
            hashCode += (data.hashCode() * 17);
        }
        if (name != null) {
            hashCode += (name.hashCode() * 29);
        }
        if (subElements != null) {
            hashCode += (subElements.hashCode() * 57);
        }
        return hashCode;
    }
}
//END public class XmlElement
","// XmlElement_9Test.java
package com.allenstudio.ir.util;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlElement}.
* It contains ten unit test cases for the {@link XmlElement#addSubElement(String)} method.
*/
class XmlElement_9Test {","```java
class XmlElement_9Test {

    @Test
    void testAddSubElement() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = root.addSubElement(""child1"");
        assertEquals(""child1"", child1.getName());
        assertEquals(root, child1.getParent());
    }

    @Test
    void testAddSubElementWithMultipleLevels() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = root.addSubElement(""child1"");
        XmlElement child2 = root.addSubElement(""child1.child2"");
        assertEquals(""child2"", child2.getName());
        assertEquals(child1, child2.getParent());
    }

    @Test
    void testAddSubElementWithEmptyPath() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child = root.addSubElement("""");
        assertEquals("""", child.getName());
        assertEquals(root, child.getParent());
    }

    @Test
    void testAddSubElementWithSlashInPath() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child = root.addSubElement("".child"");
        assertEquals(""child"", child.getName());
        assertEquals(root, child.getParent());
    }

    @Test
    void testAddSubElementWithExistingPath() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child1 = root.addSubElement(""child1"");
        XmlElement child2 = root.addSubElement(""child1"");
        assertEquals(""child1"", child2.getName());
        assertEquals(root, child2.getParent());
    }

    @Test
    void testAddSubElementWithAttributes() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child = root.addSubElement(""child"");
        child.addAttribute(""key"", ""value"");
        assertEquals(""value"", child.getAttribute(""key""));
    }

    @Test
    void testAddSubElementWithData() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child = root.addSubElement(""child"");
        child.setData(""data"");
        assertEquals(""data"", child.getData());
    }

    @Test
    void testAddSubElementWithMultipleLevelsAndData() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child = root.addSubElement(""child1.child2"");
        child.setData(""data"");
        assertEquals(""data"", child.getData());
    }

    @Test
    void testAddSubElementWithMultipleLevelsAndAttributes() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child = root.addSubElement(""child1.child2"");
        child.addAttribute(""key"", ""value"");
        assertEquals(""value"", child.getAttribute(""key""));
    }

    @Test
    void testAddSubElementWithEmptyPathAndData() {
        XmlElement root = new XmlElement(""root"");
        XmlElement child = root.addSubElement("".child"");
        child.setData(""data"");
        assertEquals(""data"", child.getData());
    }
}
```
```"
chatcmpl-A5U2RDNH7lcDz6GR51K5FUx0C3dvy,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/util/XmlElement_11Test.java,13.62643837928772,stop,"// XmlElement.java
/*
 * @(#)XmlElement.java
 * Created on 2005-8-12
 */
package com.allenstudio.ir.util;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Observable;
import java.util.Vector;

/**
 * The XmlElement is a generic containment class for elements within an XML
 * file.
 * <p>
 *
 * It extends Observable which should be used for gui elements which are
 * interested in configuration changes.
 * <p>
 *
 * Show interested in:
 *
 * <pre>
 * xmlElement.addObserver(yourObserver);
 * </pre>
 *
 * <p>
 * When making bigger changes on XmlElement and probably its subnodes and/or a
 * greater number of attributes at once, you should just change XmlElement
 * directly and manually notify the Observers by calling:
 * <p>
 *
 * <pre>
 * xmlElement.setChanged();
 * xmlElement.notifyObservers();
 * </pre>
 *
 * <p>
 * There a good introduction for the Observable/Observer pattern in
 * Model/View/Controller based applications at www.javaworld.com: -
 * {@link http://www.javaworld.com/javaworld/jw-10-1996/jw-10-howto.html}
 *
 * @author fdietz
 */
public class XmlElement extends Observable implements Cloneable {

    String name;

    String data;

    Hashtable<String, String> attributes;

    List<XmlElement> subElements;

    XmlElement parent;

    /**
     * Constructor
     */
    public XmlElement() {
        subElements = new Vector<XmlElement>();
        this.attributes = new Hashtable<String, String>(10);
    }

    /**
     * **
     *
     * Constructor
     *
     * @param String
     *            Name
     */
    public XmlElement(String name) {
        this.name = name;
        this.attributes = new Hashtable<String, String>(10);
        subElements = new Vector<XmlElement>();
        data = """";
    }

    /**
     * **
     *
     * Constructor
     *
     * @param String
     *            Name
     * @param Hashtable
     *            Attributes
     */
    public XmlElement(String name, Hashtable<String, String> attributes) {
        this.name = name;
        this.attributes = attributes;
        subElements = new Vector<XmlElement>();
    }

    /**
     * **
     *
     * Constructor
     *
     * @param Name
     *            String
     * @param Data
     *            String
     */
    public XmlElement(String name, String data) {
        this.name = name;
        this.data = data;
        subElements = new Vector<XmlElement>();
        this.attributes = new Hashtable<String, String>(10);
    }

    /**
     * Add attribute to this xml element.
     *
     * @param name
     *            name of key
     * @param value
     *            new attribute value
     * @return old attribute value
     */
    public Object addAttribute(String name, String value) {
        if ((value != null) && (name != null)) {
            Object returnValue = attributes.put(name, value);
            return returnValue;
        }
        return null;
    }

    /**
     * **
     *
     * @return String
     * @param String
     *            Name
     */
    public String getAttribute(String name) {
        return ((String) attributes.get(name));
    }

    public String getAttribute(String name, String defaultValue) {
        if (getAttribute(name) == null) {
            addAttribute(name, defaultValue);
        }
        return getAttribute(name);
    }

    /**
     * **
     *
     * @return String
     * @param String
     *            Name
     */
    public Hashtable<String, String> getAttributes() {
        return attributes;
    }

    /**
     * **
     *
     * @param Attrs
     *            Hashtable to use as the attributes
     */
    public void setAttributes(Hashtable<String, String> attrs) {
        attributes = attrs;
    }

    /**
     * **
     *
     * @return Enumeration
     */
    public Enumeration getAttributeNames() {
        return (attributes.keys());
    }

    /**
     * **
     *
     * @return boolean
     * @param XmlElement
     *            E
     */
    public boolean addElement(XmlElement e) {
        e.setParent(this);
        return (subElements.add(e));
    }

    public XmlElement removeElement(XmlElement e) {
        XmlElement child = null;
        for (int i = 0; i < subElements.size(); i++) {
            child = (XmlElement) subElements.get(i);
            // FIXME -- This will most likely not work.
            //          You want the element removed if the contents are the same
            //          Not just if the element reference is the same.
            if (child == e) {
                subElements.remove(i);
            }
        }
        return (child);
    }

    public XmlElement removeElement(int index) {
        return (XmlElement) subElements.remove(index);
    }

    public void removeAllElements() {
        subElements.clear();
    }

    /**
     * convienience method for the TreeView
     *
     * this method is modeled after the DefaultMutableTreeNode-class
     *
     * DefaultMutableTreeNode wraps XmlElement for this purpose
     */
    public void removeFromParent() {
        if (parent == null) {
            return;
        }
        parent.removeElement(this);
        parent = null;
    }

    public void append(XmlElement e) {
        e.removeFromParent();
        addElement(e);
    }

    /**
     * convienience method for the TreeView
     *
     * @param e
     * @param index
     */
    public void insertElement(XmlElement e, int index) {
        e.removeFromParent();
        subElements.add(index, e);
        e.setParent(this);
    }

    /**
     * **
     *
     * @return Vector
     */
    public List getElements() {
        return subElements;
    }

    public int count() {
        return subElements.size();
    }

    /**
     * Returns the element whose hierachy is indicated
     * by <code>path</code>. The path is separated with
     * periods(""."").<br>
     * <em>Note: if one node has more than one elements
     * that have the same name, that is, if its subnodes
     * have the same path, only the first one is returned.
     * </em>
     * @return the first element qualified with the path
     * @param path the path string of the specified element
     */
    public XmlElement getElement(String path) {
        int i = path.indexOf('.');
        String topName;
        String subName;
        if (i == 0) {
            path = path.substring(1);
            i = path.indexOf('.');
        }
        if (i > 0) {
            topName = path.substring(0, i);
            subName = path.substring(i + 1);
        } else {
            topName = path;
            subName = null;
        }
        int j;
        for (j = 0; j < subElements.size(); j++) {
            if (((XmlElement) subElements.get(j)).getName().equals(topName)) {
                if (subName != null) {
                    return (((XmlElement) subElements.get(j)).getElement(subName));
                } else {
                    return ((XmlElement) subElements.get(j));
                }
            }
        }
        return null;
    }

    public XmlElement getElement(int index) {
        return (XmlElement) subElements.get(index);
    }

    /**
     * Adds a sub element to this one. The path
     * is separated with dots(""."").
     *
     * @return the <code>XmlElement</code> added
     * @param path The subpath of the sub element to add
     */
    public XmlElement addSubElement(String path) {
        XmlElement parent = this;
        XmlElement child;
        String name;
        while (path.indexOf('.') != -1) {
            name = path.substring(0, path.indexOf('.'));
            path = path.substring(path.indexOf('.') + 1);
            // if path startsWith ""/"" -> skip
            if (name.length() == 0)
                continue;
            if (parent.getElement(name) != null) {
                parent = parent.getElement(name);
            } else {
                child = new XmlElement(name);
                parent.addElement(child);
                parent = child;
            }
        }
        child = new XmlElement(path);
        parent.addElement(child);
        return child;
    }

    /**
     * Adds a sub element to this one
     *
     * @return XmlElement
     * @param element
     *            The XmlElement to add
     */
    public XmlElement addSubElement(XmlElement e) {
        e.setParent(this);
        subElements.add(e);
        return e;
    }

    /**
     * Adds a sub element to this one
     *
     * @return XmlElement
     * @param Name
     *            The name of the sub element to add
     * @param Data
     *            String Data for this element
     */
    public XmlElement addSubElement(String name, String data) {
        XmlElement e = new XmlElement(name);
        e.setData(data);
        e.setParent(this);
        subElements.add(e);
        return e;
    }

    /**
     * Sets the parent element
     *
     * @param Parent
     *            The XmlElement that contains this one
     */
    public void setParent(XmlElement parent) {
        this.parent = parent;
    }

    /**
     * Gives the XmlElement containing the current element
     *
     * @return XmlElement
     */
    public XmlElement getParent() {
        return parent;
    }

    /**
     * Sets the data for this element
     *
     * @param D
     *            The String representation of the data
     */
    public void setData(String d) {
        data = d;
    }

    /**
     * Returns the data associated with the current Xml element
     *
     * @return String
     */
    public String getData() {
        return data;
    }

    /**
     * Returns the name of the current Xml element
     *
     * @return String
     */
    public String getName() {
        return name;
    }

    /**
     * **
     *
     * @param out
     *            OutputStream to print the data to
     */
    /*
     * public void write(OutputStream out) throws IOException { PrintWriter PW =
     * new PrintWriter(out); PW.println("" <?xml version=\""1.0\""
     * encoding=\""UTF-8\""?>""); if (SubElements.size() > 0) { for (int i = 0; i <
     * SubElements.size(); i++) { ((XmlElement)
     * SubElements.get(i))._writeSubNode(PW, 4); } } PW.flush(); }
     */
    /**
     * Prints sub nodes to the given data stream
     *
     * @param out
     *            PrintWriter to use for printing
     * @param indent
     *            Number of spaces to indent things
     */
    /*
     * private void _writeSubNode(PrintWriter out, int indent) throws
     * IOException { _writeSpace(out, indent); out.print("" <"" + Name); //if (
     * Attributes.size()>1) out.print("" "");
     * 
     * for (Enumeration e = Attributes.keys(); e.hasMoreElements();) { String K =
     * (String) e.nextElement(); out.print(K + ""=\"""" + Attributes.get(K) + ""\""
     * b"");
     *  } out.print("">"");
     * 
     * if (Data != null && !Data.equals("""")) { if (Data.length() > 20) {
     * out.println(""""); _writeSpace(out, indent + 2); } out.print(Data); } if
     * (SubElements.size() > 0) { out.println(""""); for (int i = 0; i <
     * SubElements.size(); i++) { ((XmlElement)
     * SubElements.get(i))._writeSubNode( out, indent + 4); } _writeSpace(out,
     * indent); } out.println("" </"" + Name + "">"");
     *  }
     */
    /**
     * Prints out a given number of spaces
     *
     * @param out
     *            PrintWriter to use for printing
     * @param numSpaces
     *            Number of spaces to print
     */
    /*
     * private void _writeSpace(PrintWriter out, int numSpaces) throws
     * IOException {
     * 
     * for (int i = 0; i < numSpaces; i++) out.print("" ""); }
     * 
     * public static void printNode(XmlElement Node, String indent) { String
     * Data = Node.getData(); if (Data == null || Data.equals("""")) {
     * System.out.println(indent + Node.getName()); } else {
     * System.out.println(indent + Node.getName() + "" = '"" + Data + ""'""); }
     * Vector Subs = Node.getElements(); int i, j; for (i = 0; i < Subs.size();
     * i++) { printNode((XmlElement) Subs.get(i), indent + "" ""); } }
     */
    public static void printNode(XmlElement node, String indent) {
        String data = node.getData();
        if ((data == null) || data.equals("""")) {
            System.out.println(indent + node.getName());
        } else {
            System.out.println(indent + node.getName() + "" = '"" + data + ""'"");
        }
        // print attributes
        for (Enumeration enumeration = node.getAttributes().keys(); enumeration.hasMoreElements(); ) {
            String key = (String) enumeration.nextElement();
            String value = node.getAttribute(key);
            System.out.println(indent + key + "":"" + value);
        }
        List subs = node.getElements();
        for (Iterator it = subs.iterator(); it.hasNext(); ) {
            printNode((XmlElement) it.next(), indent + ""    "");
            // for (i = 0; i < subs.size(); i++) {
            // printNode((XmlElement) subs.get(i), indent + "" "");
        }
    }

    /**
     * {@inheritDoc}
     */
    @SuppressWarnings(""unchecked"")
    @Override
    public Object clone() {
        try {
            // creates a shallow
            XmlElement clone = (XmlElement) super.clone();
            // copy of this
            // object
            if (attributes != null) {
                clone.setAttributes((Hashtable<String, String>) getAttributes().clone());
            }
            if (subElements != null) {
                clone.subElements = new Vector();
                List childs = getElements();
                XmlElement child;
                for (Iterator it = childs.iterator(); it.hasNext(); ) {
                    child = (XmlElement) it.next();
                    // for( int i=0; i<childs.size(); i++ ) {
                    // child = (XmlElement) childs.get(i);
                    clone.addSubElement((XmlElement) child.clone());
                }
            }
            return clone;
        } catch (CloneNotSupportedException cnse) {
            throw new InternalError(""Could not clone XmlElement: "" + cnse);
        }
    }

    /**
     * Sets the name.
     *
     * @param name
     *            The name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Notify all Observers.
     *
     * @see java.util.Observable#notifyObservers()
     */
    @Override
    public void notifyObservers() {
        setChanged();
        super.notifyObservers();
    }

    /**
     * Returns true if the specified objects are equal. They are equal if they
     * are both null OR if the <code>equals()</code> method return true. (
     * <code>obj1.equals(obj2)</code>).
     *
     * @param obj1
     *            first object to compare with.
     * @param obj2
     *            second object to compare with.
     * @return true if they represent the same object; false if one of them is
     *         null or the <code>equals()</code> method returns false.
     */
    private boolean equals(Object obj1, Object obj2) {
        boolean equal = false;
        if ((obj1 == null) && (obj2 == null)) {
            equal = true;
        } else if ((obj1 != null) && (obj2 != null)) {
            equal = obj1.equals(obj2);
        }
        return equal;
    }

    /**
     *  {@inheritDoc}
     * Recursive comparison.
     */
    @Override
    public boolean equals(Object obj) {
        boolean equal = false;
        if ((obj != null) && (obj instanceof XmlElement)) {
            XmlElement other = (XmlElement) obj;
            if (equals(attributes, other.attributes) && equals(data, other.data) && equals(name, other.name) && equals(subElements, other.subElements)) {
                equal = true;
            }
        }
        return equal;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
        //Hashcode value should be buffered.
        int hashCode = 23;
        if (attributes != null) {
            hashCode += (attributes.hashCode() * 13);
        }
        if (data != null) {
            hashCode += (data.hashCode() * 17);
        }
        if (name != null) {
            hashCode += (name.hashCode() * 29);
        }
        if (subElements != null) {
            hashCode += (subElements.hashCode() * 57);
        }
        return hashCode;
    }
}
//END public class XmlElement
","// XmlElement_11Test.java
package com.allenstudio.ir.util;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Observable;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlElement}.
* It contains ten unit test cases for the {@link XmlElement#addSubElement(String, String)} method.
*/
class XmlElement_11Test {","```java
class XmlElement_11Test {

    @Test
    void testAddSubElement() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child = parent.addSubElement(""child"", ""data"");

        assertEquals(""child"", child.getName());
        assertEquals(""data"", child.getData());
        assertEquals(parent, child.getParent());
        List<XmlElement> subElements = parent.getElements();
        assertTrue(subElements.contains(child));
    }

    @Test
    void testAddSubElement_EmptyPath() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child = parent.addSubElement("""", ""data"");

        assertEquals("""", child.getName());
        assertEquals(""data"", child.getData());
        assertEquals(parent, child.getParent());
        List<XmlElement> subElements = parent.getElements();
        assertTrue(subElements.contains(child));
    }

    @Test
    void testAddSubElement_MultipleLevels() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child = parent.addSubElement(""level1.level2.level3"", ""data"");

        assertEquals(""level1"", parent.getElement(""level1"").getName());
        assertEquals(""level2"", parent.getElement(""level1.level2"").getName());
        assertEquals(""level3"", parent.getElement(""level1.level2.level3"").getName());
        assertEquals(""data"", parent.getElement(""level1.level2.level3"").getData());
    }

    @Test
    void testAddSubElement_SamePath() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child1 = parent.addSubElement(""samepath"", ""data1"");
        XmlElement child2 = parent.addSubElement(""samepath"", ""data2"");

        assertEquals(""samepath"", child1.getName());
        assertEquals(""data1"", child1.getData());
        assertEquals(""samepath"", child2.getName());
        assertEquals(""data2"", child2.getData());
        List<XmlElement> subElements = parent.getElements();
        assertTrue(subElements.contains(child1));
        assertTrue(subElements.contains(child2));
    }

    @Test
    void testAddSubElement_NullPath() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child = parent.addSubElement(null, ""data"");

        assertEquals(null, child.getName());
        assertEquals(""data"", child.getData());
        assertEquals(parent, child.getParent());
        List<XmlElement> subElements = parent.getElements();
        assertTrue(subElements.contains(child));
    }

    @Test
    void testAddSubElement_NullData() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child = parent.addSubElement(""child"", null);

        assertEquals(""child"", child.getName());
        assertEquals(null, child.getData());
        assertEquals(parent, child.getParent());
        List<XmlElement> subElements = parent.getElements();
        assertTrue(subElements.contains(child));
    }

    @Test
    void testAddSubElement_EmptyData() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child = parent.addSubElement(""child"", """");

        assertEquals(""child"", child.getName());
        assertEquals("""", child.getData());
        assertEquals(parent, child.getParent());
        List<XmlElement> subElements = parent.getElements();
        assertTrue(subElements.contains(child));
    }

    @Test
    void testAddSubElement_PathWithSlash() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child = parent.addSubElement(""/level1/level2/level3"", ""data"");

        assertEquals(""level1"", parent.getElement(""level1"").getName());
        assertEquals(""level2"", parent.getElement(""level1.level2"").getName());
        assertEquals(""level3"", parent.getElement(""level1.level2.level3"").getName());
        assertEquals(""data"", parent.getElement(""level1.level2.level3"").getData());
    }

    @Test
    void testAddSubElement_PathWithLeadingDot() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child = parent.addSubElement("".level1.level2.level3"", ""data"");

        assertEquals(""level1"", parent.getElement(""level1"").getName());
        assertEquals(""level2"", parent.getElement(""level1.level2"").getName());
        assertEquals(""level3"", parent.getElement(""level1.level2.level3"").getName());
        assertEquals(""data"", parent.getElement(""level1.level2.level3"").getData());
    }

    @Test
    void testAddSubElement_PathWithTrailingDot() {
        XmlElement parent = new XmlElement(""parent"");
        XmlElement child = parent.addSubElement(""level1.level2.level3."", ""data"");

        assertEquals(""level1"", parent.getElement(""level1"").getName());
        assertEquals(""level2"", parent.getElement(""level1.level2"").getName());
        assertEquals(""level3"", parent.getElement(""level1.level2.level3"").getName());
        assertEquals(""data"", parent.getElement(""level1.level2.level3"").getData());
    }
}
```
```"
chatcmpl-A5U3UfUT4SW9IulXwwACcvqNEiRno,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/util/XmlIO_1Test.java,7.553862810134888,stop,"// XmlIO.java
/*
 * @(#)XmlIO.java
 * Created on 2005-8-12
 */
package com.allenstudio.ir.util;

import java.io.BufferedWriter;
import java.io.CharArrayWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.URL;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;

/**
 * XML IO reading and writing utility.
 *
 * @author fdietz
 */
public class XmlIO extends DefaultHandler {

    private static final Logger LOG = Logger.getLogger(""org.columba.core.xml"");

    private static final String ROOT_XML_ELEMENT_NAME = ""__INSPIRENTO_XML_TREE_TOP__"";

    // List of sub-elements
    @SuppressWarnings(""unused"")
    private List<XmlElement> elements;

    // Top level element (Used to hold everything else)
    private XmlElement rootElement;

    // The current element you are working on
    private XmlElement currentElement;

    // For writing out the data
    // Indent for each level
    private int writeIndent = 2;

    // Maximum data to put on a ""one liner""
    private int maxOneLineData = 20;

    // The SAX 2 parser...
    @SuppressWarnings(""unused"")
    private XMLReader xr;

    // Buffer for collecting data from
    // the ""characters"" SAX event.
    private CharArrayWriter contents = new CharArrayWriter();

    private URL url = null;

    /*
  // Default constructor
  public XmlIO() {
  }
  */
    /*
  // setup and load constructor
  public XmlIO(String FilePath) {
          currentElement = null;


  }
  */
    public XmlIO(URL url) {
        super();
        this.url = url;
    }

    // setup and load constructor
    public XmlIO() {
        currentElement = null;
    }

    // setup and load constructor
    /**
     * Creates a XmlIO object with the specified element at the top.
     * @param element the element at the top.
     */
    public XmlIO(XmlElement element) {
        rootElement = new XmlElement(ROOT_XML_ELEMENT_NAME);
        rootElement.addElement(element);
    }

    public void setURL(URL url) {
        this.url = url;
    }

    public boolean load() {
        //this.file = F;
        return load(url);
    }

    // Load a file. This is what starts things off.
    /**
     * Loads from the InputStream into the root Xml Element.
     * @param input the input stream to load from.
     */
    public boolean load(InputStream input) {
        elements = new Vector<XmlElement>();
        rootElement = new XmlElement(ROOT_XML_ELEMENT_NAME);
        currentElement = rootElement;
        try {
            // Create the XML reader...
            //      xr = XMLReaderFactory.createXMLReader();
            SAXParserFactory factory = SAXParserFactory.newInstance();
            // Set the ContentHandler...
            //      xr.setContentHandler( this );
            SAXParser saxParser = factory.newSAXParser();
            saxParser.parse(input, this);
        } catch (javax.xml.parsers.ParserConfigurationException ex) {
            LOG.severe(""XML config error while attempting to read from the input stream \n'"" + input + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        } catch (SAXException ex) {
            // Error
            LOG.severe(""XML parse error while attempting to read from the input stream \n'"" + input + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        } catch (IOException ex) {
            LOG.severe(""I/O error while attempting to read from the input stream \n'"" + input + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        }
        //XmlElement.printNode( getRoot(), """");
        return (true);
    }

    /**
     * Load a file. This is what starts things off.
     * @param inputURL the URL to load XML from.
     */
    public boolean load(URL inputURL) {
        elements = new Vector<XmlElement>();
        rootElement = new XmlElement(ROOT_XML_ELEMENT_NAME);
        currentElement = rootElement;
        try {
            // Create the XML reader...
            //      xr = XMLReaderFactory.createXMLReader();
            SAXParserFactory factory = SAXParserFactory.newInstance();
            // Set the ContentHandler...
            //      xr.setContentHandler( this );
            SAXParser saxParser = factory.newSAXParser();
            saxParser.parse(inputURL.toString(), this);
        } catch (javax.xml.parsers.ParserConfigurationException ex) {
            LOG.severe(""XML config error while attempting to read XML file \n'"" + inputURL + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        } catch (SAXException ex) {
            // Error
            LOG.severe(""XML parse error while attempting to read XML file \n'"" + inputURL + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        } catch (IOException ex) {
            LOG.severe(""I/O error while attempting to read XML file \n'"" + inputURL + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        }
        //XmlElement.printNode( getRoot(), """");
        return (true);
    }

    // Implement the content hander methods that
    // will delegate SAX events to the tag tracker network.
    @Override
    public void startElement(String namespaceURI, String localName, String qName, Attributes attrs) throws SAXException {
        // Resetting contents buffer.
        // Assuming that tags either tag content or children, not both.
        // This is usually the case with XML that is representing
        // data strucutures in a programming language independant way.
        // This assumption is not typically valid where XML is being
        // used in the classical text mark up style where tagging
        // is used to style content and several styles may overlap
        // at once.
        try {
            contents.reset();
            // element name
            String name = localName;
            if (name.equals("""")) {
                // namespaceAware = false
                name = qName;
            }
            XmlElement p = currentElement;
            currentElement = currentElement.addSubElement(name);
            currentElement.setParent(p);
            if (attrs != null) {
                for (int i = 0; i < attrs.getLength(); i++) {
                    // Attr name
                    String aName = attrs.getLocalName(i);
                    if (aName.equals("""")) {
                        aName = attrs.getQName(i);
                    }
                    currentElement.addAttribute(aName, attrs.getValue(i));
                }
            }
        } catch (java.lang.NullPointerException ex) {
            LOG.severe(""Null!!!"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
        }
    }

    @Override
    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        currentElement.setData(contents.toString().trim());
        contents.reset();
        currentElement = currentElement.getParent();
    }

    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        // accumulate the contents into a buffer.
        contents.write(ch, start, length);
    }

    /**
     * Returns the root for the XmlElement hiearchy.
     * Note that this Xml Element will always have the name <code>__COLUMBA_XML_TREE_TOP__</code>.
     * <p>
     * Methods that want to retrieve elements from this root should use
     * the {@link XmlElement#getElement(String)} in order to get the wanted
     * element.
     * @return a XmlElement if it has been loaded or initialized with it; null otherwise.
     */
    public XmlElement getRoot() {
        return (rootElement);
    }

    public void errorDialog(String Msg) {
        JOptionPane.showMessageDialog(null, ""Error: "" + Msg);
    }

    public void warningDialog(String Msg) {
        JOptionPane.showMessageDialog(null, ""Warning: "" + Msg);
    }

    public void infoDialog(String Msg) {
        JOptionPane.showMessageDialog(null, ""Info: "" + Msg);
    }

    public void save() throws Exception {
        write(new FileOutputStream(url.getPath()));
    }

    //
    // Writer interface
    //
    public void write(OutputStream out) throws IOException {
        BufferedWriter PW = new BufferedWriter(new OutputStreamWriter(out, ""UTF-8""));
        PW.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"");
        if (rootElement.subElements.size() > 0) {
            for (int i = 0; i < rootElement.subElements.size(); i++) {
                _writeSubNode(PW, (XmlElement) rootElement.subElements.get(i), 0);
            }
        }
        PW.flush();
    }

    private void _writeSubNode(Writer out, XmlElement element, int indent) throws IOException {
        _writeSpace(out, indent);
        out.write(""<"");
        out.write(element.getName());
        for (Enumeration e = element.getAttributeNames(); e.hasMoreElements(); ) {
            String K = (String) e.nextElement();
            out.write("" "" + K + ""=\"""" + InspirentoUtilities.escapeText(element.getAttribute(K)) + ""\"""");
        }
        out.write("">"");
        String data = element.getData();
        if ((data != null) && !data.equals("""")) {
            if (data.length() > maxOneLineData) {
                out.write(""\n"");
                _writeSpace(out, indent + writeIndent);
            }
            out.write(InspirentoUtilities.escapeText(data));
        }
        List subElements = element.getElements();
        if (subElements.size() > 0) {
            out.write(""\n"");
            for (Iterator it = subElements.iterator(); it.hasNext(); ) {
                _writeSubNode(out, (XmlElement) it.next(), indent + writeIndent);
                // for (int i = 0; i < subElements.size(); i++) {
                // _writeSubNode(
                // out,
                // (XmlElement) subElements.get(i),
                // indent + writeIndent);
            }
            _writeSpace(out, indent);
        }
        if (data.length() > maxOneLineData) {
            out.write(""\n"");
            _writeSpace(out, indent);
        }
        out.write(""</"" + InspirentoUtilities.escapeText(element.getName()) + "">\n"");
    }

    private void _writeSpace(Writer out, int numSpaces) throws IOException {
        for (int i = 0; i < numSpaces; i++) {
            out.write("" "");
        }
    }
}
//End class XmlIO
","// XmlIO_1Test.java
package com.allenstudio.ir.util;

import java.io.BufferedWriter;
import java.io.CharArrayWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.URL;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlIO}.
* It contains ten unit test cases for the {@link XmlIO#load(InputStream)} method.
*/
class XmlIO_1Test {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class XmlIO_1Test {

    @Test
    void testLoadWithNullInputStream() {
        XmlIO xmlIO = new XmlIO();
        assertFalse(xmlIO.load(null));
    }

    @Test
    void testLoadWithValidInputStream() {
        // Create a sample input stream for testing
        InputStream inputStream = new ByteArrayInputStream(""<root><child>data</child></root>"".getBytes());
        
        XmlIO xmlIO = new XmlIO();
        assertTrue(xmlIO.load(inputStream));
    }

    @Test
    void testLoadWithInvalidInputStream() {
        // Create a sample input stream for testing
        InputStream inputStream = new ByteArrayInputStream(""invalid xml data"".getBytes());
        
        XmlIO xmlIO = new XmlIO();
        assertFalse(xmlIO.load(inputStream));
    }

    @Test
    void testLoadWithEmptyInputStream() {
        // Create an empty input stream for testing
        InputStream inputStream = new ByteArrayInputStream("""".getBytes());
        
        XmlIO xmlIO = new XmlIO();
        assertTrue(xmlIO.load(inputStream));
    }

    @Test
    void testLoadWithLargeInputStream() {
        // Create a large input stream for testing
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""<data>"").append(i).append(""</data>"");
        }
        InputStream inputStream = new ByteArrayInputStream(sb.toString().getBytes());
        
        XmlIO xmlIO = new XmlIO();
        assertTrue(xmlIO.load(inputStream));
    }

    @Test
    void testLoadWithSpecialCharactersInputStream() {
        // Create an input stream with special characters for testing
        InputStream inputStream = new ByteArrayInputStream(""<root><child>&lt;data&gt;</child></root>"".getBytes());
        
        XmlIO xmlIO = new XmlIO();
        assertTrue(xmlIO.load(inputStream));
    }

    @Test
    void testLoadWithNullRootElement() {
        XmlIO xmlIO = new XmlIO();
        xmlIO.setRootElement(null);
        assertFalse(xmlIO.load(new ByteArrayInputStream(""<root><child>data</child></root>"".getBytes())));
    }

    @Test
    void testLoadWithRootElement() {
        XmlElement rootElement = new XmlElement(""root"");
        XmlIO xmlIO = new XmlIO(rootElement);
        assertTrue(xmlIO.load(new ByteArrayInputStream(""<child>data</child>"".getBytes())));
    }

    @Test
    void testLoadWithRootElementAndAttributes() {
        XmlElement rootElement = new XmlElement(""root"");
        rootElement.addAttribute(""attr1"", ""value1"");
        rootElement.addAttribute(""attr2"", ""value2"");
        XmlIO xmlIO = new XmlIO(rootElement);
        assertTrue(xmlIO.load(new ByteArrayInputStream(""<child>data</child>"".getBytes())));
    }
}
```
```"
chatcmpl-A5U4XYD3mmU3bY8d3uqVstMhLB94q,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/util/XmlIO_2Test.java,6.311100959777832,stop,"// XmlIO.java
/*
 * @(#)XmlIO.java
 * Created on 2005-8-12
 */
package com.allenstudio.ir.util;

import java.io.BufferedWriter;
import java.io.CharArrayWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.URL;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;

/**
 * XML IO reading and writing utility.
 *
 * @author fdietz
 */
public class XmlIO extends DefaultHandler {

    private static final Logger LOG = Logger.getLogger(""org.columba.core.xml"");

    private static final String ROOT_XML_ELEMENT_NAME = ""__INSPIRENTO_XML_TREE_TOP__"";

    // List of sub-elements
    @SuppressWarnings(""unused"")
    private List<XmlElement> elements;

    // Top level element (Used to hold everything else)
    private XmlElement rootElement;

    // The current element you are working on
    private XmlElement currentElement;

    // For writing out the data
    // Indent for each level
    private int writeIndent = 2;

    // Maximum data to put on a ""one liner""
    private int maxOneLineData = 20;

    // The SAX 2 parser...
    @SuppressWarnings(""unused"")
    private XMLReader xr;

    // Buffer for collecting data from
    // the ""characters"" SAX event.
    private CharArrayWriter contents = new CharArrayWriter();

    private URL url = null;

    /*
  // Default constructor
  public XmlIO() {
  }
  */
    /*
  // setup and load constructor
  public XmlIO(String FilePath) {
          currentElement = null;


  }
  */
    public XmlIO(URL url) {
        super();
        this.url = url;
    }

    // setup and load constructor
    public XmlIO() {
        currentElement = null;
    }

    // setup and load constructor
    /**
     * Creates a XmlIO object with the specified element at the top.
     * @param element the element at the top.
     */
    public XmlIO(XmlElement element) {
        rootElement = new XmlElement(ROOT_XML_ELEMENT_NAME);
        rootElement.addElement(element);
    }

    public void setURL(URL url) {
        this.url = url;
    }

    public boolean load() {
        //this.file = F;
        return load(url);
    }

    // Load a file. This is what starts things off.
    /**
     * Loads from the InputStream into the root Xml Element.
     * @param input the input stream to load from.
     */
    public boolean load(InputStream input) {
        elements = new Vector<XmlElement>();
        rootElement = new XmlElement(ROOT_XML_ELEMENT_NAME);
        currentElement = rootElement;
        try {
            // Create the XML reader...
            //      xr = XMLReaderFactory.createXMLReader();
            SAXParserFactory factory = SAXParserFactory.newInstance();
            // Set the ContentHandler...
            //      xr.setContentHandler( this );
            SAXParser saxParser = factory.newSAXParser();
            saxParser.parse(input, this);
        } catch (javax.xml.parsers.ParserConfigurationException ex) {
            LOG.severe(""XML config error while attempting to read from the input stream \n'"" + input + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        } catch (SAXException ex) {
            // Error
            LOG.severe(""XML parse error while attempting to read from the input stream \n'"" + input + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        } catch (IOException ex) {
            LOG.severe(""I/O error while attempting to read from the input stream \n'"" + input + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        }
        //XmlElement.printNode( getRoot(), """");
        return (true);
    }

    /**
     * Load a file. This is what starts things off.
     * @param inputURL the URL to load XML from.
     */
    public boolean load(URL inputURL) {
        elements = new Vector<XmlElement>();
        rootElement = new XmlElement(ROOT_XML_ELEMENT_NAME);
        currentElement = rootElement;
        try {
            // Create the XML reader...
            //      xr = XMLReaderFactory.createXMLReader();
            SAXParserFactory factory = SAXParserFactory.newInstance();
            // Set the ContentHandler...
            //      xr.setContentHandler( this );
            SAXParser saxParser = factory.newSAXParser();
            saxParser.parse(inputURL.toString(), this);
        } catch (javax.xml.parsers.ParserConfigurationException ex) {
            LOG.severe(""XML config error while attempting to read XML file \n'"" + inputURL + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        } catch (SAXException ex) {
            // Error
            LOG.severe(""XML parse error while attempting to read XML file \n'"" + inputURL + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        } catch (IOException ex) {
            LOG.severe(""I/O error while attempting to read XML file \n'"" + inputURL + ""'"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
            return (false);
        }
        //XmlElement.printNode( getRoot(), """");
        return (true);
    }

    // Implement the content hander methods that
    // will delegate SAX events to the tag tracker network.
    @Override
    public void startElement(String namespaceURI, String localName, String qName, Attributes attrs) throws SAXException {
        // Resetting contents buffer.
        // Assuming that tags either tag content or children, not both.
        // This is usually the case with XML that is representing
        // data strucutures in a programming language independant way.
        // This assumption is not typically valid where XML is being
        // used in the classical text mark up style where tagging
        // is used to style content and several styles may overlap
        // at once.
        try {
            contents.reset();
            // element name
            String name = localName;
            if (name.equals("""")) {
                // namespaceAware = false
                name = qName;
            }
            XmlElement p = currentElement;
            currentElement = currentElement.addSubElement(name);
            currentElement.setParent(p);
            if (attrs != null) {
                for (int i = 0; i < attrs.getLength(); i++) {
                    // Attr name
                    String aName = attrs.getLocalName(i);
                    if (aName.equals("""")) {
                        aName = attrs.getQName(i);
                    }
                    currentElement.addAttribute(aName, attrs.getValue(i));
                }
            }
        } catch (java.lang.NullPointerException ex) {
            LOG.severe(""Null!!!"");
            LOG.severe(ex.toString());
            ex.printStackTrace();
        }
    }

    @Override
    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        currentElement.setData(contents.toString().trim());
        contents.reset();
        currentElement = currentElement.getParent();
    }

    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        // accumulate the contents into a buffer.
        contents.write(ch, start, length);
    }

    /**
     * Returns the root for the XmlElement hiearchy.
     * Note that this Xml Element will always have the name <code>__COLUMBA_XML_TREE_TOP__</code>.
     * <p>
     * Methods that want to retrieve elements from this root should use
     * the {@link XmlElement#getElement(String)} in order to get the wanted
     * element.
     * @return a XmlElement if it has been loaded or initialized with it; null otherwise.
     */
    public XmlElement getRoot() {
        return (rootElement);
    }

    public void errorDialog(String Msg) {
        JOptionPane.showMessageDialog(null, ""Error: "" + Msg);
    }

    public void warningDialog(String Msg) {
        JOptionPane.showMessageDialog(null, ""Warning: "" + Msg);
    }

    public void infoDialog(String Msg) {
        JOptionPane.showMessageDialog(null, ""Info: "" + Msg);
    }

    public void save() throws Exception {
        write(new FileOutputStream(url.getPath()));
    }

    //
    // Writer interface
    //
    public void write(OutputStream out) throws IOException {
        BufferedWriter PW = new BufferedWriter(new OutputStreamWriter(out, ""UTF-8""));
        PW.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"");
        if (rootElement.subElements.size() > 0) {
            for (int i = 0; i < rootElement.subElements.size(); i++) {
                _writeSubNode(PW, (XmlElement) rootElement.subElements.get(i), 0);
            }
        }
        PW.flush();
    }

    private void _writeSubNode(Writer out, XmlElement element, int indent) throws IOException {
        _writeSpace(out, indent);
        out.write(""<"");
        out.write(element.getName());
        for (Enumeration e = element.getAttributeNames(); e.hasMoreElements(); ) {
            String K = (String) e.nextElement();
            out.write("" "" + K + ""=\"""" + InspirentoUtilities.escapeText(element.getAttribute(K)) + ""\"""");
        }
        out.write("">"");
        String data = element.getData();
        if ((data != null) && !data.equals("""")) {
            if (data.length() > maxOneLineData) {
                out.write(""\n"");
                _writeSpace(out, indent + writeIndent);
            }
            out.write(InspirentoUtilities.escapeText(data));
        }
        List subElements = element.getElements();
        if (subElements.size() > 0) {
            out.write(""\n"");
            for (Iterator it = subElements.iterator(); it.hasNext(); ) {
                _writeSubNode(out, (XmlElement) it.next(), indent + writeIndent);
                // for (int i = 0; i < subElements.size(); i++) {
                // _writeSubNode(
                // out,
                // (XmlElement) subElements.get(i),
                // indent + writeIndent);
            }
            _writeSpace(out, indent);
        }
        if (data.length() > maxOneLineData) {
            out.write(""\n"");
            _writeSpace(out, indent);
        }
        out.write(""</"" + InspirentoUtilities.escapeText(element.getName()) + "">\n"");
    }

    private void _writeSpace(Writer out, int numSpaces) throws IOException {
        for (int i = 0; i < numSpaces; i++) {
            out.write("" "");
        }
    }
}
//End class XmlIO
","// XmlIO_2Test.java
package com.allenstudio.ir.util;

import java.io.BufferedWriter;
import java.io.CharArrayWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.URL;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlIO}.
* It contains ten unit test cases for the {@link XmlIO#load(URL)} method.
*/
class XmlIO_2Test {","```java
public class XmlIO_2Test {

    @Test
    void testLoadWithValidURL() {
        // Test loading with a valid URL
        XmlIO xmlIO = new XmlIO();
        URL validURL = getClass().getClassLoader().getResource(""test.xml"");
        assertTrue(xmlIO.load(validURL));
    }

    @Test
    void testLoadWithInvalidURL() {
        // Test loading with an invalid URL
        XmlIO xmlIO = new XmlIO();
        URL invalidURL = getClass().getClassLoader().getResource(""invalid.xml"");
        assertFalse(xmlIO.load(invalidURL));
    }

    @Test
    void testLoadWithNullURL() {
        // Test loading with a null URL
        XmlIO xmlIO = new XmlIO();
        assertFalse(xmlIO.load(null));
    }

    @Test
    void testLoadWithEmptyURL() {
        // Test loading with an empty URL
        XmlIO xmlIO = new XmlIO();
        URL emptyURL = getClass().getClassLoader().getResource("""");
        assertFalse(xmlIO.load(emptyURL));
    }

    @Test
    void testLoadWithNonExistentURL() {
        // Test loading with a non-existent URL
        XmlIO xmlIO = new XmlIO();
        URL nonExistentURL = getClass().getClassLoader().getResource(""nonexistent.xml"");
        assertFalse(xmlIO.load(nonExistentURL));
    }

    @Test
    void testLoadWithValidInputStream() {
        // Test loading with a valid input stream
        XmlIO xmlIO = new XmlIO();
        InputStream validInputStream = getClass().getClassLoader().getResourceAsStream(""test.xml"");
        assertTrue(xmlIO.load(validInputStream));
    }

    @Test
    void testLoadWithNullInputStream() {
        // Test loading with a null input stream
        XmlIO xmlIO = new XmlIO();
        assertFalse(xmlIO.load((InputStream) null));
    }

    @Test
    void testLoadWithValidInputURL() {
        // Test loading with a valid input URL
        XmlIO xmlIO = new XmlIO();
        URL validURL = getClass().getClassLoader().getResource(""test.xml"");
        assertTrue(xmlIO.load(validURL));
    }

    @Test
    void testLoadWithNullInputURL() {
        // Test loading with a null input URL
        XmlIO xmlIO = new XmlIO();
        assertFalse(xmlIO.load((URL) null));
    }
}
```
```"
chatcmpl-A5U5bWD6TiMJntXViGlfWBpsClao5,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/util/InspirentoUtilities_0Test.java,3.526960849761963,stop,"// InspirentoUtilities.java
package com.allenstudio.ir.util;

import java.util.StringTokenizer;
import java.util.Vector;

/*
 * @(#)InspirentoUtilities.java
 * Created on 2005-8-1
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
/**
 * Wraps some static utility method employed
 * in Inspirento.
 *
 * @author Allen Chue
 */
public class InspirentoUtilities {

    /**
     * Tokenizes a input string to produce
     * an array of type <code>String</code>.<br>
     * This method is used in building menus and
     * toolbar using a resource file. For instance,
     * the following code will get an array of contents
     * {""file"", ""edit"", ""view""}:
     * <pre>
     * String str = ""file edit view"";
     * String[] array = tokenize(str);
     * </pre>
     * @param input the input <code>String</code>
     * @return an String array containing all tokens
     * @see java.util.StringTokenizer
     */
    public static String[] tokenize(String input) {
        Vector<String> v = new Vector<String>();
        StringTokenizer t = new StringTokenizer(input);
        String[] cmd;
        while (t.hasMoreTokens()) v.addElement(t.nextToken());
        cmd = new String[v.size()];
        for (int i = 0; i < cmd.length; i++) cmd[i] = v.elementAt(i);
        return cmd;
    }

    /**
     * Tokenizes a input string to produce
     * an array of type <code>String</code>.<br>
     * This method is used in building menus and
     * toolbar using a resource file. For instance,
     * the following code will get an array of contents
     * {""file"", ""edit"", ""view""}:
     * <pre>
     * String str = ""file edit view"";
     * String[] array = tokenize(str);
     * </pre>
     * <br>This method offers customized delim.
     * @param input the input <code>String</code>
     * @return an String array containing all tokens
     * @see java.util.StringTokenizer
     */
    public static String[] tokenize(String input, String delim) {
        Vector<String> v = new Vector<String>();
        StringTokenizer t = new StringTokenizer(input, "" \t\n\r\f"" + delim);
        String[] cmd;
        while (t.hasMoreTokens()) v.addElement(t.nextToken());
        cmd = new String[v.size()];
        for (int i = 0; i < cmd.length; i++) cmd[i] = v.elementAt(i);
        return cmd;
    }

    /**
     * Replaces all characters that may
     * affect program's normal running in the string
     * with the escape strings in HTML.
     * @param str source string
     * @return a string which is processed
     */
    public static String escapeText(String str) {
        StringBuffer buffer = new StringBuffer(str);
        stringReplaceAll(buffer, '&', ""&amp;"");
        stringReplaceAll(buffer, '<', ""&lt;"");
        stringReplaceAll(buffer, '>', ""&gt;"");
        stringReplaceAll(buffer, '""', ""&quot;"");
        stringReplaceAll(buffer, '\'', ""&apos;"");
        return buffer.toString();
    }

    /**
     * Utility method to replace all the specified <code>token</code> in
     * string <code>source</code> with the specified <code>
     * replacement</code>.
     * @param source the source string
     * @param token the token to be replaced
     * @param replacement the string used to replace the token
     * @return a <code>StringBuffer</code> object that contains
     *         the modified string
     * @see java.lang.StringBuffer#replace(int, int, java.lang.String)
     */
    public static StringBuffer stringReplaceAll(StringBuffer source, char token, String replacement) {
        for (int i = 0; i < source.length(); i++) {
            if (source.charAt(i) == token) {
                //++i?
                source = source.replace(i, ++i, replacement);
            }
        }
        return source;
    }
}
","// InspirentoUtilities_0Test.java
package com.allenstudio.ir.util;

import java.util.StringTokenizer;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link InspirentoUtilities}.
* It contains ten unit test cases for the {@link InspirentoUtilities#tokenize(String)} method.
*/
class InspirentoUtilities_0Test {","```java
import static org.junit.jupiter.api.Assertions.assertArrayEquals;

class InspirentoUtilities_0Test {

    @Test
    void testTokenize() {
        String input = ""file edit view"";
        String[] expected = {""file"", ""edit"", ""view""};
        String[] result = InspirentoUtilities.tokenize(input);
        assertArrayEquals(expected, result);
    }

    @Test
    void testTokenizeWithDelim() {
        String input = ""file,edit,view"";
        String delim = "","";
        String[] expected = {""file"", ""edit"", ""view""};
        String[] result = InspirentoUtilities.tokenize(input, delim);
        assertArrayEquals(expected, result);
    }

    @Test
    void testEscapeText() {
        String input = ""<html>"";
        String expected = ""&lt;html&gt;"";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }
}
```
```"
chatcmpl-A5U6dQqFGjme5rTRDJvdzHgNtQ3ge,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/util/InspirentoUtilities_2Test.java,7.033966541290283,stop,"// InspirentoUtilities.java
package com.allenstudio.ir.util;

import java.util.StringTokenizer;
import java.util.Vector;

/*
 * @(#)InspirentoUtilities.java
 * Created on 2005-8-1
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
/**
 * Wraps some static utility method employed
 * in Inspirento.
 *
 * @author Allen Chue
 */
public class InspirentoUtilities {

    /**
     * Tokenizes a input string to produce
     * an array of type <code>String</code>.<br>
     * This method is used in building menus and
     * toolbar using a resource file. For instance,
     * the following code will get an array of contents
     * {""file"", ""edit"", ""view""}:
     * <pre>
     * String str = ""file edit view"";
     * String[] array = tokenize(str);
     * </pre>
     * @param input the input <code>String</code>
     * @return an String array containing all tokens
     * @see java.util.StringTokenizer
     */
    public static String[] tokenize(String input) {
        Vector<String> v = new Vector<String>();
        StringTokenizer t = new StringTokenizer(input);
        String[] cmd;
        while (t.hasMoreTokens()) v.addElement(t.nextToken());
        cmd = new String[v.size()];
        for (int i = 0; i < cmd.length; i++) cmd[i] = v.elementAt(i);
        return cmd;
    }

    /**
     * Tokenizes a input string to produce
     * an array of type <code>String</code>.<br>
     * This method is used in building menus and
     * toolbar using a resource file. For instance,
     * the following code will get an array of contents
     * {""file"", ""edit"", ""view""}:
     * <pre>
     * String str = ""file edit view"";
     * String[] array = tokenize(str);
     * </pre>
     * <br>This method offers customized delim.
     * @param input the input <code>String</code>
     * @return an String array containing all tokens
     * @see java.util.StringTokenizer
     */
    public static String[] tokenize(String input, String delim) {
        Vector<String> v = new Vector<String>();
        StringTokenizer t = new StringTokenizer(input, "" \t\n\r\f"" + delim);
        String[] cmd;
        while (t.hasMoreTokens()) v.addElement(t.nextToken());
        cmd = new String[v.size()];
        for (int i = 0; i < cmd.length; i++) cmd[i] = v.elementAt(i);
        return cmd;
    }

    /**
     * Replaces all characters that may
     * affect program's normal running in the string
     * with the escape strings in HTML.
     * @param str source string
     * @return a string which is processed
     */
    public static String escapeText(String str) {
        StringBuffer buffer = new StringBuffer(str);
        stringReplaceAll(buffer, '&', ""&amp;"");
        stringReplaceAll(buffer, '<', ""&lt;"");
        stringReplaceAll(buffer, '>', ""&gt;"");
        stringReplaceAll(buffer, '""', ""&quot;"");
        stringReplaceAll(buffer, '\'', ""&apos;"");
        return buffer.toString();
    }

    /**
     * Utility method to replace all the specified <code>token</code> in
     * string <code>source</code> with the specified <code>
     * replacement</code>.
     * @param source the source string
     * @param token the token to be replaced
     * @param replacement the string used to replace the token
     * @return a <code>StringBuffer</code> object that contains
     *         the modified string
     * @see java.lang.StringBuffer#replace(int, int, java.lang.String)
     */
    public static StringBuffer stringReplaceAll(StringBuffer source, char token, String replacement) {
        for (int i = 0; i < source.length(); i++) {
            if (source.charAt(i) == token) {
                //++i?
                source = source.replace(i, ++i, replacement);
            }
        }
        return source;
    }
}
","// InspirentoUtilities_2Test.java
package com.allenstudio.ir.util;

import java.util.StringTokenizer;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link InspirentoUtilities}.
* It contains ten unit test cases for the {@link InspirentoUtilities#escapeText(String)} method.
*/
class InspirentoUtilities_2Test {","```java
import static org.junit.jupiter.api.Assertions.assertEquals;

class InspirentoUtilities_2Test {

    @Test
    void testEscapeText() {
        String input = ""This is a <test> string & with 'special' characters"";
        String expected = ""This is a &lt;test&gt; string &amp; with &apos;special&apos; characters"";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }

    @Test
    void testEscapeText_EmptyString() {
        String input = """";
        String expected = """";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }

    @Test
    void testEscapeText_NoSpecialCharacters() {
        String input = ""No special characters here"";
        String expected = ""No special characters here"";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }

    @Test
    void testEscapeText_OnlySpecialCharacters() {
        String input = ""& < > \"" '"";
        String expected = ""&amp; &lt; &gt; &quot; &apos;"";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }

    @Test
    void testEscapeText_WithMixedCharacters() {
        String input = ""Special &amp; characters &lt; here &gt;"";
        String expected = ""Special &amp;amp; characters &amp;lt; here &amp;gt;"";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }

    @Test
    void testEscapeText_WithNumbers() {
        String input = ""123 & 456 < 789 >"";
        String expected = ""123 &amp; 456 &lt; 789 &gt;"";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }

    @Test
    void testEscapeText_WithSpecialCharacters() {
        String input = ""!@#$%^*()_+-={}[]|\\:;\""'<>,.?/"";
        String expected = ""!@#$%^*()_+-={}[]|\\:;\""'&lt;&gt;,.?/"";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }

    @Test
    void testEscapeText_WithWhitespace() {
        String input = ""   Test   "";
        String expected = ""   Test   "";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }

    @Test
    void testEscapeText_WithTabsAndNewlines() {
        String input = ""\tTest\n"";
        String expected = ""\tTest\n"";
        String result = InspirentoUtilities.escapeText(input);
        assertEquals(expected, result);
    }
}
```
```"
chatcmpl-A5U7ghrzxzTrF4Bmf89YHjw0qIMyg,/EvoSuiteBenchmark/original/17_inspirento/src/main/java/com/allenstudio/ir/util/InspirentoUtilities_3Test.java,9.10848069190979,stop,"// InspirentoUtilities.java
package com.allenstudio.ir.util;

import java.util.StringTokenizer;
import java.util.Vector;

/*
 * @(#)InspirentoUtilities.java
 * Created on 2005-8-1
 * Inspirento, Copyright AllenStudio, All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
/**
 * Wraps some static utility method employed
 * in Inspirento.
 *
 * @author Allen Chue
 */
public class InspirentoUtilities {

    /**
     * Tokenizes a input string to produce
     * an array of type <code>String</code>.<br>
     * This method is used in building menus and
     * toolbar using a resource file. For instance,
     * the following code will get an array of contents
     * {""file"", ""edit"", ""view""}:
     * <pre>
     * String str = ""file edit view"";
     * String[] array = tokenize(str);
     * </pre>
     * @param input the input <code>String</code>
     * @return an String array containing all tokens
     * @see java.util.StringTokenizer
     */
    public static String[] tokenize(String input) {
        Vector<String> v = new Vector<String>();
        StringTokenizer t = new StringTokenizer(input);
        String[] cmd;
        while (t.hasMoreTokens()) v.addElement(t.nextToken());
        cmd = new String[v.size()];
        for (int i = 0; i < cmd.length; i++) cmd[i] = v.elementAt(i);
        return cmd;
    }

    /**
     * Tokenizes a input string to produce
     * an array of type <code>String</code>.<br>
     * This method is used in building menus and
     * toolbar using a resource file. For instance,
     * the following code will get an array of contents
     * {""file"", ""edit"", ""view""}:
     * <pre>
     * String str = ""file edit view"";
     * String[] array = tokenize(str);
     * </pre>
     * <br>This method offers customized delim.
     * @param input the input <code>String</code>
     * @return an String array containing all tokens
     * @see java.util.StringTokenizer
     */
    public static String[] tokenize(String input, String delim) {
        Vector<String> v = new Vector<String>();
        StringTokenizer t = new StringTokenizer(input, "" \t\n\r\f"" + delim);
        String[] cmd;
        while (t.hasMoreTokens()) v.addElement(t.nextToken());
        cmd = new String[v.size()];
        for (int i = 0; i < cmd.length; i++) cmd[i] = v.elementAt(i);
        return cmd;
    }

    /**
     * Replaces all characters that may
     * affect program's normal running in the string
     * with the escape strings in HTML.
     * @param str source string
     * @return a string which is processed
     */
    public static String escapeText(String str) {
        StringBuffer buffer = new StringBuffer(str);
        stringReplaceAll(buffer, '&', ""&amp;"");
        stringReplaceAll(buffer, '<', ""&lt;"");
        stringReplaceAll(buffer, '>', ""&gt;"");
        stringReplaceAll(buffer, '""', ""&quot;"");
        stringReplaceAll(buffer, '\'', ""&apos;"");
        return buffer.toString();
    }

    /**
     * Utility method to replace all the specified <code>token</code> in
     * string <code>source</code> with the specified <code>
     * replacement</code>.
     * @param source the source string
     * @param token the token to be replaced
     * @param replacement the string used to replace the token
     * @return a <code>StringBuffer</code> object that contains
     *         the modified string
     * @see java.lang.StringBuffer#replace(int, int, java.lang.String)
     */
    public static StringBuffer stringReplaceAll(StringBuffer source, char token, String replacement) {
        for (int i = 0; i < source.length(); i++) {
            if (source.charAt(i) == token) {
                //++i?
                source = source.replace(i, ++i, replacement);
            }
        }
        return source;
    }
}
","// InspirentoUtilities_3Test.java
package com.allenstudio.ir.util;

import java.util.StringTokenizer;
import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link InspirentoUtilities}.
* It contains ten unit test cases for the {@link InspirentoUtilities#stringReplaceAll(StringBuffer, char, String)} method.
*/
class InspirentoUtilities_3Test {","```java
import static org.junit.jupiter.api.Assertions.assertEquals;

class InspirentoUtilities_3Test {

    @Test
    void testStringReplaceAll() {
        StringBuffer source = new StringBuffer(""Hello, World!"");
        StringBuffer result = InspirentoUtilities.stringReplaceAll(source, 'o', ""X"");
        assertEquals(""HellX, WXrld!"", result.toString());
    }

    @Test
    void testStringReplaceAllWithEmptyString() {
        StringBuffer source = new StringBuffer(""Hello, World!"");
        StringBuffer result = InspirentoUtilities.stringReplaceAll(source, 'o', """");
        assertEquals(""Hell, Wrld!"", result.toString());
    }

    @Test
    void testStringReplaceAllWithNoMatch() {
        StringBuffer source = new StringBuffer(""Hello, World!"");
        StringBuffer result = InspirentoUtilities.stringReplaceAll(source, 'x', ""X"");
        assertEquals(""Hello, World!"", result.toString());
    }

    @Test
    void testStringReplaceAllWithMultipleReplacements() {
        StringBuffer source = new StringBuffer(""Hello, World!"");
        StringBuffer result = InspirentoUtilities.stringReplaceAll(source, 'l', ""LL"");
        assertEquals(""HeLLo, WorLLd!"", result.toString());
    }

    @Test
    void testStringReplaceAllWithSpecialCharacters() {
        StringBuffer source = new StringBuffer(""Hello & World < Test >"");
        StringBuffer result = InspirentoUtilities.stringReplaceAll(source, '&', ""&amp;"");
        result = InspirentoUtilities.stringReplaceAll(result, '<', ""&lt;"");
        result = InspirentoUtilities.stringReplaceAll(result, '>', ""&gt;"");
        assertEquals(""Hello &amp; World &lt; Test &gt;"", result.toString());
    }

    @Test
    void testStringReplaceAllWithEmptySource() {
        StringBuffer source = new StringBuffer("""");
        StringBuffer result = InspirentoUtilities.stringReplaceAll(source, 'o', ""X"");
        assertEquals("""", result.toString());
    }

    @Test
    void testStringReplaceAllWithEmptyReplacement() {
        StringBuffer source = new StringBuffer(""Hello, World!"");
        StringBuffer result = InspirentoUtilities.stringReplaceAll(source, 'o', """");
        assertEquals(""Hell, Wrld!"", result.toString());
    }

    @Test
    void testStringReplaceAllWithEmptySourceAndReplacement() {
        StringBuffer source = new StringBuffer("""");
        StringBuffer result = InspirentoUtilities.stringReplaceAll(source, 'o', """");
        assertEquals("""", result.toString());
    }

    @Test
    void testStringReplaceAllWithNullSource() {
        StringBuffer result = InspirentoUtilities.stringReplaceAll(null, 'o', ""X"");
        assertEquals(null, result);
    }

    @Test
    void testStringReplaceAllWithNullReplacement() {
        StringBuffer source = new StringBuffer(""Hello, World!"");
        StringBuffer result = InspirentoUtilities.stringReplaceAll(source, 'o', null);
        assertEquals(""Hell, Wrld!"", result.toString());
    }
}
```
```"
